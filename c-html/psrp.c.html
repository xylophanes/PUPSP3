<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>/usr/local/src/pupsp3-5.4.9.src.git/pupscore.src/psrp.c.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Purpose: User communication interface to PSRP server process</span>

<span class="Comment">    Author:  M.A. O'Neill</span>
<span class="Comment">             Tumbling Dice Ltd</span>
<span class="Comment">             Gosforth</span>
<span class="Comment">             Newcastle upon Tyne</span>
<span class="Comment">             NE3 4RT</span>
<span class="Comment">             United Kingdom</span>

<span class="Comment">    Version: 21.02 </span>
<span class="Comment">    Dated:   7th October 2023 </span>
<span class="Comment">    E-mail:  mao@tumblingdice.co.uk</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> If we have OpenMP support then we also have pthread support </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (OpenMP is built on pthreads for Linux distributions).      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#if defined(_OPENMP) &amp;&amp; !defined(PTHREAD_SUPPORT)</span>
<span class="PreProc">#define PTHREAD_SUPPORT</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef HAVE_CURSES</span>
<span class="PreProc">#include </span><span class="Constant">&lt;curses.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;me.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utils.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;netlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;psrp.h&gt;</span>

<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;bsd/string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;setjmp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pwd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/wait.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/socket.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utmp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;termios.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;vstamp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dirent.h&gt;</span>


<span class="Comment">/*</span><span class="Comment">*******************************</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Floating point representation </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">*******************************</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;ftype.h&gt;</span>

<span class="PreProc">#ifdef HAVE_READLINE</span>
<span class="PreProc">#include </span><span class="Constant">&lt;readline/readline.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;readline/history.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_READLINE </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get signal mapping appropriate to OS and hardware architecture </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define __DEFINE__</span>
<span class="PreProc">#if defined(I386) || defined(X86_64)</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.x86.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> I386 || X86_64 </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV6L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV6L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV7L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV7L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef AARCH64</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> AARCH64 </span><span class="Comment">*/</span>
<span class="PreProc">#undef __DEFINE__</span>


<span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Version </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

<span class="PreProc">#define PSRP_VERSION          </span><span class="Constant">&quot;21.02&quot;</span>


<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Defines which are local to this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>


<span class="PreProc">#define PSRP_MAX_HISTORY      </span><span class="Constant">1024</span>
<span class="PreProc">#define PML_VERSION           </span><span class="Constant">1.03</span>
<span class="PreProc">#define PSRP_LOCAL_ATOMIC     </span><span class="Constant">1</span>
<span class="PreProc">#define PSRP_LOCAL_AGGREGATE  </span><span class="Constant">2</span>
<span class="PreProc">#define PSRP_REMOTE_REQUEST   </span><span class="Constant">3</span>
<span class="PreProc">#define PSRP_REQUEST_ERROR    (-</span><span class="Constant">1</span><span class="PreProc">)</span>
<span class="PreProc">#define MAX_PSRP_MACROS       SSIZE </span>
<span class="PreProc">#define MAX_PSRP_MACRO_FILES  </span><span class="Constant">32</span>
<span class="PreProc">#define MAX_MACRO_ARGS        </span><span class="Constant">32</span>
<span class="PreProc">#define MAX_MACRO_TAGS        </span><span class="Constant">128</span><span class="PreProc"> </span>
<span class="PreProc">#define MAX_CLASH_TAGS        </span><span class="Constant">32</span><span class="PreProc"> </span>
<span class="PreProc">#define MAX_LABELS            </span><span class="Constant">128</span>
<span class="PreProc">#define EXPAND_MACRO_STREXT   </span><span class="Constant">0</span><span class="PreProc"> </span>
<span class="PreProc">#define MAX_MACRO_DEPTH       N_STREXT_STRINGS</span>
<span class="PreProc">#define EXIT_ON_INTR          </span><span class="Constant">0</span>
<span class="PreProc">#define RESTART_INTR_REQ      </span><span class="Constant">1</span>
<span class="PreProc">#define RESTART_INTR_MACRO    </span><span class="Constant">2</span>
<span class="PreProc">#define DEFAULT_PAGER         </span><span class="Constant">&quot;less&quot;</span>




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Definition of macro type </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

                                                      <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Type">typedef</span> <span class="Type">struct</span> {    <span class="Type">int</span>  cnt;                         <span class="Comment">/*</span><span class="Comment"> Number of name tags actually in use    </span><span class="Comment">*/</span>
                    <span class="Type">char</span> mdf[SSIZE];                  <span class="Comment">/*</span><span class="Comment"> Macro definition file exporting macro  </span><span class="Comment">*/</span>
                    <span class="Type">char</span> tag[MAX_MACRO_TAGS][SSIZE];  <span class="Comment">/*</span><span class="Comment"> Array of macro name tags               </span><span class="Comment">*/</span>
                    <span class="Type">char</span> body[<span class="Constant">4096</span>];                  <span class="Comment">/*</span><span class="Comment"> Body of macro                          </span><span class="Comment">*/</span>
               } macro_type;                          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get application information for slot manager ...</span>
<span class="Comment">----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot information function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_slot(<span class="Type">int</span> level)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;int app psrp </span><span class="Special">%s</span><span class="Constant">: [ANSI C]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PSRP_VERSION);

    <span class="Statement">if</span>(level &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;(C) 1994-2022 Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;Author: M.A. O'Neill</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) communication shell (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PSRP_PROTOCOL_VERSION,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Usage information function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_usage(<span class="Type">void</span>)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-startmsg:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-spid &lt;pid of PSRP server process&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-sname &lt;name of PSRP server process&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-wait:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">[-noprompt:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-log:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-trys &lt;attempts to connect to server PSRP channel&gt;]]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-quiet:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-squiet:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-c &lt;PSRP request to be executed&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-hard:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-log:FALSE&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-recursive:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">    #ifdef PSRP_AUTHENTICATE</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-password &lt;authentication token&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-user &lt;username&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef SLAVED_COMMANDS</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-clist &lt;clist file name&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-on &lt;host&gt; [-from &lt;host&gt; &lt;client&gt; &lt;client pid]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[-slaved:FALSE]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;[&gt;&amp; &lt;ASCII log file&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;SIGNALS</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>, <span class="Constant">&quot;SIGPSRP, SIGINIT, SIGCHAN, SIGCLIENT: PSRP status request signals (protocol </span><span class="Special">%5.2F</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PSRP_PROTOCOL_VERSION);

<span class="PreProc">    #ifdef CRUI_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;SIGCHECK SIGRESTART:      checkpoint and restart signals</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;SIGALIVE: check for presence of PSRP server process</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
}


<span class="PreProc">#ifdef SLOT</span>
_EXTERN <span class="Type">int</span>   max_slots                              = MAX_SLOTS;
_EXTERN <span class="Type">int</span>   max_use_slots                          = MAX_USE_SLOTS;
_EXTERN <span class="Type">void</span> (* SLOT ) __attribute__ ((aligned(<span class="Constant">16</span>))) = psrp_slot;
_EXTERN <span class="Type">void</span> (* USE  ) __attribute__ ((aligned(<span class="Constant">16</span>))) = psrp_usage;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLOT </span><span class="Comment">*/</span>



<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Application build date </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_EXTERN <span class="Type">char</span> appl_build_time[SSIZE] = <span class="Constant">__TIME__</span>;
_EXTERN <span class="Type">char</span> appl_build_date[SSIZE] = <span class="Constant">__DATE__</span>;




<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Functions imported by this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are imported by this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span>         pupshold_cnt;




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">char</span>       psrp_history[SSIZE]                = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span>       trailfile_name[SSIZE]              = <span class="Constant">&quot;&quot;</span>;
_PRIVATE _BOOLEAN   psrp_recursive                     = FALSE;
_PRIVATE <span class="Type">int</span>        request_type                       = <span class="Constant">0</span>;
_PRIVATE <span class="Type">char</span>       datasink_cmd[SSIZE]                = DEFAULT_PAGER;
_PRIVATE <span class="Type">int</span>        from_tstp_handler                  = FALSE;
_PRIVATE <span class="Type">int</span>        restricted_clist                   = FALSE;
_PRIVATE <span class="Type">int</span>        clist_size                         = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>        clist_alloc                        = <span class="Constant">0</span>;
_PRIVATE <span class="Type">char</span>       **clist                            = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;
_PRIVATE <span class="Type">char</span>       clist_f_name[SSIZE]                = <span class="Constant">&quot;&quot;</span>;
_PRIVATE _BOOLEAN   exit_on_terminate                  = FALSE;
_PRIVATE _BOOLEAN   secure_operation                   = FALSE;
_PRIVATE _BOOLEAN   do_datasink                        = FALSE;
_PRIVATE _BOOLEAN   do_bg_datasink                     = FALSE;
_PRIVATE <span class="Type">int</span>        child_pid                          = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">int</span>        from_client_pid;
_PRIVATE <span class="Type">char</span>       from_client_name[SSIZE]            = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span>       from_hostname[SSIZE]               = <span class="Constant">&quot;&quot;</span>;
_PRIVATE sigjmp_buf command_loop_top;
_PRIVATE sigjmp_buf process_loop_top;
_PRIVATE <span class="Type">char</span> macro_f_name[SSIZE]                      = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> remote_host_pathname[SSIZE]              = <span class="Constant">&quot;notset&quot;</span>;
_PRIVATE <span class="Type">char</span> channel_name[SSIZE]                      = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> channel_out[SSIZE]                       = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> psrp_server[SSIZE]                       = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> new_psrp_server[SSIZE]                   = <span class="Constant">&quot;notset&quot;</span>;
_PRIVATE <span class="Type">char</span> psrp_host[SSIZE]                         = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> request_line[SSIZE]                      = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> last_request_line[SSIZE]                 = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> psrp_c_code[SSIZE]                       = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> c_code[SSIZE]                            = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> last_macro[SSIZE]                        = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">char</span> username[SSIZE]                          = <span class="Constant">&quot;&quot;</span>;
_PRIVATE <span class="Type">int</span>  max_trys                                 = MAX_TRYS;
_PRIVATE <span class="Type">int</span>  try_cnt                                  = <span class="Constant">8</span>;
_PRIVATE <span class="Type">int</span>  server_seg_cnt                           = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>  n_m_files                                = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>  rpt_cnt                                  = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>  r_cnt                                    = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>  seg_restart_action                       = EXIT_ON_INTR;
_PRIVATE <span class="Type">int</span>  slave_pid                                = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">int</span>  rpt_period                               = PSRP_RPT_DEFAULT;


_PRIVATE <span class="Type">int</span>        n_macros = <span class="Constant">0</span>;
_PRIVATE macro_type macro[MAX_PSRP_MACROS];

_PRIVATE <span class="Type">FILE</span> *client_in                               = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
_PRIVATE <span class="Type">FILE</span> *client_out                              = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
_PRIVATE <span class="Type">FILE</span> *stream                                  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

_PRIVATE <span class="Type">int</span>      out_inode;
_PRIVATE <span class="Type">int</span>      current_out_inode;
_PRIVATE <span class="Type">int</span>      in_inode;
_PRIVATE <span class="Type">int</span>      current_in_inode;

_PRIVATE <span class="Type">int</span>      t_cnt = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>      server_pid                           = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>      new_server_pid                       = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">int</span>      repeat_count                         = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">int</span>      slave_in                             = (-<span class="Constant">1</span>);

_PRIVATE _BOOLEAN close_psrp_channel                   = FALSE;
_PRIVATE _BOOLEAN in_new_getinfo                       = FALSE;
_PRIVATE _BOOLEAN wait_for_psrp_server_startup         = FALSE;
_PRIVATE _BOOLEAN migrating_segmentation               = FALSE;
_PRIVATE _BOOLEAN do_rsnr                              = FALSE;
_PRIVATE _BOOLEAN cinit_done                           = FALSE;
_PRIVATE _BOOLEAN in_repeat_command                    = FALSE;
_PRIVATE _BOOLEAN priviliged                           = FALSE;
_PRIVATE _BOOLEAN busy_retry_mode                      = FALSE;
_PRIVATE _BOOLEAN psrp_hard_link                       = FALSE;
_PRIVATE _BOOLEAN is_builtin                           = TRUE;
_PRIVATE _BOOLEAN psrp_slaved                          = FALSE;
_PRIVATE _BOOLEAN redirected_requests                  = FALSE;
_PRIVATE _BOOLEAN is_remote                            = FALSE;
_PRIVATE _BOOLEAN psrp_log                             = FALSE;
_PRIVATE _BOOLEAN interactive_mode                     = TRUE;
_PRIVATE _BOOLEAN is_aggregate                         = FALSE;
_PRIVATE _BOOLEAN exec_shell                           = FALSE;
_PRIVATE _BOOLEAN processing_command                   = FALSE;
_PRIVATE _BOOLEAN pups_error_abort                     = FALSE;
_PRIVATE _BOOLEAN in_client_handler                    = FALSE;
_PRIVATE _BOOLEAN in_client_handler_int                = FALSE;
_PRIVATE _BOOLEAN in_append_op                         = FALSE;
_PRIVATE _BOOLEAN flycom                               = FALSE;
_PRIVATE _BOOLEAN server_verbose                       = TRUE;
_PRIVATE _BOOLEAN pel_appl_verbose                     = TRUE;
_PRIVATE _BOOLEAN save_pel_appl_verbose                = TRUE;
_PRIVATE _BOOLEAN macro_expansion                      = TRUE;
_PRIVATE _BOOLEAN macros_expanded                      = FALSE;
_PRIVATE _BOOLEAN show_body                            = FALSE;
_PRIVATE _BOOLEAN rpt_curses_mode                      = FALSE;
_PRIVATE _BOOLEAN in_prompt_loop                       = FALSE;
_PRIVATE _BOOLEAN do_repeat[MAX_MACRO_DEPTH];
_PRIVATE _BOOLEAN log_state_updated                    = FALSE;
_PRIVATE _BOOLEAN prompt                               = TRUE;
_PRIVATE _BOOLEAN have_access_lock                     = FALSE;
_PRIVATE _BOOLEAN server_connected                     = FALSE;

_PRIVATE <span class="Type">char</span> mstack_f_name[MAX_PSRP_MACRO_FILES][SSIZE] = { [<span class="Constant">0</span> ... MAX_PSRP_MACRO_FILES-<span class="Constant">1</span>] = {<span class="Constant">&quot;&quot;</span>}};




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Functions which are private to this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Check for existence of trailfile and  get its name</span>
_PRIVATE _BOOLEAN psrp_have_trailfile(<span class="Type">void</span>);

<span class="Comment">// Virtual maggot</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_virtual_maggot(<span class="Type">char</span> *);

<span class="Comment">// Get (test) password</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_get_password(<span class="Type">void</span>);

<span class="PreProc">#ifdef SLAVED_COMMANDS</span>
<span class="Comment">// Read a restricted command list</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> builtin_read_clist(_BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Is command permitted? </span>
_PROTOTYPE _PRIVATE _BOOLEAN command_permitted(<span class="Type">char</span> *);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>

<span class="Comment">// Set current working directory for PSRP client</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_builtin_set_lcwd(<span class="Type">char</span> *);

<span class="Comment">// Follow a PSRP server onto a new node</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_migrate_client_to_server_host(<span class="Type">void</span>);

<span class="Comment">// Handler for SIGABRt</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> critical_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGWINCH</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> winch_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGTSTP</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> tstp_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGGSEGV</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> segv_handler(<span class="Type">int</span>);

<span class="Comment">// Remove lockpost files</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_remove_lockpost_files(<span class="Type">void</span>);

<span class="Comment">// Set authentication token for remote PSRP services</span>
_PRIVATE _BOOLEAN builtin_set_password(<span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Change PSRP client session owner</span>
_PROTOTYPE _PRIVATE _BOOLEAN builtin_change_user(<span class="Type">char</span> *);

<span class="Comment">// Set authentication token (for remote PSRP services)</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_set_password(<span class="Type">char</span> *);

<span class="Comment">// Check password (for a given user)</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_check_password(<span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Connect to PSRP client process on remote client</span>
_PROTOTYPE _PRIVATE _BOOLEAN builtin_connect_remote_client(<span class="Type">char</span> *);

<span class="Comment">// Show PUPS channels within nominated directory</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_show_server_pool(<span class="Type">void</span>);

<span class="Comment">// Show PUPS channels within nominated directory</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_show_channels(_BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Kill PSRP servers in nominated directory</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_kill_servers(<span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Restore system status (after longjmp)</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> restore_system_status(<span class="Type">int</span>);

<span class="Comment">// Initialise do_repeat array</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> initialise_repeaters(<span class="Type">void</span>);

<span class="Comment">// Clear screen</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> cls(<span class="Type">void</span>);

<span class="Comment">// Process a repeated command</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_repeat_command(<span class="Type">int</span>, <span class="Type">char</span> *);

<span class="Comment">// Start curses screen handling</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> cinit(<span class="Type">void</span>);

<span class="Comment">// Stop curses screen handling</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> cend(<span class="Type">void</span>);

<span class="Comment">// Clear screen</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> cls(<span class="Type">void</span>);

<span class="Comment">// Print header for repeated command</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> rpthdr(<span class="Type">char</span> *);

<span class="Comment">// Find label (in macro body)</span>
_PROTOTYPE _PRIVATE _BOOLEAN req_find(<span class="Type">int</span>, <span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Load a macro definition file</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> builtin_load_macro_definitions(_BOOLEAN, _BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Edit a macro definition file</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> builtin_edit_macro_definitions(_BOOLEAN, _BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Expand recursive macro definitions</span>
_PROTOTYPE _PRIVATE _BOOLEAN expand_macros_recursive(<span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Substitute macro arguments</span>
_PROTOTYPE _PRIVATE _BOOLEAN substitute_arguments(<span class="Type">char</span> *, <span class="Type">int</span>, <span class="Type">char</span> [<span class="Constant">8</span>][SSIZE]);

<span class="Comment">// Expand macro definitions</span>
_PROTOTYPE _PRIVATE _BOOLEAN expand_macros(<span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Update the macro stack</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> update_macro_stack(_BOOLEAN, _BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Update macro definitions file</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> edit_macro_definitions(_BOOLEAN, _BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Check macro tags (for uniqueness)</span>
_PROTOTYPE _PRIVATE _BOOLEAN check_macro_tags(<span class="Type">int</span>, <span class="Type">char</span> *);

<span class="Comment">// Catentate macro to macro file</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> catenate_macro(<span class="Type">char</span> *, <span class="Type">char</span> *, _BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Purge (delete) currently loaded macro definitions</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> purge_macros(<span class="Type">char</span> *, _BOOLEAN, _BOOLEAN);

<span class="Comment">// Load macro definition file</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> load_macro_definitions(_BOOLEAN, _BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Show loaded macros</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> show_macro_tags(<span class="Type">void</span>);

<span class="Comment">// Wait for end of operation</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_waitfor_endop(<span class="Type">char</span> *);

<span class="Comment">// Interact with nominated PSRP server process</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_command_loop(<span class="Type">void</span>);

<span class="Comment">// Handler for SIGTSTP</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> tstp_handler(<span class="Type">const</span> <span class="Type">int</span>);

<span class="Comment">// Handler for SIGPSRP</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> client_handler(<span class="Type">const</span> <span class="Type">int</span>);

<span class="Comment">// Handler for SIGCHAN</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> chan_client_handler(<span class="Type">const</span> <span class="Type">int</span>);

<span class="Comment">// Handler for SIGALIVE (to server)</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> server_alive_handler(vttab_type *, <span class="Type">char</span> *);

<span class="Comment">// Send a single command to the PSRP server process</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_process_command(<span class="Type">char</span> *);

<span class="Comment">// Remove junk prior to exiting</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> remove_junk(<span class="Type">void</span>);

<span class="Comment">// Open a PSRP server process</span>
_PROTOTYPE _PRIVATE _BOOLEAN psrp_open_server(<span class="Type">void</span>);

<span class="Comment">// Close a PSRP server process</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_close_server(<span class="Type">const</span> _BOOLEAN, <span class="Type">const</span> _BOOLEAN);

<span class="Comment">// Builtin to catenate last request to macro definition file</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> builtin_catenate_macro(_BOOLEAN, <span class="Type">char</span> *);

<span class="Comment">// Builtin to open a copnnection to a new PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> builtin_open_psrp_server(<span class="Type">char</span> *);

<span class="Comment">// Display help on builtin client and server commands</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> builtin_psrp_help(<span class="Type">void</span>);

<span class="Comment">// Handler for SIGINT when PSRP server process is in a critical (blocking) state</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_critical_int_handler(<span class="Type">const</span> <span class="Type">int</span>);

<span class="Comment">// Handler for SIGINT propagates SIGINT to PSRP server process</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_int_handler(<span class="Type">const</span> <span class="Type">int</span>);

<span class="Comment">// Expand a request of the form server@host: &lt;command list&gt;</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> expand_request(<span class="Type">char</span> *, <span class="Type">char</span> *, _BOOLEAN *, <span class="Type">char</span> *);

<span class="Comment">// Test for repeated command</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> initialise_repeaters(<span class="Type">void</span>);

<span class="Comment">// Grab PSRP channel (to talk to server)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_grab_channel(<span class="Type">void</span>);

<span class="Comment">// Yield PSRP channel (to other connected client)</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_yield_channel(<span class="Type">void</span>);


<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Software I.D. tag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define VTAG  </span><span class="Constant">7496</span>
<span class="Type">extern</span> <span class="Type">int</span> appl_vtag = VTAG;




<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for SIGHUP </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> hup_handler(<span class="Type">int</span> signum)

{   (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);
}



<span class="PreProc">#ifdef PSRP_DEBUG</span>
testiface(<span class="Type">void</span>)

{   <span class="Type">char</span> line[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    (<span class="Type">void</span>)scanf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,line);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP got (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,line);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;EOT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

    exit(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PSRP communications client pups_main entry point </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_main(<span class="Type">int</span> argc, <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> psrp_request[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         pathname[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         psrp_parameters[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         remote_host[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

    sigset_t client_set;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get standard items form the command tail </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    pups_std_init(TRUE,
                  &amp;argc,
                  PSRP_VERSION,
                  <span class="Constant">&quot;M.A. O'Neill&quot;</span>,
                  <span class="Constant">&quot;psrp&quot;</span>,
                  <span class="Constant">&quot;2022&quot;</span>,
                  argv);


<span class="PreProc">    #ifdef HAVE_READLINE</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get (readline) history if any </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(psrp_history,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.</span><span class="Special">%s</span><span class="Constant">.history&quot;</span>,appl_home,appl_name);
    <span class="Statement">if</span>(access(psrp_history,F_OK | R_OK) != (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)history_truncate_file(psrp_history,PSRP_MAX_HISTORY);
       (<span class="Type">void</span>)read_history(psrp_history);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_READLINE </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Handler for SIGHUP </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)signal(<span class="Constant">SIGHUP</span>,(<span class="Type">void</span> *)&amp;hup_handler);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get password to authenticate connection to PSRP services on remote hosts </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;startmsg&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    PSRP client version </span><span class="Special">%s</span><span class="Constant">, [build </span><span class="Special">%6d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PSRP_VERSION,appl_vtag);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    (C) M.A. O'Neill, Tumbling Dice 2022</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


<span class="PreProc">    #ifdef PSRP_AUTHENTICATE </span>
    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;password&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
          psrp_set_password(appl_password);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)scanf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_password);
    }
<span class="PreProc">    #ifdef SLAVED_COMMANDS_</span>
    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;clist&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>(strccpy(clist_f_name,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting restricted command list name&quot;</span>);
       (<span class="Type">void</span>)builtin_read_clist(FALSE,clist_f_name);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>



    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hard link - psrp client stays attached to stopped servers </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;hard&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  psrp_hard_link = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): PSRP client is hard linked (client will remain attached to stopped server)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for target PSRP server to start (and then connect to it) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;wait&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  wait_for_psrp_server_startup = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): PSRP client wait mode (client will wait for target server to start and then attach to it))</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Exit when (attached) server terminates if TRUE </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;exit&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  exit_on_terminate = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): PSRP client exit mode (client will exit when attached server terminates))</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                               date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Change effective UID </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;user&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;

       <span class="Statement">if</span>(geteuid() != <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[psrp] need to set UID root to change session owner&quot;</span>);

       <span class="Statement">if</span>(strccpy(appl_owner,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting effective user name&quot;</span>);

       <span class="Statement">if</span>(psrp_check_password(appl_owner,shell) == FALSE)
          pups_error(<span class="Constant">&quot;[psrp] failed to change effective user&quot;</span>);
    }


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Run on remote host (via terminal services daemon) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(from_hostname,appl_host,SSIZE);
    (<span class="Type">void</span>)strlcpy(from_client_name,appl_name,SSIZE);
    from_client_pid = appl_pid;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are a remote client, where are we from </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;from&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">int</span> in;

       is_remote = TRUE;


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get the name of the remote host </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strccpy(from_hostname,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting name of (remote) client's host&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get the name of the remote client </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strccpy(from_client_name,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting name of (remote) client&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get the pid of the remote client </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((from_client_pid = pups_i_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">int</span>)INVALID_ARG || from_client_pid &lt; <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting name of (remote) client pid&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Build path to remote host </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(remote_host_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">[</span><span class="Special">%d</span><span class="Constant">]@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">&quot;</span>,from_client_name,from_client_pid,from_hostname,appl_owner);

<span class="PreProc">       #ifdef PSRP_DEBUG </span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REMOTE HOST PATHNAME: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,remote_host_pathname);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Slave mode - propagate PSRP protocol control words to enslaving peer </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;slaved&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  psrp_slaved = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): PSRP client is running in slaved mode (PSRP protocol propagation enabled)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                               date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Mark this PSRP instance recursive </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;recursive&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  psrp_recursive = TRUE;

      <span class="Statement">if</span>(appl_verbose == TRUE)
      {  (<span class="Type">void</span>)strdate(date);
         (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): PSRP client is running in recursive mode (processing aggregate command)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
	                                                                    date,appl_name,appl_pid,appl_host,appl_owner);
         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
      }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have a .psrprc file - re-direct stdin to it so we can execute any psrp commands </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in it before we start accepting commands from the terminal                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.psrprc&quot;</span>,getenv(<span class="Constant">&quot;HOME&quot;</span>));
    <span class="Statement">if</span>(access(pathname,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Reading commands from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (prior to interactive comamnd input)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                 date,appl_name,appl_pid,appl_host,appl_owner,pathname);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If this client is attached to a slave channel we need to duplicate </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> descriptor before we re-drirect stdin                              </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">0</span>)
          slave_in = dup(<span class="Constant">0</span>);

       (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);

       <span class="Constant">stdin</span>               = fopen(pathname,<span class="Constant">&quot;r&quot;</span>);
       redirected_requests = TRUE;
    }
    <span class="Statement">else</span>
    {  <span class="Type">struct</span> stat buf;
       (<span class="Type">void</span>)fstat(<span class="Constant">0</span>,&amp;buf);


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a regular file requests are being redirected via </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> stdin -- take appropriate action                            </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(S_ISREG(buf.st_mode))
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">):    Reading commands from redirected </span><span class="Special">\&quot;</span><span class="Constant">stdin</span><span class="Special">\&quot;</span><span class="Constant"> (prior to interactive command input)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                     date,appl_name,appl_pid,appl_host,appl_owner,pathname);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }

          redirected_requests = TRUE;
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise handler and pups_error functions </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
    (<span class="Type">void</span>)sigfillset(&amp;client_set);

    (<span class="Type">void</span>)pups_sighandle(SIGCLIENT,  <span class="Constant">&quot;client_handler&quot;</span>,     (<span class="Type">void</span> *)client_handler,      (sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(SIGCHAN,    <span class="Constant">&quot;chan_client_handler&quot;</span>,(<span class="Type">void</span> *)chan_client_handler, (sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,    <span class="Constant">&quot;tstp_handler&quot;</span>,       (<span class="Type">void</span> *)tstp_handler,        (sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(SIGCRITICAL,<span class="Constant">&quot;critical_handler&quot;</span>,   (<span class="Type">void</span> *)critical_handler,    (sigset_t *)<span class="Constant">NULL</span>);

    (<span class="Type">void</span>)strlcpy((<span class="Type">char</span> *)psrp_server,<span class="Constant">&quot;unnamed&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Select prompt mode </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;noprompt&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  prompt = FALSE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): psrp prompt mode disabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                  date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell the world we have started </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get PSRP server by pid </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    do_rsnr = FALSE;
    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;spid&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((server_pid = pups_i_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">int</span>)INVALID_ARG || server_pid &lt; <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting pid of PSRP server&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to see if this is a valid process </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(psrp_pid_to_channelname(appl_fifo_dir,server_pid,psrp_server,psrp_host) == FALSE)
          pups_error(<span class="Constant">&quot;[psrp] channel to target PSRP process does not exist&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Is the resolved process name unique? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host) &lt; <span class="Constant">0</span>)
       {  do_rsnr = TRUE;

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\%</span><span class="Constant">s </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): reverse server name resolution (cannot track PSRP channel dynamically)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                    date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }
       }
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get PSRP server by name </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;sname&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       {  <span class="Type">int</span> idum;

          try_cnt = <span class="Constant">0</span>;

          <span class="Statement">if</span>(strccpy(psrp_server,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[psrp] expecting name of PSRP server process&quot;</span>);

          <span class="Statement">if</span>(sscanf(psrp_server,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;idum) != <span class="Constant">0</span>)
             pups_error(<span class="Constant">&quot;[psrp] expecting name of PSRP server process&quot;</span>);

          <span class="Statement">while</span>(try_cnt &lt; max_trys)
          {   server_pid = psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host);


              <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Do we own the server? </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(pups_i_own(server_pid) == FALSE)
              {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[psrp] current user </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not own PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (cannot connect)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_owner,psrp_server);
                 pups_error(errstr);
              }


              <span class="Statement">if</span>(server_pid !=  PSRP_DUPLICATE_PROCESS_NAME    &amp;&amp;
                 server_pid !=  PSRP_TERMINATED                 )
                 <span class="Statement">goto</span> process_found;

              <span class="Statement">if</span>(wait_for_psrp_server_startup == FALSE)
              {  <span class="Statement">if</span>(server_pid == PSRP_TERMINATED)
                 {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                    {  <span class="Statement">if</span>(is_remote == TRUE &amp;&amp; interactive_mode == FALSE)
                       {  <span class="Statement">if</span>(do_rsnr == TRUE)
                             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot access process </span><span class="Special">\&quot;</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as PSRP server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server_pid,appl_host);
                          <span class="Statement">else</span>
                             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot access process </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as PSRP server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,appl_host);
                       }
                       <span class="Statement">else</span>
                       {  <span class="Statement">if</span>(do_rsnr == TRUE)
                             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot access process </span><span class="Special">%d</span><span class="Constant"> as PSRP server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server_pid);
                          <span class="Statement">else</span>
                             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot access process </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as PSRP server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server);
                       }

                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                    }

                    pups_exit(<span class="Constant">255</span>);
                 }
              }

              <span class="Statement">if</span>(try_cnt == max_trys &amp;&amp; server_pid == PSRP_TERMINATED)
                 pups_error(<span class="Constant">&quot;[psrp] channel to target PSRP process does not exist&quot;</span>);

              <span class="Statement">if</span>(server_pid == PSRP_DUPLICATE_PROCESS_NAME)
                 pups_error(<span class="Constant">&quot;[psrp] target PSRP process name is not unique&quot;</span>);

              ++try_cnt;


              <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Wait for migrated PSRP server to start </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(try_cnt == <span class="Constant">1</span>)
              {  <span class="Statement">if</span>(appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)strdate(date);
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): waiting for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> to start</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_host,appl_owner,psrp_server,appl_host);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }
              }

              (<span class="Type">void</span>)pups_sleep(TRY_TIMEOUT);
          }


          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Migrated PSRP server has started </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> started</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                date,appl_name,appl_pid,appl_host,appl_owner,psrp_server,appl_host);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }



          <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
             pups_exit(<span class="Constant">255</span>);
          pups_exit(<span class="Constant">0</span>);

<span class="Statement">process_found</span>:

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server is </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_host,appl_owner,psrp_server,server_pid,appl_host);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not produce output from builtin commands </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (when in non-interactive mode)              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;quiet&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
       pel_appl_verbose = FALSE;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not produce output from (psrp) server commands </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (when in non-interactive mode)                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;squiet&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
       server_verbose = FALSE;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Execute command in non-interactive mode </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;c&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>(strccpy(psrp_request,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[psrp] expecting PSRP request&quot;</span>);

       interactive_mode = FALSE;
       pups_error_abort = TRUE;

<span class="PreProc">       #ifdef PSRP_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;NON INTERACTIVE CMD: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,psrp_request);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Turn transaction logging on </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;log&quot;</span>,&amp;argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  psrp_log          = TRUE;
       log_state_updated = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Transaction logging enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                    date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If any arguments remain unparsed - complain and stop </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    pups_t_arg_errs(argd,args);


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Handle SIGPIPE </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)psrp_int_handler,(sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Current client is alway 1 for client end of PSRP connection </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    c_client = <span class="Constant">9999</span>;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create a communication channel to the target server process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(psrp_server,<span class="Constant">&quot;none&quot;</span>) != <span class="Constant">0</span> &amp;&amp; (server_connected = psrp_open_server()) == FALSE)
       (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start interacting with PSRP server process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupsighold(SIGCLIENT,TRUE);
    <span class="Statement">if</span>(interactive_mode == TRUE)
       psrp_command_loop();
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(server_pid != <span class="Constant">0</span> &amp;&amp; strin(psrp_request,<span class="Constant">&quot;close&quot;</span>) == FALSE)
          (<span class="Type">void</span>)strlcat(psrp_request,<span class="Constant">&quot;; close</span><span class="Special">\n</span><span class="Constant">&quot;</span>,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcat(psrp_request,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,SSIZE);

       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)&amp;psrp_int_handler, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)psrp_process_command(psrp_request);
    }

    <span class="Statement">if</span>(psrp_log == TRUE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">psrp(protocol </span><span class="Special">%5.2F</span><span class="Constant">): closing communication channel (</span><span class="Special">%d</span><span class="Constant"> transactions)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                              PSRP_PROTOCOL_VERSION,t_cnt);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }

    remove_junk();

    <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
       pups_exit(<span class="Constant">255</span>);
    pups_exit(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to establish a PSRP connection with a remote server process and open up a </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> dialogue with it                                                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_command_loop(<span class="Type">void</span>)

{   <span class="Type">char</span> promptc,
         expanded_request_line[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN looper  = TRUE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Process interrupt requests (from user) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(interactive_mode == TRUE)
       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)&amp;psrp_int_handler, (sigset_t *)<span class="Constant">NULL</span>);

<span class="Statement">toploop</span>:

    <span class="Statement">do</span> {   <span class="Type">int</span> ret,
               chars,
               state,
               restore_signum;


           <span class="Statement">do</span> {

                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Re-entry point after SIGINT raised      </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Sometimes SIGCLIENT also re-enters here </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> if segmentation restart action is set   </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> appropriately                           </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(interactive_mode == TRUE)
                  {  (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);
                     (<span class="Type">void</span>)pups_set_jump_vector();
                     (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)&amp;psrp_int_handler, (sigset_t *)<span class="Constant">NULL</span>);
                  }

                  <span class="Statement">if</span>((restore_signum = sigsetjmp(command_loop_top,<span class="Constant">1</span>)) &gt; <span class="Constant">0</span>)
                  {
<span class="PreProc">                     #ifdef PSRP_DEBUG</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;IN RESTORE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                     #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(pupshold_cnt &gt; <span class="Constant">0</span>)
                       (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);

                     restore_system_status(restore_signum);


                     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Re-enable processing of interrupt requests (from user) </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(interactive_mode == TRUE)
                       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)&amp;psrp_int_handler, (sigset_t *)<span class="Constant">NULL</span>);


                     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> This section of code is entered if we have an active server </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> and it is not in the process of segmenting                  </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(server_pid != <span class="Constant">0</span> &amp;&amp; in_client_handler == FALSE)
                     {  <span class="Type">char</span> buf[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                        psrp_log           = FALSE;
                        processing_command = FALSE;
                        r_cnt              = <span class="Constant">0</span>;
                        initialise_repeaters();


                        <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Termination of commands of the form server[@host]: command  </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> But note we ONLY terminate if vectoring to command_loop_top </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> was the result of a SIGINT rather than a segmentation event </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> This status is signified by in_client_handler == FALSE      </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

                        <span class="Statement">if</span>(flycom == TRUE)
                        {
<span class="PreProc">                           #ifdef PSRP_DEBUG</span>
                           (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;SCONN:</span><span class="Special">%d</span><span class="Constant">  FLYCOM: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_connected,flycom);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">                           #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

                           flycom = FALSE;
                        }
                     }
                     <span class="Statement">else</span> <span class="Statement">if</span>(in_client_handler == TRUE &amp;&amp; seg_restart_action != EXIT_ON_INTR)
                     {

                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> If this is a segmentation event restart any request </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> interrupted by the segmentation                     </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                        in_client_handler  = FALSE;
                        processing_command = FALSE;
                        r_cnt              = <span class="Constant">0</span>;
                        initialise_repeaters();

                        <span class="Statement">goto</span> process_command;
                     }
                     <span class="Statement">else</span> <span class="Statement">if</span>(close_psrp_channel == TRUE)
                     {  close_psrp_channel = FALSE;


                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                        (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);

                        client_in  = pups_fclose(client_in);
                        client_out = pups_fclose(client_out);
                     }
                  }
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);

                  flycom             = FALSE;
                  in_client_handler  = FALSE;
                  processing_command = FALSE;


                  <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Get request from user </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

<span class="Statement">prompt</span>:           <span class="Statement">if</span>(server_pid != <span class="Constant">0</span>)
                     (<span class="Type">void</span>)pups_sighandle(SIGWINCH,<span class="Constant">&quot;winch_handler&quot;</span>,(<span class="Type">void</span> *)winch_handler,(sigset_t *)<span class="Constant">NULL</span>);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)pups_sighandle(SIGWINCH,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>,(sigset_t *)<span class="Constant">NULL</span>);


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Display # prompt (if PSRP connection is priviliged) </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(priviliged == TRUE)
                     promptc = <span class="Constant">'#'</span>;
                  <span class="Statement">else</span>
                     promptc = <span class="Constant">'&gt;'</span>;

                  (<span class="Type">void</span>)strlcpy(request_line,<span class="Constant">&quot;&quot;</span>,SSIZE);
                  (<span class="Type">void</span>)strlcpy(expanded_request_line,<span class="Constant">&quot;&quot;</span>,SSIZE);

                  in_prompt_loop = TRUE;

                  <span class="Statement">if</span>(prompt == TRUE)
                  {  <span class="Type">char</span> prompt_str[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                          remote[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
                          *next_line        = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

                     <span class="Statement">if</span>(is_remote == TRUE)
                        (<span class="Type">void</span>)strlcpy(remote,<span class="Constant">&quot;remote &quot;</span>,SSIZE);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)strlcpy(remote,<span class="Constant">&quot;&quot;</span>,SSIZE);

                     <span class="Statement">if</span>(redirected_requests != TRUE)
                     {  <span class="Statement">if</span>(strcmp(psrp_server,<span class="Constant">&quot;none&quot;</span>) == <span class="Constant">0</span>)
                        {  promptc    = <span class="Constant">'&gt;'</span>;
                           priviliged = FALSE;
                           (<span class="Type">void</span>)snprintf(prompt_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant"> (no server open@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">)&gt; &quot;</span>,remote,appl_name,appl_host,appl_owner);
                        }
                        <span class="Statement">else</span>
                        {

                           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment"> Display # prompt (if PSRP connection is priviliged) </span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                           <span class="Statement">if</span>(priviliged == TRUE)
                              promptc = <span class="Constant">'#'</span>;
                           <span class="Statement">else</span>
                              promptc = <span class="Constant">'&gt;'</span>;

                           (<span class="Type">void</span>)snprintf(prompt_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">%c</span><span class="Constant"> &quot;</span>,remote,appl_name,psrp_server,server_pid,appl_host,appl_owner,promptc);
                        }
                     }


                     <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> We MUST ensure that stdin is blocking    </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> irrespective of whether it is a terminal </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> FIFO or socket                           </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

                     (<span class="Type">void</span>)fcntl(<span class="Constant">0</span>,F_SETFL,fcntl(<span class="Constant">0</span>,F_GETFL,<span class="Constant">0</span>) &amp; ~O_NONBLOCK);


                     <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> SIGCLIENT enabled </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(from_tstp_handler == FALSE)
                     {     pupsigrelse(SIGCLIENT);
                           (<span class="Type">void</span>)write(<span class="Constant">1</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>);
                     }
                     <span class="Statement">else</span>
                        from_tstp_handler = TRUE;

<span class="PreProc">                     #ifdef HAVE_READLINE</span>
                     <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
                     {  <span class="Type">char</span> history_line[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                        (<span class="Type">void</span>)strlcpy(request_line,readline(prompt_str),SSIZE);
                        <span class="Statement">if</span>(strempty(request_line) == FALSE &amp;&amp; strexccpy(request_line,history_line,<span class="Constant">&quot;</span><span class="Special">\t</span><span class="Constant">&quot;</span>) &gt; <span class="Constant">0</span>)
                           (<span class="Type">void</span>)add_history(history_line);
                     }
                     <span class="Statement">else</span>
                     {   <span class="Statement">if</span>(redirected_requests != TRUE)
                            (<span class="Type">void</span>)write(<span class="Constant">1</span>,prompt_str,strlen(prompt_str));

                         (<span class="Type">void</span>)fgets(request_line,SSIZE,<span class="Constant">stdin</span>);
                     }
<span class="PreProc">                     #else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,prompt_str);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                     (<span class="Type">void</span>)fgets(request_line,SSIZE,<span class="Constant">stdin</span>);
<span class="PreProc">                     #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_READLINE </span><span class="Comment">*/</span>

                     (<span class="Type">void</span>)pupsighold(SIGCLIENT,TRUE);


                     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> If we have exhausted data on stdin (from psrprc file) </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> re-open stdin on /dev/tty for further interactive     </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> input                                                 </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(feof(<span class="Constant">stdin</span>) != <span class="Constant">0</span>)
                     {  <span class="Type">FILE</span> *stdin_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


                        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> If this client is slaved by a server we need to reattach </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> the server stdin (rather than /dev/tty)                  </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

                        <span class="Statement">if</span>(slave_in != (-<span class="Constant">1</span>))
                        {  (<span class="Type">void</span>)dup2(slave_in,<span class="Constant">0</span>);
                           (<span class="Type">void</span>)close(slave_in);

                           stdin_stream = <span class="Constant">stdin</span>;
                           stdin_stream = fdopen(<span class="Constant">0</span>,<span class="Constant">&quot;r&quot;</span>);
                        }
                        <span class="Statement">else</span>
                        {  (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
                           <span class="Constant">stdin</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
                        }

                        redirected_requests = FALSE;
                     }
                  }
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fgets(request_line,SSIZE,<span class="Constant">stdin</span>);

                  in_prompt_loop = FALSE;


                  <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Stop application wasting CPU time (when connected to FIFO) </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);

              } <span class="Statement">while</span>(request_line[<span class="Constant">0</span>] == <span class="Special">'\0'</span> || request_line[<span class="Constant">0</span>] == <span class="Constant">'#'</span> || request_line[<span class="Constant">0</span>] == <span class="Special">'\n'</span>);

<span class="Statement">process_command</span>:

              looper = psrp_process_command(request_line);
              (<span class="Type">void</span>)strlcpy(last_request_line,request_line,SSIZE);

        }  <span class="Statement">while</span>(looper == TRUE);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Process next (compound) PSRP command </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_process_command(<span class="Type">char</span> *request_line)

{   <span class="Type">int</span> i,
        status,
        req_cnt = <span class="Constant">0</span>;

    <span class="Type">char</span> strdum[SSIZE]            = <span class="Constant">&quot;&quot;</span>,
         tmp_str[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         request[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         reply[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         target[SSIZE]            = <span class="Constant">&quot;&quot;</span>,
         server_password[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         psrp_string[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         psrp_server_info[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         toxic_1[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         toxic_2[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         toxic_3[SSIZE]           = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN ret,
             looper,
             process_new,
             server_password_set = FALSE;

    <span class="Type">int</span>    dcnt       = <span class="Constant">0</span>,
           restore_signum,
           bytes_read = <span class="Constant">0</span>,
           isysc      = <span class="Constant">0</span>;

    <span class="Type">FILE</span>   *pstream   = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> sigaction action;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Autoclean patchboard directory removing </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> stale items                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_virtual_maggot(<span class="Constant">&quot;/tmp&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Possibly because we have a non-tty connection each line of input  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to remote server has a carriage return added to it - strip it off </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(is_remote == TRUE)
    {  <span class="Statement">if</span>((<span class="Type">int</span>)request_line[strlen(request_line) - <span class="Constant">1</span>] == <span class="Constant">13</span>)
          request_line[strlen(request_line) - <span class="Constant">1</span>] = <span class="Special">'\0'</span>;
    }

    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Increase recursion count </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    ++r_cnt;
    <span class="Statement">if</span>(r_cnt == <span class="Constant">1</span>)
       initialise_repeaters();


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Test macros are not nested too deep </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(r_cnt == MAX_MACRO_DEPTH)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: macros stacked too deep (max stack depth </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_MACRO_DEPTH);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;msderr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Strip any trailing white spaces from request </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strail(request_line,<span class="Constant">' '</span>);

    (<span class="Type">void</span>)strlcpy(request,<span class="Constant">&quot;&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(reply,<span class="Constant">&quot;&quot;</span>,SSIZE);

    (<span class="Type">void</span>)m_strext(r_cnt,(<span class="Type">unsigned</span> <span class="Type">char</span>)MSTREXT_RESET_ALL,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    <span class="Statement">do</span> {    looper = m_strext(r_cnt,<span class="Constant">';'</span>,tmp_str,request_line);
            process_new = TRUE;



            <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Re-entry point after SIGCLIENT raised if user </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> has specified that interrupted request should </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> be restarted                                  </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

            (<span class="Type">void</span>)pups_set_jump_vector();
            <span class="Statement">if</span>((restore_signum = sigsetjmp(process_loop_top,<span class="Constant">1</span>)) &gt; <span class="Constant">0</span>)
            {  restore_system_status(restore_signum);
               in_client_handler  = FALSE;
            }

            <span class="Statement">if</span>(looper == FALSE)
            {  --r_cnt;

               (<span class="Type">void</span>)pups_reset_jump_vector();
               <span class="Statement">return</span>(TRUE);
            }

            (<span class="Type">void</span>)strlcpy(request,strpch(<span class="Constant">' '</span>,tmp_str),SSIZE);
            (<span class="Type">void</span>)strail(request,<span class="Constant">' '</span>);


            <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Set automatic request retry mode (if server busy) </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;retry&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Type">char</span> strdum[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                    mode[SSIZE]   = <span class="Constant">&quot;&quot;</span>;

               <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,strdum,mode) != <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(busy_retry_mode == TRUE)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">automatic request retry mode currently enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;will make </span><span class="Special">%d</span><span class="Constant"> attempts to pass current request to server (at 1000 millisecond intervals)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                                                                  max_trys);
                     }
                  }

                  <span class="Statement">else</span> <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">automatic request retry mode currently disabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;will abort current request (if server currently busy)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  }
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">if</span>(strcmp(mode,<span class="Constant">&quot;on&quot;</span>) != <span class="Constant">0</span> &amp;&amp; strcmp(mode,<span class="Constant">&quot;off&quot;</span>) != <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: retry [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">return</span>(TRUE);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(mode,<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
               {  busy_retry_mode = TRUE;

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">automatic request retry mode enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)printf(<span class="Constant">stdout</span>,<span class="Constant">&quot;will make </span><span class="Special">%d</span><span class="Constant"> attempts to pass current request to server (at 1000 millisecond intervals)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                                                              max_trys);
                  }
               }
               <span class="Statement">else</span>
               {  busy_retry_mode = FALSE;

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">automatic request retry mode disabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)printf(<span class="Constant">stdout</span>,<span class="Constant">&quot;will abort current request (if server currently busy)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  }
               }
               (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> PML label - used as a re-entry marker for the resume statement, &quot;end&quot; is a dummy statement </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> which marks the end of an expanded macro                                                   </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(request[<span class="Constant">0</span>] == <span class="Constant">'%'</span> || strncmp(request,<span class="Constant">&quot;end&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
            {  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> PML pups_error handler - invokes target command (which may be a macro) </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> if psrp_req_pups_error is TRUE                                         </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;if&quot;</span>,<span class="Constant">2</span>) == <span class="Constant">0</span>)
            {

               <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Format of if command is: if &lt;condition&gt; &lt;macro&gt;|&lt;command&gt; </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> therefore if expects 2 arguments                          </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum,c_code,target) != <span class="Constant">3</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: </span><span class="Special">\&quot;</span><span class="Constant">if</span><span class="Special">\&quot;</span><span class="Constant"> requires condition and command/macro target</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  --r_cnt;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">return</span>(TRUE);
               }

               <span class="Statement">if</span>(strcmp(psrp_c_code,c_code) == <span class="Constant">0</span>)
               {

                  <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Condition code MUST be cleared before we process any recursive </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> command or they will enter the pups_error handler erroneously  </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  (<span class="Type">void</span>)strlcpy(request,target,SSIZE);
               }
               <span class="Statement">else</span>
                  <span class="Statement">goto</span> next_request;
           }

           <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;exit&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>    ||
              strncmp(request,<span class="Constant">&quot;bye&quot;</span>,<span class="Constant">3</span>)  == <span class="Constant">0</span>    ||
              strncmp(request,<span class="Constant">&quot;quit&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>     )
           {  --r_cnt;


<span class="PreProc">              #ifdef HAVE_READLINE</span>
              <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Save history </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)write_history(psrp_history);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_READLINE </span><span class="Comment">*/</span>

              (<span class="Type">void</span>)alarm(<span class="Constant">0</span>);
              <span class="Statement">return</span>(FALSE);
           }


           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If we are not trapping pups_errors and one has been raised </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> clear the pups_error and exit                              </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strcmp(request,<span class="Constant">&quot;perror&quot;</span>) != <span class="Constant">0</span>)
           {  <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
              {   (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);

                  <span class="Statement">if</span>(req_cnt &gt; <span class="Constant">0</span>)
                  {  --r_cnt;
                    <span class="Statement">return</span>(TRUE);
                  }
              }
           }


           <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> End - wind to (inserted) end statemant </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;end&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,tmp_str) &gt; <span class="Constant">1</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: </span><span class="Special">\&quot;</span><span class="Constant">end</span><span class="Special">\&quot;</span><span class="Constant"> does not have arguments</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  --r_cnt;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">return</span>(TRUE);
               }
               <span class="Statement">else</span>
               {  --r_cnt;
                  <span class="Statement">return</span>(TRUE);
               }
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;pups_errorabort&quot;</span>,<span class="Constant">10</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,tmp_str,tmp_str) != <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: pups_errorabort on|off</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">return</span>(TRUE);
               }
               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmp_str,<span class="Constant">&quot;on&quot;</span>) != <span class="Constant">0</span> &amp;&amp; strcmp(tmp_str,<span class="Constant">&quot;off&quot;</span>) != <span class="Constant">0</span>)
               {   <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: pups_errorabort on|off</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">return</span>(TRUE);
               }

               <span class="Statement">if</span>(strcmp(tmp_str,<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
                  pups_error_abort = TRUE;
               <span class="Statement">else</span>
                  pups_error_abort = FALSE;

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">  Pause - wait for user to type &lt;return&gt; </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;pause&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,tmp_str) &gt; <span class="Constant">1</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: pause</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  --r_cnt;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
               <span class="Statement">else</span>
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;press &lt;return&gt; to continue</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)fgets(tmp_str,SSIZE,<span class="Constant">stdin</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Abort - return to command prompt </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;abort&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,tmp_str) &gt; <span class="Constant">1</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: abort</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  --r_cnt;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
               <span class="Statement">else</span>
                  pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
            }


            <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Raise - raise psrp_c_code pups_error condition </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;raise&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,psrp_c_code) != <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: raise &lt;condition code&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  --r_cnt;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Resume transaction at label </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;resume&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
            {  <span class="Type">char</span> label[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,label) != <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: resume &lt;label&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  --r_cnt;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">return</span>(TRUE);
               }
               <span class="Statement">else</span>
               {  <span class="Statement">if</span>(label[<span class="Constant">0</span>] != <span class="Constant">'%'</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: label for </span><span class="Special">\&quot;</span><span class="Constant">resume</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) malformed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,label);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     --r_cnt;

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">return</span>(TRUE);
                  }
                  <span class="Statement">else</span>
                  {  req_find(r_cnt,label,request_line);
                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }
           }


           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Is this to be interpreted as a command (e.g. no attempt is to be made  </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> to expand it) -- this feature enables us to overload names (macros and </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> commands can have the same name without clashing)                      </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;atomic&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
           {  <span class="Type">int</span>  start_index = <span class="Constant">0</span>;

              <span class="Statement">while</span>(request[start_index] != <span class="Special">'\n'</span> &amp;&amp; request[start_index] != <span class="Special">'\0'</span> &amp;&amp; request[start_index] != <span class="Constant">' '</span>)
                    ++start_index;

              <span class="Statement">if</span>(request[start_index] == <span class="Special">'\n'</span> || request[start_index] == <span class="Special">'\0'</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: atomic &lt;pdf&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                    <span class="Statement">return</span>(TRUE);
                 }

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
              }

              macro_expansion = FALSE;
              (<span class="Type">void</span>)strlcpy(tmp_str,&amp;request[start_index+<span class="Constant">1</span>],SSIZE);
              (<span class="Type">void</span>)strlcpy(request,tmp_str,SSIZE);
           }


           <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Set repeat period (for repeated command) </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;rperiod&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
           {  <span class="Type">char</span> tmpstr[SSIZE]    = <span class="Constant">&quot;&quot;</span>;
              <span class="Type">int</span>  tmp_rpt_period = (-<span class="Constant">1</span>);

              <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmpstr,tmpstr) != <span class="Constant">2</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: rperiod &lt;repeat period in seconds&gt; | default</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
              }

              <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;default&quot;</span>) != <span class="Constant">0</span> &amp;&amp; (sscanf(tmpstr,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;tmp_rpt_period) != <span class="Constant">1</span> || tmp_rpt_period &lt;= <span class="Constant">0</span>))
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: rperiod &lt;repeat period in seconds&gt; | default</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
              }
              <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
                 tmp_rpt_period = PSRP_RPT_DEFAULT;
              <span class="Statement">else</span> <span class="Statement">if</span>(tmp_rpt_period == (-<span class="Constant">1</span>))
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: rperiod &lt;repeat period in seconds&gt; | default</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
              }

              rpt_period = tmp_rpt_period;

              <span class="Statement">if</span>(pel_appl_verbose == TRUE)
              {  <span class="Statement">if</span>(rpt_period == PSRP_RPT_DEFAULT)
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">interval for </span><span class="Special">\&quot;</span><span class="Constant">repeat</span><span class="Special">\&quot;</span><span class="Constant"> directive is </span><span class="Special">%d</span><span class="Constant"> seconds (default)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,rpt_period);
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">interval for </span><span class="Special">\&quot;</span><span class="Constant">repeat</span><span class="Special">\&quot;</span><span class="Constant"> directive is </span><span class="Special">%d</span><span class="Constant"> seconds</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,rpt_period);

                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
              <span class="Statement">goto</span> next_request;
           }


           <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Is this a repeated request </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;repeat&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
           {  <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;

              <span class="Statement">if</span>(strcmp(request,<span class="Constant">&quot;repeat&quot;</span>) == <span class="Constant">0</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: repeat [cnt] &lt;PDF | inbuilt&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 --r_cnt;
                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(TRUE);
              }

              do_repeat[r_cnt] = TRUE;
              (<span class="Type">void</span>)strlcpy(tmp_str,&amp;request[ch_index(request,<span class="Constant">' '</span>) + <span class="Constant">1</span>],SSIZE);

              <span class="Statement">if</span>(sscanf(tmp_str,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;repeat_count) == <span class="Constant">1</span>)
              {  <span class="Statement">if</span>(repeat_count &lt;= <span class="Constant">0</span>)
                 {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: illegal </span><span class="Special">\&quot;</span><span class="Constant">repeat</span><span class="Special">\&quot;</span><span class="Constant"> modifier count to PSRP request</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                    }

                    --r_cnt;
                    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                    <span class="Statement">return</span>(TRUE);
                 }

                 (<span class="Type">void</span>)strlcpy(request,&amp;tmp_str[ch_index(tmp_str,<span class="Constant">' '</span>) + <span class="Constant">1</span>],SSIZE);
             }
             <span class="Statement">else</span>
                (<span class="Type">void</span>)strlcpy(request,tmp_str,SSIZE);

           }
           <span class="Statement">else</span>
              do_repeat[r_cnt] = FALSE;


           <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Show body (if command is a macro) </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;body&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
           {  <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;

              <span class="Statement">if</span>(strcmp(request,<span class="Constant">&quot;body&quot;</span>) == <span class="Constant">0</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: body &lt;PML macro&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 --r_cnt;
                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
              }

              show_body = TRUE;
              (<span class="Type">void</span>)strlcpy(request,(<span class="Type">char</span> *)index((<span class="Type">char</span> *)request,<span class="Constant">' '</span>),SSIZE);

           }
           <span class="Statement">else</span>
              show_body = FALSE;


            <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Expand any macros </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

            macros_expanded = FALSE;
            <span class="Statement">if</span>(macro_expansion == TRUE)
            {  <span class="Statement">if</span>(expand_macros_recursive(request,tmp_str) == FALSE)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                   {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: macro </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> not found</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,request);
                      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                   }

                   --r_cnt;
                   (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                   <span class="Statement">goto</span> next_request;
                }
            }
            <span class="Statement">else</span>
               macro_expansion = TRUE;


            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> If our request is a macro it may have been expanded into a </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> large aggregate of requests - process these recursively    </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(macros_expanded == TRUE)
            {

               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Body just prints out the body of the current macro - used  </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> for debugging purposes                                     </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(show_body == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,request);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }


               <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> If a repeat modifier has been detected, repeat the </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> macro                                              </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(do_repeat[r_cnt] == TRUE)
               {  <span class="Statement">if</span>(psrp_repeat_command(repeat_count,request) == FALSE)
                  {  --r_cnt;
                     <span class="Statement">return</span>(TRUE);
                  }
               }
               <span class="Statement">else</span>
               {  <span class="Statement">if</span>(psrp_process_command(request) == FALSE)
                  {  --r_cnt;
                     <span class="Statement">return</span>(TRUE);
                  }
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

<span class="PreProc">            #ifdef SSH_SUPPORT</span>
            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;connect&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(builtin_connect_remote_client(request) == FALSE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to connect remote client</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               <span class="Statement">goto</span> next_request;
            }
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


            <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Process aggregates - that is commands of the form server[@host]: &lt;command-list&gt; </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

            (<span class="Type">void</span>)strlcpy(request,tmp_str,SSIZE);

            <span class="Statement">if</span>((request_type = expand_request(tmp_str,request,&amp;flycom,psrp_host)) == PSRP_REQUEST_ERROR)
                <span class="Statement">goto</span> next_request;


            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Request is local - but has been expanded into an aggregate </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> command                                                    </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(request_type == PSRP_LOCAL_AGGREGATE)
            {  <span class="Type">int</span>  child_pipe[<span class="Constant">2</span>]         = { [<span class="Constant">0</span> ... <span class="Constant">1</span>] = (-<span class="Constant">1</span>) };

               <span class="Type">char</span> strdum[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
                    psrp_cmd[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
                    server_str[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
                    server_pid_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;



               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> An open server cannot be referenced in an aggregate command </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">               #ifdef PSRP_DEBUG</span>
               (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;AGGREGATE CMD (request: </span><span class="Special">%s</span><span class="Constant"> current server: </span><span class="Special">%s</span><span class="Constant">, pid </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request,psrp_server,server_pid);
               (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


               (<span class="Type">void</span>)snprintf(server_pid_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,server_pid);
               (<span class="Type">void</span>)sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,strdum,server_str);
               <span class="Statement">if</span>(strin(server_str,psrp_server) == TRUE || strin(server_str,server_pid_str) == TRUE)
               {
                  <span class="Statement">if</span>(strin(server_str,server_pid_str) == TRUE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">instance of PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is open (and cannot be referenced within aggregate command)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is open (and cannot be referenced within aggregate command)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  <span class="Statement">goto</span> next_request;
               }


               <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Do we have a password? </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
               {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                  (<span class="Type">void</span>)pipe(child_pipe);
                  (<span class="Type">void</span>)snprintf(tmpstr,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_password);
                  (<span class="Type">void</span>)write(child_pipe[<span class="Constant">1</span>],tmpstr,strlen(tmpstr));
                  (<span class="Type">void</span>)close(child_pipe[<span class="Constant">1</span>]);
               }


               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Get pathname for psrp client command </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(strccpy(psrp_cmd,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,appl_bin_name)) == (-<span class="Constant">1</span>))
                  pups_error(<span class="Constant">&quot;[psrp] failed to resolve ben path for psrp client&quot;</span>);


               <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Fork off child process which will actually run </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> local aggregate command                        </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>


<span class="PreProc">               #ifdef PSRP_DEBUG</span>
               (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRP COMMAND: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,psrp_cmd);
               (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>((child_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
               {

                  <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
                  {  <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
                     {  (<span class="Type">void</span>)close(<span class="Constant">0</span>);
                         (<span class="Type">void</span>)dup(child_pipe[<span class="Constant">0</span>]);
                         (<span class="Type">void</span>)close(child_pipe[<span class="Constant">0</span>]);

                         (<span class="Type">void</span>)execlp(psrp_cmd,appl_name,<span class="Constant">&quot;-recursive&quot;</span>,<span class="Constant">&quot;-password&quot;</span>,<span class="Constant">&quot;-c&quot;</span>,request,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                     }
                     <span class="Statement">else</span>
                         (<span class="Type">void</span>)execlp(psrp_cmd,appl_name,<span class="Constant">&quot;-recursive&quot;</span>,            <span class="Constant">&quot;-c&quot;</span>,request,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                  }


                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an pups_error has occured </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

                  pups_error(<span class="Constant">&quot;[psrp_process_command] failed to execute local slaved PSRP server (for aggregate command)&quot;</span>);
                  exit(<span class="Constant">255</span>);
               }


               <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span>
               {

                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> We need to be able to handle SIGINT in case the aggregate </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> command is interrupted                                    </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(interactive_mode == TRUE)
                     (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)&amp;psrp_int_handler, (sigset_t *)<span class="Constant">NULL</span>);


                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Has the aggregate command actually executed OK? </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pupswaitpid(FALSE,child_pid,&amp;status);
                  ret = WEXITSTATUS(status);


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Restore default action for SIGINT </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(interactive_mode == TRUE)
                     (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> For some reason ssh gives an exit code of 255 when  </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> PSRP server is terminated. This is a kludge, but it </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> fixes the (unwanted) error message                  </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(ret != <span class="Constant">0</span> &amp;&amp; strin(request,<span class="Constant">&quot;terminate&quot;</span>) == FALSE &amp;&amp; strin(request,<span class="Constant">&quot;kill&quot;</span>) == FALSE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to execute command (on local slaved PSRP server)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;prexerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }

               <span class="Statement">goto</span> next_request;
            }

<span class="PreProc">            #ifdef SSH_SUPPORT</span>
            <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Command to run on remote server </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">else</span> <span class="Statement">if</span>(request_type == PSRP_REMOTE_REQUEST)
            {  <span class="Type">char</span> ssh_remote_command[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                    ssh_remote_env[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

                <span class="Type">int</span> ret,
                    child_pipe[<span class="Constant">2</span>] = { [<span class="Constant">0</span> ... <span class="Constant">1</span>] = (-<span class="Constant">1</span>) };


              (<span class="Type">void</span>)psrp_exec_env(ssh_remote_env);
              (<span class="Type">void</span>)mchrep(<span class="Special">'\0'</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request);
              (<span class="Type">void</span>)snprintf(ssh_remote_command,SSIZE,<span class="Constant">&quot;bash -c '</span><span class="Special">%s</span><span class="Constant">; </span><span class="Special">%s</span><span class="Constant">'&quot;</span>,ssh_remote_env,request);


<span class="PreProc">              #ifdef PSRP_DEBUG</span>
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REMOTE CMD: (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ssh_remote_command);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


               <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Do we have a password? </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
               {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                  (<span class="Type">void</span>)pipe(child_pipe);
                  (<span class="Type">void</span>)snprintf(tmpstr,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_password);
                  (<span class="Type">void</span>)write(child_pipe[<span class="Constant">1</span>],tmpstr,strlen(tmpstr));
                         (<span class="Type">void</span>)close(child_pipe[<span class="Constant">1</span>]);
               }


               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>((child_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
               {

                  <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Terminal connection </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
                  {  <span class="Statement">if</span>(ssh_compression == TRUE)
                        (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-t&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,psrp_host,ssh_remote_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-t&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,psrp_host,ssh_remote_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                  }


                  <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> No terminal connection </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">else</span>
                  {  <span class="Statement">if</span>(ssh_compression == TRUE)
                        (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,psrp_host,ssh_remote_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,psrp_host,ssh_remote_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                  }


                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an pups_error has occured </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

                  pups_error(<span class="Constant">&quot;[psrp_process_command] failed to build ssh channel to remote host&quot;</span>);
                  exit(<span class="Constant">255</span>);
               }


               <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span>

               {

                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> We need to be able to handle SIGINT in case the remote </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> command is interrupted                                 </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(interactive_mode == TRUE)
                     (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)&amp;psrp_int_handler, (sigset_t *)<span class="Constant">NULL</span>);


                  <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Is the server actually running on the remote host? </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pupswaitpid(FALSE,child_pid,&amp;status);
                  ret = WEXITSTATUS(status);


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Restore default action for SIGINT </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(interactive_mode == TRUE)
                     (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);

                  <span class="Statement">if</span>(ret &lt; <span class="Constant">0</span>)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to execute ssh command (on remote host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_host);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;prexerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }

               <span class="Statement">goto</span> next_request;
            }
<span class="PreProc">            #else</span>
            <span class="Statement">else</span> <span class="Statement">if</span>(request_type == PSRP_REMOTE_REQUEST)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)strdate(date);
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): remote requests not supported(no socket support)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                 date,appl_name,appl_pid,appl_host,appl_owner);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


            <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Repeat loop for atomic commands </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(do_repeat[r_cnt] == TRUE)
            {  <span class="Statement">if</span>(psrp_repeat_command(repeat_count,request) == FALSE)
               {  --r_cnt;
                  <span class="Statement">return</span>(TRUE);
               }

               <span class="Statement">goto</span> next_request;
            }


<span class="PreProc">            #ifdef SLAVED_COMMANDS</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Send command to shell </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(request[<span class="Constant">0</span>] == <span class="Constant">'!'</span>)
            {  <span class="Statement">if</span>(strcmp(shell,<span class="Constant">&quot;false&quot;</span>) == <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Interactive shells are not permitted from this PSRP client (client is slaved)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psherr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">if</span>(strlen(request) &lt; <span class="Constant">2</span>)
               {
                  <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span> &amp;&amp; restricted_clist == FALSE)
                  {  exec_shell = TRUE;

<span class="PreProc">                     #ifdef NO_INTERACTIVE_SHELLS</span>
                     <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Interactive shells are not permitted from this PSRP client (no interactive shells allowed)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psherr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
<span class="PreProc">                     #else</span>  <span class="Comment">/*</span><span class="Comment"> NO_INTERACTIVE_SHELLS </span><span class="Comment">*/</span>
                     (<span class="Type">void</span>)pups_system(shell,shell,PUPS_WAIT_FOR_CHILD | PUPS_ERROR_EXIT,(<span class="Type">int</span> *)<span class="Constant">NULL</span>);
<span class="PreProc">                     #endif</span> <span class="Comment">/*</span><span class="Comment"> NO_INTERACTIVE_SHELLS </span><span class="Comment">*/</span>
                  }
                  <span class="Statement">else</span>
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Interactive remote shells are not supported for non pty (xrshd) connections (not running in terminal)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psherr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }
               <span class="Statement">else</span>
               {

                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> If we have a restricted command set filter the input to the shell. </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Only those commands which match the filter are permitted.          </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(restricted_clist == TRUE)
                  {  <span class="Statement">if</span>(command_permitted(&amp;request[<span class="Constant">1</span>]) == FALSE)
                     {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                        {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">command </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not permitted (shell commands restricted)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,&amp;request[<span class="Constant">1</span>]);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                        }

                        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psherr&quot;</span>,SSIZE);
                        <span class="Statement">goto</span> next_request;
                     }
                  }


<span class="PreProc">                  #ifdef NO_INTERACTIVE_SHELLS</span>
                  <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Has an interactive shell sneaked in through the back door? </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;sh&quot;</span>) == TRUE &amp;&amp; sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>) == <span class="Constant">1</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Interactive shells are not permitted from this PSRP client (back door interative shells not allowed)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psherr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> NO_INTERACTIVE_SHELLS </span><span class="Comment">*/</span>


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> If we have an '&amp;' detach this command from the client's process group </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> so keyboard signals sent to the client don't effect it                </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;&amp;&quot;</span>) == TRUE)
                     (<span class="Type">void</span>)pups_system(&amp;request[<span class="Constant">1</span>],shell,PUPS_ERROR_EXIT | PUPS_STREAMS_DETACHED | PUPS_NEW_SESSION,(<span class="Type">int</span> *)<span class="Constant">NULL</span>);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)pups_system(&amp;request[<span class="Constant">1</span>],shell,PUPS_WAIT_FOR_CHILD | PUPS_ERROR_EXIT,(<span class="Type">int</span> *)<span class="Constant">NULL</span>);

                  exec_shell = FALSE;

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
             }
           }
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>


            <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> PSRP builtin commands </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;lcwd&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  <span class="Type">char</span> cwd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,cwd,cwd) == <span class="Constant">1</span>)
                  (<span class="Type">void</span>)psrp_builtin_set_lcwd((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
               <span class="Statement">else</span>
                  (<span class="Type">void</span>)psrp_builtin_set_lcwd(cwd);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;wait&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  wait_for_psrp_server_startup = TRUE;

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP client will wait for server startup (and then connect to it)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;exit&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  exit_on_terminate = TRUE;

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)printf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP client will exit (if attached PSRP server terminates)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;nowait&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  wait_for_psrp_server_startup = FALSE;

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP client will abort connection attempt (if server is not running)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;pager&quot;</span>) == TRUE)
            {  <span class="Type">int</span>  args;

               <span class="Type">char</span> strdum[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                    tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum,tmpstr);


               <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Display usage information if requested or required </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(args == <span class="Constant">1</span>                                                                ||
                  args == <span class="Constant">2</span>                                                                &amp;&amp;
                  (strcmp(datasink_cmd,<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(datasink_cmd,<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)  &amp;&amp;
                  pel_appl_verbose == TRUE                                                  )
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: pager [help | usage] | [on | off | default | &lt;pager command:</span><span class="Special">%s</span><span class="Constant">&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,DEFAULT_PAGER);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }


               <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Disable pager </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
               {  do_datasink = FALSE;
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;psrp_int_handler&quot;</span>,(<span class="Type">void</span> *)psrp_int_handler,(sigset_t *)<span class="Constant">NULL</span>);

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">paging mode disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }


               <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Use current or default pager </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span> || strcmp(tmpstr,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
               {  do_datasink = TRUE;
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>, <span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">paging mode enabled (pager is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,datasink_cmd);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }


               <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Set pager command </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Default </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
               {  do_datasink = TRUE;
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>, <span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)strlcpy(datasink_cmd,DEFAULT_PAGER,SSIZE);

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">paging mode enabled (pager is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) [default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,datasink_cmd);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }


               <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Less </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;less&quot;</span>) == <span class="Constant">0</span>)
               {  do_datasink = TRUE;
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>, <span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)strlcpy(datasink_cmd,<span class="Constant">&quot;less&quot;</span>,SSIZE);

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">paging mode enabled (pager is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,datasink_cmd);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }


               <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> More </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;more&quot;</span>) == <span class="Constant">0</span>)
               {  do_datasink = TRUE;
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>, <span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                  (<span class="Type">void</span>)strlcpy(datasink_cmd,<span class="Constant">&quot;more&quot;</span>,SSIZE);

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">paging mode enabled (pager is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,datasink_cmd);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }


               <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Usage </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

               <span class="Statement">else</span>
               {

                  <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Display usage (error) </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: pager help | usage] | [on | off | default | &lt;pager command:</span><span class="Special">%s</span><span class="Constant">&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,DEFAULT_PAGER);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }


               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;sink&quot;</span>) == TRUE)
            {  <span class="Type">int</span>  args;

               <span class="Type">char</span> strdum[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
                    tmpstr_1[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                    tmpstr_2[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,strdum,tmpstr_1,tmpstr_2);
               <span class="Statement">if</span>(args == <span class="Constant">2</span> &amp;&amp; (strcmp(datasink_cmd,<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(datasink_cmd,<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>) &amp;&amp; pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: sink &lt;datasink command&gt; [bg]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
               <span class="Statement">else</span> <span class="Statement">if</span>(args == <span class="Constant">2</span>)
               {  (<span class="Type">void</span>)strlcpy(datasink_cmd,tmpstr_1,SSIZE);

                  <span class="Statement">if</span>(args == <span class="Constant">3</span> &amp;&amp; strcmp(tmpstr_2,<span class="Constant">&quot;bg&quot;</span>) == <span class="Constant">0</span>)
                     do_bg_datasink = TRUE;
                  <span class="Statement">else</span>
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: sink &lt;datasink command&gt; [bg]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }
               <span class="Statement">else</span> <span class="Statement">if</span>(args != <span class="Constant">2</span>)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: sink &lt;datasink command&gt; [bg]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">if</span>(do_datasink == TRUE)
                  do_datasink = FALSE;
               <span class="Statement">else</span>
                  do_datasink = TRUE;

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;clean&quot;</span>) == TRUE)
            {  <span class="Type">int</span>  args,
                    n_deleted = <span class="Constant">0</span>;

               <span class="Type">char</span> strdum[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
                    clean_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                    directory[SSIZE] = <span class="Constant">&quot;/tmp&quot;</span>;

               args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum,directory);

               <span class="Statement">if</span>(strcmp(strdum,<span class="Constant">&quot;clean&quot;</span>) == <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(args &gt; <span class="Constant">2</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: clean &lt;PSRP channel directory&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }

                  <span class="Statement">if</span>(args == <span class="Constant">1</span>)
                     n_deleted = psrp_virtual_maggot(<span class="Constant">&quot;/tmp&quot;</span>);
                  <span class="Statement">else</span>
                     n_deleted = psrp_virtual_maggot(directory);

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  <span class="Statement">if</span>(n_deleted == <span class="Constant">0</span>)
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channel directory </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is clean (no stale items found)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,directory);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channel directory </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> cleaned (</span><span class="Special">%d</span><span class="Constant"> stale items found)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,directory,n_deleted);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;cinit&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  rpt_curses_mode = TRUE;

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Curses mode enabled (for repeated commands)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;cend&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  rpt_curses_mode = FALSE;

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Curses mode disabled (for repeated commands)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;sleep&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Type">int</span> delay;

               <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%d</span><span class="Constant">&quot;</span>,tmp_str,&amp;delay) != <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: sleep &lt;seconds&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
               <span class="Statement">else</span>
               {  delay = iabs(delay);
                  pups_sleep(delay);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;cls&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
            {  cls();
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;quiet&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  pel_appl_verbose      = FALSE;
               save_pel_appl_verbose = FALSE;
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;squiet&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  server_verbose      = FALSE;
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;noisy&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
	    {  pel_appl_verbose      = TRUE;
               save_pel_appl_verbose = TRUE;
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;snoisy&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
	    {  server_verbose        = TRUE;
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;perror&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span> &amp;&amp; pel_appl_verbose == TRUE)
            {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;pups_error code: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,psrp_c_code);

               <span class="Statement">if</span>(pups_error_abort == TRUE)
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; (pups_error abort ON)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
               <span class="Statement">else</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; (pups_error abort OFF)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

               (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;version&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  <span class="Type">int</span> is_vmtype        = FALSE;

		  <span class="Type">char</span> machtype[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                       vmtype  [SSIZE] = <span class="Constant">&quot;&quot;</span>,
                       ostype  [SSIZE] = <span class="Constant">&quot;&quot;</span>,
                       hostname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP interaction client </span><span class="Special">%s</span><span class="Constant"> (PSRP protocol </span><span class="Special">%5.2F</span><span class="Constant">, PML version </span><span class="Special">%5.2F</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                  PSRP_VERSION,PSRP_PROTOCOL_VERSION,PML_VERSION);

                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


                  <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Use uname to get system information      </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> environment variables are not realiable  </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pups_sysinfo(hostname,ostype,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,machtype);


                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Check to see if we are running in virtual environment </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

                  is_vmtype= pups_os_is_virtual(vmtype);
		  <span class="Statement">if</span>(is_vmtype == TRUE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Running in </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> host (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,        machtype,ostype,vmtype,hostname);
                  <span class="Statement">else</span> <span class="Statement">if</span>(is_vmtype == FALSE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Running on </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> bare-metal host (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,machtype,ostype,hostname);
		  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Running on </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> unknown host</span><span class="Special">\n</span><span class="Constant">&quot;</span>,        machtype,ostype,hostname);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

<span class="PreProc">                  #ifdef ECRYPT_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Using (locally encrypted) named pipes (FIFO's) for PSRP channels</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #else</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Using named pipes (FIFO's) for PSRP channels</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> ECRYPT_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">                  #ifdef FLOAT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Floating point representation is single precision (</span><span class="Special">%d</span><span class="Constant"> bytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Statement">sizeof</span>(FTYPE));
<span class="PreProc">                  #else</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Floating point representation is double precision (</span><span class="Special">%d</span><span class="Constant"> bytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Statement">sizeof</span>(FTYPE));
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> FLOAT </span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

<span class="PreProc">                  #ifdef _OPENMP</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    </span><span class="Special">%d</span><span class="Constant"> parallel (OMP) threads available</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,omp_get_max_threads());
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> _OPENMP </span><span class="Comment">*/</span>


<span class="PreProc">                  #ifdef SHADOW_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with shadow support                  ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> SHADOW_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef NIS_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with NIS support                     ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> NIS_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef SSH_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with ssh support                     ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef DLL_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with DLL support                     ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef PTHREAD_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with thread support                  ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef PERSISTENT_HEAP_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with persistent heap support         ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef BUBBLE_MEMORY_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with dynamic bubble memory support   ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef CRIU_SUPPORT</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with state saving support            ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifndef NO_INTERACTIVE_SHELLS </span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with interactive shells              ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> NO_INTERACTIVE_SHELLS </span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef SLAVED_COMMANDS</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [with slaved commands                 ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Copyright (C), Tumbling Dice, 1994-2022 (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP is free software, covered by the GNU General Public License, and you are</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;welcome to change it and/or distribute copies of it under certain conditions.</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;See the GPL and LGPL licences at www.gnu.org for further details</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP comes with ABSOLUTELY NO WARRANTY</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
               <span class="Statement">else</span>
               {  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;id&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  <span class="Statement">if</span>(strcmp(appl_ttyname,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Client owner </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (uid:</span><span class="Special">%d</span><span class="Constant">, gid:</span><span class="Special">%d</span><span class="Constant">) (Controlling tty is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_owner,appl_uid,appl_gid,appl_ttyname);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Client owner </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (uid:</span><span class="Special">%d</span><span class="Constant">, gid:</span><span class="Special">%d</span><span class="Constant">) (No controlling tty)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_owner,appl_uid,appl_gid);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

<span class="PreProc">                  #ifdef SSH_SUPPORT</span>
                  <span class="Statement">if</span>(is_remote == TRUE)
                  {  <span class="Type">char</span> vmtype[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                     <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Are we running in virtual environment? </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(pups_os_is_virtual(vmtype) == TRUE)
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    this client is in a remote </span><span class="Special">%s</span><span class="Constant"> instance [from </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,vmtype,remote_host_pathname);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    this client is remote [from </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,remote_host_pathname);

                     <span class="Statement">if</span>(ssh_compression == TRUE)
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [connected via compressing secure shell (ssh) protocols] [via port </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ssh_remote_port);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    [connected via secure shell (ssh) protocols] [via port </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,            ssh_remote_port);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }
                  <span class="Statement">else</span>
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
                  {  <span class="Type">char</span> vmtype[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                     <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Are we running in virtual environment? </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(pups_os_is_virtual(vmtype) == TRUE)
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    this client is local to </span><span class="Special">%s</span><span class="Constant"> instance </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,vmtype,appl_host);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    this client is local to host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,appl_host);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  }

                  <span class="Statement">if</span>(do_rsnr == TRUE &amp;&amp; strcmp(psrp_server,<span class="Constant">&quot;none&quot;</span>) != <span class="Constant">0</span>)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Reverse name resolution (for  attached server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">]): cannot track PSRP channel dynamically</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                      psrp_server,server_pid,appl_host);
                  }

                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
               <span class="Statement">else</span>
               {  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
            }

<span class="PreProc">            #ifdef PSRP_AUTHENTICATE </span>
            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;user&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  builtin_change_user(request);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;password&quot;</span>,<span class="Constant">8</span>) == <span class="Constant">0</span>)
            {  builtin_set_password(request,appl_password);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;secure&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(builtin_set_password(request,server_password) == FALSE)
                  <span class="Statement">goto</span> next_request;

               (<span class="Type">void</span>)snprintf(request,SSIZE,<span class="Constant">&quot;secure </span><span class="Special">%s</span><span class="Constant">&quot;</span>,server_password);
               server_password_set = TRUE;
            }
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>

<span class="PreProc">            #ifdef SLAVED_COMMANDS</span>
            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;clist&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span> || psrp_get_password() == TRUE)
                  builtin_read_clist(TRUE,request);

               <span class="Statement">goto</span> next_request;
            }
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>


            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;chanstat&quot;</span>) == TRUE)
            {  <span class="Type">int</span>  args;

               _BOOLEAN show_all_servers = FALSE;

               <span class="Type">char</span> strdum[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
                    flag[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
                    directory[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum,flag,directory);


               <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Single argument case </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(args == <span class="Constant">1</span>)
                 (<span class="Type">void</span>)strlcpy(directory,appl_fifo_dir,SSIZE);


               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Two argument cases </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(args == <span class="Constant">2</span>)
               {

                  <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Public patchboard showing </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> live servers which we own </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

<span class="PreProc">                  #ifdef PSRP_DEBUG</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;FLAG: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,flag);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(strin(flag,<span class="Constant">&quot;-all&quot;</span>) == FALSE)
                    (<span class="Type">void</span>)strlcpy(directory,flag,SSIZE);


                  <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Private patchboard    </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> show all live servers </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

                  <span class="Statement">else</span>
                  {  (<span class="Type">void</span>)strlcpy(directory,appl_fifo_dir,SSIZE);
                     show_all_servers = TRUE;
                  }
               }


               <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Three argument cases </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(args == <span class="Constant">3</span>)
               {

                   <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Private patchboard show   </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> live servers which we own </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(strin(flag,<span class="Constant">&quot;-all&quot;</span>) == TRUE)
                     show_all_servers = TRUE;
                  <span class="Statement">else</span>
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: chanstat [-all] &lt;directory&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }


               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Too many arguments </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(strdum,<span class="Constant">&quot;chanstat&quot;</span>) == <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(args &gt; <span class="Constant">3</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: chanstat [-all] &lt;directory&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }

               psrp_show_channels(show_all_servers,directory);

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;killall&quot;</span>) == TRUE)
            {  <span class="Type">int</span>  args;

               <span class="Type">char</span> strdum[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
                    directory[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                    partname[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

               args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum,directory,partname);

               <span class="Statement">if</span>(strcmp(strdum,<span class="Constant">&quot;killall&quot;</span>) == <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(args == <span class="Constant">1</span> || args &gt; <span class="Constant">3</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: killall &lt;directory&gt; &lt;PSRP server spec&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
                  <span class="Statement">else</span> <span class="Statement">if</span>(args == <span class="Constant">1</span>)
                     (<span class="Type">void</span>)strlcpy(directory,appl_fifo_dir,SSIZE);

                  psrp_kill_servers(directory,partname);

                  <span class="Statement">if</span>(strcmp(appl_fifo_dir,<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)
                  {  <span class="Statement">if</span>(strcmp(appl_fifo_dir,<span class="Constant">&quot;/tmp&quot;</span>) != <span class="Constant">0</span>)
                        psrp_kill_servers(<span class="Constant">&quot;/tmp&quot;</span>,<span class="Constant">&quot;all&quot;</span>);
                  }
                  <span class="Statement">else</span> <span class="Statement">if</span>(args == <span class="Constant">2</span>)
                  {  <span class="Statement">if</span>(strcmp(appl_fifo_dir,<span class="Constant">&quot;/tmp&quot;</span>) != <span class="Constant">0</span>)
                        psrp_kill_servers(<span class="Constant">&quot;/tmp&quot;</span>,partname);
                  }
                  <span class="Statement">else</span>
                     psrp_kill_servers(directory,partname);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }
            }

<span class="PreProc">            #ifdef DLL_SUPPORT</span>
            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;dllstat&quot;</span>) == TRUE)
            {  <span class="Type">int</span>  args;
               <span class="Type">char</span> dll_pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,dll_pathname,dll_pathname);
               <span class="Statement">if</span>(args != <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;usage: dllstat &lt;DLL pathname&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               (<span class="Type">void</span>)pups_show_dll_orifices(<span class="Constant">stdout</span>,dll_pathname);
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;trys&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,strdum,&amp;max_trys) &lt; <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Will currently make </span><span class="Special">%d</span><span class="Constant"> attempts to complete PSRP requests</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,max_trys);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Will now make </span><span class="Special">%d</span><span class="Constant"> attempts to complete PSRP requests</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,max_trys);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;open&quot;</span>,<span class="Constant">4</span>) ==  <span class="Constant">0</span>)
            {

               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> We cannot open ourself - abort any attempt to do so! </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

               (<span class="Type">void</span>)snprintf(toxic_1,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">&quot;</span>,             appl_name);
               (<span class="Type">void</span>)snprintf(toxic_2,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">@localhost&quot;</span>,   appl_name);
               (<span class="Type">void</span>)snprintf(toxic_3,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_name,appl_host);

               <span class="Statement">if</span>(strin(request,toxic_1) == TRUE || strin(request,toxic_2) == TRUE || strin(request,toxic_3) == TRUE)
               {  <span class="Statement">if</span>(strin(request,appl_host) == TRUE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">attempt to self interact [</span><span class="Special">%s</span><span class="Constant">] -- aborting!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,toxic_3);
                  <span class="Statement">else</span> <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;localhost&quot;</span>) == TRUE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">attempt to self interact [</span><span class="Special">%s</span><span class="Constant">] -- aborting!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,toxic_2);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">attempt to self interact [</span><span class="Special">%s</span><span class="Constant">] -- aborting!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,toxic_1);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

                  <span class="Statement">goto</span> next_request;
               }


               <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> If we currently have a server open </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> close it                           </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(server_connected == TRUE)
               {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> If server is already open -- simply return </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,tmpstr,tmpstr);

                  <span class="Statement">if</span>(strcmp(psrp_server,tmpstr) == <span class="Constant">0</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is already open</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,psrp_host);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }

                  <span class="Statement">if</span>(psrp_close_server(FALSE,TRUE) == (-<span class="Constant">1</span>))
                  {  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;closerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                  server_connected   = FALSE;
                  psrp_log           = FALSE;
               }

               builtin_open_psrp_server(request);
               <span class="Statement">goto</span> next_request;
            }

<span class="PreProc">            #ifdef SSH_SUPPORT</span>
            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;compress&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
            {  <span class="Type">char</span> tmpstr[SSIZE]               = <span class="Constant">&quot;&quot;</span>,
                    new_ssh_remote_uname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               ssh_compression = FALSE;

               <span class="Statement">if</span>((ret = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,tmpstr,new_ssh_remote_uname,tmpstr)) == <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(strcmp(new_ssh_remote_uname,<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
                     ssh_compression = TRUE;
                  <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(new_ssh_remote_uname,<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
                     ssh_compression = FALSE;
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)strlcpy(ssh_remote_uname,new_ssh_remote_uname,SSIZE);
               }
               <span class="Statement">else</span> <span class="Statement">if</span>(ret == <span class="Constant">1</span>)
                  (<span class="Type">void</span>)strlcpy(ssh_remote_uname,appl_owner,SSIZE);
               <span class="Statement">else</span> <span class="Statement">if</span>(ret == <span class="Constant">3</span>)
               {  <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
                     ssh_compression = TRUE;
                  <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(new_ssh_remote_uname,<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
                     ssh_compression = FALSE;
                  <span class="Statement">else</span>
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting </span><span class="Special">\&quot;</span><span class="Constant">on</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">off</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,tmpstr);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">return</span>(TRUE);
                  }

                  (<span class="Type">void</span>)strlcpy(ssh_remote_uname,new_ssh_remote_uname,SSIZE);
               }

               <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  <span class="Statement">if</span>(ssh_compression == TRUE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">ssh compression </span><span class="Special">\&quot;</span><span class="Constant">on</span><span class="Special">\&quot;</span><span class="Constant"> [remote userid is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,ssh_remote_uname);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">ssh compression </span><span class="Special">\&quot;</span><span class="Constant">off</span><span class="Special">\&quot;</span><span class="Constant"> [remote userid is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,ssh_remote_uname);

                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
              <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;connect&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
            {  builtin_connect_remote_client(request);
               <span class="Statement">goto</span> next_request;
            }
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;close&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span> &amp;&amp; server_connected == TRUE)
            {  <span class="Statement">if</span>(psrp_close_server(FALSE,TRUE) == (-<span class="Constant">1</span>))
               {  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;closerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
               server_connected   = FALSE;
               psrp_log           = FALSE;

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;kill&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span> &amp;&amp; server_connected == TRUE)
            {

               <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of server </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> before we kill it                     </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

               (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


               <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Try to kill PSRP server </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(kill(server_pid,<span class="Constant">SIGTERM</span>) == (-<span class="Constant">1</span>))
               {

                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> If we fail to kill it better keep monitoring it! </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)server_alive_handler);
                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;killerr&quot;</span>,SSIZE);
               }


               <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Success - report on servers demise </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> and clean up broken connection     </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span>
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">target PSRP server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been killed (by active client)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                       psrp_server,server_pid,psrp_host);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                  server_connected = FALSE;
                  server_pid       = (-<span class="Constant">1</span>);
                  psrp_log         = FALSE;

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               }

               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;segaction&quot;</span>,<span class="Constant">9</span>) == <span class="Constant">0</span>)
            {  <span class="Type">int</span> n_args = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,tmp_str,tmp_str);

               <span class="Statement">if</span>(n_args == <span class="Constant">1</span> &amp;&amp; pel_appl_verbose == TRUE)
               {  <span class="Statement">switch</span>(seg_restart_action)
                  {     <span class="Statement">case</span> RESTART_INTR_MACRO: (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Macros restarted on server segmentation</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                                                 <span class="Statement">break</span>;

                        <span class="Statement">case</span> RESTART_INTR_REQ:   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Stalled request restarted on server segmentation</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                                                 <span class="Statement">break</span>;

                        <span class="Statement">case</span> EXIT_ON_INTR:       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Request processing interrupted on server segmentation</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                                                 <span class="Statement">break</span>;

                        <span class="Statement">default</span>:                 <span class="Statement">break</span>;
                  }
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }
               <span class="Statement">else</span> <span class="Statement">if</span>(n_args == <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(strncmp(tmp_str,<span class="Constant">&quot;macro&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
                     seg_restart_action = RESTART_INTR_MACRO;
                  <span class="Statement">else</span> <span class="Statement">if</span>(strncmp(tmp_str,<span class="Constant">&quot;request&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
                     seg_restart_action = RESTART_INTR_REQ;
                  <span class="Statement">else</span> <span class="Statement">if</span>(strncmp(tmp_str,<span class="Constant">&quot;exit&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
                     seg_restart_action = EXIT_ON_INTR;
                  <span class="Statement">else</span>
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: segaction macro|request|exit</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  <span class="Statement">switch</span>(seg_restart_action)
                     {     <span class="Statement">case</span> RESTART_INTR_MACRO: (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Macros restarted on server segmentation</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                                                    <span class="Statement">break</span>;

                           <span class="Statement">case</span> RESTART_INTR_REQ:   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Stalled request restarted on server segmentation</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                                                    <span class="Statement">break</span>;

                           <span class="Statement">case</span> EXIT_ON_INTR:       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Request processing interrupted on server segmentation</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                                                    <span class="Statement">break</span>;

                           <span class="Statement">default</span>:                 <span class="Statement">break</span>;
                      }
                      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }
               }
               <span class="Statement">else</span> <span class="Statement">if</span>(n_args &gt; <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: segaction macro|request|exit</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;chelp&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span> &amp;&amp; pel_appl_verbose == TRUE)
            {  builtin_psrp_help();
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Open macro editor (to define a new macro) </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;medit&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  builtin_edit_macro_definitions(FALSE,FALSE,request);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;mcload&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
            {  builtin_load_macro_definitions(TRUE, FALSE,request);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Append macro definitions from file (non-default) </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;mcappend&quot;</span>,<span class="Constant">9</span>) == <span class="Constant">0</span>)
            {  builtin_load_macro_definitions(TRUE, TRUE,request);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Load definition file noto macro stack </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;mload&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  builtin_load_macro_definitions(FALSE, FALSE,request);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Append macro definition file to (loaded) macro stack </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;mappend&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
            {  builtin_load_macro_definitions(FALSE, TRUE,request);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;mpurge&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
            {  <span class="Type">int</span> ret;


               <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Erase the macro file if the user has requested it </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

               ret = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,macro_f_name,tmp_str);


               <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> User pups_error - display usage </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(ret &lt; <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: mpurge &lt;macro file&gt;|all [erase]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }


               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Two parameter command - remove macro(s) but do not delete corresponding </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> definition file(s)                                                      </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(ret == <span class="Constant">2</span>)
               {  <span class="Statement">if</span>(strcmp(macro_f_name,<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)
                     purge_macros((<span class="Type">char</span> *)<span class="Constant">NULL</span>,TRUE,FALSE);
                  <span class="Statement">else</span>
                     purge_macros(macro_f_name,TRUE,FALSE);
               }


               <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Three parameter command - remove macro(s) and delete corresponding </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> definition files                                                   </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span> <span class="Statement">if</span>(ret == <span class="Constant">3</span>)
               {  <span class="Statement">if</span>(strcmp(macro_f_name,<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span> &amp;&amp; strcmp(tmp_str,<span class="Constant">&quot;erase&quot;</span>) == <span class="Constant">0</span>)
                     purge_macros((<span class="Type">char</span> *)<span class="Constant">NULL</span>,TRUE,TRUE);
                  <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmp_str,<span class="Constant">&quot;erase&quot;</span>) == <span class="Constant">0</span>)
                     purge_macros(macro_f_name,TRUE,TRUE);
               }


               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> User pups_error - display usage </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">else</span>
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: mpurge &lt;macro file&gt;|all [erase]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;macros&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
            {  show_macro_tags();
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;linktype&quot;</span>,<span class="Constant">8</span>) == <span class="Constant">0</span>)
            {  <span class="Type">char</span> linkstate[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               ret = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,linkstate,linkstate);
               <span class="Statement">if</span>(ret &gt; <span class="Constant">2</span>)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: linktype [&lt;hard | soft&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;satterr&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">if</span>(ret == <span class="Constant">1</span>)
               {  <span class="Statement">if</span>(pel_appl_verbose == TRUE &amp;&amp; psrp_hard_link == TRUE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channel hard linked: PSRP client will remain connected to stopped server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  <span class="Statement">else</span> <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channel soft linked: PSRP client will auto disconnect if connected server stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;                          and will refuse to open channels to stopped servers</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  }

                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
                  <span class="Statement">goto</span> next_request;
               }

               <span class="Statement">if</span>(strcmp(linkstate,<span class="Constant">&quot;hard&quot;</span>) == <span class="Constant">0</span>)
               {  psrp_hard_link = TRUE;

                  <span class="Statement">if</span>(pel_appl_verbose== TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channel hard linked: PSRP client will remain connected to stopped server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }
               }
               <span class="Statement">else</span>
               {  <span class="Statement">if</span>(strcmp(linkstate,<span class="Constant">&quot;soft&quot;</span>) == <span class="Constant">0</span>)
                  {  psrp_hard_link = FALSE;

                     <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channel soft linked: PSRP client will auto disconnect if connected server stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;                          and will refuse to open channels to stopped servers</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                     }
                  }
                  <span class="Statement">else</span>
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: linktype &lt;hard | soft&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;satterr&quot;</span>,SSIZE);
                     <span class="Statement">goto</span> next_request;
                  }
               }

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Commands from this point on assume that we have a server connected </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> and ready to process PSRP commands.                                </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(server_connected == FALSE)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  <span class="Statement">if</span>(secure_operation == FALSE)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;no server attached - cannot process PSRP command (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,request);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;no server attached - cannot complete (secure) operation (</span><span class="Special">%s</span><span class="Constant">) on server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,request);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               secure_operation = FALSE;
               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;satterr&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;log&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP request logging enabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               log_state_updated = TRUE;
               psrp_log          = TRUE;
            }

            <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;nolog&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP request logging disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               log_state_updated = TRUE;
               psrp_log          = FALSE;
            }

            <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;segcnt&quot;</span>) == TRUE &amp;&amp; pel_appl_verbose == TRUE)
            {  <span class="Statement">if</span>(server_seg_cnt == <span class="Constant">0</span>)
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not segmented</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server);
               <span class="Statement">else</span>
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> segment count of </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server,
                                                                          server_seg_cnt);
               (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

               (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
               <span class="Statement">goto</span> next_request;
            }


           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If we are about to overlay we must stop monitoring current server </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;overlay&quot;</span>,<span class="Constant">7</span>) == <span class="Constant">0</span>)
           {  <span class="Type">char</span> request_tail[SSIZE] = <span class="Constant">&quot;&quot;</span>;

              <span class="Statement">if</span>(strccpy(request_tail,strin2(request,<span class="Constant">&quot;-pen&quot;</span>)) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                 (<span class="Type">void</span>)sscanf(request_tail,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,new_psrp_server);
              <span class="Statement">else</span>
                 (<span class="Type">void</span>)sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,new_psrp_server,new_psrp_server);

              new_server_pid = server_pid;
           }


           <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Retry command if server was busy </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>


           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> We cannot open ourself - abort any attempt to do so! </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

           (<span class="Type">void</span>)snprintf(toxic_1,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">&quot;</span>,             appl_name);
           (<span class="Type">void</span>)snprintf(toxic_2,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">@localhost&quot;</span>,   appl_name);
           (<span class="Type">void</span>)snprintf(toxic_3,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_name,appl_host);

           <span class="Statement">if</span>(strin(request,toxic_1) == TRUE || strin(request,toxic_2) == TRUE || strin(request,toxic_3) == TRUE)
           {  <span class="Statement">if</span>(strin(request,appl_host) == TRUE)
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">attempt to self interact [</span><span class="Special">%s</span><span class="Constant">] -- aborting!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,toxic_3);
              <span class="Statement">else</span> <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;localhost&quot;</span>) == TRUE)
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">attempt to self interact [</span><span class="Special">%s</span><span class="Constant">] -- aborting!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,toxic_2);
              <span class="Statement">else</span>
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">attempt to self interact [</span><span class="Special">%s</span><span class="Constant">] -- aborting!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,toxic_1);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

              <span class="Statement">goto</span> next_request;
           }


<span class="Statement">busy_retry</span>:

           try_cnt = <span class="Constant">0</span>;


           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Grab the PSRP channel so we have the servers (metaphorical) ear! </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(psrp_grab_channel() == (-<span class="Constant">1</span>))
              <span class="Statement">goto</span> next_request;


           <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Force pause if change of server while current command is processing </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

           processing_command = TRUE;

           <span class="Statement">if</span>(request[<span class="Constant">0</span>] != <span class="Special">'\0'</span>)
           {  <span class="Type">int</span> ret,
                  ret_state,
                  current_server_pid;


              <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Test to see if server process exists </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(do_rsnr == FALSE)
                 current_server_pid = psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host);
              <span class="Statement">else</span>
                 current_server_pid = server_pid;

              ret_state = (ret = pups_statkill(server_pid,SIGCHAN) == (-<span class="Constant">1</span>));

              <span class="Statement">if</span>(ret_state &lt; <span class="Constant">0</span>)
              {

                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Has the server really terminated -- or has it actually migrated?         </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> If it has migrated  psrp_migrate_client_to_server_host() will not return </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(psrp_migrate_client_to_server_host() == <span class="Constant">0</span>)
                 {

                    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
                    <span class="Comment">/*</span><span class="Comment"> It has been terminated </span><span class="Comment">*/</span>
                    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

                    <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                    {  <span class="Statement">if</span>(ret == PUPS_TERMINATED)
                       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">target PSRP server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been terminated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                psrp_server,server_pid,psrp_host);
                          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                       }
                       <span class="Statement">else</span> <span class="Statement">if</span>(ret == PUPS_STOPPED &amp;&amp; psrp_hard_link == FALSE)
                       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">target PSRP server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been stopped</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                             psrp_server,server_pid,psrp_host);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                       }
                    }
                 }


                 <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Tell server to perform a disconnect on restart </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> if it is stopped                               </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(ret == PUPS_STOPPED &amp;&amp; psrp_hard_link == FALSE)
                    (<span class="Type">void</span>)kill(server_pid,SIGCLIENT);

                 (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                 server_connected   = FALSE;
                 server_seg_cnt     = <span class="Constant">0</span>;
                 processing_command = FALSE;
                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;stermerr&quot;</span>,SSIZE);


                 <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                 (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


                 <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> CLear curses mode (if nessessary) </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

                 cend();

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ptermerr&quot;</span>,SSIZE);
                 <span class="Statement">goto</span> next_request;
              }
              <span class="Statement">else</span>
                 server_pid = current_server_pid;


              <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">  Do logging if enabled </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(psrp_log == TRUE &amp;&amp; log_state_updated == FALSE &amp;&amp; pel_appl_verbose == TRUE)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) datagram connection via (full-duplex) channel </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                           psrp_server,server_pid,psrp_host,channel_name);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }


              <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Wait for server handshake - tells us </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> that SIGCHAN has been processed      </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

              psrp_waitfor_endop(<span class="Constant">&quot;EOP chan&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Tell server we want to talk to it </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)kill(server_pid,SIGPSRP);


              <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Negotiate connection with server process </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

              is_builtin = FALSE;

              <span class="Statement">while</span>(efgets(psrp_string,SSIZE,client_in) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                   (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);


              <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Pass request to server </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

<span class="PreProc">              #ifdef PSRP_DEBUG</span>
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REQUEST OUT </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

              (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request);
              (<span class="Type">void</span>)fflush(client_out);


              <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Activate (datasink if appropriate) </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(do_datasink == TRUE)
              {  <span class="Statement">if</span>((pstream = popen(datasink_cmd,<span class="Constant">&quot;w&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to execute datasink command </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,datasink_cmd);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

                    (<span class="Type">void</span>)kill(appl_pid,<span class="Constant">SIGINT</span>);
                 }

                 (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>,(sigset_t *)<span class="Constant">NULL</span>);


                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Send PSRP into the background if specified </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(do_bg_datasink == TRUE)
                    (<span class="Type">void</span>)kill(appl_pid,<span class="Constant">SIGTSTP</span>);
              }

              <span class="Statement">do</span> {

                     <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Get response from PSRP server process </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

                     (<span class="Type">void</span>)efgets(reply,SSIZE,client_in);

                     <span class="Statement">if</span>(do_repeat[r_cnt] == TRUE &amp;&amp; strin(reply,<span class="Constant">&quot;Illegal&quot;</span>) == TRUE)
                     {  do_repeat[r_cnt] = FALSE;
                        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sillerr&quot;</span>,SSIZE);
                     }


                     <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Has PSRP server terminated? If so detach and </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> and return to prompt mode                    </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(strncmp(reply,<span class="Constant">&quot;CST&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
                     {  (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);
                        <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                        {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;connection closed (server termination by active client)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                        }

                        server_seg_cnt     = <span class="Constant">0</span>;
                        psrp_log           = FALSE;
                        server_connected   = FALSE;
                        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;scliterr&quot;</span>,SSIZE);

                        (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);


                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> If we are slaved propagate CST (server termination) </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> flag to remote peer                                 </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                        <span class="Statement">if</span>(psrp_slaved == TRUE)
                        {  (<span class="Type">void</span>)printf(<span class="Constant">&quot;CST</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                        }

                        <span class="Statement">goto</span> next_request;
                     }


                     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> EOT safail means we have a security violation -- abort </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> connection to PSRP server.                             </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(strncmp(reply,<span class="Constant">&quot;EOT safail&quot;</span>,<span class="Constant">10</span>) == <span class="Constant">0</span>)
                     {  <span class="Statement">if</span>(psrp_close_server(FALSE,TRUE) == (-<span class="Constant">1</span>))
                        {  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;closerr&quot;</span>,SSIZE);
                           <span class="Statement">goto</span> next_request;
                        }

                        (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                        server_connected   = FALSE;
                        psrp_log           = FALSE;

                        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;safailerr&quot;</span>,SSIZE);
                        <span class="Statement">goto</span> next_request;
                     }


                     <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Write server reply to stdout </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(strncmp(reply,<span class="Constant">&quot;EOT&quot;</span>,<span class="Constant">3</span>) != <span class="Constant">0</span> &amp;&amp; log_state_updated == FALSE)
                     {  <span class="Statement">if</span>(server_verbose == TRUE)
                        {

<span class="PreProc">                           #ifdef HAVE_CURSES</span>
                           <span class="Statement">if</span>(rpt_curses_mode == TRUE &amp;&amp; in_repeat_command == TRUE)
                           {  <span class="Statement">if</span>(do_datasink == TRUE)
                              {  (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,reply);
                                 (<span class="Type">void</span>)fflush(pstream);
                              }
                              <span class="Statement">else</span>
                                 (<span class="Type">void</span>)printw(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,reply);
                           }
                           <span class="Statement">else</span>
<span class="PreProc">                           #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

                           {  <span class="Statement">if</span>(do_datasink == TRUE)
                              {  (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,reply);
                                 (<span class="Type">void</span>)fflush(pstream);
                              }
                              <span class="Statement">else</span>
                              {  (<span class="Type">void</span>)printf(<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,reply);
                                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                              }
                           }
                        }
                     }


                     <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> If we are slaved propagate EOT (end of transmission) </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> flag to remote peer                                  </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(strncmp(reply,<span class="Constant">&quot;EOT&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span> &amp;&amp; psrp_slaved == TRUE)
                     {  (<span class="Type">void</span>)printf(<span class="Constant">&quot;EOT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }
                 }  <span class="Statement">while</span>(strncmp(reply,<span class="Constant">&quot;EOT&quot;</span>,<span class="Constant">3</span>) != <span class="Constant">0</span>);


                 <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> If datasink is active terminate it </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(do_datasink == TRUE)
                 {  (<span class="Type">void</span>)pclose(pstream);
                    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;tstp_handler&quot;</span>,(<span class="Type">void</span> *)tstp_handler, (sigset_t *)<span class="Constant">NULL</span>);
                 }


                 <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Extract PSRP service function return code </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

                 (<span class="Type">void</span>)sscanf(reply,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,tmp_str,psrp_c_code);

<span class="PreProc">                 #ifdef PSRP_DEBUG</span>
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP CODE RETURNED: </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_c_code,reply);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">                 #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(log_state_updated == TRUE)
                    log_state_updated = FALSE;
                 <span class="Statement">else</span>
                 {  <span class="Statement">if</span>(psrp_log == TRUE)
                    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) EOT sent</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                          psrp_server,server_pid,psrp_host,psrp_string);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                    }
                 }

                 ++t_cnt;


                 <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Wait for server to tell us that SIGPSRP has been handled </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

                 psrp_waitfor_endop(<span class="Constant">&quot;EOP psrp&quot;</span>);

                 (<span class="Type">void</span>)empty_fifo(fileno(client_in));
                 (<span class="Type">void</span>)empty_fifo(fileno(client_out));

                 processing_command = FALSE;


                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> We have finished the current transaction - yield the channel so that           </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> other attached clients can submit their PSRP requests. SIGINT is blocked       </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> at this time, as we can only service it when the server is actually processing </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> a PSRP request                                                                 </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

                 psrp_yield_channel();


                 <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> If our server has returned busy lets do it all again! </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;busy&quot;</span>) == <span class="Constant">0</span>)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;psrp: retrying request (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                    <span class="Statement">if</span>(busy_retry_mode == TRUE &amp;&amp; try_cnt++ &lt; max_trys)
                    {  (<span class="Type">void</span>)pups_usleep(<span class="Constant">1000</span>);
                       <span class="Statement">goto</span> busy_retry;
                    }
                 }


                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Have we failed to get authorisation token? </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;autherr&quot;</span>) == <span class="Constant">0</span>)
                    priviliged = FALSE;
             }


             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Update local password (if last request updated server secure password) </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(server_password_set == TRUE)
             {  server_password_set = FALSE;
                (<span class="Type">void</span>)strlcpy(appl_password,server_password,SSIZE);
             }

<span class="Statement">next_request</span>: ++req_cnt;

             <span class="Statement">if</span>(psrp_slaved == TRUE)
             {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;EOT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
             }

             <span class="Statement">if</span>(pups_error_abort == TRUE &amp;&amp; strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
             {  <span class="Statement">if</span>(interactive_mode == FALSE)
                   pups_exit(<span class="Constant">255</span>);
                <span class="Statement">else</span>
                   pups_sigvector(<span class="Constant">SIGALRM</span>,&amp;command_loop_top);
             }

       } <span class="Statement">while</span>(looper == TRUE);

       (<span class="Type">void</span>)pups_reset_jump_vector();
       processing_command = FALSE;
       --r_cnt;
       <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for SIGCRITICAL (toggle handling of SIGINT) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> critical_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{   _IMMORTAL _BOOLEAN toggle = FALSE;

    _IMMORTAL <span class="Type">struct</span> sigaction ignore_sigint_action,
                               prev_sigint_action;

    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Ignore SIGINT </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(toggle == FALSE)
    {  toggle                          = TRUE;
       ignore_sigint_action.sa_handler = (<span class="Type">void</span> *)psrp_critical_int_handler;
       ignore_sigint_action.sa_flags   = <span class="Constant">0</span>;
       (<span class="Type">void</span>)sigaction(<span class="Constant">SIGINT</span>,&amp;ignore_sigint_action,&amp;prev_sigint_action);
    }


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Handle SIGINT </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  toggle = FALSE;
       (<span class="Type">void</span>)sigaction(<span class="Constant">SIGINT</span>,&amp;prev_sigint_action,(<span class="Type">struct</span> sigaction *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dummy handler for SIGTSTP </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> tstp_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">psrp client process does not support BSD style job control</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Send SIGCONT to rest of process group </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGCONT</span>);

    from_tstp_handler = TRUE;

    <span class="Statement">if</span>(exec_shell == FALSE)
       pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Handler for SIGPSRP - this is sent to suspend (and subsequently to reactivate) the</span>
<span class="Comment">    client during segmented server exec operations ...</span>
<span class="Comment">----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> client_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{   <span class="Type">int</span> ret  = <span class="Constant">0</span>,
        trys = <span class="Constant">0</span>,
        old_client_indes  = (-<span class="Constant">1</span>),
        old_client_outdes = (-<span class="Constant">1</span>);

    <span class="Type">char</span> current_psrp_server[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         pending_request[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">struct</span> stat buf;
    sigset_t    client_set;

    cend();

<span class="PreProc">    #ifdef PSRP_DEBUG </span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;CLIENT HANDLER</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    in_client_handler = TRUE;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Release signals once we have indicated that </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> client handler is active                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;client_set);
    (<span class="Type">void</span>)sigaddset(&amp;client_set,<span class="Constant">SIGTSTP</span>);
    (<span class="Type">void</span>)sigaddset(&amp;client_set,<span class="Constant">SIGTERM</span>);
    (<span class="Type">void</span>)sigaddset(&amp;client_set,SIGALIVE);
    (<span class="Type">void</span>)sigaddset(&amp;client_set,<span class="Constant">SIGALRM</span>);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_UNBLOCK,&amp;client_set,(sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have the channel to the server -- yield it -- we  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> may not be the first to acquire the seglock, in which   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> case its unfortunate possessor would hang!              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_yield_channel();


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> CURSES silently un-installs signal handler for SIGALRM </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> re-install it before proceding                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_vitrestart();


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save name of the current server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(current_psrp_server,psrp_server,SSIZE);


    <span class="Statement">if</span>(pel_appl_verbose == TRUE &amp;&amp; psrp_have_trailfile() == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;waiting for trailfile to migrated segment (</span><span class="Special">%d</span><span class="Constant">) of PSRP  server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                                                         server_seg_cnt+<span class="Constant">1</span>,psrp_server);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait to acquire seglock - when we have it re-connect to new segment  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> unless the file has disappeared, in which case we need to find where </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the new segment has migrated to before connecting to it              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>(pups_get_fd_lock(fileno(client_in),TSTLOCK) == FALSE)
          pups_sleep(<span class="Constant">100</span>);


    <span class="Statement">if</span>(pel_appl_verbose == TRUE &amp;&amp; psrp_have_trailfile() == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;trailfile to new segment (</span><span class="Special">%d</span><span class="Constant">) for server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> ready</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                         server_seg_cnt+<span class="Constant">1</span>,psrp_server);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Server has crashed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(psrp_server,<span class="Constant">&quot;none&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Release channel segment lock </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_in));
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> On a heavily loaded machine we may drop the connection  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> even if our target is a PSRP server, as it may not have </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> time to re-create its communication channel             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sleep(<span class="Constant">1</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have to be a bit clever here. If we are not the client which    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> initiated segmentation we need to look up the (possibly new) name  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> of the server using the PID                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we return FALSE here -- it means the entitiy we are waiting for </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is not a PSRP server. Abort to command line closing PSRP channel   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_pid_to_channelname(appl_fifo_dir,server_pid,psrp_server,appl_host);
    <span class="Statement">if</span>(strcmp(psrp_server,<span class="Constant">&quot;nochan&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is a not a PSRP server (cannot autoconnect it)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server);
           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       client_in  = pups_fclose(client_in);
       client_out = pups_fclose(client_out);

       (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
       server_connected   = FALSE;
       server_pid         = <span class="Constant">0</span>;
       server_seg_cnt     = <span class="Constant">0</span>;
       processing_command = FALSE;
       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;iclerr&quot;</span>,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;autocerr&quot;</span>,SSIZE);
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
    }

    <span class="Statement">if</span>(pel_appl_verbose == TRUE)
    {  <span class="Statement">if</span>(strcmp(current_psrp_server,psrp_server) != <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(strcmp(psrp_server,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP server [</span><span class="Special">%d</span><span class="Constant">] (name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) has terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_pid,psrp_server);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP server [</span><span class="Special">%d</span><span class="Constant">] has changed its name from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,server_pid,
                                                                                         current_psrp_server,
                                                                                                 psrp_server);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }

    <span class="Statement">if</span>(strcmp(current_psrp_server,psrp_server) != <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)snprintf(channel_name_out,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span> ,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
       (<span class="Type">void</span>)snprintf(channel_name_in,SSIZE,  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
       (<span class="Type">void</span>)snprintf(channel_name,SSIZE,     <span class="Constant">&quot;psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#IO#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>    ,psrp_server,psrp_host,server_pid,getuid());
    }

    (<span class="Type">void</span>)pups_usleep(<span class="Constant">100000</span>);


<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;GOT CHANNEL LOCK</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>



    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do we have a trailfile? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_have_trailfile() == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check for any requests which are pending as a result </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> of the client waiting for the new server segment     </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strlcpy(pending_request,<span class="Constant">&quot;&quot;</span>,SSIZE);
       <span class="Statement">if</span>(pups_monitor(<span class="Constant">0</span>,<span class="Constant">0</span>,<span class="Constant">100</span>) == READ_DATA)
       {  (<span class="Type">void</span>)read(<span class="Constant">0</span>,pending_request,<span class="Constant">256</span>);


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have a pending close operation on the server   </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> simply indicate &quot;no-connection&quot; to server and vector </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> back to the command loop top                         </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strncmp(pending_request,<span class="Constant">&quot;close&quot;</span>,<span class="Constant">5</span>) == <span class="Constant">0</span>    ||
             strncmp(pending_request,<span class="Constant">&quot;bye&quot;</span>,<span class="Constant">3</span>)   == <span class="Constant">0</span>    ||
             strncmp(pending_request,<span class="Constant">&quot;exit&quot;</span>,<span class="Constant">4</span>)  == <span class="Constant">0</span>    ||
             strncmp(pending_request,<span class="Constant">&quot;quit&quot;</span>,<span class="Constant">4</span>)  == <span class="Constant">0</span>     )
          {  server_connected = FALSE;
             (<span class="Type">void</span>)psrp_close_server(TRUE,FALSE);
             (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
             server_connected   = FALSE;
             processing_command = FALSE;
             psrp_log           = FALSE;
             psrp_log           = FALSE;
             initialise_repeaters();

             (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;scloscond&quot;</span>,SSIZE);
             (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
          }
          <span class="Statement">else</span>
          {  <span class="Type">int</span> i;


             <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Make sure that the pending request is serviced </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> when we vector back to the command loop top    </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

             processing_command = TRUE;


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check for a repeated command - if we get one we need to  </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> turn the repeat flag on as well                          </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(strncmp(pending_request,<span class="Constant">&quot;repeat&quot;</span>,<span class="Constant">6</span>) == <span class="Constant">0</span>)
                do_repeat[r_cnt] = TRUE;


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If we have accumulated a lot of requests during the      </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> segmentation operation -- this is possible if the server </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> has migrated far away in cyber space, the linefeeds need </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> to be replaced with ';' demarcation characters           </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(i=pups_strlen(pending_request) - <span class="Constant">2</span>; i&gt;=<span class="Constant">0</span>; --i)
             {  <span class="Statement">if</span>(pending_request[i] == <span class="Special">'\n'</span>)
                   pending_request[i] = <span class="Constant">';'</span>;
             }

             <span class="Statement">if</span>(strcmp(request_line,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)strlcat(request_line,<span class="Constant">&quot;; &quot;</span>,SSIZE);
                (<span class="Type">void</span>)strlcat(request_line,pending_request,SSIZE);
             }
             <span class="Statement">else</span>
                (<span class="Type">void</span>)strlcpy(request_line,pending_request,SSIZE);
          }
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a command of the form server: &lt;command&gt; the </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> leading server string should be stripped and (as the   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> server is already open) and a close should be appended </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strin(request_line,<span class="Constant">&quot;: &quot;</span>) == TRUE)
       {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)strpch(<span class="Constant">' '</span>,request_line);
          (<span class="Type">void</span>)strfrm(request_line,<span class="Constant">':'</span>,<span class="Constant">1</span>,tmpstr);
          (<span class="Type">void</span>)snprintf(request_line,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">; close</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tmpstr);
       }



       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Reconnect to server process </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)stat(channel_name_out,&amp;buf);
       current_out_inode = buf.st_ino;

       (<span class="Type">void</span>)stat(channel_name_in,&amp;buf);
       current_in_inode  = buf.st_ino;

       <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          <span class="Statement">if</span>(processing_command == TRUE)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">: server segment (</span><span class="Special">%d</span><span class="Constant">) now ready (restarting interrupted PSRP transaction)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                         psrp_server,server_seg_cnt+<span class="Constant">1</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">: server segment (</span><span class="Special">%d</span><span class="Constant">) now ready</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                               psrp_server,server_seg_cnt+<span class="Constant">1</span>);

          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">reconnecting PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [PSRP input channel ID changed]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                            psrp_server,server_pid,psrp_host);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       in_inode          = current_in_inode;
       out_inode         = current_out_inode;

       (<span class="Type">void</span>)cend();
       (<span class="Type">void</span>)psrp_close_server(TRUE,FALSE);
       server_connected  = FALSE;


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Reconnect server (testing for possible connection errors) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((server_connected  = psrp_open_server()) == FALSE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;server segment (</span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">):</span><span class="Special">%s</span><span class="Constant">):  reconnection failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                             date,appl_name,appl_pid,appl_host,appl_owner,server_seg_cnt+<span class="Constant">1</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

          (<span class="Type">void</span>)pups_release_fd_lock(old_client_indes);
          (<span class="Type">void</span>)close(old_client_indes);
          (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
       }
    }

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;CLIENT HANDLER EXIT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Where we vector to here depends on whether we are going to restart </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the precise request that was interrupted or the whole macro        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(seg_restart_action == RESTART_INTR_REQ &amp;&amp; strcmp(request_line,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;process_loop_top);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);

    in_client_handler = FALSE;
}





<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Handler for SIGCHAN -- this will be raised when another client (or other process) has</span>
<span class="Comment">    terminated the PSRP server process ...</span>
<span class="Comment">----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> chan_client_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the server has already disconnected by the time we get here </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> simply return to caller                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(server_connected == FALSE)
       <span class="Statement">return</span>(<span class="Constant">0</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Has the server really terminated -- or has it actually migrated?       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If it has migrated  rp_migrate_client_to_server_host() will not return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_migrate_client_to_server_host() == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">connection failed (PSRP server </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been terminated)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                     psrp_server,server_pid,psrp_host);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Release channel access lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_out));

    cend();
    remove_junk();
    pups_exit(<span class="Constant">255</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove junk prior to exiting </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> remove_junk(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Type">char</span> pwd_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         pwd_link_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(client_in != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_fclose(client_in);

    <span class="Statement">if</span>(client_out != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>(have_access_lock == TRUE)
       {  (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_out));
          have_access_lock = FALSE;
       }
       (<span class="Type">void</span>)pups_fclose(client_out);
    }

    (<span class="Type">void</span>)snprintf(pwd_link_name,SSIZE,<span class="Constant">&quot;/tmp/authtok.</span><span class="Special">%d</span><span class="Constant">.lnk.tmp&quot;</span>,getpid());

    <span class="Statement">if</span>(access(pwd_link_name,F_OK | R_OK | W_OK) == <span class="Constant">0</span>)
    {  <span class="Type">struct</span> stat stat_buf;

       (<span class="Type">void</span>)unlink(pwd_link_name);
       (<span class="Type">void</span>)snprintf(pwd_file_name,SSIZE,<span class="Constant">&quot;/tmp/authtok.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,appl_uid);
       (<span class="Type">void</span>)stat(pwd_file_name,&amp;stat_buf);

       <span class="Statement">if</span>(stat_buf.st_nlink == <span class="Constant">1</span>)
          (<span class="Type">void</span>)unlink(pwd_file_name);
    }

    <span class="Statement">if</span>(clist_alloc &gt; <span class="Constant">0</span>)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;clist_size; ++i)
          (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)clist[i]);
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)clist);
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Open channel to PSRP server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_open_server(<span class="Type">void</span>)

{   <span class="Type">int</span> trys = <span class="Constant">0</span>;

    <span class="Type">char</span> full_channel_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         psrp_server_info[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         tmp_str[SSIZE]            = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">struct</span> stat buf;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If server is already open -- simply return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(server_connected == TRUE)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is already open</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,psrp_host);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(TRUE);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build PSRP channel name bindings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(channel_name_out,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span> ,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
    (<span class="Type">void</span>)snprintf(channel_name_in,SSIZE,  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
    (<span class="Type">void</span>)snprintf(channel_name,SSIZE,     <span class="Constant">&quot;psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#IO#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>    ,psrp_server,psrp_host,server_pid,getuid());


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We HAVE to try to open the PSRP channel ahead of actually telling the server we </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> wish to do so (or even knowing whether it will support PSRP protocols). This is </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> so we can use the network lock manager to handle locking for PSRP. Note we can  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> only hold locks on an OPEN file object                                          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>((client_in = pups_fopen((<span class="Type">char</span> *)channel_name_in, <span class="Constant">&quot;r+&quot;</span>,DEAD)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {     (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
          ++trys;

          <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Problem opening PSRP input channel </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(trys &gt; max_trys)
          {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
             {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) could not open PSRP input channel</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                            psrp_server,
                                                                             server_pid,
                                                                              psrp_host,
                                                                           channel_name);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) connection failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
                (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
             }

             (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
             <span class="Statement">return</span>(FALSE);
          }
    }

    (<span class="Type">void</span>)stat(channel_name_in,&amp;buf);
    in_inode = buf.st_ino;

    trys = <span class="Constant">0</span>;
    <span class="Statement">while</span>((client_out = pups_fopen((<span class="Type">char</span> *)channel_name_out,<span class="Constant">&quot;r+&quot;</span>,DEAD)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {     pups_usleep(<span class="Constant">100</span>);
          ++trys;

          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Problem opening PSRP output channel </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(trys &gt; max_trys)
          {  (<span class="Type">void</span>)pups_fclose(client_in);

             <span class="Statement">if</span>(pel_appl_verbose == TRUE)
             {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) could not open PSRP output channel</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                             psrp_server,
                                                                              server_pid,
                                                                               psrp_host,
                                                                            channel_name);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) connection failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
                (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
             }



             (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
             <span class="Statement">return</span>(FALSE);
          }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if PSRP server is currently busy </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> if we are soft linked to it                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Soft link </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_hard_link == FALSE)
    {  trys = <span class="Constant">0</span>;

       <span class="Statement">while</span>(pups_get_fd_lock(fileno(client_out),TSTLOCK) != TRUE)
       {    pups_usleep(<span class="Constant">100</span>);
            ++trys;

            <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Problem acquiring file lock </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(trys &gt; max_trys)
             {  (<span class="Type">void</span>)pups_fclose(client_in);
                (<span class="Type">void</span>)pups_fclose(client_out);

                <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) busy</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                  psrp_server,
                                                   server_pid,
                                                    psrp_host,
                                                 channel_name);
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) connection failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                }

                (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
                <span class="Statement">return</span>(FALSE);
             }
        }
    }


    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hard link </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       pups_get_fd_lock(fileno(client_out),GETLOCK);


    have_access_lock = TRUE;

    (<span class="Type">void</span>)stat(channel_name_out,&amp;buf);
    out_inode = buf.st_ino;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that client will support PSRP protocol and that channels are intact </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(client_in == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> &amp;&amp; client_out == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) does not support Process Status Request Protocol (via </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                              psrp_server,
                                                                                               server_pid,
                                                                                                psrp_host,
                                                                                             channel_name);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) connection failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(FALSE);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(client_in == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || client_out == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">) broken PSRP channel</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                        date,
                                                                 psrp_server,
                                                                  server_pid,
                                                                   psrp_host,
                                                                  appl_owner);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">) connection failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,psrp_server,server_pid,psrp_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }

          (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;cbrokerr&quot;</span>,SSIZE);
          <span class="Statement">return</span>(FALSE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell server we wish to open a channel to it </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(do_rsnr == FALSE)
       server_pid = psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host);

    <span class="Statement">if</span>(pups_i_own(server_pid) == FALSE)
    {  (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_out));

       (<span class="Type">void</span>)printf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">user </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not own PSRP server </span><span class="Special">\%</span><span class="Constant">s</span><span class="Special">\&quot;</span><span class="Constant"> (cannot connect)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_owner,psrp_server);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">if</span>(pups_statkill(server_pid,SIGINIT) == PUPS_STOPPED)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                          date,
                                                   psrp_server,
                                                    server_pid,
                                                     psrp_host,
                                                    appl_owner);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">) connection failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,psrp_server,server_pid,psrp_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;csstoperr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">if</span>(pel_appl_verbose == TRUE)
    {  (<span class="Type">void</span>)printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">psrp(protocol </span><span class="Special">%5.2F</span><span class="Constant">): opening PSRP communication channel to </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                            PSRP_PROTOCOL_VERSION,psrp_server,server_pid,psrp_host);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)server_alive_handler);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell server that this is an OPEN operation on the PSRP </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> channel. Send password to authenticate remote access.  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;OPEN </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,appl_password);
    (<span class="Type">void</span>)fflush(client_out);
    (<span class="Type">void</span>)efgets(tmp_str,SSIZE,client_in);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;SERVER INFO: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tmp_str);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sscanf(tmp_str,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;server_seg_cnt);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are a remote client send full client path (rather </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> than client name) to server                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(is_remote == TRUE)
       (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host,remote_host_pathname);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);

    (<span class="Type">void</span>)fflush(client_out);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for server to handshake to tell us SIGCHAN (GRAB) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is processed                                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    psrp_waitfor_endop(<span class="Constant">&quot;EOP grope&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Release channel access lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_out));
    have_access_lock = FALSE;

    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Close channel to PSRP server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_close_server(<span class="Type">const</span> _BOOLEAN force_hard_link, <span class="Type">const</span> _BOOLEAN tell_server)

{

    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get channel access lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(have_access_lock == FALSE)
    {  <span class="Type">int</span> trys = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Soft link </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(psrp_hard_link == FALSE &amp;&amp; force_hard_link == FALSE)
       {
          <span class="Statement">while</span>(pups_get_fd_lock(fileno(client_out),TSTLOCK) != TRUE)
          {    pups_usleep(<span class="Constant">100</span>);
               ++trys;

               <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Problem acquiring file lock </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(trys &gt; max_trys)
                {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                   {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) busy</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     psrp_server,
                                                      server_pid,
                                                       psrp_host,
                                                    channel_name);
                      (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) request failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
                      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                   }

                   (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;soperr&quot;</span>,SSIZE);
                   <span class="Statement">return</span>(-<span class="Constant">1</span>);
                }
           }
       }

       <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Hard link </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
          (<span class="Type">void</span>)pups_get_fd_lock(fileno(client_out),GETLOCK);
    }


    (<span class="Type">void</span>)fflush(client_in);
    (<span class="Type">void</span>)fflush(client_out);

    (<span class="Type">void</span>)empty_fifo(fileno(client_in));
    (<span class="Type">void</span>)empty_fifo(fileno(client_out));

    <span class="Statement">if</span>(tell_server == TRUE)
    {  (<span class="Type">void</span>)kill(server_pid,SIGINIT);

       errno = <span class="Constant">0</span>;
       (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;CLOSE </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid);
       (<span class="Type">void</span>)fflush(client_out);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Wait for server handshake indicating (processing of SIGINIT (CLOSE) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> completed                                                           </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

       psrp_waitfor_endop(<span class="Constant">&quot;EOP close&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Release channel access lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_out));
    have_access_lock = FALSE;

    (<span class="Type">void</span>)ftruncate(fileno(client_in), <span class="Constant">0</span>);
    (<span class="Type">void</span>)ftruncate(fileno(client_out),<span class="Constant">0</span>);

    client_in =  pups_fclose(client_in);
    client_out = pups_fclose(client_out);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin command to open a connection to a new PSRP server process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (and close the connection to the current server if any)           </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> builtin_open_psrp_server(<span class="Type">char</span> *request)

{   <span class="Type">int</span>  ret,
         trys,
         tmp_pid = PSRP_TERMINATED;

    <span class="Type">char</span> tmp_str[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         tmp_str2[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         server[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
         psrp_parameters[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         rhost[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         channel_name[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

     _BOOLEAN exists = TRUE;

     <span class="Statement">if</span>(request == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting target PSRP server name</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
        <span class="Statement">return</span>;
     }

     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);
     (<span class="Type">void</span>)strext(<span class="Special">'\0'</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
     (<span class="Type">void</span>)strext(<span class="Constant">' '</span>,tmp_str,request);

     <span class="Statement">if</span>(strext(<span class="Constant">' '</span>,tmp_str,request) != END_STRING)
     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting server/host name</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psnynerr&quot;</span>,SSIZE);
        <span class="Statement">return</span>;
     }

     <span class="Statement">if</span>(ret == PSRP_DUPLICATE_PROCESS_NAME)
     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">vector channel name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> not unique</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,tmp_str);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sexerr&quot;</span>,SSIZE);
        <span class="Statement">return</span>;
     }
     <span class="Statement">else</span> <span class="Statement">if</span>(ret == TRUE)
        <span class="Statement">return</span>;


     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Check to see if we are going to try to talk to a PSRP </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> server on a remote host                               </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">// MAO - need to edit this </span>

     <span class="Statement">if</span>(strin(tmp_str,<span class="Constant">&quot;@&quot;</span>) == TRUE)
     {  <span class="Type">int</span>  i = <span class="Constant">0</span>;

<span class="PreProc">#ifndef SSH_SUPPORT</span>
        (<span class="Type">void</span>)strdate(date);
        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): remote open not supported (no ssh support)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner);

        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


        <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Host not up </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;nsuperr&quot;</span>,SSIZE);
        <span class="Statement">return</span>;
<span class="PreProc">#else</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


        (<span class="Type">void</span>)mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;:@&quot;</span>,tmp_str);
        (<span class="Type">void</span>)sscanf(tmp_str,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,server,rhost);


        <span class="Statement">while</span>(tmp_str[i] != <span class="Constant">'@'</span>)
        {     server[i] = tmp_str[i];
              ++i;
        }

        server[i++] = <span class="Special">'\0'</span>;
        (<span class="Type">void</span>)strpch(<span class="Constant">' '</span>,server);


        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Get name of the host which is currently running the server we wish to talk </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> to                                                                         </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)strlcpy(rhost,&amp;tmp_str[i],SSIZE);
        (<span class="Type">void</span>)strpch(<span class="Constant">' '</span>,rhost);


        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> If we are going to open a server which is implicitly running somewhere     </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> on the local cluster we need to find out where it is and then to subsitute </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> the name of that host                                                      </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

        {  <span class="Type">char</span> ssh_command[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
                ssh_remote_env[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                sshPortOpt[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

           <span class="Type">int</span> ret,
               status;


           <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Set up environment on remote host </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

           (<span class="Type">void</span>)psrp_exec_env(ssh_remote_env);


           <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Access remote server by PID </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(sscanf(server,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;server_pid) == <span class="Constant">1</span>)
              (<span class="Type">void</span>)snprintf(psrp_parameters,SSIZE,<span class="Constant">&quot;bash -c '</span><span class="Special">%s</span><span class="Constant">; psrp -spid  </span><span class="Special">%d</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">'&quot;</span>,ssh_remote_env,server_pid,rhost,appl_host,appl_name,appl_pid);


           <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Access remote server by name </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">else</span>
              (<span class="Type">void</span>)snprintf(psrp_parameters,SSIZE,<span class="Constant">&quot;bash -c '</span><span class="Special">%s</span><span class="Constant">; psrp -sname </span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">'&quot;</span>,ssh_remote_env,server,    rhost,appl_host,appl_name,appl_pid);


           <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Are we using a non standard port - we may be if the remote </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> end of this connection is living in a container            </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

           (<span class="Type">void</span>)snprintf(sshPortOpt,SSIZE,<span class="Constant">&quot;-p </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssh_remote_port);
           <span class="Statement">if</span>((child_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
           {


              <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Terminal connection to server </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
              {  <span class="Statement">if</span>(ssh_compression == TRUE)
                    (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-t&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-t&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
              }


              <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Non terminal connection to server </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">else</span>
              {  <span class="Statement">if</span>(ssh_compression == TRUE)
                    (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
              }


              <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an pups_error has occured </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

              pups_error(<span class="Constant">&quot;[builtin_open_psrp_server] failed to open ssh channel to remote host&quot;</span>);
              exit(<span class="Constant">255</span>);
           }
           <span class="Statement">else</span>
           {

              <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

              <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Is the server actually running on the remote host? </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)pupswaitpid(FALSE,child_pid,&amp;status);
              ret = WEXITSTATUS(status);

              <span class="Statement">if</span>(ret != <span class="Constant">0</span>)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to open remote PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> on host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,server,rhost);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sloerr&quot;</span>,SSIZE);
              }

              <span class="Statement">return</span>;

           }
        }
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

     }
     <span class="Statement">else</span>
     {

        <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Open request has the form open &lt;PSRP server&gt; </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> e.g. server is on the local host             </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)strlcpy(server,tmp_str,SSIZE);
     }


     trys             = <span class="Constant">0</span>;
     server_connected = FALSE;

     <span class="Statement">while</span>(server_connected == FALSE)
     {    do_rsnr = FALSE;

          <span class="Statement">if</span>(sscanf(server,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;tmp_pid) != <span class="Constant">1</span>)
             tmp_pid = psrp_channelname_to_pid(appl_fifo_dir,server,tmp_str2);
          <span class="Statement">else</span>
          {  exists  = psrp_pid_to_channelname(appl_fifo_dir,tmp_pid,server,tmp_str2);
             <span class="Statement">if</span>(psrp_channelname_to_pid(appl_fifo_dir,server,psrp_host) &lt; <span class="Constant">0</span>)
             {  do_rsnr = TRUE;

                <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Reverse server name resolution mode (cannot track PSRP channel dynamically)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                }
             }
          }

          <span class="Statement">if</span>(tmp_pid != PSRP_DUPLICATE_PROCESS_NAME    &amp;&amp;
             tmp_pid != PSRP_TERMINATED                &amp;&amp;
             exists  == TRUE                            )
          {  (<span class="Type">void</span>)strlcpy(psrp_server,server,SSIZE);
             (<span class="Type">void</span>)strlcpy(psrp_host,tmp_str2,SSIZE);
             server_pid = tmp_pid;

             <span class="Statement">if</span>((server_connected = psrp_open_server()) == FALSE)
             {  (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                (<span class="Type">void</span>)strlcpy(psrp_host,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                server_pid = (-<span class="Constant">1</span>);

                (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sexerr&quot;</span>,SSIZE);
                <span class="Statement">return</span>;
             }

             psrp_log         = FALSE;
             <span class="Statement">return</span>;
          }
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(wait_for_psrp_server_startup == FALSE)
             {  <span class="Statement">if</span>(tmp_pid == PSRP_TERMINATED || exists == FALSE)
                {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                   {  <span class="Statement">if</span>(is_remote == TRUE &amp;&amp; interactive_mode == FALSE)
                         (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot access process </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as PSRP server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server,appl_host);
                      <span class="Statement">else</span>
                         (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot access process </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as PSRP server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server);

                      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                   }

                   (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sexerr&quot;</span>,SSIZE);
                   <span class="Statement">return</span>;
                }
             }

             <span class="Statement">if</span>(exists == FALSE || tmp_pid == PSRP_TERMINATED)
             {  <span class="Statement">if</span>(trys == max_trys)
                {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                   {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">channel to target process (</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) does not exist</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server,appl_host);
                      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                   }

                   (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sexerr&quot;</span>,SSIZE);
                   <span class="Statement">return</span>;
                }
                <span class="Statement">else</span>
                {  ++trys;

                   <span class="Statement">if</span>(trys == <span class="Constant">1</span> &amp;&amp; pel_appl_verbose == TRUE)
                   {  (<span class="Type">void</span>)strdate(date);
                      (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">waiting for PSRP server </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant"> to start</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server,appl_host);
                      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                   }

                   (<span class="Type">void</span>)pups_sleep(TRY_TIMEOUT);
                }
             }

             <span class="Statement">if</span>(tmp_pid == PSRP_DUPLICATE_PROCESS_NAME)
             {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">target PSRP process name is not unique</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                }

                (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sunerr&quot;</span>,SSIZE);
                <span class="Statement">return</span>;
             }
         }
     }


     <span class="Statement">if</span>(pel_appl_verbose == TRUE)
     {  (<span class="Type">void</span>)strdate(date);
         (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant"> has started</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,server,appl_host);
         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
     }

}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display help on buitlin commands supported by the psrp client process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> builtin_psrp_help()

{    <span class="Type">FILE</span> *pstream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

     pstream = popen(datasink_cmd,<span class="Constant">&quot;w&quot;</span>);

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    PRSP process interaction client version </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,PSRP_VERSION);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    Macro control statements</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    if      &lt;cond&gt; &lt;cmd&gt;         : execute &lt;cmd&gt; if &lt;cond&gt; TRUE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    </span><span class="Special">%%</span><span class="Constant">&lt;label&gt;                     : target label for resume</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    resume </span><span class="Special">%%</span><span class="Constant">&lt;label&gt;              : resume macro execution at </span><span class="Special">%%</span><span class="Constant">&lt;label&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    pups_errorabort on|off       : PML script aborted if on and pups_error code for last command != </span><span class="Special">\&quot;</span><span class="Constant">ok</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    sleep   &lt;secs&gt;               : Delay PML script execution for &lt;secs&gt; second</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    end                          : end macro currently executing</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    abort                        : abort current PML script</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    atomic  &lt;cmd&gt;                : do not try to expand &lt;cmd&gt; as macro</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    body    &lt;cmd&gt;                : show body (if &lt;cmd&gt; is a macro)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    repeat  &lt;cnt&gt; &lt;command&gt;      : repeat command &lt;cnt&gt; times</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    rperiod &lt;seconds&gt;            : set repeat command repeat interval (in seconds)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    repeat  &lt;command&gt;            : repeat command infinitely</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    raise   &lt;cond&gt;               : raise condition &lt;cond&gt; (pups_mainly used for testing)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Builtin PSRP macro commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ===========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    medit                        : update PML (PSRP macro) definition file,  &lt;file&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    mcload   &lt;file&gt;              : load macro file overwriting macro stack (with syntax check)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    mcappend &lt;file&gt;              : append macro file to macro stack (with syntax check)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    mload    &lt;file&gt;              : load macro file overwriting macro stack)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    mappend  &lt;file&gt;              : append macro file to macro stack</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    mpurge   all|&lt;file&gt;          : delete all PML macros or those in &lt;file&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    macros                       : show tags for all loaded PML macros</span><span class="Special">\n</span><span class="Constant">&quot;</span>);



     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Builtin PSRP commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    =====================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    Help and display settings</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    =========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    version                      : version of this PSRP interaction client</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    chelp                        : display help on builtin commands for client</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    pager    on|off|&lt;pager&gt;      : Set output pager</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    quiet                        : do not display output from builtin PSRP client commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    squiet                       : do not display output from PSRP server dispatch functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    noisy                        : display output from builtin PSRP client commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    snoisy                       : display output from builtin PSRP server dispatch functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    perror                       : print pups_error handler status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    id                           : print owner, uid, gid and controlling tty for this [psrp] process</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

     <span class="Statement">if</span>(server_connected == TRUE)
     {  (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    log                          : switch PSRP protocol transaction logging on</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
        (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    nolog                        : switch PSRP protocol transaction logging on</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     }

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Curses settings</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ===============</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    cinit                        : enter curses mode (for repeated commands)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    cend                         : exit curses mode (for repeated commands)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    cls                          : clear screen</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    PSRP client action settings</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ===========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    open      &lt;server&gt;[@&lt;host&gt;]  : open PSRP server process &lt;server&gt; [on &lt;host&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    close                        : close PSRP server process</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    kill                         : kill PSRP server process immediately</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    trys      &lt;num trys&gt;         : set number of attempts to open PSRP server</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    retry     &lt;on | off&gt;         : enable or disable automatic request repetition (if server busy)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    wait                         : PSRP client will wait for server to start (and then connect to it)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    nowait                       : PSRP client will abort connection attempt (if server not running)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    exit                         : PSRP client will exit (if attached PSRP server terminates)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    lcwd      &lt;path&gt;             : set current working directory for PSRP client</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    sink      [&lt;dsink cmd&gt;] [bg] : redirect PSRP client output to datasink command [in background]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    clean     &lt;PSRP channel dir&gt; : clean stale PSRP channels from PSRP channel (patchboard) dir(ectory)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    chanstat  [-all] &lt;dir&gt;       : show active PSRP channels in (patchboard) &lt;directory&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    dllstat   &lt;DLL pathname&gt;     : show orifices exported by &lt;DLL name&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    linktype                     : show type of PSRP channel link</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    linktype  &lt;hard | soft&gt;      : set type of PSRP channel link (soft link disconnects if server stopped)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    killall   &lt;directory&gt; &lt;spec&gt; : Kill all PSRP servers in &lt;directory&gt; matching &lt;spec&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    segaction &lt;action&gt;           : specify/display request processing action on server segmenation</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    segcnt                       : display number of segments (for segmented server)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    quit | exit | bye            : terminate psrp client</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Builtin PSRP security commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ==============================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">     #ifdef PSRP_AUTHENTICATE </span>
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    user      &lt;username&gt;         : change session owner to &lt;username&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    password                     : set PSRP services authentication token</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    secure                       : set server side PSRP services authentication token</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>

<span class="PreProc">     #ifdef SLAVED_COMMANDS</span>
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    clist     &lt;clist file&gt;       : read list of commands which can be executed by slaved shells</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Builtin PSRP remote server commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ===================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">     #ifdef SSH_SUPPORT</span>
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    compress  [on | off]         : switch ssh compression on or off</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    connect   [&lt;user&gt;@]&lt;host&gt;    : connect to remote PSRP client on &lt;host&gt; [under UID &lt;user&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    &lt;srv&gt;: &lt;req&gt;                 : send &lt;req&gt; to &lt;srv&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">     #ifdef SSH_SUPPORT</span>
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    &lt;srv&gt;@&lt;host&gt;: &lt;req&gt;          : send &lt;req&gt; to &lt;srv&gt; running on &lt;host&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;                                 : &lt;host&gt;=? means search local cluster for &lt;srv&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;                                 : and then send request if &lt;srv&gt; is uniquely pups_located</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Pass command to shell</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    =====================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    !&lt;command&gt;                   : send command to users default shell</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Multiple command processing</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    ===========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    c1; c2; c3                   : process multiple requests       </span><span class="Special">\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;    c </span><span class="Special">\&quot;</span><span class="Constant">a1 a2</span><span class="Special">\&quot;</span><span class="Constant">                    : glob argument </span><span class="Special">\&quot;</span><span class="Constant">a1 a2</span><span class="Special">\&quot;</span><span class="Constant"> to a1a2 </span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
     (<span class="Type">void</span>)fflush(pstream);

     (<span class="Type">void</span>)pclose(pstream);
}



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for SIGINT when server is in a critical (blocking) state </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_critical_int_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">*** server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not interruptable</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for SIGINT - propagate to client - note that we have the PSRP channel if this </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> handler is not blocked                                                                </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span> pupsighold_cnt[];
_PRIVATE <span class="Type">int</span> psrp_int_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{    <span class="Type">int</span>  index;

     <span class="Type">char</span> junk[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
          signame[SSIZE] = <span class="Constant">&quot;&quot;</span>;


     <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Aggregate command which has been interrupted </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(request_type == PSRP_LOCAL_AGGREGATE)
        (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);


     <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Remote command which has been interrupted </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(request_type == PSRP_REMOTE_REQUEST)
        (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);


     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> If we don't have the channel lock, we cannot interrupt the server </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> process as it is dealing with someone else's request              </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(pups_get_fd_lock(fileno(client_in),TSTLOCK) == FALSE)
        (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);


     <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Sometimes this handler can be called as the client_handler    </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> exits - make sure that in_client_handler is FALSE (this means </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> command_loop_top will behave properly despite this interrupt) </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(in_client_handler == TRUE)
     {  in_client_handler     = FALSE;
        in_client_handler_int = TRUE;
        processing_command   = FALSE;
        initialise_repeaters();

<span class="PreProc">        #ifdef PSRP_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;CHALT IN INT_HANDLER</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

        <span class="Statement">return</span>(<span class="Constant">0</span>);
     }

<span class="PreProc">     #ifdef PSRP_DEBUG</span>
     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: SIGINT (child </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,child_pid);
     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

     cend();
     in_repeat_command = FALSE;
     pel_appl_verbose  = save_pel_appl_verbose;


     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> This fixes a bug which causes the PSRP client </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> to report a hold/relse count mismatch         </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(pupsighold_cnt[SIGCLIENT] == <span class="Constant">0</span>)
        pupsighold_cnt[SIGCLIENT] = <span class="Constant">1</span>;


     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Wait for child to exit before continuing -- this means       </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> children which change tty modes have a chance to restore     </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> them (so psrp's terminal handler continues to run correctly) </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(child_pid != (-<span class="Constant">1</span>))
     {  <span class="Type">int</span> status;

        (<span class="Type">void</span>)kill(child_pid,<span class="Constant">SIGINT</span>);
        (<span class="Type">void</span>)pupswaitpid(FALSE,child_pid,&amp;status);

<span class="PreProc">        #ifdef PSRP_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: SIGINT (child </span><span class="Special">%d</span><span class="Constant"> exited)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,child_pid);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

        child_pid = (-<span class="Constant">1</span>);
     }

<span class="PreProc">     #ifdef PSRP_DEBUG</span>
     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">interrupted (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_pid);
     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> We cannot interrupt a server if it is interacting with another client </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(server_connected == FALSE || in_prompt_loop == TRUE || is_builtin == TRUE)
     {  <span class="Statement">if</span>(interactive_mode == TRUE)
        {  (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
            (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">interactive (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_pid);
            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
        }
        <span class="Statement">else</span>
        {  (<span class="Type">void</span>)remove_junk();

           <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
              (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);

           (<span class="Type">void</span>)pups_exit(<span class="Constant">0</span>);
        }
     }


     <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Tell server that we have had a SIGINT raised </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> which it must process as a SIGABRT           </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Pass the details of the interrupting client  </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> to the server -- this permits thread control </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> in the case of multithreaded servers         </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(server_pid != (-<span class="Constant">1</span>))
     {

<span class="PreProc">        #ifdef PSRP_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ABRT sent (to server </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_pid);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

        (<span class="Type">void</span>)kill(server_pid,<span class="Constant">SIGABRT</span>);
     }


     <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> None interactive mode </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(interactive_mode == FALSE)
     {
<span class="PreProc">        #ifdef PSRP_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ABRT sent (to server </span><span class="Special">%d</span><span class="Constant">) wait for abrt</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_pid);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


        <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> PID of this process (so server knows who caused abort) </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;ABRT </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid);
        (<span class="Type">void</span>)fflush(client_out);


        <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Wait for server to inform us that it has finished abort </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> processing.                                             </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)psrp_waitfor_endop(<span class="Constant">&quot;EOP abrt&quot;</span>);
        (<span class="Type">void</span>)empty_fifo(fileno(client_in));
        (<span class="Type">void</span>)empty_fifo(fileno(client_out));
        (<span class="Type">void</span>)psrp_close_server(TRUE,TRUE);
        (<span class="Type">void</span>)remove_junk();

<span class="PreProc">        #ifdef PSRP_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ABRT sent (to server </span><span class="Special">%d</span><span class="Constant">) got abrt</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_pid);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

        <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
          (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);
        (<span class="Type">void</span>)pups_exit(<span class="Constant">0</span>);
     }


     <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> If we are processing a command abort it </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

     processing_command = FALSE;


     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> If we were executing a repeated command abort it </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

     initialise_repeaters();

     (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid);
     (<span class="Type">void</span>)fflush(client_out);
     (<span class="Type">void</span>)psrp_waitfor_endop(<span class="Constant">&quot;EOP abrt&quot;</span>);

     <span class="Statement">if</span>(flycom == FALSE)
        (<span class="Type">void</span>)psrp_yield_channel();

     --r_cnt;


<span class="Statement">done</span>:

         <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> If interrupt generated by SIGPIPE exit </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

         <span class="Statement">if</span>(signum == <span class="Constant">SIGPIPE</span>)
            pups_exit(<span class="Constant">255</span>);

         (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);

}





<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for broken channel (to server) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> server_alive_handler(vttab_type *tinfo, <span class="Type">char</span> *args)

{    <span class="Type">int</span> ret,
         current_in_inode,
         current_out_inode,
         current_server_pid;

     <span class="Type">struct</span>   stat buf;
     sigset_t set,
              o_set;

     <span class="Type">char</span> wait[SSIZE] = <span class="Constant">&quot;&quot;</span>;

     (<span class="Type">void</span>)sigfillset(&amp;set);
     (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,&amp;o_set);


     <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> If server is migrating to another host terminate homeostat </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(appl_rooted == FALSE &amp;&amp; migrating_segmentation == TRUE)
     {

        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);

        <span class="Statement">if</span>(pel_appl_verbose == TRUE)
        {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is migrating to another host (terminating server alive homeostat)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server);
           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
        }

        <span class="Statement">return</span>;
     }


     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> If we have a SIGCLIENT pending, service it immediately </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)sigpending(&amp;set);
     <span class="Statement">if</span>(sigismember(&amp;set,SIGCLIENT))
        pups_signalpause(SIGCLIENT);

     (<span class="Type">void</span>)stat(channel_name_out,&amp;buf);
     current_out_inode = buf.st_ino;

     (<span class="Type">void</span>)stat(channel_name_in,&amp;buf);
     current_in_inode  = buf.st_ino;


     <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Check to see if server is in a fit state to interact </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> with client                                          </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(in_client_handler == FALSE)
     {  <span class="Statement">if</span>(do_rsnr == FALSE)
        {  <span class="Statement">if</span>((current_server_pid = psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host)) == PSRP_DUPLICATE_PROCESS_NAME)
           {  do_rsnr          = TRUE;

              <span class="Statement">if</span>(pel_appl_verbose == TRUE)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is no longer unique (switching to implicit reverse server name resolution mode)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              current_server_pid = server_pid;
              (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
           }
        }
        <span class="Statement">else</span>
        {

           <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> check to see if this server is now unique </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>((current_server_pid = psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host)) &gt; <span class="Constant">0</span>)
           {  do_rsnr = FALSE;

              <span class="Statement">if</span>(pel_appl_verbose == TRUE)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now unique (switching to implicit server PID resolution mode)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
           }
           <span class="Statement">else</span>
              current_server_pid = server_pid;
        }
     }


     ret = pups_statkill(server_pid,SIGALIVE);

     <span class="Statement">if</span>(ret == PUPS_TERMINATED || (ret == PUPS_STOPPED &amp;&amp; psrp_hard_link == FALSE))
     {  cend();

        <span class="Statement">if</span>(ret == PUPS_TERMINATED)
        {

           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Has the server really terminated -- or has it actually migrated?        </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If it has migrated psrp_migrate_client_to_server_host() will not return </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

           psrp_migrate_client_to_server_host();

           <span class="Statement">if</span>(pel_appl_verbose == TRUE)
           {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">target PSRP server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been terminated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                      psrp_server,server_pid,psrp_host);
              (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
           }
        }
        <span class="Statement">else</span> <span class="Statement">if</span>(ret == PUPS_STOPPED)
        {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
           {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">target PSRP server process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been stopped</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                   psrp_server,server_pid,psrp_host);
              (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
           }
        }

        close_psrp_channel = TRUE;


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Tell server to perform a disconnect on retart </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> if it is stopped                              </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(ret == PUPS_STOPPED)
           kill(server_pid,SIGCLIENT);

        (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
        server_connected   = FALSE;
        server_pid         = (-<span class="Constant">1</span>);
        server_seg_cnt     = <span class="Constant">0</span>;
        processing_command = FALSE;
        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;stermerr&quot;</span>,SSIZE);


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


        <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> If we are running non-interactively -- exit </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(prompt == FALSE)
        {  <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);
           pups_exit(<span class="Constant">0</span>);
        }

        (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
     }
     <span class="Statement">else</span>
        current_server_pid = server_pid;


     <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Check for server in (overfork) wait state </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)snprintf(wait,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.wait&quot;</span>,channel_name_in);
     <span class="Statement">if</span>(access(wait,F_OK | R_OK | W_OK) == <span class="Constant">0</span> &amp;&amp; psrp_hard_link == FALSE)
     {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
        {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">target process </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has been overforked</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
           (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
        }

        close_psrp_channel = TRUE;


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Tell server to perform a disconnect on retart </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> if it is stopped                              </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(ret == PUPS_STOPPED)
           kill(server_pid,SIGCLIENT);

        (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
        server_connected   = FALSE;
        server_pid         = <span class="Constant">0</span>;
        server_seg_cnt     = <span class="Constant">0</span>;
        processing_command = FALSE;
        (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sovfmerr&quot;</span>,SSIZE);


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


        <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> If we are running non-interactively -- exit </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(prompt == FALSE)
        {  <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);
           pups_exit(<span class="Constant">0</span>);
        }

        (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
     }

     <span class="Statement">if</span>(in_client_handler == FALSE)
     {  _BOOLEAN reconnected = FALSE,
                 overlaying  = FALSE;

        <span class="Type">char</span> wait_channelname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

        _IMMORTAL <span class="Type">int</span> cr_cnt = <span class="Constant">0</span>;


        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Check to see if client I/P channel lost - if it is </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> wait for the server to provide a new channel and   </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> connect to it                                      </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)stat(channel_name_in,&amp;buf);
        current_in_inode = buf.st_ino;

        (<span class="Type">void</span>)snprintf(wait_channelname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.wait&quot;</span>,channel_name_in);
        <span class="Statement">if</span>(access(wait_channelname,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>) &amp;&amp; current_in_inode != in_inode)
        {  <span class="Type">int</span> trys = <span class="Constant">0</span>;


           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If we have just passed an overlay command to the new server </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> we must update the PSRP channel name                        </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strcmp(new_psrp_server,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
           {  <span class="Statement">if</span>(strcmp(new_psrp_server,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
                 (<span class="Type">void</span>)strlcpy(psrp_server,new_psrp_server,SSIZE);

              (<span class="Type">void</span>)strlcpy(new_psrp_server,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
              <span class="Statement">if</span>(new_server_pid != (-<span class="Constant">1</span>))
                 current_server_pid = server_pid = new_server_pid;

              (<span class="Type">void</span>)snprintf(channel_name_out,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span> ,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
              (<span class="Type">void</span>)snprintf(channel_name_in,SSIZE,  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
              (<span class="Type">void</span>)snprintf(channel_name,SSIZE,     <span class="Constant">&quot;psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#IO#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>    ,psrp_server,psrp_host,server_pid,getuid());

              overlaying = TRUE;
           }


           <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Wait for server to re-create channel </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

           trys = <span class="Constant">0</span>;
           <span class="Statement">while</span>(access(channel_name_in,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
           {   _BOOLEAN ret = FALSE;


               <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> If PSRP server has not re-created its channels in a second we will    </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> still drop the connection -- this has implications if the PSRP server </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> is running on a heavily loaded machine                                </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

               (<span class="Type">void</span>)pups_sleep(<span class="Constant">1</span>);
               (<span class="Type">void</span>)psrp_pid_to_channelname(appl_fifo_dir,server_pid,new_psrp_server,appl_host);

               <span class="Statement">if</span>(strcmp(new_psrp_server,psrp_server) != <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(strcmp(new_psrp_server,<span class="Constant">&quot;nochan&quot;</span>) == <span class="Constant">0</span>)
                  {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not a PSRP server (cannot autoconnect it)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     close_psrp_channel = TRUE;

                     (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                     server_connected   = FALSE;
                     server_pid         = (-<span class="Constant">1</span>);
                     server_seg_cnt     = <span class="Constant">0</span>;
                     processing_command = FALSE;
                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;iclerr&quot;</span>,SSIZE);


                     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                     (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);

                     (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;autocerr&quot;</span>,SSIZE);
                     (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
                  }
                  <span class="Statement">else</span>
                  {  pups_sleep(<span class="Constant">1</span>);
                     ++trys;

                  }

                  <span class="Statement">if</span>(strcmp(new_psrp_server,<span class="Constant">&quot;nohost&quot;</span>) != <span class="Constant">0</span>)
                  {  <span class="Statement">if</span>(in_new_getinfo == FALSE &amp;&amp; pel_appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server has changed its name from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> to </span><span class="Special">\%</span><span class="Constant">s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,psrp_server,new_psrp_server);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     (<span class="Type">void</span>)strlcpy(psrp_server,new_psrp_server,SSIZE);
                     (<span class="Type">void</span>)strlcpy(new_psrp_server,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
                     (<span class="Type">void</span>)snprintf(channel_name_out,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span> ,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
                     (<span class="Type">void</span>)snprintf(channel_name_in,SSIZE,  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,psrp_server,psrp_host,server_pid,getuid());
                     (<span class="Type">void</span>)snprintf(channel_name,SSIZE,     <span class="Constant">&quot;psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#IO#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>    ,psrp_server,psrp_host,server_pid,getuid());
                  }

                  overlaying = TRUE;
               }

               <span class="Statement">if</span>(trys &gt; max_trys)
               {  cend();

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)strdate(date);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">no client input channel to </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [not a PSRP server?]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                      psrp_server,server_pid,psrp_host);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  close_psrp_channel = TRUE;

                  (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                  server_connected   = FALSE;
                  server_pid         = <span class="Constant">0</span>;
                  server_seg_cnt     = <span class="Constant">0</span>;
                  processing_command = FALSE;
                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;iclerr&quot;</span>,SSIZE);


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


                  <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> If we are running non-interactively -- exit </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(prompt == FALSE)
                  {  <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
                        (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);
                     pups_exit(<span class="Constant">0</span>);
                  }

                  (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
               }

               ++trys;

               <span class="Statement">if</span>(access(channel_name_in,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
                  (<span class="Type">void</span>)pups_usleep(<span class="Constant">1000000</span>);
           }

           <span class="Statement">if</span>(pel_appl_verbose == TRUE)
           {  <span class="Statement">if</span>(cr_cnt == <span class="Constant">0</span>)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              (<span class="Type">void</span>)strdate(date);
              <span class="Statement">if</span>(pel_appl_verbose == TRUE)
              {  <span class="Statement">if</span>(overlaying == FALSE)
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">reconnecting PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [PSRP input channel ID changed]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                        psrp_server,server_pid,psrp_host);
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">autoconnecting overlayed PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [PSRP input channel]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);

                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              ++cr_cnt;
              <span class="Statement">if</span>(cr_cnt == <span class="Constant">2</span>)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                 cr_cnt = <span class="Constant">0</span>;
              }
           }

           (<span class="Type">void</span>)strlcpy(new_psrp_server,<span class="Constant">&quot;notset&quot;</span>,SSIZE);

           client_in = pups_fclose(client_in);
           client_in = pups_fopen(channel_name_in,<span class="Constant">&quot;r+&quot;</span>,DEAD);
           (<span class="Type">void</span>)stat(channel_name_in,&amp;buf);
           in_inode    = buf.st_ino;
           reconnected = TRUE;
        }


        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Check to see if client O/P channel lost - if it is </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> wait for the server to provide a new channel and   </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> connect to it                                      </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)stat(channel_name_out,&amp;buf);
        current_out_inode  = buf.st_ino;

        (<span class="Type">void</span>)snprintf(wait_channelname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.wait&quot;</span>,channel_name_out);
        <span class="Statement">if</span>(access(wait_channelname,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>)  &amp;&amp; current_out_inode != out_inode)
        {  <span class="Type">int</span> trys = <span class="Constant">0</span>;


           <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Wait for server to re-create channel </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">while</span>(access(channel_name_out,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>));
           {   <span class="Statement">if</span>(trys &gt; max_trys)
               {  cend();

                  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">no client output channel to </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [not a PSRP server?]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                             psrp_server,server_pid,psrp_host);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                  }

                  close_psrp_channel = TRUE;

                  (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
                  server_connected   = FALSE;
                  server_pid         = <span class="Constant">0</span>;
                  server_seg_cnt     = <span class="Constant">0</span>;
                  processing_command = FALSE;
                  (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;oclerr&quot;</span>,SSIZE);


                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Stop homeostatic monitoring of connection to server </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;server_alive_handler&quot;</span>);


                  <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> If we are running non-interactively -- exit </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(prompt == FALSE)
                  {  <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
                        pups_exit(<span class="Constant">255</span>);
                     pups_exit(<span class="Constant">0</span>);
                  }

                  (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
               }

               ++trys;

               <span class="Statement">if</span>(access(channel_name_out,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
                  (<span class="Type">void</span>)pups_usleep(<span class="Constant">1000000</span>);
           }

           server_pid = current_server_pid;

           <span class="Statement">if</span>(pel_appl_verbose == TRUE)
           {  <span class="Statement">if</span>(cr_cnt == <span class="Constant">0</span>)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              (<span class="Type">void</span>)strdate(date);
              <span class="Statement">if</span>(pel_appl_verbose == TRUE)
              {  <span class="Statement">if</span>(overlaying == FALSE)
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">reconnecting PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [PSRP output channel ID changed]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                         psrp_server,server_pid,psrp_host);
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">autoconnecting overlayed PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [PSRP output channel]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                        psrp_server,server_pid,psrp_host);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              ++cr_cnt;
              <span class="Statement">if</span>(cr_cnt == <span class="Constant">2</span>)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                 cr_cnt = <span class="Constant">0</span>;
              }
           }

           client_out = pups_fclose(client_out);
           client_out = pups_fopen(channel_name_out,<span class="Constant">&quot;r+&quot;</span>,DEAD);
           (<span class="Type">void</span>)stat(channel_name_out,&amp;buf);
           out_inode   = buf.st_ino;
           reconnected = TRUE;
        }

        <span class="Statement">if</span>(reconnected == TRUE)
           (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);
     }
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Expand requests of the form server@host: &lt;command list&gt; </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return first non-whitespace character </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">char</span> first_non_whitespace(<span class="Type">int</span> from, <span class="Type">char</span> *s)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(from &gt;= strlen(s))
       <span class="Statement">return</span>(<span class="Special">'\0'</span>);

    <span class="Statement">for</span>(i=from; i&lt;strlen(s); ++i)
    {  <span class="Statement">if</span>(s[i] != <span class="Constant">' '</span>)
          <span class="Statement">return</span>(s[i]);
    }

    <span class="Statement">return</span>(<span class="Special">'\0'</span>);
}


<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Expand aggregated and remote requests </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> expand_request(<span class="Type">char</span> *request, <span class="Type">char</span> *expanded_request, _BOOLEAN *flycom, <span class="Type">char</span> *rhost)

{   <span class="Type">int</span>  i,
         cnt             = <span class="Constant">0</span>,
         at_pos          = (-<span class="Constant">1</span>),
         sc_pos          = (-<span class="Constant">1</span>),
         n_ats           = <span class="Constant">0</span>,
         n_semicolons    = <span class="Constant">0</span>,
         request_type    = PSRP_LOCAL_ATOMIC;

    <span class="Type">char</span> tmpstr[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         rserver[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         reply[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN glob           = FALSE,
             scope_op_found = FALSE,
             psuedoserver   = FALSE;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If this is a shell command -- abort </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(first_non_whitespace(<span class="Constant">0</span>,request) == <span class="Constant">'!'</span>)
       <span class="Statement">return</span>(request_type);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open is not expanded here. This enables us to process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> remote open commands of the form open &lt;server&gt;@&lt;host&gt; </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;open&quot;</span>) == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check for syntax pups_errors in open request </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(first_non_whitespace(<span class="Constant">4</span>,request) == <span class="Constant">'@'</span>)
       {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error (open request has form server@host: &lt;command list&gt;)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }

          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
          <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
       }

       (<span class="Type">void</span>)strlcpy(expanded_request,request,SSIZE);
       <span class="Statement">return</span>(request_type);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(first_non_whitespace(<span class="Constant">0</span>,request) == <span class="Constant">'@'</span>)
          psuedoserver = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check request for syntax pups_errors </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;pups_strlen(request); ++i)
    {  <span class="Statement">if</span>(request[i] == <span class="Constant">':'</span> &amp;&amp; request[i+<span class="Constant">1</span>] != <span class="Constant">' '</span> &amp;&amp; isdigit(request[i+<span class="Constant">1</span>]) == <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error (expanded request has form server@host: &lt;command list&gt;)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }

          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
          <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
       }


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to see if we need to glob </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(request[i] == <span class="Constant">'&quot;'</span>)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Glob material enclosed in double quotes </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;!&quot;</span>)        == FALSE    &amp;&amp;
             strin(request,<span class="Constant">&quot;overfork&quot;</span>) == FALSE    &amp;&amp;
             strin(request,<span class="Constant">&quot;overlay&quot;</span>)  == FALSE     )
          {  <span class="Statement">if</span>(glob == TRUE)
                glob = FALSE;
             <span class="Statement">else</span>
                glob = TRUE;
          }

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Do not glob if we are going to submit this line to another </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> command processor                                          </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
             glob = FALSE;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(strncmp(&amp;request[i],<span class="Constant">&quot;::&quot;</span>,<span class="Constant">2</span>) == <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(scope_op_found == FALSE)
             {  tmpstr[cnt++]   =  request[i];
                i               += <span class="Constant">1</span>;
                scope_op_found  =  TRUE;
             }
          }
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(request[i] == <span class="Constant">':'</span> &amp;&amp; isdigit(request[i+<span class="Constant">1</span>]) == <span class="Constant">0</span>)
             {  sc_pos = i;
                ++n_semicolons;
             }
          }

          <span class="Statement">if</span>(request[i] == <span class="Constant">'@'</span>)
          { at_pos = i;
            ++n_ats;
          }

          <span class="Statement">if</span>(glob == FALSE)
             tmpstr[cnt++] = request[i];
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(request[i] != <span class="Constant">' '</span>)
                tmpstr[cnt++] = request[i];
          }
       }
    }

    <span class="Statement">if</span>(n_semicolons &gt; <span class="Constant">1</span> || (n_semicolons &gt; <span class="Constant">0</span> &amp;&amp; scope_op_found == TRUE))
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error (expanded request has form server@host: &lt;command list&gt;)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
    }

    <span class="Statement">if</span>(n_ats &gt; <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error (expanded request has form server@host: &lt;command list&gt;)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
    }

    <span class="Statement">if</span>(sc_pos - at_pos &lt; <span class="Constant">2</span> &amp;&amp; (sc_pos != (-<span class="Constant">1</span>) &amp;&amp; at_pos != (-<span class="Constant">1</span>)))
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error (expanded request has form server@host: &lt;command list&gt;)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
    }

    <span class="Statement">if</span>(at_pos &gt; sc_pos || sc_pos == <span class="Constant">0</span> || (at_pos == <span class="Constant">0</span> &amp;&amp; psuedoserver == FALSE))
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error (expanded request has form server@host: &lt;command list&gt;)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
    }

    (<span class="Type">void</span>)strlcpy(request,tmpstr,SSIZE);
    <span class="Statement">if</span>(n_semicolons &gt; <span class="Constant">0</span> &amp;&amp; strin(request,<span class="Constant">&quot;:&quot;</span>) == TRUE &amp;&amp; strin(request,<span class="Constant">&quot;::&quot;</span>) == FALSE)
    {  i = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get name of remote PSRP server </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(psuedoserver == FALSE)
       {  <span class="Statement">while</span>(request[i] != <span class="Constant">':'</span> &amp;&amp; request[i] != <span class="Constant">'@'</span>)
          {     rserver[i] = request[i];
                ++i;
          }

          rserver[i]                    = <span class="Special">'\0'</span>;
          request[pups_strlen(request) - <span class="Constant">1</span>] = <span class="Special">'\0'</span>;

          <span class="Statement">if</span>(strcmp(rserver,<span class="Constant">&quot;psrp&quot;</span>) == <span class="Constant">0</span>)
             psuedoserver = TRUE;
       }

       <span class="Statement">if</span>(request[i] == <span class="Constant">'@'</span>)
       {  <span class="Type">int</span> cnt = <span class="Constant">0</span>;

          ++i;
          <span class="Statement">while</span>(request[i] != <span class="Constant">':'</span>)
          {     rhost[cnt] = request[i];

                ++i;
                ++cnt;
          }
          rhost[cnt] = <span class="Special">'\0'</span>;


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Make sure we don't try to connect to the localhost </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> if the user has typed &lt;srv&gt;@&lt;localhost&gt;: &lt;cmd&gt;     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strcmp(rhost,<span class="Constant">&quot;localhost&quot;</span>) == <span class="Constant">0</span>)
             request_type = PSRP_LOCAL_AGGREGATE;
          <span class="Statement">else</span>
             request_type = PSRP_REMOTE_REQUEST;
       }
       <span class="Statement">else</span>
          request_type = PSRP_LOCAL_AGGREGATE;

       <span class="Statement">if</span>(request_type == PSRP_REMOTE_REQUEST)
       {

<span class="PreProc">          #ifdef SSH_SUPPORT</span>
          <span class="Type">int</span> j,
              n_hosts,
              sdes = (-<span class="Constant">1</span>);

          <span class="Type">char</span> psrp_client[SSIZE]                 = <span class="Constant">&quot;&quot;</span>,
               psrp_parameters[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
               host_list[MAX_PSRP_SERVERS][SSIZE] = { [<span class="Constant">0</span> ... MAX_PSRP_SERVERS-<span class="Constant">1</span>] = {<span class="Constant">&quot;&quot;</span>}};

          <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
             (<span class="Type">void</span>)strlcpy(psrp_client,<span class="Constant">&quot;psrp&quot;</span>,SSIZE);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(psrp_client,SSIZE,<span class="Constant">&quot;psrp -password&quot;</span>);


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Translate command list demarcation for fly aggregate on remote PSRP server </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)mchrep(<span class="Constant">';'</span>,<span class="Constant">&quot;,&quot;</span>,&amp;request[i+<span class="Constant">1</span>]);


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Are we contacting a real server process at the remote host, or </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> are we simply asking the remote psrp client for a service?     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(psuedoserver == TRUE)
             (<span class="Type">void</span>)snprintf(expanded_request,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -c </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant">; bye</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                     psrp_client,appl_host,&amp;request[i+<span class="Constant">1</span>]);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(expanded_request,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -c </span><span class="Special">\&quot;</span><span class="Constant">open </span><span class="Special">%s</span><span class="Constant">; </span><span class="Special">%s</span><span class="Constant">; close; bye</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                             psrp_client,appl_host,rserver,&amp;request[i+<span class="Constant">1</span>]);
<span class="PreProc">          #else</span>
          (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): remote command expansion not supported (no ssh support)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                date,appl_name,appl_pid,appl_host,appl_owner);

          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


          <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Host not up </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;nsuperr&quot;</span>,SSIZE);
          <span class="Statement">return</span>(PSRP_REQUEST_ERROR);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Translate command list demarcation fly aggragate on local PSRP  server </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)mchrep(<span class="Constant">';'</span>,<span class="Constant">&quot;,&quot;</span>,&amp;request[i+<span class="Constant">1</span>]);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Build command to be run on local host </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)snprintf(expanded_request,SSIZE,<span class="Constant">&quot;open </span><span class="Special">%s</span><span class="Constant">; </span><span class="Special">%s</span><span class="Constant">; close</span><span class="Special">\n</span><span class="Constant">&quot;</span>,rserver,&amp;request[i+<span class="Constant">1</span>]);
       }

       <span class="Statement">if</span>(*flycom == FALSE)
       {  <span class="Statement">if</span>(strin(expanded_request,<span class="Constant">&quot;open&quot;</span>) == TRUE &amp;&amp; strin(expanded_request,<span class="Constant">&quot;close&quot;</span>) == TRUE)
             *flycom = TRUE;
       }
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(expanded_request,request,SSIZE);

    <span class="Statement">return</span>(request_type);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to yeild PSRP connection to any other clients which may be attached to the same server. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Clients compete for the PSRP lock -- the client which gains the lock can talk to the server     </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_yield_channel(<span class="Type">void</span>)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Temporarily close connection and free lock to let other clients talk to server   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't tell server -- it doesn't care whose requests it is processing!            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    have_access_lock = FALSE;
    (<span class="Type">void</span>)pups_release_fd_lock(fileno(client_out));
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to grab open PSRP connection </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_grab_channel(<span class="Type">void</span>)

{   <span class="Type">int</span>  trys         = <span class="Constant">0</span>;
    <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;</span><span class="Special">\0</span><span class="Constant">&quot;</span>;

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;IN PSRP GRAB CHANNEL</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we already have the channel simply return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(have_access_lock == TRUE)
       <span class="Statement">return</span>(<span class="Constant">0</span>);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;GRABOP</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait till we reaquire the PSRP channel lock -- when we do re-open our connection </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to the server                                                                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Soft link </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_hard_link == FALSE)
    {  <span class="Statement">while</span>(pups_get_fd_lock(fileno(client_out),TSTLOCK) != TRUE)
       {    pups_usleep(<span class="Constant">100</span>);
            ++trys;

            <span class="Statement">if</span>(trys &gt; max_trys)
            {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
               {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) busy</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                 psrp_server,
                                                  server_pid,
                                                   psrp_host,
                                                channel_name);
                  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) request failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
               }

               <span class="Statement">return</span>(-<span class="Constant">1</span>);
           }
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hard link </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)pups_get_fd_lock(fileno(client_out),GETLOCK);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;GRABOP LOCKED</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(do_rsnr == FALSE)
       server_pid = psrp_channelname_to_pid(appl_fifo_dir,psrp_server,psrp_host);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We now have lock - lets re-establish full communication to server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    have_access_lock = TRUE;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We need to update the server so that all PSRP signals are directed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to us                                                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)kill(server_pid,SIGINIT);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;SIGNAL </span><span class="Special">%d</span><span class="Constant"> (SIGINIT) sent</span><span class="Special">\n</span><span class="Constant">&quot;</span>,SIGINIT);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;GRAB </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,appl_password);
    (<span class="Type">void</span>)fflush(client_out);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;GRAB OUT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sscanf(tmp_str,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;server_seg_cnt);
    (<span class="Type">void</span>)efprintf(client_out,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host,remote_host_pathname);
    (<span class="Type">void</span>)fflush(client_out);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for server handshake indicating SIGINIT (GRAB) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> has been serviced                                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    psrp_waitfor_endop(<span class="Constant">&quot;EOP grope&quot;</span>);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;GRABOP DONE (seg cnt = </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_seg_cnt);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Wait for end of operation code </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_waitfor_endop(<span class="Type">char</span> *opcode)

{   <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;</span><span class="Special">\0</span><span class="Constant">&quot;</span>;

    <span class="Statement">do</span> {   (<span class="Type">void</span>)strlcpy(tmp_str,<span class="Constant">&quot;</span><span class="Special">\0</span><span class="Constant">&quot;</span>,SSIZE);
           (<span class="Type">void</span>)efgets(tmp_str,SSIZE,client_in);
       } <span class="Statement">while</span>(strncmp(tmp_str,opcode,pups_strlen(opcode) - <span class="Constant">1</span>) != <span class="Constant">0</span>);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;WFE got </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tmp_str);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add a new entry to the macro stack and load all macros in it </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> update_macro_stack(_BOOLEAN check_mode, _BOOLEAN append, <span class="Type">char</span> *macro_f_name)

{   <span class="Type">int</span> i,
        save_n_m_files;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are not appending - simpy purge macros </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> clear mdf stack and initialise with current  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> macro                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(append == FALSE)
    {  purge_macros((<span class="Type">char</span> *)<span class="Constant">NULL</span>,FALSE,FALSE);
       load_macro_definitions(check_mode,FALSE,macro_f_name);
       (<span class="Type">void</span>)strlcpy(mstack_f_name[<span class="Constant">0</span>],macro_f_name,SSIZE);
       ++n_m_files;

       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       in_append_op = TRUE;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> See if the macro file we have just referenced is in the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> macro file stack - if it isn't add it                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_m_files; ++i)
    {  <span class="Type">int</span> cmp_cnt;

       <span class="Statement">if</span>(pups_strlen(mstack_f_name[i]) &gt; pups_strlen(macro_f_name))
          cmp_cnt = pups_strlen(mstack_f_name[i]);
       <span class="Statement">else</span>
          cmp_cnt = pups_strlen(macro_f_name);

       <span class="Statement">if</span>(strncmp(mstack_f_name[i],macro_f_name,cmp_cnt) == <span class="Constant">0</span>)
          <span class="Statement">goto</span> in_m_f_stack;
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do we need to add this definitions file to the stack </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> of loaded definitions files?                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_m_files &lt; MAX_PSRP_MACRO_FILES)
    {  (<span class="Type">void</span>)strlcpy(mstack_f_name[n_m_files],macro_f_name,SSIZE);
       ++n_m_files;
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">too many macro definition files (maximum of </span><span class="Special">%d</span><span class="Constant"> permitted)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                      MAX_PSRP_MACRO_FILES);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       <span class="Statement">return</span>;
    }


<span class="Statement">in_m_f_stack</span>:


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Re-load macro file stack after loading new member </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_m_files; ++i)
    {  <span class="Statement">if</span>(i == <span class="Constant">0</span>)
          (<span class="Type">void</span>)load_macro_definitions(check_mode,FALSE,mstack_f_name[i]);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)load_macro_definitions(check_mode,TRUE,mstack_f_name[i]);
    }

    in_append_op = FALSE;
}



<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Define a new macro definition </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> edit_macro_definitions(_BOOLEAN load, _BOOLEAN append, <span class="Type">char</span> *macro_f_name)

{   <span class="Type">char</span> edit_macro_command[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         editor[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         username[SSIZE]           = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Editor needs a tty connection -- in general we       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> cannot get such a connection if we have used rsh etc </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to start this instance of the PSRP client -- check   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> that we have a tty connection -- if not exit         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">not a tty connection -- cannot edit macro definition file</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get file editor -- default is vi </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((<span class="Type">char</span> *)getenv(<span class="Constant">&quot;EDITOR&quot;</span>) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(editor,<span class="Constant">&quot;vi&quot;</span>,SSIZE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(editor,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;EDITOR&quot;</span>),SSIZE);

    <span class="Statement">if</span>(strcmp(macro_f_name,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get username </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((<span class="Type">char</span> *)getenv(<span class="Constant">&quot;HOME&quot;</span>) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)strlcpy(username,<span class="Constant">&quot;.&quot;</span>,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(username,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.&quot;</span>,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;HOME&quot;</span>));

       (<span class="Type">void</span>)snprintf(macro_f_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">.mdf&quot;</span>,username,appl_name);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have no macro defintions file -- create it </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(macro_f_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)pups_creat(macro_f_name,<span class="PreProc">0</span><span class="Constant">600</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Edit the macro file for this PSRP client </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(edit_macro_command,SSIZE,<span class="Constant">&quot;bash -c </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,editor,macro_f_name);
    (<span class="Type">void</span>)system(edit_macro_command);

    <span class="Statement">if</span>(load == TRUE)
       update_macro_stack(TRUE,append,macro_f_name);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  Load macro definitions from macro file </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">                                         </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  Each macro is of the form:             </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">                                         </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  tag_1                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  tag_2                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  tag_3                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  {   &lt;macro command definition&gt;         </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">  }                                      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> load_macro_definitions(_BOOLEAN check_mode, _BOOLEAN append, <span class="Type">char</span> *macro_f_name)

{   <span class="Type">char</span>  next_line[SSIZE] = <span class="Constant">&quot;&quot;</span>,
          tmp_str[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
          root_tag[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *macro_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">int</span> i,
        start_str,
        end_str,
        macro_cnt,
        n_labels                       = <span class="Constant">0</span>,
        head_cnt                       = <span class="Constant">0</span>,
        line_cnt                       = <span class="Constant">0</span>,
        start                          = <span class="Constant">0</span>;

    _BOOLEAN in_body                   = FALSE,
             begin_body_transcription  = FALSE,
             macro_head                = TRUE,
             has_head                  = FALSE,
             has_body                  = FALSE,
             max_tag_warning           = FALSE,
             is_comment                = FALSE,
             macro_decoded             = TRUE;


    <span class="Statement">if</span>(access(macro_f_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    PML macro file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;cmnserr&quot;</span>,SSIZE);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

    macro_stream = pups_fopen(macro_f_name,<span class="Constant">&quot;r&quot;</span>,LIVE);

    <span class="Statement">if</span>(pel_appl_verbose == TRUE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    PML (Process Enquiry Language) version 1.00</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">if</span>(check_mode == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Checking macro file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,macro_f_name);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Processing macro file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,macro_f_name);

       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise macro store </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(check_mode == FALSE)
    {  <span class="Statement">if</span>(append == FALSE)
          purge_macros((<span class="Type">char</span> *)<span class="Constant">NULL</span>,FALSE,FALSE);

       macro_cnt = n_macros;
    }
    <span class="Statement">else</span>
       macro_cnt = <span class="Constant">0</span>;

    <span class="Statement">do</span> {

           <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Skip emtpy lines and comment lines </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>


<span class="Statement">read_next_line</span>:

           <span class="Statement">do</span> {

                   <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Check for end of macro definitions file </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

                   <span class="Statement">if</span>(feof(macro_stream))
                   {  <span class="Statement">if</span>(macro_decoded == FALSE)
                      {  <span class="Statement">if</span>(pel_appl_verbose)
                         {  <span class="Statement">if</span>(line_cnt &gt; <span class="Constant">1</span>)
                               (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: premature end of file</span><span class="Special">\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt);
                            <span class="Statement">else</span>
                               (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: empty file</span><span class="Special">\n</span><span class="Constant">&quot;</span>,macro_f_name);

                            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                         }
                      }


                      <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> Check for non-unique macro tags      </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> If we have a name clash purge loaded </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> macros and exit                      </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

                      <span class="Statement">if</span>(check_macro_tags(macro_cnt,macro_f_name) == FALSE)
                      {  <span class="Statement">if</span>(check_mode == FALSE)
                            purge_macros(macro_f_name,TRUE,FALSE);

                         (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;cmnserr&quot;</span>,SSIZE);
                         <span class="Statement">return</span>(-<span class="Constant">1</span>);
                      }

                      (<span class="Type">void</span>)pups_fclose(macro_stream);

                      <span class="Statement">if</span>(check_mode == TRUE)
                      {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                         {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    </span><span class="Special">%d</span><span class="Constant"> macro definition(s) checked</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_cnt);
                            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                         }
                      }
                      <span class="Statement">else</span>
                      {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                         {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    </span><span class="Special">%d</span><span class="Constant"> macro definition(s) loaded</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_cnt);
                            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                         }

                         n_macros = macro_cnt;
                      }

                      <span class="Statement">return</span>(<span class="Constant">0</span>);
                   }

                   (<span class="Type">void</span>)fgets(next_line,SSIZE,macro_stream);

                   <span class="Statement">while</span>(next_line[start++] == <span class="Constant">' '</span>);
                   is_comment = FALSE;
                   start      = <span class="Constant">0</span>;


                   <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Ignore comments </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

                   <span class="Statement">if</span>(next_line[start] == <span class="Constant">'#'</span>)
                      is_comment = TRUE;
                   <span class="Statement">else</span>
                   {

                      <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> Strip trailing comments </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

                      <span class="Statement">while</span>(next_line[start] != <span class="Constant">'#'</span> &amp;&amp; next_line[start] != <span class="Special">'\n'</span> &amp;&amp; next_line[start] != <span class="Special">'\0'</span>)
                            ++start;

                      <span class="Statement">if</span>(next_line[start] == <span class="Constant">'#'</span>)
                         next_line[start] = <span class="Special">'\0'</span>;
                   }

                   ++line_cnt;
              } <span class="Statement">while</span>(is_comment == TRUE || strcmp(next_line,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>) == <span class="Constant">0</span>);


           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Decode macro tags -- these are the names by which the </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> macro is known to the client/user                     </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

           macro_decoded            = FALSE;

           <span class="Statement">if</span>(strin(next_line,<span class="Constant">&quot;atomic&quot;</span>) == TRUE &amp;&amp; in_body == FALSE)
           {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - </span><span class="Special">\&quot;</span><span class="Constant">atomic</span><span class="Special">\&quot;</span><span class="Constant"> is a reserved word</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
              }

              <span class="Statement">if</span>(check_mode == FALSE)
                 purge_macros(macro_f_name,TRUE,FALSE);

              (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
              <span class="Statement">return</span>(-<span class="Constant">1</span>);
           }

           <span class="Statement">if</span>(strin(next_line,<span class="Constant">&quot;{&quot;</span>) == TRUE)
           {  <span class="Statement">if</span>(strchcnt(<span class="Constant">'{'</span>,next_line) &gt; <span class="Constant">1</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - </span><span class="Special">\&quot;</span><span class="Constant">{</span><span class="Special">\&quot;</span><span class="Constant"> occurs multiply in macro </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,root_tag);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              <span class="Statement">if</span>(in_body == TRUE)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - </span><span class="Special">\&quot;</span><span class="Constant">{</span><span class="Special">\&quot;</span><span class="Constant"> found embedded in body of macro </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,root_tag);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              <span class="Statement">if</span>(has_head == FALSE)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - macro has no head</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);
                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              in_body                  = TRUE;
              begin_body_transcription = TRUE;

              <span class="Statement">if</span>(pups_strlen(next_line) &lt; <span class="Constant">2</span>)
                 <span class="Statement">goto</span> read_next_line;
              <span class="Statement">else</span>
              {  (<span class="Type">void</span>)strlcpy(tmp_str,strpch(<span class="Constant">'{'</span>,next_line),SSIZE);
                 (<span class="Type">void</span>)strlcpy(next_line,tmp_str,SSIZE);
              }
           }
           <span class="Statement">else</span> <span class="Statement">if</span>(strin(next_line,<span class="Constant">&quot;}&quot;</span>) == TRUE)
           {  <span class="Statement">if</span>(has_body == FALSE)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - macro </span><span class="Special">%s</span><span class="Constant"> has no body</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,root_tag);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              <span class="Statement">if</span>(pups_strlen(next_line) &gt; <span class="Constant">4</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - </span><span class="Special">\&quot;</span><span class="Constant">}</span><span class="Special">\&quot;</span><span class="Constant"> found embedded in body of </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,root_tag);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              <span class="Statement">if</span>(in_body == FALSE)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - </span><span class="Special">\&quot;</span><span class="Constant">}</span><span class="Special">\&quot;</span><span class="Constant"> found embedded in head of </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,root_tag);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              macro_decoded = TRUE;
              macro_head    = TRUE;
              has_head      = FALSE;
              in_body       = FALSE;
              ++macro_cnt;
              head_cnt      = <span class="Constant">0</span>;
              <span class="Statement">if</span>(macro_cnt == MAX_PSRP_MACROS)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: cannot load any more macros (maximum of </span><span class="Special">%d</span><span class="Constant"> macros permitted)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_PSRP_MACROS);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }

              <span class="Statement">goto</span> read_next_line;
           }


           <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Strip leading spaces from string </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;pups_strlen(next_line); ++i)
              <span class="Statement">if</span>(next_line[i] != <span class="Constant">' '</span> &amp;&amp; next_line[i] != <span class="Constant">'{'</span>)
              {  start_str = i;
                 <span class="Statement">goto</span> sl_spaces_done;
              }


<span class="Statement">sl_spaces_done</span>:


           <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Strip trailing spaces and linefeed from string </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">for</span>(i=pups_strlen(next_line) - <span class="Constant">1</span>; i&gt;= <span class="Constant">0</span>; --i)
              <span class="Statement">if</span>(next_line[i] != <span class="Special">'\n'</span> &amp;&amp; next_line[i] != <span class="Constant">' '</span> &amp;&amp; (<span class="Type">int</span>)next_line[i] != <span class="Constant">0</span>)
              {  end_str = i;
                 <span class="Statement">goto</span> st_spaces_done;
              }


<span class="Statement">st_spaces_done</span>:

           next_line[end_str + <span class="Constant">1</span>] = <span class="Special">'\0'</span>;


           <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If all we have left is a new-line -- ignore it </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(strcmp(next_line,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>) != <span class="Constant">0</span>)
           {

           (<span class="Type">void</span>)strlcpy(tmp_str,(<span class="Type">char</span> *)&amp;next_line[start_str],SSIZE);
           (<span class="Type">void</span>)strlcpy(next_line,tmp_str,SSIZE);


           <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If we are in the macro body simply copy it to the </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> body area of the PSRP client macro table          </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(in_body == TRUE)
           {  <span class="Type">char</span> label[MAX_LABELS][SSIZE] = { [<span class="Constant">0</span> ... MAX_LABELS-<span class="Constant">1</span>] = {<span class="Constant">&quot;&quot;</span>}};


              <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> If this is a label - check that it is unique </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(next_line[<span class="Constant">0</span>] == <span class="Constant">'%'</span>)
              {

                 <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Check label syntax </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(sscanf(next_line,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,tmp_str,tmp_str) &gt; <span class="Constant">1</span>)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - malformed label </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,next_line);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                    <span class="Statement">if</span>(check_mode == FALSE)
                       purge_macros(macro_f_name,TRUE,FALSE);

                    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                    <span class="Statement">return</span>(-<span class="Constant">1</span>);
                 }


                 <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Make sure that we have space to process this label </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>(n_labels == MAX_LABELS)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - too many labels (max </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,MAX_LABELS);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                    <span class="Statement">if</span>(check_mode == FALSE)
                       purge_macros(macro_f_name,TRUE,FALSE);

                    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                    <span class="Statement">return</span>(-<span class="Constant">1</span>);
                 }

                 <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_labels; ++i)
                 {  <span class="Type">int</span> cmp_cnt;

                    <span class="Statement">if</span>(pups_strlen(next_line) &gt; pups_strlen(label[i]))
                       cmp_cnt = pups_strlen(next_line);
                    <span class="Statement">else</span>
                       cmp_cnt = pups_strlen(label[i]);

                    <span class="Statement">if</span>(strncmp(label[i],next_line,cmp_cnt) == <span class="Constant">0</span>)
                    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - label </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not unique</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,label[i]);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                       <span class="Statement">if</span>(check_mode == FALSE)
                          purge_macros(macro_f_name,TRUE,FALSE);

                       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                       <span class="Statement">return</span>(-<span class="Constant">1</span>);
                    }
                 }

                 (<span class="Type">void</span>)strlcpy(label[n_labels++],next_line,SSIZE);
                 ++n_labels;
              }

              <span class="Statement">if</span>(begin_body_transcription == TRUE)
              {  <span class="Statement">if</span>(check_mode == FALSE)
                 {  begin_body_transcription = FALSE;
                    (<span class="Type">void</span>)strlcpy(macro[macro_cnt].body,next_line,SSIZE);
                 }

                 has_body = TRUE;
              }
              <span class="Statement">else</span> <span class="Statement">if</span>(check_mode == FALSE)
              {  (<span class="Type">void</span>)strlcat(macro[macro_cnt].body,<span class="Constant">&quot;; &quot;</span>,SSIZE);
                 (<span class="Type">void</span>)strlcat(macro[macro_cnt].body,next_line,SSIZE);
              }
           }
           <span class="Statement">else</span>
           {  <span class="Type">char</span> strdum1[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                   strdum2[SSIZE] = <span class="Constant">&quot;&quot;</span>;


              <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Check that we only have one synonym per line in  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> the head of the macro                            </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(sscanf(next_line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum1,strdum2) &gt; <span class="Constant">1</span> &amp;&amp; strdum2[<span class="Constant">0</span>] != <span class="Constant">'#'</span>)
              {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - head has more than one synonym on line (</span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant"> ...)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                         macro_f_name,line_cnt,strdum1,strdum2);
                    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                 }

                 <span class="Statement">if</span>(check_mode == FALSE)
                    purge_macros(macro_f_name,TRUE,FALSE);

                 (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
              }
              (<span class="Type">void</span>)strlcpy(next_line,strdum1,SSIZE);

              <span class="Statement">if</span>(macro_head == TRUE)
              {  <span class="Statement">if</span>(check_mode == FALSE)
                 {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%-4d</span><span class="Constant">: loading PML macro (root tag </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,next_line);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                    }
                 }
                 <span class="Statement">else</span>
                 {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%-4d</span><span class="Constant">: PML macro (root tag </span><span class="Special">%s</span><span class="Constant">) OK</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,next_line);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                    }
                 }

                 macro_head = FALSE;
              }


              <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> We are in the head of the macro -- copy alias to </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> next free slot in alias table                    </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(head_cnt &lt; MAX_MACRO_TAGS)
              {  <span class="Statement">if</span>(check_mode == FALSE)
                 {  <span class="Statement">if</span>(has_head == FALSE)
                    {  (<span class="Type">void</span>)strlcpy(root_tag,next_line,SSIZE);
                       (<span class="Type">void</span>)strlcpy(macro[macro_cnt].mdf,macro_f_name,SSIZE);
                    }

                    macro[macro_cnt].cnt = head_cnt + <span class="Constant">1</span>;
                    (<span class="Type">void</span>)strlcpy(macro[macro_cnt].tag[head_cnt],next_line,SSIZE);
                 }

                 ++head_cnt;
              }
              <span class="Statement">else</span>
              {  <span class="Statement">if</span>(max_tag_warning == FALSE)
                 {  max_tag_warning = TRUE;

                    <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">: PML syntax pups_error - head of </span><span class="Special">%s</span><span class="Constant"> has too many tags</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name,line_cnt,root_tag);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                    }

                    <span class="Statement">if</span>(check_mode == FALSE)
                       purge_macros(macro_f_name,TRUE,FALSE);

                    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                    <span class="Statement">return</span>(-<span class="Constant">1</span>);
                 }
              }

              has_head = TRUE;
           }
           }

       } <span class="Statement">while</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Substitute macro arguments - PML uses a simple scheme $1 - $8 identify arguments 1 to 8. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Each argument is substituted for the appropriate item in the argument list               </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN substitute_arguments(<span class="Type">char</span> *macro_body, <span class="Type">int</span> n_args, <span class="Type">char</span> argument_list[<span class="Constant">8</span>][SSIZE])

{   <span class="Type">int</span>  i,
         index,
         cnt                          = <span class="Constant">0</span>;

    <span class="Type">char</span> dummy[SSIZE]                   = <span class="Constant">&quot;&quot;</span>,
         substituted_macro_body[<span class="Constant">4096</span>] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure that we have correct number of dummy variables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in macro body                                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_args; ++i)
    {  (<span class="Type">void</span>)snprintf(dummy,SSIZE,<span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>,i+<span class="Constant">1</span>);
       <span class="Statement">if</span>(strin(macro_body,dummy) == FALSE)
          <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have the correct number of arguments - so lets substitute them   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> NOTE: we have assumed that we are never likely to have a body which </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> occupies more than 95% of the space assigned to it                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(substituted_macro_body,<span class="Constant">&quot;&quot;</span>,SSIZE);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;pups_strlen(macro_body); ++i)
    {  <span class="Statement">if</span>(cnt &gt; SSIZE)
          pups_error(<span class="Constant">&quot;[substitute_arguments]  macro body too big&quot;</span>);

       <span class="Statement">if</span>(macro_body[i] == <span class="Constant">'$'</span>)
       {  (<span class="Type">void</span>)sscanf(&amp;macro_body[i],<span class="Constant">&quot;$</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;index);
          (<span class="Type">void</span>)strlcat(substituted_macro_body,argument_list[index-<span class="Constant">1</span>],SSIZE);
          cnt += pups_strlen(argument_list[index-<span class="Constant">1</span>]);
          i   += <span class="Constant">2</span>;
       }
       <span class="Statement">else</span>
       {  substituted_macro_body[cnt++] = macro_body[i];
          substituted_macro_body[cnt+<span class="Constant">1</span>] = <span class="Special">'\0'</span>;
       }
    }

    (<span class="Type">void</span>)strlcpy(macro_body,substituted_macro_body,SSIZE);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Expand any macros in the request_line </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN expand_macros(<span class="Type">char</span> *request_line, <span class="Type">char</span> *expanded_request_line)

{   <span class="Type">int</span> i,
        j,
        n_args  = <span class="Constant">0</span>,
        cnt     = <span class="Constant">0</span>,
        start   = <span class="Constant">0</span>;

    _BOOLEAN looper,
             is_macro = FALSE;

    <span class="Type">char</span>     tmp_str[SSIZE]                       = <span class="Constant">&quot;&quot;</span>,
             next_item[<span class="Constant">4096</span>]                      = <span class="Constant">&quot;&quot;</span>,
             argument_list[MAX_MACRO_ARGS][SSIZE] = { [<span class="Constant">0</span> ... MAX_MACRO_ARGS-<span class="Constant">1</span>] = {<span class="Constant">&quot;&quot;</span>}};


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise sub-string extractor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)m_strext(EXPAND_MACRO_STREXT,<span class="Special">'\2'</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build expanded macros </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(expanded_request_line,<span class="Constant">&quot;&quot;</span>,SSIZE);
    <span class="Statement">do</span> {

          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Is request line a compound command? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strin(request_line,<span class="Constant">&quot;;&quot;</span>) == TRUE)

             <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Process as compound command </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

             looper = m_strext(EXPAND_MACRO_STREXT,<span class="Constant">';'</span>,tmp_str,request_line);
          <span class="Statement">else</span>
          {

             <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Process as atomic command </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

             looper = FALSE;
             (<span class="Type">void</span>)strlcpy(tmp_str,request_line,SSIZE);
          }

          i   = <span class="Constant">0</span>;
          cnt = <span class="Constant">0</span>;


          <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Get macro name </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

          <span class="Statement">while</span>(tmp_str[i] == <span class="Constant">' '</span>)
                ++i;

          <span class="Statement">while</span>(tmp_str[i] != <span class="Constant">' '</span> &amp;&amp; tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>)
          {     next_item[cnt++] = tmp_str[i];
                ++i;
          }

          next_item[cnt] = <span class="Special">'\0'</span>;


          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> &quot;if&quot;, &quot;atomic&quot; and &quot;resume&quot; statements should be left alone as they are </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> dealt with in psrp_process_command                                      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Anything with a ! in it is by definition not a macro                    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strcmp(next_item,<span class="Constant">&quot;if&quot;</span>) == <span class="Constant">0</span> || strcmp(next_item,<span class="Constant">&quot;atomic&quot;</span>) == <span class="Constant">0</span> || strcmp(next_item,<span class="Constant">&quot;resume&quot;</span>) == <span class="Constant">0</span> || next_item[<span class="Constant">0</span>] == <span class="Constant">'!'</span>)
          {  (<span class="Type">void</span>)strlcpy(next_item,tmp_str,SSIZE);
             <span class="Statement">goto</span> reserved_word_statement;
          }

          <span class="Statement">if</span>(tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>)
          {

             <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Expand the argument list </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

             n_args = <span class="Constant">0</span>;
             <span class="Statement">do</span> {

                     <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Move to next argument </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

                     <span class="Statement">while</span>(tmp_str[i] == <span class="Constant">' '</span> &amp;&amp; tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>)
                           ++i;

                     <span class="Statement">if</span>(tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>)
                     {  cnt = <span class="Constant">0</span>;


                        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Read next argument (globbing between parentheses if necessary) </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

                        <span class="Statement">if</span>(tmp_str[i] == <span class="Constant">'&quot;'</span>)
                        {
                           argument_list[n_args][cnt++] = tmp_str[i++];
                           <span class="Statement">while</span>(tmp_str[i] != <span class="Constant">'&quot;'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>)
                           {     argument_list[n_args][cnt++] = tmp_str[i];
                                 ++i;
                           }


                           <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment"> No delimiter (end of input string) - flag pups_error and exit </span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

                           <span class="Statement">if</span>(tmp_str[i] == <span class="Special">'\0'</span> || tmp_str[i] == <span class="Special">'\n'</span>)
                           {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: closing </span><span class="Special">\&quot;</span><span class="Constant"> delimiter not found (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,last_macro);
                                 (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                              }

                              (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                              <span class="Statement">return</span>(FALSE);
                           }
                           argument_list[n_args][cnt++] = tmp_str[i++];
                        }
                        <span class="Statement">else</span>
                        {  <span class="Statement">while</span>(tmp_str[i] != <span class="Constant">' '</span> &amp;&amp; tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>)
                           {     argument_list[n_args][cnt++] = tmp_str[i];
                                 ++i;
                           }
                        }


                        <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Terminate next argument </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

                        argument_list[n_args][cnt] = <span class="Special">'\0'</span>;
                        ++n_args;


                       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
                       <span class="Comment">/*</span><span class="Comment"> Check that we don't have too many arguments </span><span class="Comment">*/</span>
                       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

                       <span class="Statement">if</span>(n_args &gt; MAX_MACRO_ARGS)
                       {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: PML macros may have up to </span><span class="Special">%d</span><span class="Constant"> arguments</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_MACRO_ARGS);
                             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                          }

                          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
                          <span class="Statement">return</span>(FALSE);
                       }
                   }

                } <span class="Statement">while</span>(tmp_str[i] != <span class="Special">'\n'</span> &amp;&amp; tmp_str[i] != <span class="Special">'\0'</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Expand (possible) macro </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strail(next_item,<span class="Constant">' '</span>);
          is_macro = FALSE;
          <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_macros; ++i)
             <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;macro[i].cnt; ++j)
             {  <span class="Type">int</span> cmp_cnt;

                <span class="Statement">if</span>(pups_strlen(macro[i].tag[j]) &gt; pups_strlen(next_item))
                   cmp_cnt = pups_strlen(macro[i].tag[j]);
                <span class="Statement">else</span>
                   cmp_cnt = pups_strlen(next_item);

                <span class="Statement">if</span>(strncmp(macro[i].tag[j],next_item,cmp_cnt) == <span class="Constant">0</span>)
                {

                   <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Get body of macro </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

                   (<span class="Type">void</span>)strlcpy(next_item,macro[i].body,SSIZE);


                   <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> If the macro has any arguments substitute them now </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

                   <span class="Statement">if</span>(n_args &gt; <span class="Constant">0</span>)
                   {  <span class="Statement">if</span>(substitute_arguments(next_item,n_args,argument_list) == FALSE)
                      {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                         {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: macro argument substitution failed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                         }

                         (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psuberr&quot;</span>,SSIZE);
                         <span class="Statement">return</span>(FALSE);
                      }
                   }
                   <span class="Statement">else</span>
                   {

                      <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> Macro function has arguments but we have failed to substitute then </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

                      <span class="Statement">if</span>(strin(next_item,<span class="Constant">&quot;$&quot;</span>) == TRUE)
                      {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                         {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error: macro has unsubstituted arguments</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                         }

                         (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psuberr&quot;</span>,SSIZE);
                         <span class="Statement">return</span>(FALSE);
                      }
                   }

                   (<span class="Type">void</span>)strlcpy(last_macro,macro[i].tag[j],SSIZE);
                   is_macro = TRUE;
                   <span class="Statement">goto</span> macro_expanded;
                }
              }


<span class="Statement">reserved_word_statement</span>:


           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If this is not a macro we need whole input buffer (including arguments) </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">while</span>(tmp_str[start] == <span class="Constant">' '</span>)
                 ++start;

           (<span class="Type">void</span>)strlcpy(next_item,&amp;tmp_str[start],SSIZE);


<span class="Statement">macro_expanded</span>:

           (<span class="Type">void</span>)strlcat(expanded_request_line,next_item,SSIZE);

           <span class="Statement">if</span>(looper == TRUE)
              (<span class="Type">void</span>)strlcat(expanded_request_line,<span class="Constant">&quot;; &quot;</span>,SSIZE);

       } <span class="Statement">while</span>(looper == TRUE);

    <span class="Statement">if</span>(is_macro == TRUE)
       (<span class="Type">void</span>)strlcat(expanded_request_line,<span class="Constant">&quot;; end&quot;</span>,SSIZE);

    <span class="Statement">return</span>(TRUE);
}





<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show loaded macros </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> purge_macros(<span class="Type">char</span> *macro_f_name, _BOOLEAN appl_verbose, _BOOLEAN erase_macro_files)

{   <span class="Type">int</span> i,
        j;

    <span class="Statement">if</span>(n_macros == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">no macros loaded</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       <span class="Statement">return</span>;
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_macros; ++i)
    {  <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;macro[i].cnt; ++j)
          (<span class="Type">void</span>)strlcpy(macro[i].tag[j],<span class="Constant">&quot;&quot;</span>,SSIZE);

       (<span class="Type">void</span>)strlcpy(macro[i].body,<span class="Constant">&quot;&quot;</span>,SSIZE);
       macro[i].cnt = <span class="Constant">0</span>;
    }

    n_macros = <span class="Constant">0</span>;

    <span class="Statement">if</span>(macro_f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">all macros removed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       }

       <span class="Statement">if</span>(erase_macro_files == TRUE)
       {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_m_files; ++i)
             (<span class="Type">void</span>)unlink(mstack_f_name[i]);

          <span class="Statement">if</span>(pel_appl_verbose == TRUE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; (all loaded macro files deleted)&quot;</span>);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }
       }

       <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we are called by an append operation - retain names of </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> macro definition files, as they will be required for      </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> append-reload operation                                   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(in_append_op == FALSE)
       {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_m_files; ++i)
             (<span class="Type">void</span>)strlcpy(mstack_f_name[i],<span class="Constant">&quot;&quot;</span>,SSIZE);
          n_m_files = <span class="Constant">0</span>;
       }
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">all macros from macro file </span><span class="Special">%s</span><span class="Constant"> removed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,macro_f_name);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       }


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Reload all macro files (except the one we have just asked to delete)  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> This will be quite inefficient in macros which delete multipled files </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_m_files; ++i)
          <span class="Statement">if</span>(strcmp(mstack_f_name[i],macro_f_name) == <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(erase_macro_files == TRUE)
             {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; (macro file </span><span class="Special">%s</span><span class="Constant"> deleted)&quot;</span>,macro_f_name);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                }

                (<span class="Type">void</span>)unlink(macro_f_name);
             }

             <span class="Statement">for</span>(j=i; j&lt;n_m_files-<span class="Constant">1</span>; ++j)
                (<span class="Type">void</span>)strlcpy(mstack_f_name[j],mstack_f_name[j+<span class="Constant">1</span>],SSIZE);

             --n_m_files;


             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Reload all remaining macro files </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;n_m_files; ++j)
                <span class="Statement">if</span>(j == <span class="Constant">0</span>)
                   (<span class="Type">void</span>)load_macro_definitions(FALSE,FALSE,mstack_f_name[i]);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)load_macro_definitions(FALSE,TRUE,mstack_f_name[i]);

             <span class="Statement">if</span>(pel_appl_verbose == TRUE)
             {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
             }

             <span class="Statement">return</span>;
          }
     }
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Check macro tags to ensure that they are unique </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN check_macro_tags(<span class="Type">int</span> n_macros, <span class="Type">char</span> *macro_f_name)

{   <span class="Type">int</span> i,
        j,
        k,
        l,
        m,
        eff_n_tags,
        n_clashes = <span class="Constant">0</span>;

    _BOOLEAN ret = TRUE;

    <span class="Type">char</span> clash_tags[MAX_CLASH_TAGS][SSIZE] = { [<span class="Constant">0</span> ... MAX_CLASH_TAGS-<span class="Constant">1</span>] = {<span class="Constant">&quot;&quot;</span>}};

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_macros; ++i)
    {  <span class="Statement">for</span>(j=i+<span class="Constant">1</span>; j&lt;n_macros; ++j)
       {  <span class="Statement">if</span>(macro[i].cnt &gt; macro[j].cnt)
             eff_n_tags = macro[i].cnt;
          <span class="Statement">else</span>
             eff_n_tags = macro[j].cnt;

          <span class="Statement">for</span>(k=<span class="Constant">0</span>; k&lt;eff_n_tags; ++k)
             <span class="Statement">for</span>(l=k; l&lt;eff_n_tags; ++l)
                <span class="Statement">if</span>(strcmp(macro[i].tag[k],macro[j].tag[l]) == <span class="Constant">0</span>)
                {  <span class="Statement">for</span>(m=<span class="Constant">0</span>; m&lt;n_clashes; ++m)
                      <span class="Statement">if</span>(strcmp(clash_tags[m],macro[i].tag[k]) == <span class="Constant">0</span>)
                         <span class="Statement">goto</span> already_found;

                   <span class="Statement">if</span>(n_clashes &gt; MAX_CLASH_TAGS)
                   {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
                      {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: too many tags are non unique</span><span class="Special">\n</span><span class="Constant">&quot;</span>,macro_f_name);
                         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                      }

                      (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;mtuerr&quot;</span>,SSIZE);
                      <span class="Statement">return</span>(FALSE);
                   }
                   <span class="Statement">else</span>
                   {  (<span class="Type">void</span>)strlcpy(clash_tags[n_clashes],macro[i].tag[k],SSIZE);
                      ++n_clashes;
                   }


<span class="Statement">already_found</span>:     ret = FALSE;
                }
       }
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_clashes; ++i)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not unique</span><span class="Special">\n</span><span class="Constant">&quot;</span>,macro_f_name,clash_tags[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;mtuerr&quot;</span>,SSIZE);
    }

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add the current macro to the end of the macro file </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> catenate_macro(<span class="Type">char</span> *name, <span class="Type">char</span> *body, _BOOLEAN append, <span class="Type">char</span> *macro_f_name)

{   <span class="Type">FILE</span> *macro_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If file does not exist - create it </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(macro_f_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)pups_creat(macro_f_name,<span class="PreProc">0</span><span class="Constant">600</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build new macro and add it to macro file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    macro_stream = pups_fopen(macro_f_name,<span class="Constant">&quot;a&quot;</span>,LIVE);

    (<span class="Type">void</span>)strdate(date);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;# </span><span class="Special">%s</span><span class="Constant">: Macro </span><span class="Special">%s</span><span class="Constant"> catenated from PSRP client</span><span class="Special">\n</span><span class="Constant">&quot;</span>,macro_f_name,name);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,name);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;{</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,body);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;}</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(macro_stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(macro_stream);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Re-read macro file (to make catenated macro active) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_fclose(macro_stream);
}




<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show loaded macros </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> -------------------</span><span class="Comment">*/</span>


_PRIVATE <span class="Type">void</span> show_macro_tags(<span class="Type">void</span>)

{   <span class="Type">int</span> i,
        j;

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    </span><span class="Special">%d</span><span class="Constant"> macro(s) currently loaded</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_macros);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_macros; ++i)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    macro </span><span class="Special">%d</span><span class="Constant"> (mdf </span><span class="Special">%s</span><span class="Constant">):&quot;</span>,i,macro[i].mdf);

       <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;macro[i].cnt; ++j)
          <span class="Statement">if</span>(j == <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; [root tag] </span><span class="Special">%s</span><span class="Constant">;&quot;</span>,macro[i].tag[j]);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; </span><span class="Special">%s</span><span class="Constant">;&quot;</span>,macro[i].tag[j]);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Catenate macro definitions </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> builtin_catenate_macro(_BOOLEAN append, <span class="Type">char</span> *request)

{  <span class="Type">int</span>  i,
        ret,
        cnt,
        m_body_bra,
        m_body_ket,
        start,
        end,
        body_size;

   <span class="Type">char</span> tmp_str[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
        tag_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


   <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Before we do anything else we must extract the macro body (if any) </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> specified on the command line                                      </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

   m_body_bra = strchcnt(<span class="Constant">'{'</span>,request);
   m_body_ket = strchcnt(<span class="Constant">'}'</span>,request);


   <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Check that the macro body is enclosed by bra and ket ( { &lt;body&gt; } ) </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

   <span class="Statement">if</span>(m_body_bra &gt; <span class="Constant">1</span>)
   {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
      {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error - to many </span><span class="Special">\&quot;</span><span class="Constant">{</span><span class="Special">\&quot;</span><span class="Constant"> symbols in inline macro definition</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
      }

      (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
      <span class="Statement">return</span>;
   }
   <span class="Statement">else</span> <span class="Statement">if</span>(m_body_ket &gt; <span class="Constant">1</span>)
   {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
      {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error - to many </span><span class="Special">\&quot;</span><span class="Constant">}</span><span class="Special">\&quot;</span><span class="Constant"> symbols in inline macro definition</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
      }

      (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
      <span class="Statement">return</span>;
   }
   <span class="Statement">else</span> <span class="Statement">if</span>((m_body_bra == <span class="Constant">1</span> &amp;&amp; m_body_ket == <span class="Constant">0</span>) || (m_body_bra == <span class="Constant">0</span> &amp;&amp; m_body_ket == <span class="Constant">1</span>))
   {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
      {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PML syntax pups_error - inline macro body is not closed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
      }

      (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
      <span class="Statement">return</span>;
   }


   <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Extract macro body and store it </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

   start     = ch_pos(request,<span class="Constant">'{'</span>) + <span class="Constant">1</span>;
   end       = ch_pos(request,<span class="Constant">'}'</span>);
   body_size = end - start;

   cnt = <span class="Constant">0</span>;
   <span class="Statement">for</span>(i=start; i&lt;end; ++i)
      last_request_line[cnt++] = request[i];

   last_request_line[cnt] = <span class="Special">'\0'</span>;

   --start;
   ++end;
   <span class="Statement">for</span>(i=end; i&lt;pups_strlen(request_line); ++i)
      request[start++] = request[end++];

   ret = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_str,tag_name,macro_f_name,tmp_str);


   <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Less than two parameters - user pups_error </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

   <span class="Statement">if</span>(ret &lt; <span class="Constant">2</span>)
   {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: mcat &lt;tagname&gt; [&lt;mdf file&gt;] [body]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
      (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

      <span class="Statement">return</span>;
   }


   <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Two parameter command - add macro to default macro definition file </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> for this application                                               </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

   <span class="Statement">else</span> <span class="Statement">if</span>(ret == <span class="Constant">2</span>)
   {   <span class="Type">char</span> username[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get username </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((<span class="Type">char</span> *)getenv(<span class="Constant">&quot;HOME&quot;</span>) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)strlcpy(username,<span class="Constant">&quot;.&quot;</span>,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(username,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.&quot;</span>,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;HOME&quot;</span>));

       (<span class="Type">void</span>)snprintf(macro_f_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">.mdf&quot;</span>,username,appl_name);
       catenate_macro(tag_name,last_request_line,append,macro_f_name);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Three parameter command - add macro definition to name file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(ret == <span class="Constant">3</span>)
       catenate_macro(tag_name,last_request_line,append,macro_f_name);
}




<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Load macro definitions </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> builtin_load_macro_definitions(_BOOLEAN check_mode, _BOOLEAN append, <span class="Type">char</span> *request)

{

    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Have we defined a macro file, or are we going </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to use the default file?                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,macro_f_name,macro_f_name) == <span class="Constant">2</span>)
       update_macro_stack(check_mode,append,macro_f_name);
    <span class="Statement">else</span>
    {   <span class="Type">char</span> username[SSIZE] = <span class="Constant">&quot;&quot;</span>;


        <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Get username </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>((<span class="Type">char</span> *)getenv(<span class="Constant">&quot;HOME&quot;</span>) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
           (<span class="Type">void</span>)strlcpy(username,<span class="Constant">&quot;.&quot;</span>,SSIZE);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)snprintf(username,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.&quot;</span>,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;HOME&quot;</span>));
        (<span class="Type">void</span>)snprintf(macro_f_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">.mdf&quot;</span>,username,appl_name);
        update_macro_stack(check_mode,append,macro_f_name);
     }
}




<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Edit macro definitions </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> builtin_edit_macro_definitions(_BOOLEAN load, _BOOLEAN append, <span class="Type">char</span> *request)

{

    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Have we defined a macro file, or are we going </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to use the default file?                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,macro_f_name,macro_f_name) == <span class="Constant">2</span>)
       edit_macro_definitions(load,append,macro_f_name);
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)strlcpy(macro_f_name,<span class="Constant">&quot;default&quot;</span>,SSIZE);
       edit_macro_definitions(load,append,macro_f_name);
    }
}




<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Expand recursive macro definitions </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN expand_macros_recursive(<span class="Type">char</span> *request_line, <span class="Type">char</span> *expanded_request_line)

{   _BOOLEAN looper = TRUE;

    macros_expanded = FALSE;
    <span class="Statement">do</span> {    <span class="Statement">if</span>(expand_macros(request_line,expanded_request_line) == FALSE)
               <span class="Statement">return</span>(FALSE);


            <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Lop off leading and trailing spaces before we attempt </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> any comparision                                       </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

            (<span class="Type">void</span>)strail(expanded_request_line,<span class="Constant">' '</span>);
            (<span class="Type">void</span>)strlcpy(expanded_request_line,strlead(expanded_request_line,<span class="Constant">' '</span>),SSIZE);
            (<span class="Type">void</span>)strail(request_line,<span class="Constant">' '</span>);
            (<span class="Type">void</span>)strlcpy(request_line,strlead(request_line,<span class="Constant">' '</span>),SSIZE);

            <span class="Statement">if</span>(strcmp(expanded_request_line,request_line) == <span class="Constant">0</span>)
               looper = FALSE;
            <span class="Statement">else</span>
            {  (<span class="Type">void</span>)strlcpy(request_line,expanded_request_line,SSIZE);
               macros_expanded = TRUE;
            }

       } <span class="Statement">while</span>(looper == TRUE);

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Move to request (in request line) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN req_find(<span class="Type">int</span> r_cnt, <span class="Type">char</span> *label, <span class="Type">char</span> *request_line)

{   <span class="Type">int</span>      s1,
             s2,
             cmp_size,
             cnt = <span class="Constant">0</span>;

    _BOOLEAN ret;
    <span class="Type">char</span>     next_item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    (<span class="Type">void</span>)m_strext(r_cnt,<span class="Special">'\2'</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);

    <span class="Statement">do</span> {   ret = m_strext(r_cnt,<span class="Constant">';'</span>,next_item,request_line);

           s1 = pups_strlen(label);
           s2 = pups_strlen(next_item);

           (<span class="Type">void</span>)strlcpy(next_item,strlead(next_item,<span class="Constant">' '</span>),SSIZE);
           <span class="Statement">if</span>(pups_strlen(label) &gt; pups_strlen(next_item))
              cmp_size = pups_strlen(label);
           <span class="Statement">else</span>
              cmp_size = pups_strlen(next_item);

           <span class="Statement">if</span>(ret == FALSE)
              <span class="Statement">return</span>(FALSE);

           <span class="Statement">if</span>(strncmp(next_item,label,cmp_size) == <span class="Constant">0</span>)
              <span class="Statement">return</span>(TRUE);

           ++cnt;
       } <span class="Statement">while</span>(TRUE);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to repeat a command -- if the repeat count is negative, the loop is infinite </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_repeat_command(<span class="Type">int</span> count, <span class="Type">char</span> *request_line)


{   rpt_cnt               = <span class="Constant">0</span>;
    in_repeat_command     = TRUE;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Builtin commands cannot be supported in curses mode </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(server_pid == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot repeat builtin commands in curses mode</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }


<span class="PreProc">    #ifdef HAVE_CURSES</span>
    <span class="Statement">if</span>(rpt_curses_mode == TRUE)
    {  save_pel_appl_verbose = pel_appl_verbose;
       pel_appl_verbose      = FALSE;
    }

    <span class="Statement">if</span>(rpt_curses_mode == TRUE &amp;&amp; cinit_done == FALSE)
    {  cinit();
       cls();
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>


    <span class="Statement">if</span>(count &lt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Process an infinite repeat loop </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">while</span>(TRUE)
       {

<span class="PreProc">            #ifdef HAVE_CURSES</span>
            <span class="Statement">if</span>(rpt_curses_mode == TRUE)
              move(<span class="Constant">0</span>,<span class="Constant">0</span>);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

            rpthdr(request_line);
            <span class="Statement">if</span>(psrp_process_command(request_line) == FALSE)
            {
<span class="PreProc">               #ifdef HAVE_CURSES</span>
               <span class="Statement">if</span>(rpt_curses_mode == TRUE)
               {  pel_appl_verbose  = save_pel_appl_verbose;
                  in_repeat_command = FALSE;
               }
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

               <span class="Statement">return</span>(FALSE);
            }

<span class="PreProc">            #ifdef HAVE_CURSES</span>
            <span class="Statement">if</span>(rpt_curses_mode == TRUE)
               (<span class="Type">void</span>)refresh();
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

            ++rpt_cnt;
            (<span class="Type">void</span>)pups_sleep(rpt_period);
        }
    }
    <span class="Statement">else</span>
    {  <span class="Type">int</span> i;


       <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Process a finite repeat loop </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;count; ++i)
       {

<span class="PreProc">           #ifdef HAVE_CURSES</span>
           <span class="Statement">if</span>(rpt_curses_mode == TRUE)
              move(<span class="Constant">0</span>,<span class="Constant">0</span>);
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

           rpthdr(request_line);
           <span class="Statement">if</span>(psrp_process_command(request_line) == FALSE)
           {

<span class="PreProc">               #ifdef HAVE_CURSES</span>
               <span class="Statement">if</span>(rpt_curses_mode == TRUE)
               {  pel_appl_verbose  = save_pel_appl_verbose;
                  in_repeat_command = FALSE;
               }
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

               <span class="Statement">return</span>(FALSE);
            }

<span class="PreProc">           #ifdef HAVE_CURSES</span>
           <span class="Statement">if</span>(rpt_curses_mode == TRUE)
              (<span class="Type">void</span>)refresh();
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

           ++rpt_cnt;
           (<span class="Type">void</span>)pups_sleep(rpt_period);
       }
   }

<span class="PreProc">   #ifdef HAVE_CURSES</span>
   <span class="Statement">if</span>(rpt_curses_mode == TRUE)
      cend();

   <span class="Statement">if</span>(rpt_curses_mode == TRUE)
   {  in_repeat_command = FALSE;
      pel_appl_verbose  = save_pel_appl_verbose;
   }
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

   <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set up curses system </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> cinit(<span class="Type">void</span>)

{

<span class="PreProc">    #ifdef HAVE_CURSES</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up curses </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(isatty(<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)initscr();
       (<span class="Type">void</span>)echo();
       (<span class="Type">void</span>)keypad(stdscr,TRUE);
    }
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;curserr&quot;</span>,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

    cinit_done = TRUE;
}



<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Stop curses system </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> cend(<span class="Type">void</span>)

{

<span class="PreProc">    #ifdef HAVE_CURSES</span>
    <span class="Statement">if</span>(rpt_curses_mode == TRUE)
    {  endwin();
       cinit_done = FALSE;
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Clear screen command (cls) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> cls(<span class="Type">void</span>)

{

<span class="PreProc">    #ifdef HAVE_CURSES</span>
    <span class="Statement">if</span>(rpt_curses_mode == TRUE &amp;&amp; cinit_done == TRUE)
    {  (<span class="Type">void</span>)clear();
       (<span class="Type">void</span>)refresh();
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;curserr&quot;</span>,SSIZE);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;curserr&quot;</span>,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Print header for repeated command </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> rpthdr(<span class="Type">char</span> *request)

{
<span class="PreProc">    #ifdef HAVE_CURSES</span>
    <span class="Statement">if</span>(rpt_curses_mode == TRUE)
    {  (<span class="Type">void</span>)printw(<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Repeating request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [rpt cnt is </span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request,rpt_cnt);
       <span class="Statement">if</span>(server_seg_cnt &gt; <span class="Constant">0</span>)
          (<span class="Type">void</span>)printw(<span class="Constant">&quot;    Server is segmented [segment </span><span class="Special">%d</span><span class="Constant"> active]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_seg_cnt);

       <span class="Statement">if</span>(server_pid == <span class="Constant">0</span>)
          (<span class="Type">void</span>)printw(<span class="Constant">&quot;    Command is local [on PSRP client] (^C exits)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)printw(<span class="Constant">&quot;    PSRP server is </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) (^C exits)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);

    }
    <span class="Statement">else</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_CURSES </span><span class="Comment">*/</span>

    {   (<span class="Type">void</span>)printf(<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Repeating request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [rpt cnt is </span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,request,rpt_cnt);
        <span class="Statement">if</span>(server_seg_cnt &gt; <span class="Constant">0</span>)
           (<span class="Type">void</span>)printf(<span class="Constant">&quot;    Server is segmented [segment </span><span class="Special">%d</span><span class="Constant"> active]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,server_seg_cnt);

        <span class="Statement">if</span>(server_pid == <span class="Constant">0</span>)
           (<span class="Type">void</span>)printf(<span class="Constant">&quot;    Command is local [on PSRP client] (^C exits)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)printf(<span class="Constant">&quot;    PSRP server is </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) (^C exits)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_server,server_pid,psrp_host);
    }
}




<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Initialise do_repeat array </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> initialise_repeaters(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_MACRO_DEPTH; ++i)
       do_repeat[i] = FALSE;
}




<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Restore system (and signal) status </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> restore_system_status(<span class="Type">int</span> signum)

{    <span class="Statement">if</span>(signum &gt; <span class="Constant">0</span> &amp;&amp; signum &lt; MAX_SIGS)
     {  sigset_t set;

<span class="PreProc">        #ifdef PSRP_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;RESTORING </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,signum);
        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

        (<span class="Type">void</span>)sigemptyset(&amp;set);
        (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);

        (<span class="Type">void</span>)pups_vitrestart();
     }
     <span class="Statement">else</span>
        pups_error(<span class="Constant">&quot;[restore_system_status] bad signal&quot;</span>);


     <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Not too sure why appl_pid needs to be reset    </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> could be a side effect of call to siglongjmp() </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> which got us here                              </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

     appl_pid = getpid();
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display the current PUPS connections on the client machine </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_show_channels(_BOOLEAN show_all_servers, <span class="Type">char</span> *directory)

{   <span class="Type">int</span> i,
        pid,
        uid,
        entry_cnt,
        n_entries,
        schan,
        cnt = <span class="Constant">0</span>;

    <span class="Type">char</span> vector[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         strdum[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         application[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         hostname[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         pathname[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         **entry_list       = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

    <span class="Type">struct</span> stat   buf;
    <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we are actually looking at a directory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)stat(directory,&amp;buf);
    <span class="Statement">if</span>(!S_ISDIR(buf.st_mode))
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not a directory</span><span class="Special">\n</span><span class="Constant">&quot;</span>,directory);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>;
    }

    entry_list = pups_get_directory_entries(directory,<span class="Constant">&quot;psrp&quot;</span>,&amp;n_entries,&amp;entry_cnt);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get the owner of resource </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,directory,entry_list[i]);
       (<span class="Type">void</span>)stat(pathname,&amp;buf);
       pwent = pups_getpwuid(buf.st_uid);

       mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;#&quot;</span>,entry_list[i]);

       <span class="Statement">if</span>(strin(entry_list[i],<span class="Constant">&quot;psrp&quot;</span>) == TRUE                                             &amp;&amp;
          (strin(entry_list[i],<span class="Constant">&quot;fifo in&quot;</span>) == TRUE || strin(entry_list[i],<span class="Constant">&quot;vector&quot;</span>) == TRUE))
       {

          <span class="Type">int</span>  j,
               entries;

          _BOOLEAN not_owner    = FALSE;

          <span class="Type">char</span> procpidpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
               binname[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

<span class="PreProc">          #ifdef PSRP_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ENTRY LIST[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,i,entry_list[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

          entries = sscanf(entry_list[i],<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d%d%s%d</span><span class="Constant">&quot;</span>,strdum,application,hostname,vector,strdum,&amp;pid,&amp;uid,strdum,&amp;schan);

<span class="PreProc">          #ifdef PSRP_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ENTRIES: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,entries);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

          <span class="Statement">if</span>(entries == <span class="Constant">7</span> || entries == <span class="Constant">9</span>)
          {  <span class="Type">char</span>   state[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant">: PSRP channels on </span><span class="Special">%s</span><span class="Constant"> (via </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,date,appl_host,directory);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;Application</span><span class="Special">\t\t</span><span class="Constant">owner</span><span class="Special">\t\t\t</span><span class="Constant">state</span><span class="Special">\t\t\t</span><span class="Constant">pid</span><span class="Special">\t\t</span><span class="Constant">binname</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
             }


             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> test whether channel is active </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

             errno     = <span class="Constant">0</span>;
             not_owner = FALSE;

             <span class="Statement">if</span>(strcmp(vector,<span class="Constant">&quot;vector&quot;</span>) == <span class="Constant">0</span>)
                (<span class="Type">void</span>)strlcpy(state,<span class="Constant">&quot;vector&quot;</span>,SSIZE);
             <span class="Statement">else</span> <span class="Statement">if</span>(kill(pid,SIGALIVE) == (-<span class="Constant">1</span>))
             {  <span class="Statement">if</span>(errno == <span class="Constant">ESRCH</span>)
                   (<span class="Type">void</span>)strlcpy(state,<span class="Constant">&quot;dead&quot;</span>,SSIZE);
                <span class="Statement">else</span>
                {  (<span class="Type">void</span>)strlcpy(state,<span class="Constant">&quot;not owner&quot;</span>,SSIZE);
                   not_owner = TRUE;
                }
             }
             <span class="Statement">else</span>
             {  <span class="Type">char</span> lockname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Channel is alive - is it busy ? </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

                (<span class="Type">void</span>)snprintf(lockname,SSIZE,<span class="Constant">&quot;psrp.</span><span class="Special">%d</span><span class="Constant">.lock&quot;</span>,pid);
                <span class="Statement">if</span>(access(lockname,F_OK | R_OK | W_OK) == <span class="Constant">1</span>)
                   (<span class="Type">void</span>)strlcpy(state,<span class="Constant">&quot;live (busy)&quot;</span>,SSIZE);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)strlcpy(state,<span class="Constant">&quot;live (idle)&quot;</span>,SSIZE);
             }


             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Don't show servers we don't own </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> if show_all_servers ifs FALSE   </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(show_all_servers == FALSE &amp;&amp; not_owner == TRUE)
                <span class="Statement">continue</span>;


             <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Display server details </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%-15s</span><span class="Special">\t\t</span><span class="Special">%-15s</span><span class="Special">\t\t</span><span class="Special">%-15s</span><span class="Special">\t\t</span><span class="Special">%d</span><span class="Constant">&quot;</span>,application,pwent-&gt;pw_name,state,pid);


                <span class="Statement">if</span>(strcmp(state,<span class="Constant">&quot;vector&quot;</span>) == <span class="Constant">0</span>)
                {  (<span class="Type">void</span>)strlcpy(binname,<span class="Constant">&quot;****&quot;</span>,SSIZE);
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\t\t</span><span class="Special">%15s</span><span class="Constant">&quot;</span>,binname);
                }
                <span class="Statement">else</span>
                {

                   <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Get name of binary (if we can) </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

                   <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;<span class="Constant">256</span>; ++j)
                      binname[j] = <span class="Special">'\0'</span>;

                   (<span class="Type">void</span>)snprintf(procpidpath,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/exe&quot;</span>,pid);
                   (<span class="Type">void</span>)readlink(procpidpath,binname,<span class="Constant">256</span>);

                   <span class="Statement">for</span>(j=<span class="Constant">255</span>; j&gt;=<span class="Constant">0</span>; --j)
                   {  <span class="Statement">if</span>(binname[j] == <span class="Constant">'/'</span>)
                         <span class="Statement">break</span>;
                   }

                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\t\t</span><span class="Special">%-15s</span><span class="Constant">&quot;</span>,&amp;binname[j+<span class="Constant">1</span>]);
                }
             }


             <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> PSRP channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(entries == <span class="Constant">7</span>)
             {

                <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Are we connected to this PSRP server ? </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(pid == server_pid)
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; [PSRP*]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; [PSRP]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

             }


             <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> SIC channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span>
             {

                <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Is this SIC channel associated with       </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> the server we are currently connected to? </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(pid == server_pid)
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; [SIC*: </span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,schan);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot; [SIC: </span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,schan);
             }

             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
             ++cnt;
          }
       }
    }

    <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;No PSRP channels mounted via </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,directory);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear the entry list </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
          (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list[i]);
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list);

       <span class="Statement">return</span>;
    }


    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear the entry list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list[i]);
    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list);
}




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Connect to remote client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN builtin_connect_remote_client(<span class="Type">char</span> *request)

{

<span class="PreProc">#ifndef SSH_SUPPORT</span>
    (<span class="Type">void</span>)pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(FALSE);
<span class="PreProc">#else</span>

    <span class="Type">char</span> cwd[SSIZE]               = <span class="Constant">&quot;&quot;</span>,
         strdum[SSIZE]            = <span class="Constant">&quot;&quot;</span>,
         ruser[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         rhost[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         psrp_parameters[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         ssh_command[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         ssh_remote_env[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span>  ret                      = <span class="Constant">0</span>,
         status                   = <span class="Constant">0</span>;


    <span class="Statement">if</span>(request == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,strdum,rhost) != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;expecting remote host name</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;psynerr&quot;</span>,SSIZE);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up environment on remote host </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_exec_env(ssh_remote_env);
    (<span class="Type">void</span>)snprintf(psrp_parameters,SSIZE,<span class="Constant">&quot;bash -c '</span><span class="Special">%s</span><span class="Constant">; psrp -on </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">'&quot;</span>,ssh_remote_env,rhost,appl_host,appl_name,appl_pid);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((child_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Terminal connection </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
       {

           <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Overlay ssh command </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(ssh_compression == TRUE)
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-t&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-t&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Non terminal connection </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {

           <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Overlay ssh command </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(ssh_compression == TRUE)
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;-q&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,rhost,psrp_parameters,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
       }

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an pups_error has occured </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

       pups_error(<span class="Constant">&quot;psrp: failed to build ssh channel to remote host&quot;</span>);

       (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;sexerr&quot;</span>,SSIZE);
       exit(<span class="Constant">255</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Wait for child (checking that it exited OK) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pupswaitpid(FALSE,child_pid,&amp;status);
       ret = WEXITSTATUS(status);
    }

    <span class="Statement">if</span>(ret != <span class="Constant">0</span>)
       <span class="Statement">return</span>(FALSE);

    <span class="Statement">return</span>(TRUE);

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
}





<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Authenticate a user token </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_check_password(<span class="Type">char</span> *username, <span class="Type">char</span> *shell)

{   <span class="Type">char</span> password_banner[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         password[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         salt[<span class="Constant">2</span>]                 = <span class="Constant">&quot;&quot;</span>,
         envstr[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         crypted_password[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span>           cnt    = <span class="Constant">0</span>;
    <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>((pwent = pups_getpwnam(username)) == (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;No such user </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,username);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">do</span> {     <span class="Type">int</span> verify_cnt = <span class="Constant">0</span>;

             <span class="Type">char</span> tmp_pw_1[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                  tmp_pw_2[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             <span class="Statement">if</span>(interactive_mode == TRUE)
             {  <span class="Statement">do</span> {   <span class="Statement">if</span>(verify_cnt &gt; <span class="Constant">0</span>)
                       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">not confirmed -- try again</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                       }

                       (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) password: &quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                       (<span class="Type">void</span>)strlcpy(tmp_pw_1,getpass(password_banner),SSIZE);

                       (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) verify password:&quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                       (<span class="Type">void</span>)strlcpy(tmp_pw_2,getpass(password_banner),SSIZE);

                       ++verify_cnt;
                   } <span class="Statement">while</span>(strcmp(tmp_pw_1,tmp_pw_2) != <span class="Constant">0</span>);

                (<span class="Type">void</span>)strlcpy(password,tmp_pw_1,SSIZE);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) password: &quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                (<span class="Type">void</span>)strlcpy(appl_password,getpass(password_banner),SSIZE);
             }

            ++cnt;
            <span class="Statement">if</span>(cnt &gt;= max_trys)
               <span class="Statement">return</span>(FALSE);
       } <span class="Statement">while</span>(strlen(password) == <span class="Constant">0</span>);

    salt[<span class="Constant">0</span>] = pwent-&gt;pw_passwd[<span class="Constant">0</span>];
    salt[<span class="Constant">1</span>] = pwent-&gt;pw_passwd[<span class="Constant">1</span>];

    (<span class="Type">void</span>)strlcpy(crypted_password,(<span class="Type">char</span> *)crypt(password,salt),SSIZE);
    <span class="Statement">if</span>(strcmp(pwent-&gt;pw_passwd,crypted_password) == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(setreuid(pwent-&gt;pw_uid,(-<span class="Constant">1</span>)) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;Permission denied (failed to set uid=</span><span class="Special">%d</span><span class="Constant"> for </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,pwent-&gt;pw_uid,username);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

          <span class="Statement">return</span>(FALSE);
       }

       <span class="Statement">if</span>(setregid(pwent-&gt;pw_gid,(-<span class="Constant">1</span>)) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;Permission denied (failed to set gid=</span><span class="Special">%d</span><span class="Constant"> for </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,pwent-&gt;pw_gid,username);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

          <span class="Statement">return</span>(FALSE);
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Are we a PSRP server access account (access to PSRP server only) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;user </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now owner of this PSRP session (uid=</span><span class="Special">%d</span><span class="Constant">, gid=</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,username,getuid(),getgid());
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Close any open server </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(server_connected == TRUE)
       {  psrp_close_server(TRUE,TRUE);
          server_connected   = FALSE;
          psrp_log           = FALSE;
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set up users preferred shell </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(envstr,SSIZE,<span class="Constant">&quot;SHELL=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,pwent-&gt;pw_shell);
       (<span class="Type">void</span>)putenv(envstr);


       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set users home directory </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(envstr,SSIZE,<span class="Constant">&quot;HOME=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,pwent-&gt;pw_dir);
       (<span class="Type">void</span>)putenv(envstr);


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set application owner and (clear) password </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strlcpy(appl_owner,pwent-&gt;pw_name,SSIZE);
       (<span class="Type">void</span>)strlcpy(appl_password,password,SSIZE);

       (<span class="Type">void</span>)snprintf(envstr,SSIZE,<span class="Constant">&quot;LOGNAME=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_owner);
       (<span class="Type">void</span>)putenv(envstr);

       (<span class="Type">void</span>)snprintf(envstr,SSIZE,<span class="Constant">&quot;USER=</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_owner);
       (<span class="Type">void</span>)putenv(envstr);


<span class="PreProc">       #ifdef HAVE_LOGWTMP</span>
       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Update wtmp file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

       logwtmp(ttyname(<span class="Constant">0</span>),appl_name,appl_host);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_LOGWTMP </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(TRUE);
    }

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;Permission denied (authentication failure for user </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,username);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

    <span class="Statement">return</span>(FALSE);
}





<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Change to a new userid </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN builtin_change_user(<span class="Type">char</span> *request)

{   <span class="Type">char</span> strdum[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         username[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(geteuid() != <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;Cannot change session owner unless client (psrp) has effective root UID</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,strdum,username) != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: user &lt;username&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }

    (<span class="Type">void</span>)printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) changing PSRP session owner (from </span><span class="Special">%s</span><span class="Constant"> to </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                        appl_host,PSRP_PROTOCOL_VERSION,appl_owner,username);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

    <span class="Statement">if</span>(psrp_check_password(username,shell) == FALSE)
       <span class="Statement">return</span>(FALSE);

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get current authentication token for client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_get_password(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Type">char</span> password_banner[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         tmp_pw_1[SSIZE]        = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;max_trys; ++i)
    {  (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) password: &quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
       (<span class="Type">void</span>)strlcpy(tmp_pw_1,getpass(password_banner),SSIZE);

       <span class="Statement">if</span>(strcmp(tmp_pw_1,appl_password) == <span class="Constant">0</span>)
          <span class="Statement">return</span>(TRUE);
    }

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">too many trys</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set current authentication token (for client) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_set_password(<span class="Type">char</span> *password)

{   <span class="Type">char</span> password_banner[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         pwd_file_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span>  cnt = <span class="Constant">0</span>;

    <span class="Statement">do</span> {    <span class="Type">int</span> verify_cnt = <span class="Constant">0</span>;

            <span class="Type">char</span> tmp_pw_1[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                 tmp_pw_2[SSIZE] = <span class="Constant">&quot;&quot;</span>;

            <span class="Statement">if</span>(interactive_mode == TRUE)
            {  <span class="Statement">do</span> {   <span class="Statement">if</span>(verify_cnt &gt; <span class="Constant">0</span>)
                      {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">not confirmed -- try again</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                      }

                      (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) new password: &quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                      (<span class="Type">void</span>)strlcpy(tmp_pw_1,getpass(password_banner),SSIZE);

                      <span class="Statement">if</span>(strcmp(tmp_pw_1,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
                      {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">aborted</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                         (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

                         <span class="Statement">return</span>(FALSE);
                      }

                      (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) verify new password:&quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                      (<span class="Type">void</span>)strlcpy(tmp_pw_2,getpass(password_banner),SSIZE);

                      ++verify_cnt;
                  } <span class="Statement">while</span>(strcmp(tmp_pw_1,tmp_pw_2) != <span class="Constant">0</span>);

               (<span class="Type">void</span>)strlcpy(password,tmp_pw_1,SSIZE);
            }
            <span class="Statement">else</span>
            {  (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) new password: &quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
               (<span class="Type">void</span>)strlcpy(password,getpass(password_banner),SSIZE);
            }

            ++cnt;

            <span class="Statement">if</span>(cnt &gt;= max_trys)
               <span class="Statement">return</span>(FALSE);
       } <span class="Statement">while</span>(strlen(password) == <span class="Constant">0</span> &amp;&amp; cnt &lt; max_trys);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Creat authentication file so other [PSRP] applications </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> can authenticate themselves without needing to ask the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> client owner for a password                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(pwd_file_name,SSIZE,<span class="Constant">&quot;/tmp/authtok.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,appl_uid);
    <span class="Statement">if</span>(access(pwd_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Type">FILE</span> *pwd_stream        = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
       <span class="Type">char</span> pwd_link_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)pups_creat(pwd_file_name,<span class="PreProc">0</span><span class="Constant">600</span>);

       (<span class="Type">void</span>)snprintf(pwd_link_name,SSIZE,<span class="Constant">&quot;/tmp/authtok.</span><span class="Special">%d</span><span class="Constant">.lnk.tmp&quot;</span>,appl_pid);
       (<span class="Type">void</span>)link(pwd_file_name,pwd_link_name);

       pwd_stream = pups_fopen(pwd_file_name,<span class="Constant">&quot;w&quot;</span>,DEAD);

       (<span class="Type">void</span>)fprintf(pwd_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,password);
       (<span class="Type">void</span>)fflush(pwd_stream);
       (<span class="Type">void</span>)pups_fclose(pwd_stream);
    }

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set current authentication token </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN builtin_set_password(<span class="Type">char</span> *request, <span class="Type">char</span> *password)

{   _IMMORTAL _BOOLEAN update_cnt = <span class="Constant">0</span>;
    <span class="Type">char</span> strdum[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check request syntax is correct </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,strdum,strdum) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Usage: password</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;secure&quot;</span>,<span class="Constant">8</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)strlcpy(tmpstr,<span class="Constant">&quot;(server) &quot;</span>,SSIZE);
       secure_operation = TRUE;
    }

    (<span class="Type">void</span>)printf(<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) setting </span><span class="Special">%s</span><span class="Constant">authentication token for PSRP services</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                          appl_host,PSRP_PROTOCOL_VERSION,tmpstr);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have a current password we must authenticate ourselves </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> before we can change it.                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(psrp_get_password() == FALSE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">authentication failure</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          <span class="Statement">return</span>(FALSE);
       }
    }

    <span class="Statement">if</span>(strncmp(request,<span class="Constant">&quot;secure&quot;</span>,<span class="Constant">8</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)strlcpy(tmpstr,<span class="Constant">&quot;(client side) &quot;</span>,SSIZE);

    <span class="Statement">if</span>(psrp_set_password(password) == TRUE)
    {  <span class="Statement">if</span>(update_cnt == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant">authentication token for PSRP services set</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,tmpstr);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant">authentication token for PSRP services updated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,tmpstr);
       ++update_cnt;
    }
    <span class="Statement">else</span>
      (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant">authentication token for remote PSRP not set</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,tmpstr);

    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove lockpost files </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_remove_lockpost_files(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">3</span>; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remove this applictions' stdio lockpost files </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;    Removing lockpost file (</span><span class="Special">%s%d</span><span class="Constant">) from patchboard directory </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ftab[i].fname,i,appl_fifo_dir);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }

       (<span class="Type">void</span>)unlink(ftab[i].fname);
       (<span class="Type">void</span>)unlink(ftab[i].fshadow);
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handle SIGWINCH </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> winch_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{

    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are relaying we need to propagate SIGWINCH </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to slave (and its process group)                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(slave_pid != (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)kill(slave_pid,SIGWINCH);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;*** window resized</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>
}



<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Migrate to host that server has migrated to </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_migrate_client_to_server_host(<span class="Type">void</span>)

{   <span class="Type">struct</span> stat buf;

    <span class="Type">char</span> remote_server[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         remote_host[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         remote_host_port[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         remote_psrp_command[SSIZE] = <span class="Constant">&quot;&quot;</span>;


<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;MIGRATE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not follow server if psrp client recursive </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> as this means it is executing an aggregated   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> migration request                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_recursive == TRUE)
       <span class="Statement">return</span>(PSRP_RECURSIVE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Has target server migrated under us? If so there simply inform </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> user and abandon what we are doing                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;READING TRAILFILE INTERACTIVE MODE: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,interactive_mode);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;TRAILFILE NAME: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,trailfile_name);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(interactive_mode == FALSE || psrp_have_trailfile() == FALSE <span class="Comment">/*</span><span class="Comment">|| strcmp(trailfile_name,&quot;&quot;) == 0</span><span class="Comment">*/</span>)
    {
<span class="PreProc">       #ifdef PSRP_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;FAIL</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;HAVE TRAILFILE: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_have_trailfile());
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(PSRP_NOTRAIL);
    }

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;READ TRAILFILE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pel_appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> has migrated to another host (reading trail data from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_server,trailfile_name);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> For now simply extract the trail data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_read_trailfile(trailfile_name,remote_server,remote_host,remote_host_port) == TRUE)
    {  <span class="Statement">if</span>(pel_appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now running as </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> on host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (port: </span><span class="Special">%s</span><span class="Constant">) (client migrating to reconnect to it)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                        psrp_server,remote_server,remote_host,remote_host_port);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Migrate onto the servers machine and reconnect to it  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> note that we may arrive at the servers node before it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> does so we may have to wait for it, Note if we are    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> remote report basal PSRP client location as this is   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> where the user is!                                    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> PSRP client is does not have pen </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(appl_name,appl_bin_name) == <span class="Constant">0</span>)
       {


          <span class="Statement">if</span>(is_remote == TRUE)
             (<span class="Type">void</span>)snprintf(remote_psrp_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -ssh_port </span><span class="Special">%s</span><span class="Constant"> -wait -sname </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,
                                                                                         appl_bin_name,
                                                                                           remote_host,
                                                                                      remote_host_port,
                                                                                         remote_server,
                                                                                         from_hostname,
                                                                                      from_client_name,
                                                                                       from_client_pid);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(remote_psrp_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -ssh_port </span><span class="Special">%s</span><span class="Constant"> -wait -sname </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,
                                                                                         appl_bin_name,
                                                                                           remote_host,
                                                                                      remote_host_port,
                                                                                         remote_server,
                                                                                             appl_host,
                                                                                             appl_name,
                                                                                              appl_pid);
       }


       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> PSRP client has pen </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(is_remote == TRUE)
             (<span class="Type">void</span>)snprintf(remote_psrp_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -pen </span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -ssh_port </span><span class="Special">%s</span><span class="Constant"> -wait -sname </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,
                                                                                                        appl_bin_name,
                                                                                                            appl_name,
                                                                                                          remote_host,
                                                                                                     remote_host_port,
                                                                                                        remote_server,
                                                                                                        from_hostname,
                                                                                                            appl_name,
                                                                                                      from_client_pid);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(remote_psrp_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -pen </span><span class="Special">%s</span><span class="Constant"> -on </span><span class="Special">%s</span><span class="Constant"> -ssh_port </span><span class="Special">%s</span><span class="Constant"> -wait -sname </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">&quot;</span>,
                                                                                                        appl_bin_name,
                                                                                                            appl_name,
                                                                                                          remote_host,
                                                                                                     remote_host_port,
                                                                                                        remote_server,
                                                                                                            appl_host,
                                                                                                            appl_name,
                                                                                                             appl_pid);
       }

<span class="PreProc">       #ifdef PSRP_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;RCOMM: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,remote_psrp_command);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(WEXITSTATUS(system(remote_psrp_command)) &gt;= <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Destroy stack of sockets to remote endpoint </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(is_remote == TRUE)
          {  <span class="Statement">if</span>(strcmp(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>) != <span class="Constant">0</span>)
                pups_exit(<span class="Constant">255</span>);
             pups_exit(<span class="Constant">0</span>);
          }
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to exec PSRP command (on migrated server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,remote_server);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
       }
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to to find trail to migrated server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,remote_server);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remote PSRP connection has been closed -- resume </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> local PSRP client                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(psrp_server,<span class="Constant">&quot;none&quot;</span>,SSIZE);
    (<span class="Type">void</span>)psrp_close_server(TRUE,FALSE);

    server_connected   = FALSE;
    processing_command = FALSE;
    psrp_log           = FALSE;

    initialise_repeaters();
    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;scloscond&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for further command input from user </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;command_loop_top);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set current working directory </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_builtin_set_lcwd(<span class="Type">char</span> *cwd)

{   <span class="Type">char</span> cwdpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         relpath[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN default_cwd = FALSE;

    <span class="Statement">if</span>(cwd == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">current working directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_cwd,cwdpath);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }

    <span class="Statement">if</span>(strcmp(cwd,<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(cwd,<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  cwd [help | usage] [&lt;current working directory:</span><span class="Special">%s</span><span class="Constant">&gt; | default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">if</span>(strcmp(cwd,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)strlcpy(appl_cwd,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;PWD&quot;</span>),SSIZE);
       default_cwd = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if path is absolute </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(cwd[<span class="Constant">0</span>] == <span class="Constant">'/'</span>)
       (<span class="Type">void</span>)strlcpy(cwdpath,cwd,SSIZE);
    <span class="Statement">else</span> <span class="Statement">if</span>(cwd[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
    {  <span class="Statement">if</span>(cwd[<span class="Constant">1</span>] == <span class="Constant">'.'</span>)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;std_init: cannot have </span><span class="Special">\&quot;</span><span class="Constant">..</span><span class="Special">\&quot;</span><span class="Constant"> in cwd path&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

          <span class="Statement">return</span>(FALSE);
       }

       (<span class="Type">void</span>)getcwd(relpath,SSIZE);
       (<span class="Type">void</span>)snprintf(cwdpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,relpath,&amp;cwd[<span class="Constant">2</span>]);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)getcwd(relpath,SSIZE);
       (<span class="Type">void</span>)snprintf(cwdpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,relpath,cwd);
    }

    <span class="Statement">if</span>(chdir(cwdpath) != (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)strlcpy(appl_cwd,cwdpath,SSIZE);

       <span class="Statement">if</span>(default_cwd == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">set current working directory to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">set current working directory to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">current working directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (could not change it to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_cwd,cwdpath);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
    }

    <span class="Statement">return</span>(TRUE);
}



<span class="PreProc">#ifdef SLAVED_COMMANDS</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is command permitted </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN command_permitted(<span class="Type">char</span> *cmd)

{   <span class="Type">int</span>  i;

    <span class="Type">char</span> strdum[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         effective_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    (<span class="Type">void</span>)sscanf(cmd,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,effective_cmd,strdum);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;clist_size; ++i)
    {  <span class="Statement">if</span>(strcmp(clist[i],effective_cmd) == <span class="Constant">0</span>)
          <span class="Statement">return</span>(TRUE);
    }

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Read restricted command list </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> builtin_read_clist(_BOOLEAN interactive, <span class="Type">char</span> *request)

{   <span class="Type">FILE</span> *stream          = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>,
         *stripped_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">int</span> i,
        ret;

    <span class="Type">char</span> strdum[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         tmp_f_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         clist_f_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(interactive == TRUE)
       ret = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,strdum,clist_f_name);
    <span class="Statement">else</span>
       ret = sscanf(request,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,clist_f_name);

    <span class="Statement">if</span>(ret &gt; <span class="Constant">1</span> &amp;&amp; clist_alloc &gt; <span class="Constant">0</span>)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;clist_alloc; ++i)
          (<span class="Type">void</span>)pups_free((<span class="Type">char</span> *)clist[i]);
       clist = (<span class="Type">char</span> **)pups_free((<span class="Type">char</span> *)clist);
       clist_size = clist_alloc = <span class="Constant">0</span>;
    }

    <span class="Statement">if</span>(strcmp(clist_f_name,<span class="Constant">&quot;none&quot;</span>) == <span class="Constant">0</span>)
    {  restricted_clist = FALSE;

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">restricted command list revoked (any command can be executed by default shell)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    <span class="Statement">if</span>(interactive == TRUE &amp;&amp; ret == <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(clist_size == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting restricted command list file name</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">RCL command list</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;clist_size; ++i)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%32s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,clist[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(access(clist_f_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot find/access restricted command list file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,clist_f_name);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Strip any comment from command list file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    stream          = fopen(clist_f_name,<span class="Constant">&quot;r&quot;</span>);
    (<span class="Type">void</span>)snprintf(tmp_f_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.tmp&quot;</span>,appl_name,appl_pid,appl_host);
    stripped_stream = pups_strp_commnts(<span class="Constant">'#'</span>,stream, tmp_f_name);

    <span class="Statement">do</span> {   <span class="Statement">if</span>(clist_alloc == <span class="Constant">0</span>)
           {  clist_alloc = ALLOC_QUANTUM;
              clist       = (<span class="Type">char</span> **)pups_calloc(clist_alloc,<span class="Statement">sizeof</span>(<span class="Type">char</span> **));
           }
           <span class="Statement">else</span> <span class="Statement">if</span>(clist_alloc == clist_size)
           {  clist_alloc += ALLOC_QUANTUM;
              clist = (<span class="Type">char</span> **)pups_realloc((<span class="Type">void</span> *)clist,clist_alloc*<span class="Statement">sizeof</span>(<span class="Type">char</span> **));
           }


           <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Read next command from file </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

           clist[clist_size] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">256</span>*<span class="Statement">sizeof</span>(<span class="Type">char</span>));
           (<span class="Type">void</span>)fscanf(stripped_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,clist[clist_size]);

           ++clist_size;
       } <span class="Statement">while</span>(feof(stripped_stream) == <span class="Constant">0</span>);

    --clist_size;
    (<span class="Type">void</span>)fclose(stripped_stream);
    (<span class="Type">void</span>)unlink(tmp_f_name);

    restricted_clist = TRUE;

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> commands read from rcl file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,clist_size,clist_f_name);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLAVED_COMMANDS </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display the current PUPS connections on the client machine </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_kill_servers(<span class="Type">char</span> *directory, <span class="Type">char</span> *part_name)

{   <span class="Type">int</span> i,
        pid,
        entry_cnt,
        n_entries,
        cnt = <span class="Constant">0</span>;

    <span class="Type">char</span> strdum[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         application[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         hostname[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         pathname[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         **entry_list       = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

    <span class="Type">struct</span> stat   buf;
    <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we are actually looking at a directory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)stat(directory,&amp;buf);
    <span class="Statement">if</span>(!S_ISDIR(buf.st_mode))
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not a directory</span><span class="Special">\n</span><span class="Constant">&quot;</span>,directory);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

       <span class="Statement">return</span>;
    }

    entry_list = pups_get_directory_entries(directory,<span class="Constant">&quot;psrp&quot;</span>,&amp;n_entries,&amp;entry_cnt);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get the owner of resource </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,directory,entry_list[i]);
       (<span class="Type">void</span>)stat(pathname,&amp;buf);
       pwent = pups_getpwuid(buf.st_uid);

       mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;#&quot;</span>,entry_list[i]);

       <span class="Statement">if</span>(strin(entry_list[i],<span class="Constant">&quot;psrp&quot;</span>) == TRUE &amp;&amp; strin(entry_list[i],<span class="Constant">&quot;fifo in&quot;</span>) == TRUE)
       {

          <span class="Type">int</span>  j;

          <span class="Type">char</span> procpidpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
               binname[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(sscanf(entry_list[i],<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d</span><span class="Constant">&quot;</span>,strdum,application,hostname,strdum,strdum,&amp;pid) == <span class="Constant">6</span>)
          {  <span class="Type">char</span>   state[SSIZE] = <span class="Constant">&quot;&quot;</span>;


             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Get name of binary (if we can) </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;<span class="Constant">256</span>; ++j)
                binname[j] = <span class="Special">'\0'</span>;

             (<span class="Type">void</span>)snprintf(procpidpath,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/exe&quot;</span>,pid);
             (<span class="Type">void</span>)readlink(procpidpath,binname,<span class="Constant">256</span>);

             <span class="Statement">for</span>(j=<span class="Constant">255</span>; j&gt;=<span class="Constant">0</span>; --j)
             {  <span class="Statement">if</span>(binname[j] == <span class="Constant">'/'</span>)
                   <span class="Statement">goto</span> name_extracted;
             }

<span class="Statement">name_extracted</span>:
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%16s</span><span class="Constant">&quot;</span>,&amp;binname[j+<span class="Constant">1</span>]);


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check that PSRP servers associated with this channel list </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> are local.                                                </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(strcmp(hostname,appl_host) != <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP channels on </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> are not local to </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,directory,appl_host);
                (<span class="Type">void</span>)fflush(psrp_out);


                <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Clear the entry list </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

                <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
                    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list[i]);
                (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list);

                <span class="Statement">return</span>;
             }

             <span class="Statement">if</span>(strcmp(part_name,<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)
                (<span class="Type">void</span>)kill(pid,<span class="Constant">SIGTERM</span>);
             <span class="Statement">else</span> <span class="Statement">if</span>(strin(application,part_name) == TRUE)
                (<span class="Type">void</span>)kill(pid,<span class="Constant">SIGTERM</span>);

             <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
                (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);


             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (bin name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,application,binname);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);

             <span class="Statement">if</span>(exit_on_terminate == TRUE)
                pups_exit(<span class="Constant">255</span>);

             ++cnt;
          }
       }
    }

    <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear the entry list </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
          (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list[i]);
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list);

       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear the entry list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entries; ++i)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list[i]);
    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entry_list);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Virtual maggot remove stale channels, lockposts and locks </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_virtual_maggot(<span class="Type">char</span> *dirname)


{   <span class="Type">int</span>    ret              = <span class="Constant">0</span>,
	   cnt              = <span class="Constant">0</span>,
           owner            = <span class="Constant">0</span>,
           lock_pid         = <span class="Constant">0</span>,
           deleted          = <span class="Constant">0</span>;

    <span class="Type">DIR</span>    *dirp            = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span>   tmpstr[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
           next_item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">struct</span> dirent *next_entry = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>((dirp = opendir(dirname)) == (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    <span class="Statement">do</span> {    next_entry = readdir(dirp);

            (<span class="Type">void</span>)strext(<span class="Constant">' '</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


            <span class="Statement">if</span>(next_entry != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>           &amp;&amp;
               (strncmp(next_entry-&gt;d_name,<span class="Constant">&quot;psrp&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>    ||
                strncmp(next_entry-&gt;d_name,<span class="Constant">&quot;pups&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>    ||
                strncmp(next_entry-&gt;d_name, <span class="Constant">&quot;lid&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>    ||
                strin(next_entry-&gt;d_name,<span class="Constant">&quot;.tmp&quot;</span>)     == TRUE ))
            {  <span class="Type">struct</span> stat buf;
               <span class="Type">char</span>   item_path[SSIZE] = <span class="Constant">&quot;&quot;</span>;

               (<span class="Type">void</span>)strlcpy(tmpstr,next_entry-&gt;d_name,SSIZE);
               (<span class="Type">void</span>)mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;#:&quot;</span>,tmpstr);  <span class="Comment">// MAO removed '.'</span>


               <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Do we own this file? </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

               (<span class="Type">void</span>)snprintf(item_path,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,dirname,next_entry-&gt;d_name);
               (<span class="Type">void</span>)lstat(item_path,&amp;buf);

               <span class="Statement">if</span>(getuid() == <span class="Constant">0</span> || buf.st_uid == getuid())
               {

		  <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
		  <span class="Comment">/*</span><span class="Comment"> Parse psrp object name for PID </span><span class="Comment">*/</span>
		  <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

                  cnt = <span class="Constant">0</span>;
                  <span class="Statement">do</span> {    ret = strext(<span class="Constant">' '</span>,next_item,tmpstr);


                          <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>
                          <span class="Comment">/*</span><span class="Comment"> PID </span><span class="Comment">*/</span>
                          <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>

                          <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
                          {  <span class="Statement">if</span>(sscanf(next_item,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;lock_pid) == <span class="Constant">1</span>)
		                ++cnt;
                          }


                          <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
                          <span class="Comment">/*</span><span class="Comment"> Owner </span><span class="Comment">*/</span>
                          <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

                          <span class="Statement">else</span> <span class="Statement">if</span>(cnt == <span class="Constant">1</span>)
                          {  <span class="Statement">if</span>(sscanf(next_item,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;owner) == <span class="Constant">1</span>)
		                ++cnt;
                          }


			  <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
			  <span class="Comment">/*</span><span class="Comment"> Have process PID and owner </span><span class="Comment">*/</span>
			  <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

			  <span class="Statement">if</span>(cnt == <span class="Constant">2</span>)
                          {
<span class="PreProc">                             #ifdef PSRP_DEBUG </span>
                             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;OWNER </span><span class="Special">%d</span><span class="Constant">  LOCK PID </span><span class="Special">%d</span><span class="Constant">: ITEM </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,owner,lock_pid,item_path);
                             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                             #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>


                             <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
                             <span class="Comment">/*</span><span class="Comment"> Is owner live? </span><span class="Comment">*/</span>
                             <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

                             <span class="Statement">if</span>(kill(lock_pid,SIGALIVE) == (-<span class="Constant">1</span>))
                             {

                                ++deleted;
                                (<span class="Type">void</span>)unlink(item_path);

<span class="PreProc">                                #ifdef PSRP_DEBUG </span>
                                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;OWNER </span><span class="Special">%d</span><span class="Constant">  LOCK PID </span><span class="Special">%d</span><span class="Constant">: ITEM REMOVED </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,owner,lock_pid,item_path);
                                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                                #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>
                             }

                             <span class="Statement">break</span>;
                          }

                     } <span class="Statement">while</span>(ret != END_STRING);
               }
            }
        } <span class="Statement">while</span>(next_entry != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Repair potential damage to /dev/tty </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span> (getuid() == <span class="Constant">0</span>)
       (<span class="Type">void</span>)system(<span class="Constant">&quot;mktty&quot;</span>);

    <span class="Statement">return</span>(deleted);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Check for existence of trailfile and  get its name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_have_trailfile(<span class="Type">void</span>)


{

    (<span class="Type">void</span>)snprintf(trailfile_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.trail&quot;</span>,channel_name_in);

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;TRAILFILE: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,trailfile_name);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(trailfile_name,F_OK | R_OK) == (-<span class="Constant">1</span>))
    {
<span class="PreProc">       #ifdef PSRP_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;NO TRAILFILE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(FALSE);
    }

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;HAVE TRAILFILE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(TRUE);
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
