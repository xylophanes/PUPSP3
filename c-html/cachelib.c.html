<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>/usr/local/src/pupsp3-5.4.9.src.git/pupscore.src/cachelib.c.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span>
<span class="Comment">    Purpose: Fast cache library.</span>

<span class="Comment">    Author:  M.A. O'Neill</span>
<span class="Comment">             Tumbling Dice Ltd</span>
<span class="Comment">             Gosforth</span>
<span class="Comment">             NE3 54RT</span>
<span class="Comment">             Tyne and Wear</span>

<span class="Comment">    Version: 4.14</span>
<span class="Comment">    Dated:   18th September 2023 </span>
<span class="Comment">    Email:   mao@tumblingdice.co.uk</span>
<span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;me.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utils.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;math.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/mman.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/utsname.h&gt;</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> If we have OpenMP support then we also have pthread support </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (OpenMP is built on pthreads for Linux distributions).      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#if defined(_OPENMP) &amp;&amp; !defined(PTHREAD_SUPPORT)</span>
<span class="PreProc">#define PTHREAD_SUPPORT</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;tad.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#undef  __NOT_LIB_SOURCE__</span>
<span class="PreProc">#include </span><span class="Constant">&lt;cache.h&gt;</span>
<span class="PreProc">#define __NOT_LIB_SOURCE__</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get signal mapping appropriate to OS and hardware architecture </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define __DEFINE__</span>
<span class="PreProc">#if defined(I386) || defined(X86_64)</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.x86.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> I386 || X86_64 </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV6L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV6L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV7L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV7L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef AARCH64</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> AARCH64 </span><span class="Comment">*/</span>
<span class="PreProc">#undef __DEFINE__</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get application information for slot manager </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot information function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> cache_slot(<span class="Type">int</span> level)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;lib cachelib </span><span class="Special">%s</span><span class="Constant">: [ANSI C]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CACHELIB_VERSION);

    <span class="Statement">if</span>(level &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;(c) 2001-2022 Tumbling Dice, Gosforth</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;Author: M.A. O'Neill</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PUPS/P3 fast caching library (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
}


<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Segment identification for cache library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SLOT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;slotman.h&gt;</span>
_EXTERN <span class="Type">void</span> (* SLOT )() __attribute__ ((aligned(<span class="Constant">16</span>))) = cache_slot;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLOT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Cache table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN cache_table_initialised = FALSE;
_PRIVATE          cache_type cache[MAX_CACHES];


<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Function which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Print number of bytes in cache</span>
_PRIVATE <span class="Type">int</span> print_bytes(<span class="Type">FILE</span> *,
                         <span class="Type">const</span> <span class="Type">char</span> *,
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span>);

<span class="Comment">// Inversely map existing process memory into a</span>
<span class="Comment">// ghost file, synchronising it with memory area</span>
_PRIVATE <span class="Type">void</span> *mmap_invmap_cachememory(<span class="Type">unsigned</span> <span class="Type">int</span>,
                                       <span class="Type">const</span> <span class="Type">char</span> *,
                                       <span class="Type">const</span> <span class="Type">int</span>,
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>);

<span class="Comment">// Memory map cache directly into the address space</span>
<span class="Comment">// of the program</span>
_PRIVATE <span class="Type">void</span> *mmap_fwdmap_cachememory(<span class="Type">unsigned</span> <span class="Type">int</span>,
                                       <span class="Type">const</span> <span class="Type">char</span> *,
                                       <span class="Type">const</span> <span class="Type">int</span>,
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>);

<span class="Comment">// Map cache memory</span>
_PRIVATE <span class="Type">void</span> *cache_mmap_cachememory (<span class="Type">unsigned</span> <span class="Type">int</span>,
                                       <span class="Type">const</span> <span class="Type">char</span> *,
                                       <span class="Type">const</span>  <span class="Type">int</span>,
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>,
                                       <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *);




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Memory map cache directly into the address space </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> of the program                                   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> *mmap_fwdmap_cachememory(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>                c_index,  <span class="Comment">// Cache index</span>
                                       <span class="Type">const</span>          <span class="Type">char</span>       *cachefile_name,  <span class="Comment">// Cache file name</span>
                                       <span class="Type">const</span>          <span class="Type">int</span>              h_p_state,  <span class="Comment">// Hoemostatic protection state</span>
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>              size)  <span class="Comment">// Size of cache</span>

{   <span class="Type">int</span> fd,
        map_flags = <span class="Constant">0</span>;

    <span class="Type">void</span> *cache_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> File permissions must match memory mapping mode </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((fd = pups_open(cachefile_name,O_RDWR,h_p_state)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)snprintf(<span class="Constant">&quot;[mmap_fwdmap_cachememory] cannot open cachefile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,SSIZE,cachefile_name);
       pups_error(errstr);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)flock(fd,LOCK_EX);


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read only mapping </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PRIVATE)
       map_flags = MAP_PRIVATE;


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read/write mapping </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PUBLIC)
       map_flags = MAP_SHARED;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Populate mapping to prevent page faults </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_POPULATE)
       map_flags |= MAP_POPULATE;

    <span class="Statement">if</span>((cache_ptr = mmap(<span class="Constant">NULL</span>,
                         size,
                         PROT_READ  | PROT_WRITE,
                         map_flags,
                         fd,
                         <span class="Constant">0L</span>)) == (<span class="Type">void</span> *)MAP_FAILED)
    {  (<span class="Type">void</span>)pups_close(fd);
       (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[mmap_fwdmap_cachememory] cannot map cachfile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> into process address space&quot;</span>,cachefile_name);
       pups_error(errstr);
    }

    cache[c_index].mmap_fd = fd;
    (<span class="Type">void</span>)strlcpy(cache[c_index].mmap_name,cachefile_name,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): mapping to cachefile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual), </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner,cachefile_name,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache_ptr,errno);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(cache_ptr);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Inversely map existing process memory into a  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> ghost file, synchronising it with memory area </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> *mmap_invmap_cachememory(<span class="Type">const</span>    <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index</span>
                                       <span class="Type">const</span>    <span class="Type">char</span>         *cachefile_name,  <span class="Comment">// Name of cache file</span>
                                       <span class="Type">const</span>    <span class="Type">int</span>                h_p_state,  <span class="Comment">// Homeostatic protection state</span>
                                       <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>                size)  <span class="Comment">// Size of cache</span>

{   <span class="Type">int</span>  map_flags = <span class="Constant">0</span>,
         fd        = (-<span class="Constant">1</span>);

    <span class="Type">void</span> *cache_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Creat a ghost file of the right size for the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> cache and then map cache                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(cachefile_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(pups_creat(cachefile_name,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[mmap_invmap_cachememory] cannot create cachefile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,cachefile_name);
          pups_error(errstr);
       }
    }

    <span class="Statement">if</span>((fd = pups_open(cachefile_name,O_RDWR,h_p_state)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[mmap_invmap_cachememory] cannot open cachefile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,cachefile_name);
       pups_error(errstr);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)flock(fd,LOCK_EX);


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set file size </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)ftruncate(fd,size);
    (<span class="Type">void</span>)posix_fallocate(fd, <span class="Constant">0</span>, size);


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read only mapping </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PRIVATE)
       map_flags = MAP_PRIVATE;


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read/write mapping </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PUBLIC)
       map_flags = MAP_SHARED;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Populate mapping to prevent page faults </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_POPULATE)
       map_flags |= MAP_POPULATE;


    <span class="Statement">if</span>((cache_ptr = mmap(<span class="Constant">NULL</span>,
                         size,
                         PROT_READ  | PROT_WRITE,
                         map_flags,
                         fd,
                         <span class="Constant">0L</span>)) == (<span class="Type">void</span> *)MAP_FAILED)
   {    (<span class="Type">void</span>)pups_close(fd);
        (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[mmap_invmap_cachememory] cannot map cachefile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> into process address space&quot;</span>,cachefile_name);
        pups_error(errstr);
   }


   <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Tell Kernel we will be accessing cache   </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> and it would be a good idea to read some </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> pages ahead                              </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

   cache[c_index].mmap_fd = fd;
   (<span class="Type">void</span>)strlcpy(cache[c_index].mmap_name,cachefile_name,SSIZE);

   <span class="Statement">if</span>(appl_verbose == TRUE)
   {  (<span class="Type">void</span>)strdate(date);
      (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): inverse mapping to cachefile </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                    date,appl_name,appl_pid,appl_host,appl_owner,cachefile_name,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache_ptr);
      (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
   }

   pups_set_errno(OK);
   <span class="Statement">return</span>(cache_ptr);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return the index of a (named) cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_name2index(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_name2index] expecting cache name&quot;</span>);


    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CACHES; ++i)
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[i].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(cache[i].name,name) == <span class="Constant">0</span>)
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          <span class="Statement">if</span>(have_cache_lock == FALSE)
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[i].mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[i].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
    }

    (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_name2index] cannot find cache </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,name);
    pups_error(errstr);

    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Map cache memory - create an </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> inverse map if backing file  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> does not exit                </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> *cache_mmap_cachememory(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     c_index,  <span class="Comment">// Cache index</span>
                                      <span class="Type">const</span> <span class="Type">char</span>          *file_name,  <span class="Comment">// Cache file name</span>
                                      <span class="Type">const</span> <span class="Type">int</span>            h_p_state,  <span class="Comment">// Homeostatic protection state</span>
                                      <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span>   <span class="Type">int</span> size,  <span class="Comment">// Cache size</span>
                                      <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>         *crc)  <span class="Comment">// Cache (64 bit) CRC </span>

{   <span class="Type">void</span> *cache_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_mmap_cachememory] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create and map new cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       cache_ptr = mmap_invmap_cachememory(c_index,file_name,h_p_state,size);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Map existing cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> tmp_crc,
                         old_size;


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check CRC (is cache corrupted?) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       cache_ptr = mmap_fwdmap_cachememory(c_index,file_name,h_p_state,size);


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check CRC (is cache corrupted?) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(crc != (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
       {  tmp_crc   = pups_crc_64(size,cache_ptr);

          <span class="Statement">if</span>(tmp_crc != <span class="Constant">0x0</span> &amp;&amp; cache[c_index].crc != <span class="Constant">0x0</span> &amp;&amp; cache[c_index].crc != tmp_crc)
          {

             <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Unmap the cache and  </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> return CRC to caller </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

             cache[c_index].cache_ptr = cache_ptr;
             (<span class="Type">void</span>)cache_destroy(TRUE,FALSE,c_index);

             *crc = <span class="Constant">0x0</span>;

             pups_set_errno(<span class="Constant">EINVAL</span>);
             <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
          }


          <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Return CRC to caller </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span> <span class="Statement">if</span>(crc != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             *crc = tmp_crc;
       }
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(cache_ptr);
}



<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Initialise cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_table_init(<span class="Type">void</span>)

{   <span class="Type">int</span> i,
        c_index;

    <span class="Type">char</span> mmap_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_table_init] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise cache table entries </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_table_initialised == FALSE)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CACHES; ++i)
       {   <span class="Type">int</span> j;
           pthread_mutexattr_t attr;

           (<span class="Type">void</span>)strlcpy(cache[i].path        ,<span class="Constant">&quot;&quot;</span> ,SSIZE);
           (<span class="Type">void</span>)strlcpy(cache[i].name        ,<span class="Constant">&quot;&quot;</span>, SSIZE);
           (<span class="Type">void</span>)strlcpy(cache[i].mapinfo_name,<span class="Constant">&quot;&quot;</span>, SSIZE);
           (<span class="Type">void</span>)strlcpy(cache[i].mmap_name   ,<span class="Constant">&quot;&quot;</span>, SSIZE);
           (<span class="Type">void</span>)strlcpy(cache[i].auxinfo     ,<span class="Constant">&quot;&quot;</span>, SSIZE);

           (<span class="Type">void</span>)pthread_mutexattr_settype(&amp;attr,PTHREAD_MUTEX_RECURSIVE);
           (<span class="Type">void</span>)pthread_mutex_init(&amp;cache[i].mutex,&amp;attr);

           cache[i].mapinfo_fd = (-<span class="Constant">1</span>);
           cache[i].mmap_fd    = (-<span class="Constant">1</span>);
           cache[i].mmap       = FALSE;
           cache[i].u_blocks   = <span class="Constant">0</span>;
           cache[i].n_blocks   = <span class="Constant">0</span>;
           cache[i].n_objects  = <span class="Constant">0</span>;
           cache[i].block_size = <span class="Constant">0L</span>;
           cache[i].cache_size = <span class="Constant">0L</span>;
           cache[i].crc        = <span class="Constant">0L</span>;
           cache[i].colsize    = <span class="Constant">0</span>;

           <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;MAX_CACHE_BLOCK_OBJECTS; ++j)
           {  cache[i].object_size[i]   = <span class="Constant">0L</span>;
              cache[i].object_offset[i] = <span class="Constant">0L</span>;
              (<span class="Type">void</span>)strlcpy(cache[i].object_desc[i],<span class="Constant">&quot;none&quot;</span>,SSIZE);
           }

           cache[i].blockmap     = (block_mtype      *)<span class="Constant">NULL</span>;
           cache[i].cache_ptr    = (<span class="Type">void</span>             *)<span class="Constant">NULL</span>;
           cache[i].flags        = (_BYTE            *)<span class="Constant">NULL</span>;
           cache[i].tag          = (<span class="Type">unsigned</span> <span class="Type">int</span>     *)<span class="Constant">NULL</span>;
           cache[i].lifetime     = (<span class="Type">int</span>              *)<span class="Constant">NULL</span>;
           cache[i].hubness      = (<span class="Type">unsigned</span> <span class="Type">int</span>     *)<span class="Constant">NULL</span>;
           cache[i].rwlock       = (pthread_rwlock_t *)<span class="Constant">NULL</span>;
       }

       cache_table_initialised = TRUE;
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add object to cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_add_object(<span class="Type">const</span> _BOOLEAN          have_cache_lock,  <span class="Comment">// If TRUE lock on cache held</span>
                             <span class="Type">const</span> <span class="Type">char</span>                        *desc,  <span class="Comment">// Description of object</span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>            size,  <span class="Comment">// Size of object (bytes)</span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>              c_index)  <span class="Comment">// Cache index (identifier)</span>

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_add_object] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_add_object] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(size == <span class="Constant">0</span>)
      pups_error(<span class="Constant">&quot;[cache_add_object] object has zero size&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].n_objects &gt; MAX_CACHE_BLOCK_OBJECTS)
       pups_error(<span class="Constant">&quot;[cache_add_object] too many objects in cache&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Object description </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(desc != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(cache[c_index].object_desc[cache[c_index].n_objects],desc,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set object size and increment object counter </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    cache[c_index].object_size[cache[c_index].n_objects] = size;
    ++cache[c_index].n_objects;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get machine architecture </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> get_march(<span class="Type">char</span> *march)

{    <span class="Type">struct</span> utsname buf;

     <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> get machine architecture </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)uname(&amp;buf);
     (<span class="Type">void</span>)strlcpy(march,buf.machine,SSIZE);

     pups_set_errno(OK);
     <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Creat a dynamic multiple block cache with multiple </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> objects per block                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_create(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// Lock held on cache if TRUE</span>
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>            mmap,  <span class="Comment">// Memory mapping operation</span>
                         <span class="Type">const</span> <span class="Type">char</span>                   *name,  <span class="Comment">// Cache name</span>
                         <span class="Type">int</span>                       n_blocks,  <span class="Comment">// Number of blocks in cache</span>
                         <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>             *crc,  <span class="Comment">// Cache (64 bit) CRC</span>
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index)  <span class="Comment">// Cache indentifier</span>

{   <span class="Type">int</span> i,
        h_p_state = DEAD;

    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> current_offset = <span class="Constant">0L</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_create] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_create] expecting cache name&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_create] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Cache already in use </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(cache[c_index].cache_ptr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_create] cache is already in use&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((mmap &amp; CACHE_USE_MAPINFO) == <span class="Constant">0</span>)
    {  <span class="Type">char</span> path[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
            basename[SSIZE]  = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Sanity check (number of blocks) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(n_blocks &lt;= <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[cache_create] number of blocks in cache &lt;= 0&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set cache path </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strbranch(name,path);
       (<span class="Type">void</span>)strlcpy (cache[c_index].path,path,SSIZE);


       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set cache name </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strleaf(name,basename);
       (<span class="Type">void</span>)strtrnc(basename,<span class="Constant">'.'</span>,<span class="Constant">1</span>);
       (<span class="Type">void</span>)strlcpy (cache[c_index].name,basename,SSIZE);

       cache[c_index].mmap = CACHE_MMAP;


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Private mapping </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mmap &amp; CACHE_PRIVATE)
          cache[c_index].mmap |= CACHE_PRIVATE;


       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Public mapping </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(mmap &amp; CACHE_PUBLIC)
          cache[c_index].mmap |= CACHE_PUBLIC;


       <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Default </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
          cache[c_index].mmap |= CACHE_PUBLIC;


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Preload mapping </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mmap &amp; CACHE_POPULATE)
          cache[c_index].mmap |= CACHE_POPULATE;


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> No preloaded mapping </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(mmap &amp; CACHE_DEPOPULATE)
          cache[c_index].mmap |= CACHE_DEPOPULATE;


       <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Default </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
          cache[c_index].mmap != CACHE_DEPOPULATE;


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Homeostatic protection </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mmap &amp; CACHE_LIVE)
       {  cache[c_index].mmap |= CACHE_LIVE;
          h_p_state = LIVE;
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Always honour populate and  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> populate flags irrespective </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> of how we get other cache   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> parameters                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  cache[c_index].mmap = CACHE_MMAP;


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Private mapping </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mmap &amp; CACHE_PRIVATE)
          cache[c_index].mmap |= CACHE_PRIVATE;


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Public mapping </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(mmap &amp; CACHE_PUBLIC)
          cache[c_index].mmap |= CACHE_PUBLIC;


       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Preloading </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mmap &amp; CACHE_POPULATE)
          cache[c_index].mmap |= CACHE_POPULATE;


       <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> No preloading </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(mmap &amp; CACHE_DEPOPULATE)
          cache[c_index].mmap |= CACHE_DEPOPULATE;


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Homeostatic protection </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mmap &amp; CACHE_LIVE)
       {  cache[c_index].mmap |= CACHE_LIVE;
          h_p_state = LIVE;
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build new cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((mmap &amp; CACHE_USE_MAPINFO) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Compute offsets of all blocks and mark them </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> unused and accessible                       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;=cache[c_index].n_objects; ++i)
       {  current_offset                  += cache[c_index].object_size[i-<span class="Constant">1</span>];
          cache[c_index].object_offset[i]  = current_offset;
       }


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Allocate block flags </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].flags == (_BYTE *)<span class="Constant">NULL</span>)
          cache[c_index].flags = (_BYTE *)pups_calloc(n_blocks,<span class="Statement">sizeof</span>(_BYTE));

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
           cache[c_index].flags[i] = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Allocate block tags </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].tag == (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
          cache[c_index].tag = (<span class="Type">unsigned</span> <span class="Type">int</span> *)pups_calloc(n_blocks,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
           cache[c_index].tag[i] = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Allocate lifetime </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].lifetime == (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
          cache[c_index].lifetime = (<span class="Type">int</span> *)pups_calloc(n_blocks,<span class="Statement">sizeof</span>(<span class="Type">int</span>));

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
           cache[c_index].lifetime[i] = BLOCK_IMMORTAL;


       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Allocate hubness </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].hubness == (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
          cache[c_index].hubness = (<span class="Type">unsigned</span> <span class="Type">int</span> *)pups_calloc(n_blocks,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
           cache[c_index].hubness[i] = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Allocate binding </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].binding == (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
          cache[c_index].binding = (<span class="Type">unsigned</span> <span class="Type">int</span> *)pups_calloc(n_blocks,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
           cache[c_index].binding[i] = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Allocate block rwlocks </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].rwlock == (pthread_rwlock_t *)<span class="Constant">NULL</span>)
          cache[c_index].rwlock = (pthread_rwlock_t *)pups_calloc(n_blocks,<span class="Statement">sizeof</span>(pthread_rwlock_t));

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
           (<span class="Type">void</span>)pthread_rwlock_init(&amp;cache[c_index].rwlock[i],(pthread_rwlockattr_t *)<span class="Constant">NULL</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get offsets into cache block (in bytes) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Size of entire cache block (in bytes) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       cache[c_index].block_size = current_offset + cache[c_index].object_size[cache[c_index].n_objects-<span class="Constant">1</span>];


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Size of entire cache (in bytes) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       cache[c_index].n_blocks   = n_blocks;
       cache[c_index].cache_size = cache[c_index].n_blocks*cache[c_index].block_size;


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Record architecture of machine used to create cache </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)get_march(cache[c_index].march);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Map existing cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">char</span> my_march[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check that the architecture used   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> to create cache is compatible with </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> the one running calling process    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)get_march(my_march);
       <span class="Statement">if</span>(strcmp(my_march,cache[c_index].march) != <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;cache create] cache was created on </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">, but current architecture is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)&quot;</span>,cache[c_index].march,my_march);
           pups_error(errstr);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate contiguous memory for entire cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Map cache segment into process address space </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check for errors mapping cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((cache[c_index].cache_ptr = (<span class="Type">void</span> *)cache_mmap_cachememory(c_index,
                                                                  name,
                                                                  h_p_state,
                                                                  cache[c_index].n_blocks*cache[c_index].block_size,
                                                                                                               crc)) == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)

    {

        <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> If we are not returning CRC to caller </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> this is a fatal error                 </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(crc == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
           pups_error(<span class="Constant">&quot;[cache_create] failed to map cache into process address space&quot;</span>);


        <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Return CRC to caller </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

        <span class="Statement">else</span>
        {  pups_set_errno(<span class="Constant">EINVAL</span>);
           <span class="Statement">return</span>(-<span class="Constant">1</span>);
        }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate cache block pointer map </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].blockmap == (block_mtype *)<span class="Constant">NULL</span>)
       cache[c_index].blockmap = (block_mtype *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(block_mtype));


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Map object pointers within cache blocks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {  <span class="Type">int</span> j;

       <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;cache[c_index].n_objects; ++j)                                                          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
          cache[c_index].blockmap[i].object_ptr[j] = (<span class="Type">void</span> *)(cache[c_index].object_offset[j]          +  <span class="Comment">/*</span><span class="Comment"> Object offset within block </span><span class="Comment">*/</span>
                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)i*cache[c_index].block_size    +  <span class="Comment">/*</span><span class="Comment"> Block offset within cache  </span><span class="Comment">*/</span>
                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache[c_index].cache_ptr);        <span class="Comment">/*</span><span class="Comment"> Base address of cache      </span><span class="Comment">*/</span>
                                                                                                          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Sync cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_msync(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{
<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only sychronise cache if it public </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((cache[c_index].mmap &amp; CACHE_PRIVATE) == <span class="Constant">0</span>)
    {
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Synchronise cache with disk image   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> and block until operation completes </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)msync((<span class="Type">void</span> *)cache[c_index].cache_ptr,
                   cache[c_index].cache_size,
                   MS_SYNC | MS_INVALIDATE);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Make all file descriptors associated with cache live </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (i.e. homeostatic)                                   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_live(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span> h_p_level_1,
        h_p_level_2;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache destroy] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_destroy] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make cache live </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((h_p_level_1 = pups_fd_alive(cache[c_index].mmap_fd,   <span class="Constant">&quot;pups_default_fd_homeostat&quot;</span>,&amp;pups_default_fd_homeostat)) == (-<span class="Constant">1</span>))
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make mapinfo file live </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((h_p_level_2 = pups_fd_alive(cache[c_index].mapinfo_fd,<span class="Constant">&quot;pups_default_fd_homeostat&quot;</span>,&amp;pups_default_fd_homeostat)) == (-<span class="Constant">1</span>)  ||
        h_p_level_2 != h_p_level_1                                                                                               )
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(h_p_level_1);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Make all file descriptors associated with cache dead </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (i.e. non homeostatic)                               </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_dead(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span> h_p_level_1,
        h_p_level_2;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache destroy] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_destroy] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make cache dead  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((h_p_level_1 = pups_fd_dead(cache[c_index].mmap_fd)) == (-<span class="Constant">1</span>))
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make  mapinfo file dead </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((h_p_level_2 = pups_fd_dead(cache[c_index].mapinfo_fd)) == (-<span class="Constant">1</span>)  ||
        h_p_level_1 != h_p_level_2                                       )
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }



<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(h_p_level_1);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destroy cache (optionally deleting it) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_destroy(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> _BOOLEAN delete_cache, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache destroy] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_destroy] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free (mapped) cache memory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].cache_ptr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Unmap cache </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(munmap(cache[c_index].cache_ptr,cache[c_index].cache_size) == (-<span class="Constant">1</span>))
         pups_error(<span class="Constant">&quot;[cache_destroy] cannot unmap cache&quot;</span>);


       (<span class="Type">void</span>)strlcpy(cache[c_index].mapinfo_name,<span class="Constant">&quot;&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(cache[c_index].mmap_name,   <span class="Constant">&quot;&quot;</span>,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Release lock on (mapped) file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)flock(cache[c_index].mmap_fd,LOCK_UN);


       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Close descriptor to mapinfo file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_close(cache[c_index].mapinfo_fd);


       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Close descriptor to mapping file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_close(cache[c_index].mmap_fd);

       cache[c_index].mmap_fd = (-<span class="Constant">1</span>);
       cache[c_index].mmap    = <span class="Constant">0</span>;


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Delete cache if asked to do so </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(delete_cache == TRUE)
       {  (<span class="Type">void</span>)unlink(cache[c_index].mapinfo_name);
          (<span class="Type">void</span>)unlink(cache[c_index].mmap_name);
       }
    }

    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear cache datastructures and </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> free allocated memory          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cache[c_index].path,<span class="Constant">&quot;&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(cache[c_index].name,<span class="Constant">&quot;&quot;</span>,SSIZE);

    cache[c_index].u_blocks   = <span class="Constant">0</span>;
    cache[c_index].n_blocks   = <span class="Constant">0</span>;
    cache[c_index].n_objects  = <span class="Constant">0</span>;
    cache[c_index].block_size = <span class="Constant">0L</span>;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CACHE_BLOCK_OBJECTS; ++i)
    {  cache[c_index].object_size[i]   = <span class="Constant">0L</span>;
       cache[c_index].object_offset[i] = <span class="Constant">0L</span>;
    }


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free blockmap </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].blockmap != (block_mtype *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].blockmap);
       cache[c_index].blockmap = (block_mtype *)<span class="Constant">NULL</span>;
    }

    cache[c_index].cache_ptr  = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    cache[c_index].cache_size = <span class="Constant">0L</span>;


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free block flags </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].flags != (_BYTE *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].flags);
       cache[c_index].flags = (_BYTE *)<span class="Constant">NULL</span>;
    }


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free block tags </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].tag != (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].tag);
       cache[c_index].tag = (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>;
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free block lifetime </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].lifetime != (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].lifetime);
       cache[c_index].lifetime = (<span class="Type">int</span> *)<span class="Constant">NULL</span>;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free block hubness </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].hubness != (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].hubness);
       cache[c_index].hubness = (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free block binding </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].binding != (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].binding);
       cache[c_index].binding = (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>;
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free block access rwlocks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].rwlock != (pthread_rwlock_t *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cache[c_index].rwlock);
       cache[c_index].rwlock = (pthread_rwlock_t *)<span class="Constant">NULL</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Detach all caches </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> cache_exit(<span class="Type">void</span>)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Loop over all caches detaching those  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> which are in use. We don't care who   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> has the lock as we will be destroying </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the cache anyway                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CACHES; ++i)
    {  <span class="Statement">if</span>(cache[i].cache_ptr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cache_destroy(TRUE,FALSE,i);
    }
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Print bytes in appropriate units </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> print_bytes(<span class="Type">FILE</span>             *stream,  <span class="Comment">// Status/logging stream</span>
                         <span class="Type">const</span> <span class="Type">char</span>         *text,  <span class="Comment">// Test to be printed</span>
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> size)  <span class="Comment">// Number of bytes for formatted print</span>

{   <span class="Type">char</span>   eff_text[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">double</span> fsize;

    <span class="Statement">if</span>(text == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || strcmp(text,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
      (<span class="Type">void</span>)strlcpy(eff_text,<span class="Constant">&quot;size&quot;</span>,SSIZE);
    <span class="Statement">else</span>
      (<span class="Type">void</span>)strlcpy(eff_text,text,SSIZE);

    <span class="Statement">if</span>(size &gt; GIGABYTE)
    {  fsize = (<span class="Type">double</span>)size / (<span class="Type">double</span>)GIGABYTE;
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant">:  </span><span class="Special">%6.2f</span><span class="Constant"> Gigabytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,eff_text,fsize);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(size &gt; MEGABYTE)
    {  fsize = (<span class="Type">double</span>)size / (<span class="Type">double</span>)MEGABYTE;
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant">:  </span><span class="Special">%6.2f</span><span class="Constant"> Megabytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,eff_text,fsize);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(size &gt; KILOBYTE)
    {  fsize = (<span class="Type">double</span>)size / (<span class="Type">double</span>)KILOBYTE;
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant">:  </span><span class="Special">%6.2f</span><span class="Constant"> Kilobytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,eff_text,fsize);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant">:  </span><span class="Special">%6d</span><span class="Constant"> bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      eff_text,size);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display cache statistics </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_display_statistics(<span class="Type">const</span> _BOOLEAN   have_cache_lock,  <span class="Comment">// TRUE if lock held on cache</span>
                                     <span class="Type">FILE</span>                     *stream,  <span class="Comment">// Status/log stream </span>
                                     <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>       c_index)  <span class="Comment">// Cache index</span>

{   <span class="Type">int</span> i,
        used   = <span class="Constant">0</span>,
        tagged = <span class="Constant">0</span>;

    <span class="Type">char</span> blockstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_display_statistics] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_display_statistics] status/logging stream is not allocated&quot;</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_display_statistics] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Name of this cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Cache statistics</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                                       <span class="Constant">&quot;cache identifier&quot;</span>             ,c_index);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                                       <span class="Constant">&quot;cache co-ordination list size&quot;</span>,cache[c_index].colsize);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                                   <span class="Constant">&quot;cache 64 bit CRC&quot;</span>             ,cache[c_index].crc);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,                                   <span class="Constant">&quot;cache path&quot;</span>                   ,cache[c_index].path);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,                                   <span class="Constant">&quot;cache name&quot;</span>                   ,cache[c_index].name);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                           <span class="Constant">&quot;cache located at&quot;</span>             ,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache[c_index].cache_ptr);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                                       <span class="Constant">&quot;cache (machine) architecture&quot;</span> ,cache[c_index].march);

    <span class="Statement">if</span>(strcmp(cache[c_index].auxinfo,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                                       <span class="Constant">&quot;cache auxilliary data&quot;</span>,<span class="Constant">&quot;none&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,                                       <span class="Constant">&quot;cache auxilliary data&quot;</span>,cache[c_index].auxinfo);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Cache mapping information </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  memory mapped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Constant">&quot;cache type&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">\&quot;</span><span class="Special">%-.48s</span><span class="Constant">.map</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;cache mapinfo file&quot;</span>,cache[c_index].mapinfo_name);


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hidden mmap file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap_name[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
      (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">\&quot;</span><span class="Special">%-.48s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,   <span class="Constant">&quot;cache mmap file&quot;</span>, &amp;cache[c_index].mmap_name[<span class="Constant">1</span>]);


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Visible mmap file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
      (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">\&quot;</span><span class="Special">%-.48s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,   <span class="Constant">&quot;cache mmap file&quot;</span>, cache[c_index].mmap_name);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Cache pages preloaded into memory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to reduce page faults             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_POPULATE)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,              <span class="Constant">&quot;cache preloading&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  disabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,             <span class="Constant">&quot;cache preloading&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Cache mapped privately - this is used </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> when cache is readonly                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PRIVATE)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  private (read only)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,  <span class="Constant">&quot;cache access&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  public  (read/write)</span><span class="Special">\n</span><span class="Constant">&quot;</span>, <span class="Constant">&quot;cache access&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sizes of cache and block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Cache geometry</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ==============</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-32s</span><span class="Constant">:  </span><span class="Special">%d</span><span class="Constant"> blocks of </span><span class="Special">%d</span><span class="Constant"> objects (</span><span class="Special">%d</span><span class="Constant"> used)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Constant">&quot;cache format&quot;</span>,cache[c_index].n_blocks,cache[c_index].n_objects,cache[c_index].u_blocks);
    (<span class="Type">void</span>)print_bytes(stream,<span class="Constant">&quot;cache size                      &quot;</span>,            cache[c_index].cache_size);
    (<span class="Type">void</span>)print_bytes(stream,<span class="Constant">&quot;block size                      &quot;</span>,            cache[c_index].block_size);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Object sizes and offsets within cache block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Block geometry</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ==============</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block object sizes and offsets </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {  <span class="Type">char</span> objectstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Object details </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    object [</span><span class="Special">%04d</span><span class="Constant">] </span><span class="Special">%s</span><span class="Constant">       :  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,<span class="Constant">&quot;description&quot;</span>,cache[c_index].object_desc[i]);

       (<span class="Type">void</span>)snprintf(objectstr,SSIZE,<span class="Constant">&quot;object [</span><span class="Special">%04d</span><span class="Constant">] size              &quot;</span>,i);
       (<span class="Type">void</span>)print_bytes(stream,objectstr,   cache[c_index].object_size[i]);

       (<span class="Type">void</span>)snprintf(objectstr,SSIZE,<span class="Constant">&quot;object [</span><span class="Special">%04d</span><span class="Constant">] block offset      &quot;</span>,i);
       (<span class="Type">void</span>)print_bytes(stream,objectstr,cache[c_index].object_offset[i]);

       <span class="Statement">if</span>(i &lt; cache[c_index].n_objects - <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(stream);
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Objects allocated within cache block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].n_objects == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    no objects allocated</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(cache[c_index].n_objects == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> object in cache block</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> objects in cache block</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,cache[c_index].n_objects);
    }
    (<span class="Type">void</span>)fflush(stream);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display cache table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_display(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        mapped_caches    = <span class="Constant">0</span>;

    <span class="Type">char</span> mapoptstr[SSIZE]  = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_display] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_display] status/logging stream is not allocated&quot;</span>);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Mapped data caches</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ==================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CACHES; ++i)
    {  <span class="Type">double</span> fsize;
       <span class="Type">char</span>   unitstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[i].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(cache[i].name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
       {  ++mapped_caches;


          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Get cache size in most appropriate units </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Gigabytes </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(cache[i].cache_size &gt; GIGABYTE)
          {  fsize = (<span class="Type">double</span>)cache[i].cache_size / (<span class="Type">double</span>)GIGABYTE;
             (<span class="Type">void</span>)strlcpy(unitstr,<span class="Constant">&quot;Gbytes&quot;</span>,SSIZE);
          }

          <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Megabytes </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

          <span class="Statement">else</span> <span class="Statement">if</span>(cache[i].cache_size &gt; MEGABYTE)
          {  fsize = (<span class="Type">double</span>)cache[i].cache_size / (<span class="Type">double</span>)MEGABYTE;
             (<span class="Type">void</span>)strlcpy(unitstr,<span class="Constant">&quot;Mbytes&quot;</span>,SSIZE);
          }


          <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Kilobytes </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

          <span class="Statement">else</span> <span class="Statement">if</span>(cache[i].cache_size &gt; KILOBYTE)
          {  fsize = (<span class="Type">double</span>)cache[i].cache_size / (<span class="Type">double</span>)KILOBYTE;
             (<span class="Type">void</span>)strlcpy(unitstr,<span class="Constant">&quot;Kbytes&quot;</span>,SSIZE);
          }

          <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Bytes </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  fsize = (<span class="Type">double</span>)cache[i].cache_size;
             (<span class="Type">void</span>)strlcpy(unitstr,<span class="Constant">&quot; Bytes&quot;</span>,SSIZE);
          }


          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Get cache mapping options </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(cache[i].mmap &amp; CACHE_PRIVATE)
          {

              <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Cache private (read only) and preloaded </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(cache[i].mmap &amp; CACHE_POPULATE)
                 (<span class="Type">void</span>)strlcpy(mapoptstr,<span class="Constant">&quot;[private, preload]&quot;</span>,SSIZE);


              <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Cache private, no preloading </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">else</span>
                 (<span class="Type">void</span>)strlcpy(mapoptstr,<span class="Constant">&quot;[private]&quot;</span>,SSIZE);
          }


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Cache public (read/write) and preloaded </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span> <span class="Statement">if</span>(cache[i].mmap &amp; CACHE_POPULATE)
                 (<span class="Type">void</span>)strlcpy(mapoptstr,<span class="Constant">&quot;[public, preload]&quot;</span>,SSIZE);


          <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Cache public </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
                 (<span class="Type">void</span>)strlcpy(mapoptstr,<span class="Constant">&quot;[public]&quot;</span>,SSIZE);



          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Gbytes, Mbytes or Kbytes - use fractional units </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strcmp(unitstr,<span class="Constant">&quot; Bytes&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: (</span><span class="Special">\&quot;</span><span class="Special">%-24s</span><span class="Special">\&quot;</span><span class="Constant"> path </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant">): </span><span class="Special">%08d</span><span class="Constant"> blocks, </span><span class="Special">%7.3f</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> mapped into process address space (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                                         i,
                                                                                                                                             cache[i].name,
                                                                                                                                             cache[i].path,
                                                                                                                                         cache[i].n_blocks,
                                                                                                                                                     fsize,
                                                                                                                                                   unitstr,
                                                                                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache[i].cache_ptr,
                                                                                                                                                 mapoptstr);

          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Bytes - use integer units </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: (</span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> path </span><span class="Special">\&quot;</span><span class="Special">%-24s</span><span class="Special">\&quot;</span><span class="Constant">): </span><span class="Special">%04d</span><span class="Constant"> blocks, </span><span class="Special">%04d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> mapped into process address space (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                                        i,
                                                                                                                                            cache[i].name,
                                                                                                                                            cache[i].path,
                                                                                                                                        cache[i].n_blocks,
                                                                                                                                      cache[i].cache_size,
                                                                                                                                                  unitstr,
                                                                                                                    (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache[i].cache_ptr,
                                                                                                                                                mapoptstr);
          (<span class="Type">void</span>)fflush(stream);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[i].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
    }

    <span class="Statement">if</span>(mapped_caches == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    none (</span><span class="Special">%d</span><span class="Constant"> caches available)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_CACHES);
    <span class="Statement">else</span> <span class="Statement">if</span>(mapped_caches == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> cache mapped (</span><span class="Special">%d</span><span class="Constant"> caches available)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,
                                                                     MAX_CACHES - <span class="Constant">1</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> cache mapped (</span><span class="Special">%d</span><span class="Constant"> caches available)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                         mapped_caches,MAX_CACHES - mapped_caches);
    (<span class="Type">void</span>)fflush(stream);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return size of object within block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_object_size(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// TRUE if lock held on cache</span>
                              <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index,  <span class="Comment">// Block index (within cache) </span>
                              <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>    object_index,  <span class="Comment">// Object index (within block)</span>
                              <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index)  <span class="Comment">// Cache index </span>

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> object_size;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;cache_object_size] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_object_size] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index  &gt; cache[c_index].n_blocks    ||
       object_index &gt; cache[c_index].n_objects    )
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_object_size] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_objects);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_rwlock_rdlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    object_size = cache[c_index].object_size[object_index];


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_rwlock_unlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(object_size);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return (read only) pointer to object within block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">const</span> <span class="Type">void</span> *cache_access_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> cache_lock_state,  <span class="Comment">// State of cache lock</span>
                                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> block_locktype,    <span class="Comment">// Type of lock on accessed object (RDLOCK or WRLOCK)</span>
                                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> block_index,       <span class="Comment">// Block index of access object </span>
                                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> object_index,      <span class="Comment">// Object index of accessed object</span>
                                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)           <span class="Comment">// Cache index of accessed object</span>

{   <span class="Type">void</span> *object_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_access_object] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(cache_lock_state != CACHE_LOCK &amp;&amp; cache_lock_state != CACHE_HAVELOCK)
        pups_error(<span class="Constant">&quot;[cache_access_object] expecting cache lock state </span><span class="Special">\&quot;</span><span class="Constant">CACHE_LOCK</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">CACHE_HAVELOCK</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(block_locktype != BLOCK_WRLOCK &amp;&amp; block_locktype != BLOCK_RDLOCK &amp;&amp; block_locktype != BLOCK_HAVELOCK)
        pups_error(<span class="Constant">&quot;[cache_access_object] expecting lock type </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_RDLOCK</span><span class="Special">\&quot;</span><span class="Constant">, </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_WRLOCK</span><span class="Special">\&quot;</span><span class="Constant">, or </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_HAVELOCK</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(cache_lock_state == CACHE_LOCK)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index  &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_access_object] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Object index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(object_index &gt;= cache[c_index].n_objects)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_access_object] object index range error [object index (</span><span class="Special">%d</span><span class="Constant">) &gt; max objects (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,object_index,cache[c_index].n_objects);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Writelock on object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_locktype == BLOCK_WRLOCK)
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_rwlock_wrlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Readlock on object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(block_locktype == BLOCK_RDLOCK)
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_rwlock_rdlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
    }


    object_ptr = cache[c_index].blockmap[block_index].object_ptr[object_index];


<span class="PreProc">    #ifdef CACHELIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PTR </span><span class="Special">%016lx</span><span class="Constant"> CBLOCK </span><span class="Special">%04d</span><span class="Constant"> OBJECT </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)object_ptr,block_index,object_index);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CACHELIB_DEBUG </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(object_ptr);
}




<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Map 2D array to object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> **cache_map_2D_array(<span class="Type">const</span> <span class="Type">void</span>         *object_ptr,  <span class="Comment">// Pointer to cached object</span>
                                  <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>        rows,  <span class="Comment">// Number of rows in (2D) object matrix</span>
                                  <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>        cols,  <span class="Comment">// Number of cols in (2D) object matrix</span>
                                  <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span>   <span class="Type">int</span> size)  <span class="Comment">// Size of object</span>

{   <span class="Type">int</span>  i;
    <span class="Type">void</span> **array_ptr = (<span class="Type">void</span> **)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       error(<span class="Constant">&quot;[cache_map_2D_array] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(object_ptr == (<span class="Type">const</span> <span class="Type">void</span> *) <span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_map_2D_array] object pointer NULL&quot;</span>);

    array_ptr = (<span class="Type">void</span> **)pups_calloc(rows,<span class="Statement">sizeof</span>(<span class="Type">void</span> *));

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;rows; ++i)
       array_ptr[i] = (<span class="Type">void</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)object_ptr + (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)(i*cols)*size);

    pups_set_errno(OK);
    <span class="Statement">return</span>(array_ptr);
}



<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Write contents of cache to file </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_write(<span class="Type">const</span> <span class="Type">int</span>                         fd,  <span class="Comment">// File descriptor to write to</span>
                        <span class="Type">const</span> _BOOLEAN       have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>           c_index)  <span class="Comment">// Index of cache to be written</span>

{   <span class="Type">int</span>  eff_fd;
    <span class="Type">char</span> eff_wcache_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache write] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_write] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Use specified file descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(fd != (-<span class="Constant">1</span>))
       eff_fd = fd;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Use cache specified file descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       eff_fd = cache[c_index].mmap_fd;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Write (mapped) cache back         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> making sue EINTR is taken care of </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_lseek(eff_fd,<span class="Constant">SEEK_SET</span>,<span class="Constant">0</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure the full file is written </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and that EINTR is taken care of    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_write(eff_fd,cache[c_index].cache_ptr,cache[c_index].cache_size);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get the size of a cached object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> cache_get_object_size(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index</span>
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         o_index)  <span class="Comment">// Object for which size is required</span>

{   <span class="Type">long</span> <span class="Type">int</span> size;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_object_size] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Object index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(o_index &gt;= cache[c_index].n_objects)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_object_size] object index range error [object index (</span><span class="Special">%d</span><span class="Constant">) &gt; max objects (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,o_index,cache[c_index].n_objects);
       pups_error(errstr);
    }
    <span class="Statement">else</span>
       size = (<span class="Type">long</span> <span class="Type">int</span>)cache[c_index].object_size[o_index];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(size);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get the size of a cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> cache_get_block_size(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span>      i;
    <span class="Type">long</span> <span class="Type">int</span> size = <span class="Constant">0L</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_block_size] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
       size += (<span class="Type">long</span> <span class="Type">int</span>)cache[c_index].object_size[i];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(size);
}




<span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Taglist </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

_PRIVATE taglist_type taglist[MAX_TAGLIST_SIZE];

<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Initialise taglist </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> taglist_init(<span class="Type">void</span>)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_TAGLIST_SIZE; ++i)
    {  taglist[i].tag           = (-<span class="Constant">1</span>);
       taglist[i].tagged_blocks = <span class="Constant">0</span>;
    }
}


<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add entry to taglist </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> update_taglist(<span class="Type">const</span> <span class="Type">int</span> tag)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_TAGLIST_SIZE; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tag found so increment (tagged block) counter </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> and return to caller                          </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(taglist[i].tag == tag)
       {  ++taglist[i].tagged_blocks;

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Failed to find tag so add it to list </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(taglist[i].tag == (-<span class="Constant">1</span>))
          <span class="Statement">break</span>;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No room at the Inn </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(i == MAX_TAGLIST_SIZE)
       pups_error(<span class="Constant">&quot;[update_taglist] too many tags in list&quot;</span>);

    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get statistics for all tags in specified cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_show_blocktag_stats(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">int</span> c_index)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i,
                 tags          = <span class="Constant">0</span>,
                 tagged_blocks = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_show_blocktag_stats] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_show_blocktag_stats] status/log stream not specified&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initilise taglist </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    taglist_init();


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search specified cache for matching tags </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_rwlock_rdlock(&amp;cache[c_index].rwlock[i]);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].flags[i] &amp; BLOCK_USED)
          (<span class="Type">void</span>)update_taglist(cache[c_index].tag[i]);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_rwlock_unlock(&amp;cache[c_index].rwlock[i]);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Report tag statistics for specified cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_TAGLIST_SIZE; ++i)
    {
       <span class="Statement">if</span>(taglist[i].tag &gt;= <span class="Constant">0</span>)
       {
          <span class="Statement">if</span>(tags == <span class="Constant">0</span>)
          {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(stream);
          }

          <span class="Statement">if</span>(taglist[i].tag == SCRATCH_TAG)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    tag scratch: </span><span class="Special">%06d</span><span class="Constant"> tagged blocks</span><span class="Special">\n</span><span class="Constant">&quot;</span>,taglist[i].tag,taglist[i].tagged_blocks);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    tag    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">%06d</span><span class="Constant"> tagged blocks</span><span class="Special">\n</span><span class="Constant">&quot;</span>,taglist[i].tag,taglist[i].tagged_blocks);

          (<span class="Type">void</span>)fflush(stream);
          ++tags;
       }
    }

    <span class="Statement">if</span>(tags &gt; <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    </span><span class="Special">%d</span><span class="Constant"> tag(s) [cache </span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tags,c_index);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    no tags [cache </span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tags,c_index);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get number of blocks in cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> cache_get_blocks(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span> cache_blocks;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blocks] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache_blocks = cache[c_index].n_blocks;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(cache_blocks);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get number of objects per block in cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> cache_get_objects(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span> block_objects;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_objects] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    block_objects = cache[c_index].n_objects;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(block_objects);
}




<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get cache path </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_index2path(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                             <span class="Type">char</span>                   *cache_path,  <span class="Comment">// Path to cache</span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index)  <span class="Comment">// Index of cache</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_path == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_index2name] cache path is NULL&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cache_path,cache[c_index].path,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cache_path,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get cache name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_index2name(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                             <span class="Type">char</span>                   *cache_name,  <span class="Comment">// Name of cache</span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index)  <span class="Comment">// Index of cache</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_index2name] cache name is NULL&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cache_name,cache[c_index].name,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cache_name,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get mapinfo file name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_get_mapinfo_name(<span class="Type">const</span> _BOOLEAN         have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                   <span class="Type">char</span>               *cache_mapinfo_name,  <span class="Comment">// Name of cache mapping information file</span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>             c_index)  <span class="Comment">// Index of cache</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_mapinfo_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_index2name] expecting mapinfo file name&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cache_mapinfo_name,cache[c_index].mapinfo_name,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cache_mapinfo_name,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get map file name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_get_mmap_name(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                <span class="Type">char</span>               *cache_mmap_name,  <span class="Comment">// Name of cache mapping file</span>
                                <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index)  <span class="Comment">// Index of cache</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_mmap_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_index2name] expecting map file name&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cache_mmap_name,cache[c_index].mmap_name,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cache_mmap_name,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache memory mapped? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_is_mapped(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   _BOOLEAN mapped;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_mapped] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    mapped = cache[c_index].mmap;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(mapped);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache mapped at specified location (in file system)? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_is_mapped_at(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">char</span> *cache_pathname, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   _BOOLEAN mapped = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_mapped] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cache[c_index].mmap_name,cache_pathname) == <span class="Constant">0</span>)
       mapped = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(mapped);
}




<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache (already) loaded? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_already_loaded(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">char</span> *cache_name, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index, <span class="Type">unsigned</span> <span class="Type">int</span> *c_l_index)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;
    _BOOLEAN     ret = FALSE;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_loaded] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(cache_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_is_loaded] expecting cache name</span><span class="Special">\n</span><span class="Constant">&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search cache table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CACHES; ++i)
    {  <span class="Statement">if</span>(strcmp(cache[i].name,cache_name) == <span class="Constant">0</span>)
       {  ret = TRUE;

          <span class="Statement">if</span>(c_l_index != (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
             *c_l_index = i;

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">break</span>;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache allocated? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *cache_is_allocated(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">void</span> *cache_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_allocated] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache_ptr = cache[c_index].cache_ptr;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(cache_ptr);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Write cache mapping information </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> cache_write_mapinfo(<span class="Type">const</span> _BOOLEAN     try_homeostatic_protection,  <span class="Comment">// Try homeostatic mapfile protection if TRUE</span>
                                              <span class="Type">const</span> _BOOLEAN                have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                              <span class="Type">const</span> <span class="Type">char</span>                          *map_name,  <span class="Comment">// Name of file containing cache mapping info</span>
                                              <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>                       mmap,  <span class="Comment">// Memroy mapping flags</span>
                                              <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>                    c_index)  <span class="Comment">// Index of cached to be mapped</span>

{   <span class="Type">int</span> i,
        h_p_state                = DEAD,
        fd                       = (-<span class="Constant">1</span>);

    <span class="Type">char</span> map_path[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         map_pathname[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         cache_pathname[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         eff_cache_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         eff_mapfile_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN is_live             = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_write_mapinfo] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(map_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_write_mapinfo] expecting mapinfo file name&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get map file path and leaf names </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(map_name,<span class="Constant">&quot;/&quot;</span>) == TRUE)
    {  (<span class="Type">void</span>)strleaf(map_name,eff_mapfile_name);
       (<span class="Type">void</span>)strlcpy (map_path,map_name,SSIZE);
       (<span class="Type">void</span>)strtrnc(map_path,<span class="Constant">'/'</span>,<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No path - just a leaf (in current directory) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(eff_mapfile_name,map_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate map file name from basename </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strtrnc(eff_mapfile_name,<span class="Constant">'.'</span>,<span class="Constant">1</span>);
    (<span class="Type">void</span>)strlcpy (eff_cache_name,eff_mapfile_name,SSIZE);
    (<span class="Type">void</span>)strlcat (eff_mapfile_name,<span class="Constant">&quot;.map&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate map file pathname </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Absolute or relative path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(map_name,<span class="Constant">&quot;/&quot;</span>) == TRUE)
    {  (<span class="Type">void</span>)snprintf(map_pathname,SSIZE,  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,map_path,eff_mapfile_name);
       (<span class="Type">void</span>)snprintf(cache_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,map_path,eff_cache_name);
    }


    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)strlcpy(map_pathname,  eff_mapfile_name,SSIZE);
       (<span class="Type">void</span>)strlcpy(cache_pathname,eff_cache_name,SSIZE);
    }

    <span class="Statement">if</span>(access(map_pathname,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(pups_creat(map_pathname,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
          pups_error(<span class="Constant">&quot;[cache_write_mapinfo] cannot create mapinfo file&quot;</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only apply homeostatic protection if we </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> have not previously read map file       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(mmap &amp; CACHE_LIVE)
       h_p_state = LIVE;

    <span class="Statement">if</span>(strcmp(cache[c_index].mmap_name,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Homeostatic map file protection </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(try_homeostatic_protection == TRUE)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Is file already protected? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pups_isalive(map_pathname) == FALSE)
          {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_WRONLY,h_p_state)) == (-<span class="Constant">1</span>))
                pups_error(<span class="Constant">&quot;[cache_write_mapinfo] cannot open mapinfo file&quot;</span>);

             is_live = TRUE;
          }


          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If it is don't protect it more than once </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_WRONLY,DEAD)) == (-<span class="Constant">1</span>))
                pups_error(<span class="Constant">&quot;[cache_write_mapinfo] cannot open mapinfo file&quot;</span>);
          }
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> No homeostatic map file protection </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_WRONLY,DEAD)) == (-<span class="Constant">1</span>))
              pups_error(<span class="Constant">&quot;[cache_write_mapinfo] cannot open mapinfo file&quot;</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Homeostatic map file protection was decided </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> when map file was initially read            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_WRONLY,DEAD)) == (-<span class="Constant">1</span>))
          pups_error(<span class="Constant">&quot;[cache_write_mapinfo] cannot open mapinfo file&quot;</span>);
    }

    <span class="Comment">// Cache CRC</span>
    cache[c_index].crc = pups_crc_64(cache[c_index].cache_size,cache[c_index].cache_ptr);
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].crc,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache path</span>
    <span class="Statement">if</span>(pups_write(fd,map_path,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache name</span>
    <span class="Statement">if</span>(pups_write(fd,eff_cache_name,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache mapinfo file name</span>
    <span class="Statement">if</span>(pups_write(fd,map_pathname,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache mapfile name</span>
    <span class="Statement">if</span>(pups_write(fd,eff_mapfile_name,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Architecture of machine used to generate cache</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)cache[c_index].march,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Auxilliary data</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)cache[c_index].auxinfo,SSIZE) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }


    <span class="Comment">// Memory mapping flags  </span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].mmap,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Number of used blocks in cache</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].u_blocks,<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Number of blocks in cache</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].n_blocks,<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Number of objects per block</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].n_objects,<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache size (bytes)</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].cache_size,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Block size (bytes)</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].block_size,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Co-ordination lsit size</span>
    <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].colsize,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Write object descriptions</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {  <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].object_desc[i],<span class="Constant">256</span>*<span class="Statement">sizeof</span>(_BYTE)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write offsets of objects in cache blocks (bytes)</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].object_offset[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write sizes of objects in cache blocks (bytes)</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].object_size[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write cache block flags</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].flags[i],<span class="Statement">sizeof</span>(_BYTE)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write cache tags</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].tag[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write cache lifetimes </span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].lifetime[i],<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write cache hubnesses </span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].hubness[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Write cache binding</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_write(fd,(<span class="Type">void</span> *)&amp;cache[c_index].binding[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }


    <span class="Statement">if</span>(is_live == FALSE)
       (<span class="Type">void</span>)pups_close(fd);
    <span class="Statement">else</span>
       cache[c_index].mapinfo_fd = fd;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(cache[c_index].crc);

<span class="Statement">error_exit</span>:

    pups_error(<span class="Constant">&quot;[cache_write_mapinfo] write failed&quot;</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Compress cache and map file into </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> tar/xz archive                   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_archive(<span class="Type">const</span> _BOOLEAN    compress,  <span class="Comment">// Compress archive file if TRUE</span>
                          <span class="Type">const</span> _BOOLEAN      delete,  <span class="Comment">// Delete .mmc and .map files when archived</span>
                          <span class="Type">const</span> <span class="Type">char</span>     *cache_name)  <span class="Comment">// Basename of ,mmc and .map file to archive</span>

{   <span class="Type">int</span> ret;

    <span class="Type">char</span> tar_cmd[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         basename[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         mapname[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         cachename[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_archive] expecting cache name&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get cache archive basename </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(cache_name,<span class="Constant">&quot;.&quot;</span>) == TRUE)
    {  (<span class="Type">void</span>)strlcpy(basename,cache_name,SSIZE);
       (<span class="Type">void</span>)strtrnc(basename,<span class="Constant">'.'</span>,<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(mapname  ,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.map&quot;</span>,basename);
    (<span class="Type">void</span>)snprintf(cachename,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.mmc&quot;</span>,basename);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we have a map file and </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> corresponding cache               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(mapname,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       pups_error(<span class="Constant">&quot;[cache_archive] cannot access mapinfo file&quot;</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(access(cachename,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       pups_error(<span class="Constant">&quot;[cache_archive] cannot access cache file&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Run tar and xz commands to produced </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> compressed cache archive            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(compress == TRUE)
          (<span class="Type">void</span>)snprintf(tar_cmd,SSIZE,<span class="Constant">&quot;tar cvf - </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> 2&gt; /dev/null | xz &gt; </span><span class="Special">%s</span><span class="Constant">.tar.gz&quot;</span>,mapname,cachename,basename);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(tar_cmd,SSIZE,<span class="Constant">&quot;tar cvf - </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> 1&gt; </span><span class="Special">%s</span><span class="Constant">.tar 2&gt; /dev/null&quot;</span>,mapname,cachename,basename);

       ret = system(tar_cmd);

       <span class="Statement">if</span>(WEXITSTATUS(ret) &lt; <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[cache_archive] failed to run archive command&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remove files once we have archived them </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(delete == TRUE)
       {  (<span class="Type">void</span>)unlink(mapname);
          (<span class="Type">void</span>)unlink(cachename);
       }
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Uncompress cache archive </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_extract(<span class="Type">const</span> <span class="Type">char</span> *cache_archive)

{   <span class="Type">int</span> ret;

    <span class="Type">char</span> tar_cmd[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         basename[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
         eff_cache_archive[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache_archive == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_extract] expecting archive name&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up extraction command taking note of </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> archive file type                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Fully qualified compressed tar achive </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(cache_archive,<span class="Constant">&quot;.tar.xz&quot;</span>) == TRUE)
    {  <span class="Statement">if</span>(access(cache_archive,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
          pups_error(<span class="Constant">&quot;[cache_extract] cannot open archive file&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(tar_cmd,SSIZE,<span class="Constant">&quot;xz -d &lt;</span><span class="Special">%s</span><span class="Constant">.tar.xz | tar xvf - &gt; /dev/null&quot;</span>,cache_archive);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Fully qualified tar archive </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(strin(cache_archive,<span class="Constant">&quot;.tar&quot;</span>) == TRUE)
    {  <span class="Statement">if</span>(access(cache_archive,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
          pups_error(<span class="Constant">&quot;[cache_extract] cannot open archive file&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(tar_cmd,SSIZE,<span class="Constant">&quot;cat </span><span class="Special">%s</span><span class="Constant">.tar | tar xvf - &gt; /dev/null&quot;</span>,cache_archive);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> .map file or .mmc file - strip prefix </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strin(cache_archive,<span class="Constant">&quot;.map&quot;</span>) == TRUE || strin(cache_archive,<span class="Constant">&quot;.mmc&quot;</span>) == TRUE)
       {  (<span class="Type">void</span>)strlcpy(basename,cache_archive,SSIZE);
          (<span class="Type">void</span>)strtrnc(basename,<span class="Constant">'.'</span>,<span class="Constant">1</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(strin(cache_archive,<span class="Constant">&quot;.&quot;</span>) == TRUE)
          pups_error(<span class="Constant">&quot;[cache_extract] invalid archive file name&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(basename,cache_archive,SSIZE);

       (<span class="Type">void</span>)snprintf(eff_cache_archive,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.tar&quot;</span>,basename);


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Implicit tar archive </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(access(eff_cache_archive,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
          (<span class="Type">void</span>)snprintf(tar_cmd,SSIZE,<span class="Constant">&quot;cat </span><span class="Special">%s</span><span class="Constant"> | tar xvf - &gt; /dev/null&quot;</span>,eff_cache_archive);


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Implicit compressed tar archive </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)snprintf(eff_cache_archive,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.tar.xz&quot;</span>,cache_archive);
          <span class="Statement">if</span>(access(eff_cache_archive,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
             (<span class="Type">void</span>)snprintf(tar_cmd,SSIZE,<span class="Constant">&quot;xz -d &lt;</span><span class="Special">%s</span><span class="Constant"> | tar xvf - &gt; /dev/null&quot;</span>,eff_cache_archive);
          <span class="Statement">else</span>
             pups_error(<span class="Constant">&quot;[cache_extract] invalid archive file name&quot;</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extract cache and associated map file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    ret = system(tar_cmd);
    <span class="Statement">if</span>(WEXITSTATUS(ret) &lt; <span class="Constant">0</span>)
       pups_error(<span class="Constant">&quot;[cache_archive] failed to run archive command&quot;</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Read cache mapping information </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> cache_read_mapinfo(<span class="Type">const</span> _BOOLEAN     try_homeostatic_protection,  <span class="Comment">// If TRUE enable homeostatic protection for map file</span>
                                             <span class="Type">const</span> _BOOLEAN                have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                             <span class="Type">const</span> <span class="Type">char</span>                          *map_name,  <span class="Comment">// Name of cache map info file</span>
                                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>                       mmap,  <span class="Comment">// Memory mapping flags</span>
                                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>                    c_index)  <span class="Comment">// Cache index (to map cache into)</span>

{   <span class="Type">int</span> i,
        h_p_state            = DEAD,
        fd                   = (-<span class="Constant">1</span>);

    <span class="Type">char</span> map_path[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         map_pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         eff_map_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN is_live = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cache_read_mapinfo] attempt by non root thread to perform PUPS/P3 memory mapped cache operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_read_mapinfo] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Mapping file not found </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(map_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_read_mapinfo] expecting mapinfo file name&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get map file path and leaf names </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(map_name,<span class="Constant">&quot;/&quot;</span>) == TRUE)
    {  (<span class="Type">void</span>)strleaf(map_name,eff_map_name);
       (<span class="Type">void</span>)strlcpy (map_path,map_name,SSIZE);
       (<span class="Type">void</span>)strtrnc(map_path,<span class="Constant">'/'</span>,<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No path - just a leaf (in current directory) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(eff_map_name,map_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate map file name from basename </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strtrnc(eff_map_name,<span class="Constant">'.'</span>,<span class="Constant">1</span>);
    (<span class="Type">void</span>)strlcat (eff_map_name,<span class="Constant">&quot;.map&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate map file pathname </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Absolute or relative path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(map_name,<span class="Constant">&quot;/&quot;</span>) == TRUE)
       (<span class="Type">void</span>)snprintf(map_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,map_path,eff_map_name);


    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(map_pathname,eff_map_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Try to protect file if requested to do so </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(mmap &amp; CACHE_LIVE)
       h_p_state = LIVE;

    <span class="Statement">if</span>(try_homeostatic_protection == TRUE)
    {  <span class="Statement">if</span>(pups_isalive(map_pathname) == FALSE)
       {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_RDONLY,h_p_state)) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[cache_read_mapinfo] failed to open mapinfo file&quot;</span>);

          is_live = TRUE;
       }


       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Don't protect file more than once </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_RDONLY,DEAD)) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[cache_read_mapinfo] failed to open mapinfo file&quot;</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No homeostatic map file protection </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((fd = pups_open(map_pathname,O_RDONLY,DEAD)) == (-<span class="Constant">1</span>))
          pups_error(<span class="Constant">&quot;[cache_read_mapinfo] failed to open mapinfo file&quot;</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">// Cache CRC</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].crc,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache path </span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)cache[c_index].path,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache name</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)cache[c_index].name,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache mapinfo file name</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)cache[c_index].mapinfo_name,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache mapfile name</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)cache[c_index].mmap_name,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Architecture of machine used to generate cache</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)cache[c_index].march,<span class="Constant">256</span>) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Auxilliary information </span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)cache[c_index].auxinfo,SSIZE) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Cache mapping flags</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].mmap,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Number of used blocks in cache</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].u_blocks,<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Number of blocks in cache</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].n_blocks,<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Number of objects per block</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].n_objects,<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Size of cache (bytes)</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].cache_size,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Size of cache block (bytes)</span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].block_size,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Co-ordination list size </span>
    <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].colsize,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_close(fd);
       <span class="Statement">goto</span> error_exit;
    }

    <span class="Comment">// Read descriptions of objects in cache blocks</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].object_desc[i],<span class="Constant">256</span>*<span class="Statement">sizeof</span>(_BYTE)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Read offsets of objects in cache blocks (bytes)</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].object_offset[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Read sizes of objects in cache blocks (bytes)</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_objects; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].object_size[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Allocate space for cache block flags</span>
    <span class="Statement">if</span>(cache[c_index].flags == (_BYTE *)<span class="Constant">NULL</span>)
       cache[c_index].flags = (_BYTE *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(_BYTE));

    <span class="Comment">// Read cache block flags</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].flags[i],<span class="Statement">sizeof</span>(_BYTE)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Allocate space for cache block tags</span>
    <span class="Statement">if</span>(cache[c_index].tag == (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
       cache[c_index].tag = (<span class="Type">unsigned</span> <span class="Type">int</span> *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));

    <span class="Comment">// Read cache block tags</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].tag[i],<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Allocate space for cache block lifetimes</span>
    <span class="Statement">if</span>(cache[c_index].lifetime == (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
       cache[c_index].lifetime = (<span class="Type">int</span> *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(<span class="Type">int</span>));

    <span class="Comment">// Read cache block lifetimes </span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].lifetime[i],<span class="Statement">sizeof</span>(<span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Allocate space for cache block hubnesses </span>
    <span class="Statement">if</span>(cache[c_index].hubness == (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
       cache[c_index].hubness = (<span class="Type">unsigned</span> <span class="Type">int</span> *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));

    <span class="Comment">// Read cache block hubnesses </span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].hubness[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Allocate space for cache block binding </span>
    <span class="Statement">if</span>(cache[c_index].binding == (<span class="Type">unsigned</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
       cache[c_index].binding = (<span class="Type">unsigned</span> <span class="Type">int</span> *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));

    <span class="Comment">// Read cache block bindings </span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {   <span class="Statement">if</span>(pups_read(fd,(<span class="Type">void</span> *)&amp;cache[c_index].binding[i],<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>)) == (-<span class="Constant">1</span>))
        {  (<span class="Type">void</span>)pups_close(fd);
           <span class="Statement">goto</span> error_exit;
        }
    }

    <span class="Comment">// Allocate space for rwlocks</span>
    <span class="Statement">if</span>(cache[c_index].rwlock == (pthread_rwlock_t *)<span class="Constant">NULL</span>)
    <span class="Comment">// Allocate space for rwlocks</span>
    <span class="Statement">if</span>(cache[c_index].rwlock == (pthread_rwlock_t *)<span class="Constant">NULL</span>)
       cache[c_index].rwlock = (pthread_rwlock_t *)pups_calloc(cache[c_index].n_blocks,<span class="Statement">sizeof</span>(pthread_rwlock_t));

    <span class="Comment">// Initialise rwlocks</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
        (<span class="Type">void</span>)pthread_rwlock_init(&amp;cache[c_index].rwlock[i],(pthread_rwlockattr_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Keep file descriptor open if we want        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PUPS/P3 homeostatic protection for map file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(is_live == FALSE)
       (<span class="Type">void</span>)pups_close(fd);
    <span class="Statement">else</span>
       cache[c_index].mapinfo_fd = fd;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(cache[c_index].crc);

<span class="Statement">error_exit</span>:

    pups_error(<span class="Constant">&quot;[cache_read_mapinfo] read failed&quot;</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Reset all block (read/write) locks in cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_reset_blocklocks(<span class="Type">const</span> _BOOLEAN have_cache_lock,  <span class="Comment">// TRUE if lock held on specified cache </span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     c_index)  <span class="Comment">// Cache index</span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_unlock_block] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset block locks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
        (<span class="Type">void</span>)pthread_rwlock_init(&amp;cache[c_index].rwlock[i],(pthread_rwlockattr_t *)<span class="Constant">NULL</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get number of used blocks in cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_blocks_used(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   <span class="Type">int</span> blocks_used = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_blocks_used] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    blocks_used = cache[c_index].u_blocks;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(blocks_used);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Reset number of used blocks in cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_blocks_reset_used(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{

    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_blocks_reset_used] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache[c_index].u_blocks = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Lock block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_lock_block(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> cache_lock_state, <span class="Comment">// If TRUE lock held on cache</span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> block_locktype,   <span class="Comment">// Type of lock (RDLOCK or WRLOCK)</span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index,          <span class="Comment">// Cache index </span>
                             <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> block_index)      <span class="Comment">// Block index of block locked </span>

{

    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_lock_block] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(cache_lock_state != CACHE_LOCK &amp;&amp; cache_lock_state != CACHE_HAVELOCK)
        pups_error(<span class="Constant">&quot;[cache_access_object] expecting cache lock state </span><span class="Special">\&quot;</span><span class="Constant">CACHE_LOCK</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">CACHE_HAVELOCK</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(block_locktype != BLOCK_RDLOCK &amp;&amp; block_locktype != BLOCK_WRLOCK)
       pups_error(<span class="Constant">&quot;[cache_lock_block] expecting </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_RDLOCK</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_WRLOCK</span><span class="Special">\&quot;</span><span class="Constant"> for lock type&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(cache_lock_state == CACHE_LOCK)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_lock_block] block index range error [cache block (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(block_locktype == RDLOCK)
       (<span class="Type">void</span>)pthread_rwlock_rdlock(&amp;cache[c_index].rwlock[block_index]);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)pthread_rwlock_wrlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Unlock block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_unlock_block(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> cache_lock_state,  <span class="Comment">// State of cache lock </span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Block index of block unlocked</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_unlock_block] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(cache_lock_state != CACHE_UNLOCK &amp;&amp; cache_lock_state != CACHE_HAVELOCK)
        pups_error(<span class="Constant">&quot;[cache_access_object] expecting cache lock state </span><span class="Special">\&quot;</span><span class="Constant">CACHE_UNLOCK</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">CACHE_HAVELOCK</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_unlock_block] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_rwlock_unlock(&amp;cache[c_index].rwlock[block_index]);
    <span class="Statement">if</span>(cache_lock_state == CACHE_UNLOCK)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set/reset cache used flag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_block_set_used(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache </span>
                                 <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index</span>
                                 <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index,  <span class="Comment">// Block index</span>
                                 <span class="Type">const</span> _BOOLEAN                used)  <span class="Comment">// If TRUE mark block as used</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_used] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_used] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blockss (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(used == TRUE)
       {  cache[c_index].flags[block_index] |=  BLOCK_USED;
          ++cache[c_index].u_blocks;
       }
       <span class="Statement">else</span>
       {  cache[c_index].flags[block_index] &amp;= ~BLOCK_USED;

          <span class="Statement">if</span>(cache[c_index].u_blocks &gt; <span class="Constant">0</span>)
             --cache[c_index].u_blocks;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache in use? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_in_use(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index)  <span class="Comment">// Cache index</span>
{   _BOOLEAN ret = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_block_in_use] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].cache_ptr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       ret = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is block in use? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_block_in_use(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index)  <span class="Comment">// Block index of block tested</span>

{   _BOOLEAN ret = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_block_in_use] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_block_in_use] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(cache[c_index].flags[block_index] &amp; BLOCK_USED)
       ret = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set/reset cache busy flag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_busy(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index, <span class="Type">const</span> _BOOLEAN busy)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set)busy] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(busy == TRUE)
       cache[c_index].busy = TRUE;
    <span class="Statement">else</span>
       cache[c_index].busy = FALSE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache busy? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_is_busy(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   _BOOLEAN busy = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_mapped] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    busy = cache[c_index].busy;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
      (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(busy);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add data to cache block     </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> block MUST be locked before </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> doing this                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_add_block(<span class="Type">const</span> <span class="Type">void</span>              *data,               <span class="Comment">// Location of data to cache</span>
                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size,                <span class="Comment">// Size of data (in bytes)</span>
                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      flags,               <span class="Comment">// Access flags </span>
                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      object_index,        <span class="Comment">// Object within cache block where data is written </span>
                            <span class="Type">const</span> <span class="Type">int</span>               block_index,         <span class="Comment">// Cache block where data is written </span>
                            <span class="Type">const</span> <span class="Type">int</span>               tag,                 <span class="Comment">// Block identifier </span>
                            <span class="Type">const</span> _BOOLEAN          cache_access_state,  <span class="Comment">// If TRUE lock held on cache</span>
                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      c_index)             <span class="Comment">// Cache index </span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> i,
                 block_access_flag,
                 new_block_index;

    <span class="Type">void</span> *cache_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_add_block] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(data == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
      pups_error(<span class="Constant">&quot;[cache_add_block] null data pointer&quot;</span>);

    <span class="Statement">if</span>(flags &amp; BLOCK_RDLOCK)
       pups_error(<span class="Constant">&quot;[cache_add_block] need write access to block&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get pointer to cache block we </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> writing data to               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Write access to block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(flags &amp; BLOCK_WRLOCK)
       block_access_flag = BLOCK_WRLOCK;


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Have write access to block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>((flags &amp; BLOCK_HAVELOCK) || (flags &amp; BLOCK_LOADED))
       block_access_flag = BLOCK_HAVELOCK;


    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       pups_error(<span class="Constant">&quot;[cache_add_block] either </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_WRLOCK</span><span class="Special">\&quot;</span><span class="Constant">,  </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_HAVELOCK</span><span class="Special">\&quot;</span><span class="Constant"> or </span><span class="Special">\&quot;</span><span class="Constant">BLOCK_LOADED</span><span class="Special">\&quot;</span><span class="Constant"> expected&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we inserting data into a specific cache block? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index != ANY_CACHE_BLOCK)
    {

       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Error - cannot access block </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((cache_ptr = cache_access_object(cache_access_state,block_access_flag,block_index,object_index,c_index)) == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[cache_add_block] cannot access specified block&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Copy data to cache, tag block and </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> increment number of used blocks   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)bcopy(data,cache_ptr,size);
          ++cache[c_index].u_blocks;

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Mark block in use when we have written all objects to it </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(flags &amp; BLOCK_LOADED)
          {  cache[c_index].flags[block_index] |= BLOCK_USED;
             cache[c_index].tag[block_index]    = tag;


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Unlock block (now data has been loaded) </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)cache_unlock_block(CACHE_UNLOCK,c_index,block_index);
          }

<span class="PreProc">          #ifdef DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;CACHE </span><span class="Special">%d</span><span class="Constant">, BLOCK </span><span class="Special">%d</span><span class="Constant">, OBJECT </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,block_index,object_index);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(block_index);
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do we have an unused block in the cache we can re-use? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {

       <span class="Statement">if</span>(! (cache[c_index].flags[i] &amp; BLOCK_USED))
       {
          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Error cannot access block </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>((cache_ptr = cache_access_object(cache_access_state,block_access_flag,i,object_index,c_index)) == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[cache_add_block] cannot access specified block&quot;</span>);


          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Copy data to cache and tag block </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)bcopy(data,cache_ptr,size);


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Mark block in use when we have written all objects to it </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(flags &amp; BLOCK_LOADED)
             {  cache[c_index].flags[i] |= BLOCK_USED;
                cache[c_index].tag[i]    = tag;


                <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Unlock block (now data has been loaded) </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

                (<span class="Type">void</span>)cache_unlock_block(CACHE_UNLOCK,c_index,i);

<span class="PreProc">                #ifdef PTHREAD_SUPPORT </span>
                <span class="Statement">if</span>(cache_access_state != CACHE_HAVELOCK)
                  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PTREAD_SUPPORT </span><span class="Comment">*/</span>
             }

<span class="PreProc">             #ifdef DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ANY CACHE </span><span class="Special">%d</span><span class="Constant">, BLOCK </span><span class="Special">%d</span><span class="Constant">, OBJECT </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,block_index,object_index);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>

             pups_set_errno(OK);
             <span class="Statement">return</span>(i);
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    new_block_index          = cache[c_index].n_blocks + <span class="Constant">1</span>;
    cache[c_index].n_blocks += BLOCK_ALLOC_QUANTUM;
    (<span class="Type">void</span>)cache_resize(FALSE,cache[c_index].n_blocks,c_index);


    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((cache_ptr = cache_access_object(CACHE_LOCK,block_access_flag,new_block_index,object_index,c_index)) == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_add_block] cannot access specified block&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy data to cache and tag block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)bcopy(data,cache_ptr,size);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Mark block in use when we have written all objects to it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(flags &amp; BLOCK_LOADED)
       {  cache[c_index].flags[new_block_index] |= BLOCK_USED;
          cache[c_index].tag[new_block_index]    = tag;


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Unlock block (now data has been loaded) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)cache_unlock_block(CACHE_UNLOCK,c_index,new_block_index);
       }

<span class="PreProc">       #ifdef DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ANY CACHE </span><span class="Special">%d</span><span class="Constant">, BLOCK </span><span class="Special">%d</span><span class="Constant">, OBJECT </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,new_block_index,object_index);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT </span>
    <span class="Statement">if</span>(cache_access_state != CACHE_HAVELOCK)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(new_block_index);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Delete block of data from cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_delete_block(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// TRUE if lock held on cache</span>
                                    <span class="Type">const</span> _BOOLEAN     have_block_lock,  <span class="Comment">// TRUE if lock held on block</span>
                                    <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index </span>
                                    <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index)  <span class="Comment">// Block to be deleted</span>

{   _BOOLEAN ret = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_delete_block] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_delete_block] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If block is used mark it as unused </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_block_lock == FALSE)
       (<span class="Type">void</span>)pthread_rwlock_wrlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].flags[block_index] &amp; BLOCK_USED)
    {  cache[c_index].flags[block_index] &amp;= ~BLOCK_USED;

       <span class="Statement">if</span>(cache[c_index].u_blocks &gt; <span class="Constant">0</span>)
         --cache[c_index].u_blocks;

       ret = TRUE;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_block_lock == FALSE)
       (<span class="Type">void</span>)pthread_rwlock_unlock(&amp;cache[c_index].rwlock[block_index]);

    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Restore block of data to cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_restore_block(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// TRUE if lock held on cache</span>
                                     <span class="Type">const</span> _BOOLEAN     have_block_lock,  <span class="Comment">// TRUE if lock held on block</span>
                                     <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index</span>
                                     <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index)  <span class="Comment">// Block to be restored </span>

{   _BOOLEAN ret = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_restore_block] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_restore_block] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index,cache[c_index].n_blocks);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If block is unused mark it as used </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_block_lock == FALSE)
       (<span class="Type">void</span>)pthread_rwlock_wrlock(&amp;cache[c_index].rwlock[block_index]);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].flags[block_index] &amp; ~BLOCK_USED)
    {  cache[c_index].flags[block_index] |= BLOCK_USED;

       ++cache[c_index].u_blocks;
       ret = TRUE;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_block_lock == FALSE)
       (<span class="Type">void</span>)pthread_rwlock_unlock(&amp;cache[c_index].rwlock[block_index]);

    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Clear cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_clear(<span class="Type">const</span> _BOOLEAN have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     c_index,  <span class="Comment">// Cache index</span>
                        <span class="Type">const</span>          <span class="Type">int</span>         tag)  <span class="Comment">// Tag i.d. (which must tag i.d. of blocks cleared)</span>

{   <span class="Type">int</span> i,
        n_cleared = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_clear] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset all blocklocks before cache is walked </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cache_reset_blocklocks(have_cache_lock,c_index);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear block usage flag if block is in use </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].flags[i] &amp; BLOCK_USED)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Clear all tagged cache blocks. If ALL_BLOCKS </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> is specified clear the entire cache          </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(tag == ALL_CACHE_BLOCKS || cache[c_index].tag[i] == tag)
          {  cache[c_index].flags[i] &amp;= ~BLOCK_USED;


             <span class="Statement">if</span>(cache[c_index].u_blocks &gt; <span class="Constant">0</span>)
                --cache[c_index].u_blocks;

             ++n_cleared;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset object count </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    cache[c_index].n_objects = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(n_cleared);
}




<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Merge pair of caches </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_merge(<span class="Type">const</span> _BOOLEAN have_cache_locks,  <span class="Comment">// If TRUE locks held on caches</span>
                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>    c_index_1,  <span class="Comment">// Cache index 1</span>
                        <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>    c_index_2,  <span class="Comment">// Cache index 2</span>
                        <span class="Type">const</span>          <span class="Type">int</span>          tag)  <span class="Comment">// Tag i.d. (of merged blocks in cache 1)</span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> i,
                 n_merged   = <span class="Constant">0</span>,
                 n_blocks_1 = <span class="Constant">0</span>,
                 n_blocks_2 = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index_1 &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_merge] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index_1,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(c_index_2 &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_merge] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index_2,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_locks == FALSE)
    {  (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index_1].mutex);
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index_2].mutex);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check (machine) architecture of caches to be merged is identical </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cache[c_index_1].march,cache[c_index_2].march) != <span class="Constant">0</span>)
    {   (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_merge] blocks (in caches </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant">) have different (machine) architectures</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                               c_index_1,c_index_2);
        pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check blocksize of caches to be merged is identical? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index_1].block_size != cache[c_index_2].block_size)
    {   (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_merge] blocks (in caches </span><span class="Special">%d</span><span class="Constant"> and </span><span class="Special">%d</span><span class="Constant">) have different sizes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                             c_index_1,c_index_2);
        pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Number of blocks in cache 1 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    n_blocks_1 = cache[c_index_1].n_blocks;


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Number of blocks in cache 1 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    n_blocks_2 = cache[c_index_2].n_blocks;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Resize cache 1 (so there is enough space </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to merge the contents of cache 2         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cache_resize(have_cache_locks,(n_blocks_1 + n_blocks_2),c_index_1);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Merge caches </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=n_blocks_1; i&lt;(n_blocks_1 + n_blocks_2); ++i)
    {

       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Copy block </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
                                                                        <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
       (<span class="Type">void</span>)memcpy(cache[c_index_1].blockmap[i].object_ptr[<span class="Constant">0</span>],         <span class="Comment">/*</span><span class="Comment"> Base of destination block </span><span class="Comment">*/</span>
                    cache[c_index_2].blockmap[n_merged].object_ptr[<span class="Constant">0</span>],  <span class="Comment">/*</span><span class="Comment"> Base of source block      </span><span class="Comment">*/</span>
                    cache[c_index_2].block_size);                       <span class="Comment">/*</span><span class="Comment"> size of block             </span><span class="Comment">*/</span>
                                                                        <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Update cache datastructure </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

       cache[c_index_1].flags[i] = cache[c_index_2].flags[n_merged];
       cache[c_index_1].tag[i]   = tag;
       ++n_merged;
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update used blocks in cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    cache[c_index_1].u_blocks += cache[c_index_2].u_blocks;


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_locks == FALSE)
    {  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index_1].mutex);
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index_2].mutex);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(n_blocks_2);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get string repesentation of blockag i.d. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_get_blocktag_id_str(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> blocktag_id, <span class="Type">char</span> *blocktag_id_str)

{

    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> String values corresponding to block tag i.d's </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> All </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(blocktag_id == ALL_CACHE_BLOCKS)
       (<span class="Type">void</span>)strlcpy(blocktag_id_str,<span class="Constant">&quot;all&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Scratch </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(blocktag_id == SCRATCH_TAG)
       (<span class="Type">void</span>)strlcpy(blocktag_id_str,<span class="Constant">&quot;scratch&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Abitrary block tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(blocktag_id_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%x</span><span class="Constant">&quot;</span>,blocktag_id);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show tag of specified cache block   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_get_blocktag(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Cache block index</span>

{   <span class="Type">int</span> tag;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blocktag] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blocktag] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    tag = cache[c_index].tag[block_index];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(tag);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set tag of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_blocktag(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>              tag,  <span class="Comment">// Block tag identifier</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                               <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Cache block index</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blocktag] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blocktag] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache[c_index].tag[block_index] = tag;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Change tags of specified cache blocks </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_change_blocktag(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                  <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,  <span class="Comment">// Cache index</span>
                                  <span class="Type">const</span>          <span class="Type">int</span>        from_tag,  <span class="Comment">// Tag i.d. to be replaced</span>
                                  <span class="Type">const</span>          <span class="Type">int</span>          to_tag)  <span class="Comment">// Replacement tag i.d.</span>

{   <span class="Type">int</span> i,
        n_tags = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_change_blocktag] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cache[c_index].n_blocks; ++i)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_rwlock_wrlock(&amp;cache[c_index].rwlock[i]);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear all tagged cache blocks. If ALL_BLOCKS </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> is specified clear the entire cache          </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cache[c_index].tag[i] == from_tag)
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Change blck tag from 'from_tag' to 'to_tag' </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

          cache[c_index].tag[i] = to_tag;
          ++n_tags;
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_rwlock_unlock(&amp;cache[c_index].rwlock[i]);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(n_tags);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show lifetime of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_get_blocklifetime(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                    <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                                    <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Cache block index</span>

{   <span class="Type">int</span> lifetime = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blocklifetime] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blocklifetime] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    lifetime = cache[c_index].lifetime[block_index];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(lifetime);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set lifetime of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_blocklifetime(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                    <span class="Type">const</span> <span class="Type">int</span>                  lifetime,  <span class="Comment">// Block lifetime</span>
                                    <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                                    <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Cache block index</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blocklifetime] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blocklifetime] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache[c_index].lifetime[block_index] = lifetime;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get hubness of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">int</span> cache_get_blockhubness(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Cache block index</span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> hubness = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blockhubness] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_blockhubness] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    hubness = cache[c_index].hubness[block_index];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(hubness);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set hubness of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_blockhubness(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         hubness,   <span class="Comment">// Block hubness</span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,   <span class="Comment">// Cache index</span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index)   <span class="Comment">// Cache block index</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blockhubness] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blockhubness] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache[c_index].hubness[block_index] = hubness;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get binding of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">int</span> cache_get_blockbinding(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index,  <span class="Comment">// Cache index</span>
                                            <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>      block_index)  <span class="Comment">// Cache block index</span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> binding = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_binding] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_binding] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    binding = cache[c_index].hubness[block_index];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(binding);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set binding of specified cache block </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_blockbinding(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         binding,   <span class="Comment">// Block binding </span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index,   <span class="Comment">// Cache index</span>
                                   <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>     block_index)   <span class="Comment">// Cache block index</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blockbinding] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Block index range error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(block_index &gt;= cache[c_index].n_blocks)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_blockbinding] block index range error [block index (</span><span class="Special">%d</span><span class="Constant">) &gt; max blocks (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block_index, cache[c_index].n_blocks);
       pups_error(errstr);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache[c_index].binding[block_index] = binding;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get co-ordination list size for cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">int</span> cache_get_colsize(<span class="Type">const</span> _BOOLEAN      have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>          c_index)  <span class="Comment">// Cache index</span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> colsize = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_colsize] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    colsize = cache[c_index].colsize;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(colsize);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set co-ordination list-size for cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_colsize(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// If TRUE lock held on cache</span>
                              <span class="Type">unsigned</span> <span class="Type">int</span>       colsize,          <span class="Comment">// Co-ordination list size </span>
                              <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)          <span class="Comment">// Cache index</span>

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_colsize] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    cache[c_index].colsize = colsize;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Swap cache table entries </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> swap_cache_table_entries(<span class="Type">int</span> c_index, <span class="Type">const</span> <span class="Type">int</span> index_1, <span class="Type">const</span> <span class="Type">int</span> index_2)

{   <span class="Type">unsigned</span> <span class="Type">int</span>     tmp_int;
    pthread_rwlock_t tmp_rwlock;
    block_mtype      tmp_blockmap;


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Swap block maps </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    tmp_blockmap                     = cache[c_index].blockmap[index_1];
    cache[c_index].blockmap[index_1] = cache[c_index].blockmap[index_2];
    cache[c_index].blockmap[index_2] = tmp_blockmap;


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Swap block tags </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    tmp_int                          = cache[c_index].tag[index_1];
    cache[c_index].tag[index_1]      = cache[c_index].tag[index_2];
    cache[c_index].tag[index_2]      = tmp_int;


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Swap block flags </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    tmp_int                          = cache[c_index].flags[index_1];
    cache[c_index].flags[index_1]    = cache[c_index].flags[index_2];
    cache[c_index].flags[index_2]    = tmp_int;


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Swap block read/write locks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    tmp_rwlock                       = cache[c_index].rwlock[index_1];
    cache[c_index].rwlock[index_1]   = cache[c_index].rwlock[index_2];
    cache[c_index].rwlock[index_2]   = tmp_rwlock;
}




<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Move block (to fill hole) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> move_block(<span class="Type">const</span> <span class="Type">int</span> c_index, <span class="Type">const</span> <span class="Type">int</span> block_index, <span class="Type">const</span> <span class="Type">int</span> hole_index)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;

    <span class="Type">void</span> *to_ptr   = (<span class="Type">void</span> *)<span class="Constant">NULL</span>,
         *from_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
                                                                                       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    to_ptr   = (<span class="Type">void</span> *)(cache[c_index].cache_ptr                                   +   <span class="Comment">/*</span><span class="Comment"> Base of cache                       </span><span class="Comment">*/</span>
                       (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)hole_index  * cache[c_index].block_size  );  <span class="Comment">/*</span><span class="Comment"> Location of hole to file in cache   </span><span class="Comment">*/</span>
                                                                                       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

                                                                                        <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    from_ptr = (<span class="Type">void</span> *)(cache[c_index].cache_ptr                                    +   <span class="Comment">/*</span><span class="Comment"> Base of cache                      </span><span class="Comment">*/</span>
                       (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)block_index * cache[c_index].block_size   );  <span class="Comment">/*</span><span class="Comment"> Location of block to move in cache </span><span class="Comment">*/</span>
                                                                                        <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Move block </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)memcpy(to_ptr,from_ptr,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache[c_index].block_size);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update cache table entries </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to reflect moved block     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    swap_cache_table_entries(c_index,hole_index,block_index);

    cache[c_index].flags[hole_index]  |=  BLOCK_USED;
    cache[c_index].flags[block_index] &amp;= ~BLOCK_USED;
}




<span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Compact cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_compact(<span class="Type">const</span> _BOOLEAN have_cache_lock,  <span class="Comment">// If TRUE we hold lock on cache</span>
                          <span class="Type">const</span> <span class="Type">int</span>              c_index)  <span class="Comment">// Cache index</span>

{   <span class="Type">unsigned</span> <span class="Type">int</span> i,
                 n_blocks,
                 freed_blocks = <span class="Constant">0</span>,
                 hole_index   = <span class="Constant">0</span>,
                 used_blocks  = <span class="Constant">0</span>,
                 free_blocks  = <span class="Constant">0</span>,
                 shrink_size  = <span class="Constant">0</span>;

    _BOOLEAN hole_fill = FALSE;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_change_blocktag] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset all blocklocks before cache is walked </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Comment">//(void)cache_reset_blocklocks(have_cache_lock,c_index);</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Walk cache filling in any holes. Note this is  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> a strictly serial operation as there iterative </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> dependencies                                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>


    n_blocks = cache_get_blocks(TRUE,c_index);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_blocks; ++i)
    {


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> First free block so start filling holes </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(! (cache[c_index].flags[i] &amp; BLOCK_USED))
        {  <span class="Statement">if</span>(hole_fill == FALSE)
           {  hole_index = i;
              hole_fill  = TRUE;
           }
        }


        <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Used block so move it to full bubble </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">else</span> <span class="Statement">if</span>(hole_fill == TRUE)
        {  <span class="Statement">if</span>(cache[c_index].flags[i] &amp; BLOCK_USED)
           {  (<span class="Type">void</span>)move_block(c_index,i,hole_index);
              ++hole_index;
              ++freed_blocks;
           }
        }

    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We can only shrink a public (read/write) cache </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PUBLIC)
    {

       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Shrink cache </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       used_blocks = cache_blocks_used(TRUE,c_index);
       free_blocks = n_blocks - used_blocks;
       shrink_size = n_blocks - BLOCK_ALLOC_QUANTUM * (free_blocks / BLOCK_ALLOC_QUANTUM);


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Shrink cache if we can </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(shrink_size &gt; <span class="Constant">0</span>)
          (<span class="Type">void</span>)cache_resize(TRUE, shrink_size, c_index);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(freed_blocks);
}




<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Resize cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_resize(<span class="Type">const</span> _BOOLEAN     have_cache_lock,  <span class="Comment">// Lock on cache held if TRUE</span>
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>        n_blocks,  <span class="Comment">// New size of cache (in blocks)</span>
                         <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>         c_index)  <span class="Comment">// Cache index</span>

{   <span class="Type">int</span> i,
        map_flags = <span class="Constant">0</span>,
        fd        = (-<span class="Constant">1</span>);

    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> new_size;
    <span class="Type">void</span>              *cache_ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_resize] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If cache size hasn't changed we don't </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> have to do anything                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_blocks == cache[c_index].n_blocks)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       <span class="Statement">if</span>(have_cache_lock == FALSE)
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Cache is memory mapped so </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> get mapping flags         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read only mapping </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PRIVATE)
       map_flags = MAP_PRIVATE;


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read/write mapping </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PUBLIC)
       map_flags = MAP_SHARED;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Populate mapping to prevent page faults </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_POPULATE)
       map_flags |= MAP_POPULATE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Adjust the number of blocks and then   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> initialise the new blocks created      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    new_size = n_blocks*cache[c_index].block_size;


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unmap memory segment </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(munmap(cache[c_index].cache_ptr,cache[c_index].cache_size) == (-<span class="Constant">1</span>))
       pups_error(<span class="Constant">&quot;[cache_resize] cannot unmap cache&quot;</span>);

    <span class="Comment">//munmap(cache[c_index].cache_ptr,cache[c_index].cache_size);</span>



    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend backing file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)posix_fallocate(cache[c_index].mmap_fd,<span class="Constant">0</span>,new_size);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remap (and possibly move) memory segment </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((cache_ptr = mmap(<span class="Constant">NULL</span>,
                         new_size,
                         PROT_READ  | PROT_WRITE,
                         map_flags,
                         cache[c_index].mmap_fd,
                         <span class="Constant">0L</span>)) == (<span class="Type">void</span> *)MAP_FAILED)
       pups_error(<span class="Constant">&quot;[cache_resize] could not extend cache&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reallocate block parameters </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    cache[c_index].flags       = (_BYTE            *)pups_realloc((<span class="Type">void</span> *)cache[c_index].flags,   n_blocks*<span class="Statement">sizeof</span>(_BYTE));
    cache[c_index].tag         = (<span class="Type">unsigned</span> <span class="Type">int</span>     *)pups_realloc((<span class="Type">void</span> *)cache[c_index].tag,     n_blocks*<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">int</span>));
    cache[c_index].lifetime    = (<span class="Type">int</span>              *)pups_realloc((<span class="Type">void</span> *)cache[c_index].lifetime,n_blocks*<span class="Statement">sizeof</span>(<span class="Type">int</span>));
    cache[c_index].rwlock      = (pthread_rwlock_t *)pups_realloc((<span class="Type">void</span> *)cache[c_index].rwlock,  n_blocks*<span class="Statement">sizeof</span>(pthread_rwlock_t));
    cache[c_index].blockmap    = (block_mtype      *)pups_realloc((<span class="Type">void</span> *)cache[c_index].blockmap,n_blocks*<span class="Statement">sizeof</span>(block_mtype));
    cache[c_index].n_blocks    = n_blocks;
    cache[c_index].cache_size  = new_size;
    cache[c_index].cache_ptr   = cache_ptr;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Recompute cache offsets (and initialise extra blocks) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>;  i&lt;n_blocks; ++i)
    {  <span class="Type">int</span> j;

       <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;cache[c_index].n_objects; ++j)                                                          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       {  cache[c_index].blockmap[i].object_ptr[j] = (<span class="Type">void</span> *)(cache[c_index].object_offset[j]          +  <span class="Comment">/*</span><span class="Comment"> Object offset within block </span><span class="Comment">*/</span>
                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)i*cache[c_index].block_size    +  <span class="Comment">/*</span><span class="Comment"> Block offset within cache  </span><span class="Comment">*/</span>
                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)cache[c_index].cache_ptr);        <span class="Comment">/*</span><span class="Comment"> Base address of cache      </span><span class="Comment">*/</span>
       }                                                                                                  <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

<span class="PreProc">       #ifdef DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BLOCK </span><span class="Special">%d</span><span class="Constant"> (of </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,n_blocks-<span class="Constant">1</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Initialise extra per block parameters </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(i &gt; cache[c_index].n_blocks)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Initialise extra flags </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

          cache[c_index].flags[i] = <span class="Constant">0</span>;


          <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Initialise extra block tags </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

          cache[c_index].tag[i] = <span class="Constant">0</span>;


          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Initialise extra block lifetimes </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          cache[c_index].tag[i] = BLOCK_IMMORTAL;


          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Initialise extra wlocks </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pthread_rwlock_init(&amp;cache[c_index].rwlock[i],(pthread_rwlockattr_t *)<span class="Constant">NULL</span>);
       }
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Lock cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_lock(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_lock] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Unlock cache </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_unlock(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_unlock] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache private (read only)? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_is_private(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   _BOOLEAN ret = FALSE;

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_private] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_PRIVATE)
       ret = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is cache preloaded? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cache_is_preloaded(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{   _BOOLEAN ret = FALSE;

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_is_preloaded] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cache[c_index].mmap &amp; CACHE_POPULATE)
       ret = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}


<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set cache auxilliary data field </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_set_auxinfo(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">const</span> <span class="Type">char</span> *auxinfo, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{

    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_set_auxinfo] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(auxinfo == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_set_auxinfo] auxinfo parameter is NULL&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cache[c_index].auxinfo,auxinfo,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get cache auxilliary data field </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cache_get_auxinfo(<span class="Type">const</span> _BOOLEAN have_cache_lock, <span class="Type">char</span> *auxinfo, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> c_index)

{

    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_index &gt;= MAX_CACHES)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[cache_get_auxinfo] cache index range error [cache index (</span><span class="Special">%d</span><span class="Constant">) &gt; max caches (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_index,MAX_CACHES);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(auxinfo == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cache_get_auxinfo] auxinfo parameter is NULL&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(auxinfo,cache[c_index].auxinfo,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Statement">if</span>(have_cache_lock == FALSE)
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;cache[c_index].mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
