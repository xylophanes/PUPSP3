<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>/usr/local/src/pupsp3-5.4.9.src.git/pupscore.src/phgmalloc.c.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Error { color: #ffffff; background-color: #ff6060; padding-bottom: 1px; }
.Todo { color: #000000; background-color: #ffff00; padding-bottom: 1px; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span>
<span class="Comment">    Persistent heap library. A persistent heap is an area</span>
<span class="Comment">    of data memory which may be mapped serailly into the</span>
<span class="Comment">    address spaces of multiple process.</span>

<span class="Comment">     Author:  M.A. O'Neill</span>
<span class="Comment">              Tumbling Dice Ltd</span>
<span class="Comment">              Gosforth</span>
<span class="Comment">              Newcastle upon Tyne</span>
<span class="Comment">              NE3 4RT</span>
<span class="Comment">              United Kingdom</span>

<span class="Comment">    Version: 2.00 </span>
<span class="Comment">    Dated:   4th January 2022</span>
<span class="Comment">    Email:   mao@tumblingdice.co.uk</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> If we have OpenMP support then we also have pthread support </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (OpenMP is built on pthreads for Linux distributions).      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#if defined(_OPENMP) &amp;&amp; !defined(PTHREAD_SUPPORT)</span>
<span class="PreProc">#define PTHREAD_SUPPORT</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#include </span><span class="Constant">&lt;me.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utils.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;psrp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;netlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;casino.h&gt;</span>

<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>

<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;tad.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifndef _PHMALLOC_INTERNAL</span>
<span class="PreProc">#define _PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PHMALLOC_INTERNAL </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get signal mapping appropriate to OS and hardware architecture </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define __DEFINE__</span>
<span class="PreProc">#if defined(I386) || defined(X86_64)</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.x86.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> I386 || X86_64 </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV6L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV6L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV7L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV7L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef AARCH64</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> AARCH64 </span><span class="Comment">*/</span>
<span class="PreProc">#undef __DEFINE__</span>



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Heaptable objects used by the persistent memory allocation package </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Is persistent heap initialised</span>
_PUBLIC <span class="Type">int</span> *__phmalloc_initialized                                = (<span class="Type">int</span> *)<span class="Constant">NULL</span>;

<span class="Comment">// Number of objects in heap</span>
_PUBLIC <span class="Type">int</span> *_phobjects                                            = (<span class="Type">int</span> *)<span class="Constant">NULL</span>;

<span class="Comment">// Number of objects in heap</span>
_PUBLIC <span class="Type">int</span> *_phobjects_allocated                                  = (<span class="Type">int</span> *)<span class="Constant">NULL</span>;

<span class="Comment">// Pointer to table of significant objects on persistent heaps</span>
_PUBLIC phobmap_type ***_phobjectmap                               = (phobmap_type ***)<span class="Constant">NULL</span>;



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> List of client_info structures for client processes </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> using persistent heaps                              </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Pointer to persistent heap parameter table (on persistent heap)</span>
_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> **_pheap_parameters                      = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> **)<span class="Constant">NULL</span>;

<span class="Comment">// Pointer to the base of the first block</span>
_PUBLIC <span class="Type">char</span> **_pheapbase                                          = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

<span class="Comment">// Block information table.  Allocated with align/__free (not malloc/free)</span>
_PUBLIC malloc_info **_pheapinfo                                   = (malloc_info **)<span class="Constant">NULL</span>;

<span class="Comment">// Number of info entries</span>
_PUBLIC __malloc_size_t *pheapsize                                 = (__malloc_size_t *)<span class="Constant">NULL</span>;

<span class="Comment">// Search index in the info table.</span>
_PUBLIC __malloc_size_t *_pheapindex                               = (__malloc_size_t *)<span class="Constant">NULL</span>;

<span class="Comment">// Limit of valid info table indices</span>
_PUBLIC __malloc_size_t *_pheaplimit                               = (__malloc_size_t *)<span class="Constant">NULL</span>;

<span class="Comment">// Free lists for each fragment size</span>
_PUBLIC <span class="Type">struct</span> list **_phfraghead                                  = (<span class="Type">struct</span> list **)<span class="Constant">NULL</span>;

<span class="Comment">// Instrumentation</span>
_PUBLIC __malloc_size_t *_pheap_chunks_used                        = (__malloc_size_t *)<span class="Constant">NULL</span>;
_PUBLIC __malloc_size_t *_pheap_bytes_used                         = (__malloc_size_t *)<span class="Constant">NULL</span>;
_PUBLIC __malloc_size_t *_pheap_chunks_free                        = (__malloc_size_t *)<span class="Constant">NULL</span>;
_PUBLIC __malloc_size_t *_pheap_bytes_free                         = (__malloc_size_t *)<span class="Constant">NULL</span>;


<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> TRUE if persistent heaps initialized </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN        do_msm_init                                = FALSE;


<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Heap table mutex to allow thread-safe </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> manipulation of persistent heap       </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC pthread_mutex_t htab_mutex                                 = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
_PUBLIC pthread_mutex_t phmalloc_mutex                             = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


_IMPORT _PROTOTYPE <span class="Type">int</span> initialize_heap(<span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Persistent heap table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PUBLIC heap_type    *htable = (heap_type *)<span class="Constant">NULL</span>;




<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Functions exported by this modules </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Switch off presistent object map updating </span>
_PUBLIC <span class="Type">int</span> _no_phobject_mapping;




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> TRUE if persistent heap maps exists (e.g. if we are </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> attaching an existing persistent heap)              </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN _phmaps_exist = FALSE;



<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Function which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Relocate heap addresses </span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> msm_relocate_heap_addresses(<span class="Type">int</span>, <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>, <span class="Type">int</span>);




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Convert free block addressing from global to local (in </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> cached heap)                                           </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _PRIVATE <span class="Type">void</span> local_to_global_blocklist(<span class="Type">int</span>, <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Convert free block addressing from local to global (in </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> cached heap)                                           </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _PRIVATE <span class="Type">void</span> global_to_local_blocklist(<span class="Type">int</span>, <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>);



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Slot and usage functions - used by slot manager ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot usage function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> pheap_slot(<span class="Type">int</span> level)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;lib hseaplib </span><span class="Special">%s</span><span class="Constant">: [ANSI C]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PHEAP_VERSION);

    <span class="Statement">if</span>(level &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;(C) 2003-2022 Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;Author: M.A. O'Neill</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PUPS/P3 persistent heap support library (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    fflush(<span class="Constant">stderr</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Segment identification for persistent heap library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SLOT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;slotman.h&gt;</span>
_EXTERN <span class="Type">void</span> (* SLOT )() __attribute__ ((aligned(<span class="Constant">16</span>))) = pheap_slot;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLOT </span><span class="Comment">*/</span>





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Initialise (local process) variables associated with persistent heap ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_init(<span class="Type">const</span> <span class="Type">int</span> max_pheaps)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_init] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);

    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> max_pheaps &lt;= 0 implies that the application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is not using persistent heaps                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(max_pheaps &gt; MAX_PHEAPS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialised persistent heap tables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    htable = (heap_type *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(heap_type));
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;max_pheaps; ++i)
    {  (<span class="Type">void</span>)strlcpy(htable[i].name,<span class="Constant">&quot;&quot;</span>,SSIZE);

       htable[i].fd              = (-<span class="Constant">1</span>);
       htable[i].m_cnt           = <span class="Constant">0</span>;
       htable[i].mtime           = <span class="Constant">0L</span>;
       htable[i].sdata           = <span class="Constant">0</span>;
       htable[i].edata           = <span class="Constant">0</span>;
       htable[i].ptrsize         = <span class="Constant">8</span>*<span class="Statement">sizeof</span>(<span class="Type">void</span> *);
       htable[i].addr            = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       htable[i].exists          = FALSE;
       htable[i].addresses_local = FALSE;


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get size of pointers (for persistent heap addressing) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> 64 bit heaps </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(<span class="Statement">sizeof</span>(<span class="Type">void</span> *) == <span class="Constant">8</span>)
       {

          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Big endian architecture </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pups_bigendian() == TRUE)
             htable[i].heapmagic = HEAPMAGIC64BIG;
          <span class="Statement">else</span>
             htable[i].heapmagic = HEAPMAGIC64LITTLE;
       }


       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> 32 bit heaps </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(<span class="Statement">sizeof</span>(<span class="Type">void</span> *) == <span class="Constant">4</span>)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Little endian architecture </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pups_bigendian() == TRUE)
             htable[i].heapmagic       = HEAPMAGIC32BIG;
          <span class="Statement">else</span>
             htable[i].heapmagic       = HEAPMAGIC32LITTLE;
       }


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Error condition </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  pups_set_errno(<span class="Constant">EINVAL</span>);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise other per heap persistent heap datatstructures </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    _phobjectmap         = (phobmap_type ***)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(phobmap_type **));
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;max_pheaps; ++i)
        _phobjectmap[i] = (phobmap_type **)<span class="Constant">NULL</span>;

    _phobjects           = (<span class="Type">int</span> *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(<span class="Type">int</span>));
    _phobjects_allocated = (<span class="Type">int</span> *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(<span class="Type">int</span>));

    _pheap_parameters    = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> **)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *));
    _pheapinfo           = (malloc_info **)      pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(malloc_info *));
    _pheapbase           = (<span class="Type">char</span> **)             pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(<span class="Type">char</span> *));
    pheapsize            = (__malloc_size_t *)   pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheapindex          = (__malloc_size_t *)   pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheaplimit          = (__malloc_size_t *)   pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    _phfraghead          = (<span class="Type">struct</span> list **)      pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(<span class="Type">struct</span> list *));

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;max_pheaps; ++i)
       _phfraghead[i] = (<span class="Type">struct</span> list *)pups_calloc(BLOCKLOG,<span class="Statement">sizeof</span>(<span class="Type">struct</span> list));

    _pheap_chunks_used         = (__malloc_size_t *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheap_bytes_used          = (__malloc_size_t *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheap_chunks_free         = (__malloc_size_t *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheap_bytes_free          = (__malloc_size_t *)pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(__malloc_size_t));
    __phmalloc_initialized     = (<span class="Type">int</span> *)            pups_calloc(max_pheaps,<span class="Statement">sizeof</span>(<span class="Type">int</span>));


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): persistent heap table initialised (</span><span class="Special">%d</span><span class="Constant"> heaps slots)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                             date,appl_name,appl_pid,appl_host,appl_owner,max_pheaps);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }



    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Flag persistent heap initialisation </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    do_msm_init = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Extend (local process) variables associated with persistent heap ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_extend(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> from_size, <span class="Type">unsigned</span> <span class="Type">int</span> to_size)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(to_size &lt; from_size)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_extend] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend persistent heap tables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    htable = (heap_type *)pups_realloc((<span class="Type">void</span> *)htable,to_size*<span class="Statement">sizeof</span>(heap_type));
    <span class="Statement">for</span>(i=from_size; i&lt;to_size; ++i)
    {  (<span class="Type">void</span>)strlcpy(htable[i].name,<span class="Constant">&quot;&quot;</span>,SSIZE);

       htable[i].fd              = (-<span class="Constant">1</span>);
       htable[i].mtime           = <span class="Constant">0L</span>;
       htable[i].sdata           = <span class="Constant">0</span>;
       htable[i].edata           = <span class="Constant">0</span>;
       htable[i].ptrsize         = <span class="Constant">8</span>*<span class="Statement">sizeof</span>(<span class="Type">void</span> *);
       htable[i].addr            = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       htable[i].exists          = FALSE;
       htable[i].addresses_local = FALSE;


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get size of pointers (for persistentheap addressing) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> 64 bit heaps </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(<span class="Statement">sizeof</span>(<span class="Type">void</span> *) == <span class="Constant">8</span>)
       {

          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Big endian architecture </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pups_bigendian() == TRUE)
             htable[i].heapmagic = HEAPMAGIC64BIG;
          <span class="Statement">else</span>
             htable[i].heapmagic = HEAPMAGIC64LITTLE;
       }


       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> 32 bit heaps </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(<span class="Statement">sizeof</span>(<span class="Type">void</span> *) == <span class="Constant">4</span>)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Little endian architecture </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pups_bigendian() == TRUE)
             htable[i].heapmagic       = HEAPMAGIC32BIG;
          <span class="Statement">else</span>
             htable[i].heapmagic       = HEAPMAGIC32LITTLE;
       }


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Error condition </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  pups_set_errno(<span class="Constant">EINVAL</span>);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise other per heap persistent heap datatstructures </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    _phobjectmap               = (phobmap_type ***)pups_realloc((<span class="Type">void</span> *)_phobjectmap,to_size*<span class="Statement">sizeof</span>(phobmap_type **));
    <span class="Statement">for</span>(i=from_size; i&lt;to_size; ++i)
        _phobjectmap[i] = (phobmap_type **)<span class="Constant">NULL</span>;

    _phobjects                 = (<span class="Type">int</span> *)pups_realloc((<span class="Type">void</span> *)_phobjects,to_size*<span class="Statement">sizeof</span>(<span class="Type">int</span>));
    _phobjects_allocated       = (<span class="Type">int</span> *)pups_realloc((<span class="Type">void</span> *)_phobjects_allocated,to_size*<span class="Statement">sizeof</span>(<span class="Type">int</span>));

    _pheap_parameters          = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> **)pups_realloc((<span class="Type">void</span> *)_pheap_parameters,to_size*<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *));
    _pheapinfo                 = (malloc_info **)pups_realloc((<span class="Type">void</span> *)_pheapinfo,to_size*<span class="Statement">sizeof</span>(malloc_info *));
    _pheapbase                 = (<span class="Type">char</span> **)pups_realloc((<span class="Type">void</span> *)_pheapbase,to_size*<span class="Statement">sizeof</span>(<span class="Type">char</span> *));
    pheapsize                  = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)pheapsize,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheapindex                = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)_pheapindex,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheaplimit                = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)_pheapindex,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));

    _phfraghead                = (<span class="Type">struct</span> list **)pups_realloc((<span class="Type">void</span> *)_phfraghead,to_size*<span class="Statement">sizeof</span>(<span class="Type">struct</span> list *));
    <span class="Statement">for</span>(i=from_size; i&lt;to_size; ++i)
        _phfraghead[i] = (<span class="Type">struct</span> list *)pups_calloc(BLOCKLOG,<span class="Statement">sizeof</span>(<span class="Type">struct</span> list));

    _pheap_chunks_used         = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)_pheap_chunks_used,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheap_bytes_used          = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)_pheap_bytes_used,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheap_chunks_free         = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)_pheap_chunks_free,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));
    _pheap_bytes_free          = (__malloc_size_t *)pups_realloc((<span class="Type">void</span> *)_pheap_bytes_free,to_size*<span class="Statement">sizeof</span>(__malloc_size_t));
    __phmalloc_initialized     = (<span class="Type">int</span> *)            pups_realloc((<span class="Type">void</span> *)__phmalloc_initialized,to_size*<span class="Statement">sizeof</span>(<span class="Type">int</span>));

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): persistent heap table extended  (from </span><span class="Special">%d</span><span class="Constant"> to </span><span class="Special">%d</span><span class="Constant"> heaps slots)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                               date,appl_name,appl_pid,appl_host,appl_owner,from_size,to_size);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Tell heap to destroy itself when we detach it ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_set_autodestruct_state(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> _BOOLEAN autodestruct)

{

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------*</span>
<span class="Comment">    </span><span class="Error">/</span><span class="Comment">* Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps || htable[hdes].exists == FALSE ||
       (autodestruct != FALSE &amp;&amp; autodestruct != TRUE)          )
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_set_autodestruct_state] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);


    htable[hdes].autodestruct = autodestruct;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Return a handle to the persistent heap whose pathname is map_f_path. The flags</span>
<span class="Comment">    specifies the (file) I/O mode the persistent heap, and mode specifies the level</span>
<span class="Comment">    of file protection ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_heap_attach(<span class="Type">const</span> <span class="Type">char</span> *map_f_path, <span class="Type">const</span> <span class="Type">int</span> attach_mode)

{   <span class="Type">int</span> i,
	flags,
        ret,
        start     = <span class="Constant">0</span>;

    <span class="Type">size_t</span> size,
           offset = <span class="Constant">0L</span>;

    _BOOLEAN map_exists = FALSE;



    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable == (<span class="Type">const</span> heap_type *)<span class="Constant">NULL</span> &amp;&amp; (! attach_mode &amp; CREATE_PHEAP) &amp;&amp; (! attach_mode &amp; ATTACH_PHEAP))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_heap_attach] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If creation mode is not specified and the persistent heap </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> does not exist this is an error                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>( !(attach_mode &amp; CREATE_PHEAP) &amp;&amp; access(map_f_path,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to make sure that we aren't already attached to this persistent heap </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(htable[i].name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(htable[i].name,map_f_path) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(EALREADY);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       <span class="Statement">if</span>(htable[i].addr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       {  <span class="Type">int</span> ret,
              f_index;

          _BOOLEAN lock_tried = FALSE;

          <span class="Statement">if</span>(access(map_f_path,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
          {  htable[i].exists = FALSE;


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
	     <span class="Comment">/*</span><span class="Comment"> We need to avoid a potential race condition at the time  </span><span class="Comment">*/</span>
	     <span class="Comment">/*</span><span class="Comment"> of file creation here. If we have failed to win the race </span><span class="Comment">*/</span>
	     <span class="Comment">/*</span><span class="Comment"> to create the file simply attach it.                     </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(pups_creat(map_f_path,<span class="PreProc">0</span><span class="Constant">644</span>) == (-<span class="Constant">1</span>))
             {

<span class="PreProc">                #ifdef PTHREAD_SUPPORT</span>
                (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


                <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Delay to make sure winner initialises heap </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

	        (<span class="Type">void</span>)pups_usleep(<span class="Constant">1000000</span>);

                <span class="Statement">if</span>(attach_mode &amp; LIVE_PHEAP)
                   <span class="Statement">return</span>(msm_heap_attach(map_f_path, ATTACH_PHEAP | LIVE_PHEAP));
                <span class="Statement">else</span>
                   <span class="Statement">return</span>(msm_heap_attach(map_f_path, ATTACH_PHEAP));
	     }
          }
          <span class="Statement">else</span>
             htable[i].exists = TRUE;


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> At present flags are the same for all map modes. This may </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> change in the future.                                     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

	  flags = O_RDWR;


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Protect heap mapping homeostatically if asked to do so </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(attach_mode &amp; LIVE)
             htable[i].fd = pups_open(map_f_path, flags, LIVE);
          <span class="Statement">else</span>
             htable[i].fd = pups_open(map_f_path, flags, DEAD);

          <span class="Statement">if</span>(htable[i].fd == (-<span class="Constant">1</span>))
          {
<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EPERM</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Lock the persistent heap so we have exlusive access </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_lockf(htable[i].fd,PUPS_WRLOCK,<span class="Constant">0</span>);


          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Set file type to persistent heap </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          f_index = pups_get_ftab_index(htable[i].fd);
          ftab[f_index].pheap = TRUE;


          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> New persistent heap </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(htable[i].exists == FALSE)
          {  (<span class="Type">void</span>)pups_lseek(htable[i].fd,PHM_BSTORE_SIZE - <span class="Constant">1</span>,<span class="Constant">SEEK_END</span>);
             (<span class="Type">void</span>)write(htable[i].fd,<span class="Constant">&quot;b&quot;</span>,<span class="Constant">1</span>);
             (<span class="Type">void</span>)pups_lseek(htable[i].fd,<span class="Constant">0</span>,<span class="Constant">SEEK_SET</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Is file existing persistent heap? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> magic,
                               htag;


             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check this is a valid heap file </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(pups_lseek(htable[i].fd,MAGIC_OFFSET*<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>),<span class="Constant">SEEK_SET</span>) == (-<span class="Constant">1</span>))
             {  htable[i].fd = pups_close(htable[i].fd);

<span class="PreProc">                #ifdef PTHREAD_SUPPORT</span>
                (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                pups_set_errno(<span class="Constant">EINVAL</span>);
                <span class="Statement">return</span>(-<span class="Constant">1</span>);
             }


             <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Get heap magic (used to identify persistent heap) </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)pups_pipe_read(htable[i].fd,&amp;magic,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>));


             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Is this the correct type of heap? </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(<span class="Statement">sizeof</span>(<span class="Type">void</span> *) == <span class="Constant">8</span>)
             {  <span class="Statement">if</span>(pups_bigendian() == TRUE)
                   ret = (magic == HEAPMAGIC64BIG);
                <span class="Statement">else</span>
                   ret = (magic == HEAPMAGIC64LITTLE);
             }
             <span class="Statement">else</span>
             {  <span class="Statement">if</span>(pups_bigendian() == TRUE)
                   ret = (magic == HEAPMAGIC32BIG);
                <span class="Statement">else</span>
                   ret = (magic == HEAPMAGIC32LITTLE);
             }


             <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Not a persistent heap </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(! ret)
             {  htable[i].fd = pups_close(htable[i].fd);

<span class="PreProc">                #ifdef PTHREAD_SUPPORT</span>
                (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                <span class="Statement">if</span>(appl_verbose == TRUE)
                {  (<span class="Type">void</span>)strdate(date);
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): not a valid persistent heap (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
		                       date,appl_name,appl_pid,appl_host,appl_owner,map_f_path);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                }

                pups_set_errno(<span class="Constant">EINVAL</span>);
                <span class="Statement">return</span>(-<span class="Constant">1</span>);
             }


             <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check that heap is not stale </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)pups_pipe_read(htable[i].fd,&amp;htag,<span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>));
             <span class="Statement">if</span>(appl_vtag != NO_VERSION_CONTROL &amp;&amp; htag != appl_vtag)
             {  htable[i].fd = pups_close(htable[i].fd);

<span class="PreProc">                #ifdef PTHREAD_SUPPORT</span>
                (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                <span class="Statement">if</span>(appl_verbose == TRUE)
                {  (<span class="Type">void</span>)strdate(date);
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stale persistent heap (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner,map_f_path);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                }

                pups_set_errno(<span class="Constant">EINVAL</span>);
                <span class="Statement">return</span>(-<span class="Constant">1</span>);
             }


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check that the host whose process is trying to attach the heap </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> can support the address width of this heap                     </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(htable[i].ptrsize != <span class="Constant">8</span>*<span class="Statement">sizeof</span>(<span class="Type">void</span> *))
             {  htable[i].fd = pups_close(htable[i].fd);

<span class="PreProc">                #ifdef PTHREAD_SUPPORT</span>
                (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                <span class="Statement">if</span>(appl_verbose == TRUE)
                {  (<span class="Type">void</span>)strdate(date);
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): heap (</span><span class="Special">%s</span><span class="Constant">) address mode conflict</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner,map_f_path);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                }

                pups_set_errno(<span class="Constant">EINVAL</span>);
                <span class="Statement">return</span>(-<span class="Constant">1</span>);
             }
          }


          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Map heap into process address space </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>((htable[i].addr = (<span class="Type">void</span> *)mmap(<span class="Constant">0</span>,
                                            PHM_SBRK_SIZE,
                                            PROT_READ  | PROT_WRITE,
                                            MAP_SHARED,
                                            htable[i].fd,
                                            offset)) == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  htable[i].fd = pups_close(htable[i].fd);

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EAGAIN</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Save heap map and prot modes (for checkpointing) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

          htable[i].segment_size = PHM_SBRK_SIZE;
          htable[i].flags        = flags;


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> First sizeof(long) bytes is the size of this heap </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(htable[i].name,map_f_path,SSIZE);


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> This is a dummy which will be overwritten if the heap we </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> are mapping already exists                               </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

          htable[i].sdata = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[i].addr + <span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>);
          htable[i].edata = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[i].addr + <span class="Statement">sizeof</span>(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>);


          <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> This is a new persistent heap </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(htable[i].exists == FALSE)
          {

             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Length of allocated heap in bytes </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                              <span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%03d</span><span class="Constant"> bit persistent heap </span><span class="Special">%d</span><span class="Constant"> [</span><span class="Special">%-32s</span><span class="Constant">], length </span><span class="Special">%016lx</span><span class="Constant"> created and attached at </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                  date,appl_name,appl_pid,appl_host,appl_owner,
                                                                                                                             htable[i].ptrsize,
                                                                                                                                             i,
                                                                                                                                    map_f_path,
                                                                                                             htable[i].edata - htable[i].sdata,
                                                                                                                               htable[i].sdata);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }


             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Initialise heap datastrutctures </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)initialize_heap(i);
             <span class="Statement">break</span>;
          }

          _phmaps_exist = TRUE;


          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Initialise heap datastructures </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)initialize_heap(i);

          <span class="Statement">if</span>(appl_verbose == TRUE)
	  {     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                              <span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%03d</span><span class="Constant"> bit persistent heap </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%-32s</span><span class="Constant">), length </span><span class="Special">%016lx</span><span class="Constant"> (segment </span><span class="Special">%016lx</span><span class="Constant">) attached at </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                       date,appl_name,appl_pid,appl_host,appl_owner,
                                                                                                                                  htable[i].ptrsize,
                                                                                                                                                  i,
                                                                                                                                         map_f_path,
                                                                                                                  htable[i].edata - htable[i].sdata,
                                                                                                          (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[i].segment_size,
						                                                                                    htable[i].sdata);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          <span class="Statement">break</span>;
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Persistent heap table full </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(i == appl_max_pheaps)
    {

<span class="PreProc">      #ifdef PTHREAD_SUPPORT</span>
      (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">      #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

      pups_set_errno(<span class="Constant">EACCES</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make addresses in persistent heap local  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to this process so we can access objects </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> located on it                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[i].addresses_local == FALSE)
       (<span class="Type">void</span>)msm_isync_heaptables(i);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(i);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Detach a persistent heap -- if flags | O_DESTROY the persistent heap is unlinked</span>
<span class="Comment">    and destroyed ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_heap_detach(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">int</span> flags)

{   <span class="Type">int</span>  i;
    <span class="Type">char</span> args[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &lt; <span class="Constant">0</span> || hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_heap_detach] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[hdes].fd == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Close mapping file (open of persistent heap is homeostatically protected) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_fd_islive(htable[hdes].fd) == TRUE)
       (<span class="Type">void</span>)pups_close(htable[hdes].fd);


    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                     <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): persistent heap </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%-32s</span><span class="Constant">), length </span><span class="Special">%016lx</span><span class="Constant"> (segment </span><span class="Special">%016lx</span><span class="Constant">) detached from </span><span class="Special">%016lx</span><span class="Constant"> virtual&quot;</span>,
                                                                                      date,appl_name,appl_pid,appl_host,appl_owner,
                                                                                                                              hdes,
                                                                                                                 htable[hdes].name,
                                                                                           htable[hdes].edata - htable[hdes].sdata,
                                                                                      (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[hdes].segment_size,
                                                                                                                htable[hdes].sdata);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Display details of pending destruction </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(flags &amp; O_DESTROY)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot; (destroyed)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make addresses global so they       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> can be mapped into the address      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> space of the next process attaching </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the heap                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)msm_sync_heaptables(hdes);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update of objects on persistent heaps happens </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> when an object is unlocked                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)msync((caddr_t)htable[hdes].addr,htable[hdes].segment_size,MS_SYNC | MS_INVALIDATE);
    (<span class="Type">void</span>)munmap((caddr_t)htable[hdes].addr,htable[hdes].segment_size);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unlock heap so other processes </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> can access it                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_lockf(htable[hdes].fd,PUPS_UNLOCK,<span class="Constant">0</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Close mapping file for heap </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_close(htable[hdes].fd);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No new clients can attach heap       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> once it is unlinked but existing     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> clients remain attached to its inode </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(flags &amp; O_DESTROY || htable[hdes].autodestruct == TRUE)
       (<span class="Type">void</span>)unlink(htable[hdes].name);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear entry in heap table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    htable[hdes].fd           = (-<span class="Constant">1</span>);
    htable[hdes].sdata        = <span class="Constant">0</span>;
    htable[hdes].edata        = <span class="Constant">0</span>;
    htable[hdes].segment_size = <span class="Constant">0</span>;
    htable[hdes].addr         = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    (<span class="Type">void</span>)strlcpy(htable[hdes].name,<span class="Constant">&quot;&quot;</span>,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    sbrk on the persistent heap whose heap descriptor is hdes - size extra bytes will be</span>
<span class="Comment">    mapped into the address spaces of the processes attached to the heap ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *msm_sbrk(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">size_t</span> size)

{   <span class="Type">void</span> *ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    <span class="Type">size_t</span> brk_core_size,
           brk_core_needed,
           old_segment_size;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &lt; <span class="Constant">0</span> || hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[hdes].fd == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do we need to mmap more resources into the address space of this </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> process?                                                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

    brk_core_size   = htable[hdes].edata - htable[hdes].sdata - <span class="Statement">sizeof</span>(<span class="Type">int</span>) + size;

    <span class="Statement">if</span>(brk_core_size &gt; htable[hdes].segment_size)
       brk_core_needed = brk_core_size -  htable[hdes].segment_size;
    <span class="Statement">else</span>
       brk_core_needed = <span class="Constant">0</span>;

    <span class="Statement">if</span>(brk_core_needed &gt; <span class="Constant">0</span>)
    {  <span class="Type">int</span> n_brk_segments;

       <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> seg_used;
       <span class="Type">void</span>              *old_addr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       <span class="Type">long</span>              offset    = <span class="Constant">0L</span>;

<span class="PreProc">       #ifdef PHEAP_DEBUG</span>
       print_heaptables(hdes,<span class="Constant">&quot;BEFORE EXTEND&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[hdes].addr);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get number of SBRK segments currently in use by this persistent heap </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

       seg_used = htable[hdes].edata - htable[hdes].sdata   - (<span class="Type">unsigned</span> <span class="Type">long</span>)<span class="Statement">sizeof</span>(<span class="Type">int</span>);


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extend backing store (file) object - note that we do this BEFORE </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> the heap is flushed so that the isync to pull the heap back into </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> local address space after remapping sees the adjusted segment    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> size                                                             </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

       old_segment_size          =  htable[hdes].segment_size;
       n_brk_segments            =  (<span class="Type">int</span>)ceil((<span class="Type">double</span>)brk_core_needed / (<span class="Type">double</span>)PHM_SBRK_SIZE);
       htable[hdes].segment_size += PHM_SBRK_SIZE*n_brk_segments;


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Flush local changes to persistent memory before brk extends persistent </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> memory segment                                                         </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remember that we must save the old mapping address in order to         </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> be able to update all pointers in the (possibly moved) mmap'ed         </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> persistent heap                                                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="PreProc">       #ifdef PHEAP_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;EXTEND BRK SEGMENT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)msm_sync_heaptables(hdes);
       (<span class="Type">void</span>)msync((caddr_t)htable[hdes].addr,old_segment_size,MS_SYNC | MS_INVALIDATE);
       (<span class="Type">void</span>)munmap((caddr_t)htable[hdes].addr,old_segment_size);


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extend backing store (file) object </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       n_brk_segments            =  (<span class="Type">int</span>)ceil((<span class="Type">double</span>)brk_core_needed / (<span class="Type">double</span>)PHM_SBRK_SIZE);
       htable[hdes].segment_size += PHM_SBRK_SIZE*n_brk_segments;

<span class="PreProc">       #ifdef PHEAP_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;msm_sbrk: EXTENDING MAPPED SEGMENT (by </span><span class="Special">%04d</span><span class="Constant"> brk segments = </span><span class="Special">%016lx</span><span class="Constant"> bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                          n_brk_segments,
                                                                            PHM_SBRK_SIZE*n_brk_segments);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extend memory object </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       htable[hdes].addr = (<span class="Type">void</span> *)mmap((caddr_t)htable[hdes].addr,
                                        (<span class="Type">size_t</span>)htable[hdes].segment_size,
                                        PROT_READ  | PROT_WRITE,
                                        MAP_SHARED,
                                        htable[hdes].fd,
                                        (<span class="Type">off_t</span>)offset);


       <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Adjust sbrk limits </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)msm_isync_heaptables(hdes);

<span class="PreProc">       #ifdef PHEAP_DEBUG</span>
      (<span class="Type">void</span>)fprint_heaptables(hdes,<span class="Constant">&quot;AFTER EXTEND&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[hdes].addr);
<span class="PreProc">      #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>
    }

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  ptr                        =  (<span class="Type">void</span> *)(htable[hdes].edata);
       htable[hdes].edata         += size;
    }
    <span class="Statement">else</span>
    {  htable[hdes].edata         -= size;
       ptr                        =  (<span class="Type">void</span> *)(htable[hdes].edata);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PHEAP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;msm_sbrk: heap </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%-32s</span><span class="Constant">) extended by </span><span class="Special">%016lx</span><span class="Constant"> bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,hdes,htable[hdes].name,size);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(ptr);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to stat a heap (in a similar manner to stat on a file) ...</span>
<span class="Comment">---------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_hstat(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, heap_type *heapinfo)


{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes&lt;<span class="Constant">0</span> || hdes &gt;= appl_max_pheaps            ||
       heapinfo       == (<span class="Type">const</span> heap_type *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[hdes].fd == (-<span class="Constant">1</span>))
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    *heapinfo = htable[hdes];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Find first free named persistent object slot in the map area ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_get_free_mapslot(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i,
        h_index;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
    {  <span class="Statement">if</span>(_phobjectmap[hdes][i] == (phobmap_type *)<span class="Constant">NULL</span>)
       {

<span class="PreProc">          #ifdef PHEAP_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;msm_get_free_mapslot: returned slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>

<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

         pups_set_errno(OK);
         <span class="Statement">return</span>(i);
       }
    }

    h_index                     =  _phobjects_allocated[hdes];
    _phobjects_allocated[hdes] += PHOBMAP_QUANTUM;
    <span class="Statement">if</span>((_phobjectmap[hdes] = (phobmap_type **)phrealloc(hdes,
                                                        (<span class="Type">void</span> *)_phobjectmap[hdes],
                                                        _phobjects_allocated[hdes],
                                                        <span class="Constant">&quot;address map&quot;</span>)) == (phobmap_type **)<span class="Constant">NULL</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ENOMEM</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=h_index; i&lt;_phobjects_allocated[hdes]; ++i)
       _phobjectmap[hdes][i] = (phobmap_type *)<span class="Constant">NULL</span>;

<span class="PreProc">    #ifdef PHEAP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;msm_get_free_mapslot: map table extended by </span><span class="Special">%d</span><span class="Constant"> slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PHOBMAP_QUANTUM);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(h_index);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Find mapped object (returning its index) ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_find_mapped_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes&lt;<span class="Constant">0</span> || hdes &gt;= appl_max_pheaps || ptr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

   <span class="Statement">if</span>(_no_phobject_mapping == <span class="Constant">1</span>)
   {

<span class="PreProc">      #ifdef PTHREAD_SUPPORT</span>
      (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">      #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

      pups_set_errno(<span class="Constant">EACCES</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

   <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
   {  <span class="Statement">if</span>(_phobjectmap[hdes][i] != (phobmap_type *)<span class="Constant">NULL</span> &amp;&amp;
         _phobjectmap[hdes][i]-&gt;addr == ptr             )
      {
<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

         pups_set_errno(OK);
         <span class="Statement">return</span>(i);
      }
   }

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

   pups_set_errno(<span class="Constant">ESRCH</span>);
   <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Add object to the persitent heap object map ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_map_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index, <span class="Type">const</span> <span class="Type">void</span> *ptr, <span class="Type">const</span> <span class="Type">char</span> *name)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps       ||
       name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       ptr  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity checks (heap statistics) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index &gt; _phobjects_allocated[hdes])
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    _no_phobject_mapping = <span class="Constant">1</span>;
    <span class="Statement">if</span>((_phobjectmap[hdes][h_index] = (phobmap_type *)phmalloc(hdes,<span class="Statement">sizeof</span>(phobmap_type),(<span class="Type">char</span> *)<span class="Constant">NULL</span>)) == (phobmap_type *)<span class="Constant">NULL</span>)
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ENOMEM</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Pointer to the object we have mapped </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    _no_phobject_mapping               = <span class="Constant">0</span>;
    _phobjectmap[hdes][h_index]-&gt;addr  = ptr;
    _phobjectmap[hdes][h_index]-&gt;size  = <span class="Constant">0</span>;

    <span class="Statement">if</span>(name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(_phobjectmap[hdes][h_index]-&gt;name,name,SSIZE);

    (<span class="Type">void</span>)strlcpy(_phobjectmap[hdes][h_index]-&gt;info,<span class="Constant">&quot;type unknown&quot;</span>,SSIZE);
    ++_phobjects[hdes];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Remove persisent object from object map ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_unmap_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes&lt;<span class="Constant">0</span> || hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check (heap statistics) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index &lt; <span class="Constant">0</span> || h_index &gt; _phobjects_allocated[hdes])
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(_phobjectmap[hdes][h_index] == (phobmap_type *)<span class="Constant">NULL</span>)
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    _phobjectmap[hdes][h_index]-&gt;addr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    (<span class="Type">void</span>)strlcpy(_phobjectmap[hdes][h_index]-&gt;name,<span class="Constant">&quot;&quot;</span>,SSIZE);
    --_phobjects[hdes];

    _no_phobject_mapping = <span class="Constant">1</span>;
    _phobjectmap[hdes][h_index] = (phobmap_type *)phfree(hdes,_phobjectmap[hdes][h_index]);
    _no_phobject_mapping = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent object name to index ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_map_objectname2index(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps || name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
    {  <span class="Statement">if</span>(_phobjectmap[hdes][i] != (phobmap_type *)<span class="Constant">NULL</span> &amp;&amp; strcmp(_phobjectmap[hdes][i]-&gt;name,name) == <span class="Constant">0</span>)
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent object address to index ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_map_objectaddr2index(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">void</span> *addr)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps || addr == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
    {  <span class="Statement">if</span>(_phobjectmap[hdes][i] != (phobmap_type *)<span class="Constant">NULL</span> &amp;&amp; _phobjectmap[hdes][i]-&gt;addr == addr)
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent object name to address ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *msm_map_objectname2addr(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span>  i;
    <span class="Type">void</span> *addr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps       ||
       name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
    {  <span class="Statement">if</span>(strcmp(_phobjectmap[hdes][i]-&gt;name,name) == <span class="Constant">0</span>)
       {  addr = _phobjectmap[hdes][i]-&gt;addr;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(addr);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent object index to name ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *map_objectindex2name(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index)

{   <span class="Type">char</span> *name = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check (persistent heap) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index &gt; _phobjects_allocated[hdes])
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(_phobjectmap[hdes][h_index]-&gt;addr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  name = _phobjectmap[hdes][h_index]-&gt;name;

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent object index to address ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *map_objectindex2addr(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index)

{   <span class="Type">void</span> *addr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check (persistent heap) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index &gt; _phobjects_allocated[hdes])
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get address </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(_phobjectmap[hdes][h_index]-&gt;addr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  addr = _phobjectmap[hdes][h_index]-&gt;addr;

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(addr);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Make sure that a mapname is unique ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_mapname_unique(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Statement">return</span>(msm_map_objectname2index(hdes,name));
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Set the info field for a mapped object ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_map_setinfo(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index, <span class="Type">const</span> <span class="Type">char</span> *info)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps    ||
       info == (<span class="Type">char</span> *)<span class="Constant">NULL</span>        )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check (persistent heap) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index&gt;_phobjects_allocated[hdes])
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)strlcpy(_phobjectmap[hdes][h_index]-&gt;info,info,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Set the size field for a mapped object ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_map_setsize(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index, <span class="Type">size_t</span> size)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check (persistent heap) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index&gt;_phobjects_allocated[hdes])
    {
<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    _phobjectmap[hdes][h_index]-&gt;size = size;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Display statistics of object on persistent heap ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_show_mapped_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> h_index, <span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">char</span> size_str[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         endian_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps || stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_show_mapped_object] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check (persistent heap) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(h_index &gt; _phobjects_allocated[hdes])
    {  pups_set_errno(<span class="Constant">ERANGE</span>);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(_phobjectmap[hdes][h_index]-&gt;addr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Size of mapped object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(_phobjectmap[hdes][h_index]-&gt;size != <span class="Constant">0</span>)
       (<span class="Type">void</span>)snprintf(size_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%016lx</span><span class="Constant"> bytes&quot;</span>,_phobjectmap[hdes][h_index]-&gt;size);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(size_str,SSIZE,<span class="Constant">&quot;unknown&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get endian-ness of hardware </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_bigendian() == TRUE)
       (<span class="Type">void</span>)strlcpy(endian_str,<span class="Constant">&quot;big endian&quot;</span>,SSIZE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(endian_str,<span class="Constant">&quot;little endian&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display details of object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    object                :  </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,      _phobjectmap[hdes][h_index]-&gt;name);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    object descriptor     :  </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,          h_index);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap                  :  </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,        msm_hdes2name(hdes));
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap descriptor       :  </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,          hdes);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    object information    :  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,            _phobjectmap[hdes][h_index]-&gt;info);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    pointer size          :  </span><span class="Special">%04d</span><span class="Constant"> bytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,    htable[hdes].ptrsize);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    pointer configuration :  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,            endian_str);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    object location       :  </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes][h_index]-&gt;addr);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    object size           :  </span><span class="Special">%016lx</span><span class="Constant"> bytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,_phobjectmap[hdes][h_index]-&gt;size);

    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Display objects on persistent heap ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_show_mapped_objects(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        objects = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps || stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_show_mapped_objects] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Persistent object map for heap </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                msm_hdes2name(hdes),
                                                               (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[hdes].addr);
    (<span class="Type">void</span>)fflush(stream);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display each mapped object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
    {  <span class="Statement">if</span>(_phobjectmap[hdes][i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       {  <span class="Type">char</span> size_str[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(_phobjectmap[hdes][i]-&gt;size != <span class="Constant">0</span>)
             (<span class="Type">void</span>)snprintf(size_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%016lx</span><span class="Constant"> bytes&quot;</span>,_phobjectmap[hdes][i]-&gt;size);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(size_str,SSIZE,<span class="Constant">&quot;unknown&quot;</span>);

          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: object </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> [</span><span class="Special">%-32s</span><span class="Constant">] at </span><span class="Special">%016lx</span><span class="Constant"> virtual [size </span><span class="Special">%-16s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                   i,
                                                                         _phobjectmap[hdes][i]-&gt;name,
                                                                         _phobjectmap[hdes][i]-&gt;info,
                                                      (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes][i]-&gt;addr,
                                                                                            size_str);
          (<span class="Type">void</span>)fflush(stream);

          ++objects;
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display number of atatched objects </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(objects == <span class="Constant">0</span>)
        (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    no mapped objects (</span><span class="Special">%04d</span><span class="Constant"> map slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,_phobjects_allocated[hdes]);
    <span class="Statement">else</span> <span class="Statement">if</span>(objects == <span class="Constant">1</span>)
        (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">   </span><span class="Special">%04d</span><span class="Constant"> mapped object (</span><span class="Special">%04d</span><span class="Constant"> map slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,_phobjects_allocated[hdes]);
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> mapped objects (</span><span class="Special">%04d</span><span class="Constant"> map slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,_phobjects[hdes],
                                                       _phobjects_allocated[hdes] - _phobjects[hdes]);
       (<span class="Type">void</span>)fflush(stream);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}






<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent heap hdes (heap descriptor) to name ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *msm_hdes2name(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes)

{

    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes &gt;= appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[hdes].addr != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(htable[hdes].name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">EACCES</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate persistent heap name to hdes (heap descriptor) ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_name2hdes(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {  <span class="Statement">if</span>(htable[i].fd != (-<span class="Constant">1</span>) &amp;&amp; strcmp(htable[i].name,name) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Make heap table addresses process local ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_isync_heaptables(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes)

{    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> offset;
     <span class="Type">char</span>          info[SSIZE] = <span class="Constant">&quot;&quot;</span>;


     <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(hdes &gt; appl_max_pheaps)
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Relocation offset (for persistent heap addresses) </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

     offset = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[hdes].addr;

     _pheap_parameters[hdes]      = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Statement">sizeof</span>(<span class="Type">long</span>)              + offset);


     _pheapindex[hdes]            = _pheap_parameters[hdes][<span class="Constant">0</span>];
     _pheap_bytes_used[hdes]      = _pheap_parameters[hdes][<span class="Constant">1</span>];
     _pheap_bytes_free[hdes]      = _pheap_parameters[hdes][<span class="Constant">2</span>];
     _pheap_chunks_used[hdes]     = _pheap_parameters[hdes][<span class="Constant">3</span>];
     _pheap_chunks_free[hdes]     = _pheap_parameters[hdes][<span class="Constant">4</span>];
     pheapsize[hdes]              = _pheap_parameters[hdes][<span class="Constant">5</span>];
     _pheaplimit[hdes]            = _pheap_parameters[hdes][<span class="Constant">6</span>];
     _pheapinfo[hdes]             = (malloc_info *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">7</span>]     + offset);
     _phobjects[hdes]             = _pheap_parameters[hdes][<span class="Constant">8</span>];
     _phobjects_allocated[hdes]   = _pheap_parameters[hdes][<span class="Constant">9</span>];
     _phobjectmap[hdes]           = (phobmap_type  **)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">10</span>] + offset);
     _pheapbase[hdes]             = (<span class="Type">char</span>           *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">11</span>] + offset);
     htable[hdes].sdata           = _pheap_parameters[hdes][<span class="Constant">15</span>]                                       + offset;
     htable[hdes].edata           = _pheap_parameters[hdes][<span class="Constant">16</span>]                                       + offset;
     htable[hdes].segment_size    = _pheap_parameters[hdes][<span class="Constant">17</span>];
     htable[hdes].heapmagic       = _pheap_parameters[hdes][<span class="Constant">18</span>];
     htable[hdes].ptrsize         = _pheap_parameters[hdes][<span class="Constant">20</span>];


     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Map all addresses in persistent memory into the address space of the the </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> current process                                                          </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)msm_relocate_heap_addresses(hdes,offset,ADD_OFFSET);

<span class="PreProc">     #ifdef PHEAP_DEBUG</span>
     (<span class="Type">void</span>)snprintf(info,SSIZE,<span class="Constant">&quot;hdes </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">): persistent heap tables inversely sychronised&quot;</span>,hdes,htable[hdes].name);
     print_heaptables(hdes,info,offset);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Record of heap address mode </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

     htable[hdes].addresses_local = TRUE;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     pups_set_errno(OK);
     <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Make heap table addresses global ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_sync_heaptables(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes)

{    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> offset;
     <span class="Type">char</span>              info[SSIZE] = <span class="Constant">&quot;&quot;</span>;


     <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(hdes &gt; appl_max_pheaps)
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Compute offset between global and local process address spaces </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

     offset = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[hdes].addr;


     <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Map heap parameter table addresses into global address space   </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> of persistent heap                                             </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

     _pheap_parameters[hdes][<span class="Constant">0</span>]    = _pheapindex[hdes];
     _pheap_parameters[hdes][<span class="Constant">1</span>]    = _pheap_bytes_used[hdes];
     _pheap_parameters[hdes][<span class="Constant">2</span>]    = _pheap_bytes_free[hdes];
     _pheap_parameters[hdes][<span class="Constant">3</span>]    = _pheap_chunks_used[hdes];
     _pheap_parameters[hdes][<span class="Constant">4</span>]    = _pheap_chunks_free[hdes];
     _pheap_parameters[hdes][<span class="Constant">5</span>]    = pheapsize[hdes];
     _pheap_parameters[hdes][<span class="Constant">6</span>]    = _pheaplimit[hdes];
     _pheap_parameters[hdes][<span class="Constant">7</span>]    = (<span class="Type">long</span> <span class="Type">int</span>)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheapinfo[hdes]     - offset);
     _pheap_parameters[hdes][<span class="Constant">8</span>]    = _phobjects[hdes];
     _pheap_parameters[hdes][<span class="Constant">9</span>]    = _phobjects_allocated[hdes];
     _pheap_parameters[hdes][<span class="Constant">10</span>]   = (<span class="Type">long</span> <span class="Type">int</span>)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes]   - offset);
     _pheap_parameters[hdes][<span class="Constant">11</span>]   = (<span class="Type">long</span> <span class="Type">int</span>)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheapbase[hdes]     - offset);
     _pheap_parameters[hdes][<span class="Constant">15</span>]   = htable[hdes].sdata                                 - offset;
     _pheap_parameters[hdes][<span class="Constant">16</span>]   = htable[hdes].edata                                 - offset;
     _pheap_parameters[hdes][<span class="Constant">17</span>]   = htable[hdes].segment_size;
     _pheap_parameters[hdes][<span class="Constant">18</span>]   = htable[hdes].heapmagic;
     _pheap_parameters[hdes][<span class="Constant">19</span>]   = appl_vtag;
     _pheap_parameters[hdes][<span class="Constant">20</span>]   = <span class="Statement">sizeof</span>(<span class="Type">void</span> *)*<span class="Constant">8</span>;


     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Map process addresses into global address space of persistent heap </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)msm_relocate_heap_addresses(hdes,offset,SUBTRACT_OFFSET);


<span class="PreProc">     #ifdef PHEAP_DEBUG </span>
     (<span class="Type">void</span>)snprintf(info,SSIZE,<span class="Constant">&quot;hdes </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">): persistent heap tables sychronised&quot;</span>,hdes,htable[hdes].name);
     print_heaptables(hdes,info,offset);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Record addressing mode </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

     _pheap_parameters[hdes][<span class="Constant">14</span>]  = FALSE;
     htable[hdes].addresses_local = FALSE;

     _pheap_parameters[hdes]     = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Statement">sizeof</span>(<span class="Type">long</span>) - offset);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     pups_set_errno(OK);
     <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Display heap information ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_print_heaptables(<span class="Type">const</span> <span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">char</span> *info, <span class="Type">const</span> <span class="Type">size_t</span> offset)

{

     <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span> || hdes&gt;appl_max_pheaps || offset == <span class="Constant">0</span>)
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }


<span class="PreProc">     #ifndef PHEAP_DEBUG</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
        pups_error(<span class="Constant">&quot;[msm_print_heaptables] attempt by non root thread to perform PUPS/P3 persistent heap operation&quot;</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,info);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    hdes </span><span class="Special">%04d</span><span class="Constant"> address table at </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,hdes,offset);

     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap index        : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">0</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    bytes used        : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">1</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    bytes free        : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">2</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    chunks used       : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">3</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    chunks free       : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">4</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap size         : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">5</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap limit        : </span><span class="Special">%08ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      _pheap_parameters[hdes][<span class="Constant">6</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap info         : </span><span class="Special">%010x</span><span class="Special">\n</span><span class="Constant">&quot;</span>,      (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">7</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap objects      : </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,       _pheap_parameters[hdes][<span class="Constant">8</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap object slots : </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,       _pheap_parameters[hdes][<span class="Constant">9</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap object table : </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">10</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap base         : </span><span class="Special">%016lx</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,   (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">11</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap clients      : </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,       _pheap_parameters[hdes][<span class="Constant">12</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap client slots : </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,       _pheap_parameters[hdes][<span class="Constant">13</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap client table : </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">14</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap base         : </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">15</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap top          : </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">16</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap segment size : </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">17</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heapmagic         : </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">18</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap vtag         : </span><span class="Special">%04d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,       (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">19</span>]);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    heap address size : </span><span class="Special">%04d</span><span class="Constant"> (bits)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_pheap_parameters[hdes][<span class="Constant">20</span>]);
     (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     pups_set_errno(OK);
     <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Relocate persistent heap (after munmap/mmap extension remapping) ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> msm_relocate_heap_addresses(<span class="Type">int</span> hdes, <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> offset, <span class="Type">int</span> offset_op)

{   <span class="Type">int</span>  i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hdes   &lt;  <span class="Constant">0</span>                                                ||
       hdes   &gt;  appl_max_pheaps                                  ||
       offset == <span class="Constant">0</span>                                                ||
      (offset_op != SUBTRACT_OFFSET &amp;&amp; offset_op != ADD_OFFSET)    )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PHEAP_DEBUG</span>
    <span class="Statement">if</span>(offset_op == ADD_OFFSET)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    heap </span><span class="Special">%04d</span><span class="Constant"> mapped into process memory map at </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,hdes,offset);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    heap </span><span class="Special">%04d</span><span class="Constant"> unmapped to global address map</span><span class="Special">\n</span><span class="Constant">&quot;</span>,hdes);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Relocate all pointer addresses with the persistent heap map </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(_phobjectmap[hdes] != (phobmap_type **)<span class="Constant">NULL</span>)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
       {  <span class="Statement">if</span>(_phobjectmap[hdes][i] != (phobmap_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>(offset_op == ADD_OFFSET)
             {  <span class="Statement">if</span>(_phmaps_exist == TRUE)
                {  _phobjectmap[hdes][i]       = (phobmap_type *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes][i] + offset);
                   _phobjectmap[hdes][i]-&gt;addr = (<span class="Type">void</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes][i]-&gt;addr   + offset);
                }
             }
             <span class="Statement">else</span>
             {  _phobjectmap[hdes][i]-&gt;addr = (<span class="Type">void</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes][i]-&gt;addr   - offset);
                _phobjectmap[hdes][i]       = (phobmap_type *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phobjectmap[hdes][i] - offset);
             }
          }
       }

       <span class="Statement">if</span>(_phmaps_exist == FALSE)
          _phmaps_exist = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Adjust free block lists </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(offset_op == ADD_OFFSET &amp;&amp; htable[hdes].addresses_local == FALSE)
       global_to_local_blocklist(hdes, offset);
    <span class="Statement">else</span>
       local_to_global_blocklist(hdes, offset);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert free block list from global to local addressing  ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> global_to_local_blocklist(<span class="Type">int</span> hdes, <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> offset)

{   <span class="Type">int</span>    i;
    <span class="Type">struct</span> list *next = (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>;

    _BOOLEAN fraghead_address;


    <span class="Statement">if</span>(htable[hdes].addresses_local == TRUE)
       <span class="Statement">return</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Relocate all free block pointers </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;BLOCKLOG; ++i)
    {  next             = _phfraghead[hdes][i].next;
       fraghead_address = TRUE;

       <span class="Statement">if</span>(next != (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>)
       {  next = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)next + offset);

          <span class="Statement">if</span>(fraghead_address == TRUE)
          {  _phfraghead[hdes][i].next = next;

<span class="PreProc">             #ifdef PHEAP_DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;log: </span><span class="Special">%04d</span><span class="Constant"> pointer </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phfraghead[hdes][i].next);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>
          }


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> &quot;walk&quot; the free block list relocating its addresses </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">while</span>(next-&gt;next != (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>)
          {  next-&gt;next = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)next-&gt;next + offset);

             <span class="Statement">if</span>(next-&gt;prev != (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>)
             {  <span class="Statement">if</span>(fraghead_address == TRUE)
                {  <span class="Comment">//next-&gt;prev-&gt;next = next + offset;</span>
                   fraghead_address = FALSE;
                }
                <span class="Statement">else</span>
                   next-&gt;prev = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)next-&gt;prev + offset);
             }


             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Step to next free block in list </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             next = next-&gt;next;
          }
       }
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert free block list from local to global addressing  ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> local_to_global_blocklist(<span class="Type">int</span> hdes, <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> offset)

{   <span class="Type">int</span>    i;
    <span class="Type">struct</span> list *next = (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>,
                *step = (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>;

    _BOOLEAN    fraghead_address;

    <span class="Statement">if</span>(htable[hdes].addresses_local == FALSE)
       <span class="Statement">return</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Relocate all free block pointers </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;BLOCKLOG; ++i)
    {  next             = _phfraghead[hdes][i].next;
       fraghead_address = TRUE;

       <span class="Statement">if</span>(next != (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> &quot;walk&quot; the free block list relocating its addresses </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">while</span>(next-&gt;next != (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>)
          {
             step       = next-&gt;next;
             next-&gt;next = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)next-&gt;next - offset);

             <span class="Statement">if</span>(next-&gt;prev != (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>)
             {  <span class="Statement">if</span>(fraghead_address == TRUE)
                   next-&gt;prev-&gt;next = next - offset;
                <span class="Statement">else</span>
                   next-&gt;prev = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)next-&gt;prev - offset);
             }


             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Step to next free block in list </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             next = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span>)next - offset);

             <span class="Statement">if</span>(fraghead_address == TRUE)
             {  fraghead_address = FALSE;
                _phfraghead[hdes][i].next = next;

<span class="PreProc">                #ifdef PHEAP_DEBUG </span>
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;log: </span><span class="Special">%04d</span><span class="Constant"> pointer </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phfraghead[hdes][i].next);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>
             }
             next = step;
          }


          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Special case if the fraghead is also the end of </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> the linked list                                 </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(fraghead_address == TRUE)
          {  _phfraghead[hdes][i].next = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)next - offset);

<span class="PreProc">             #ifdef PHEAP_DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;log: </span><span class="Special">%04d</span><span class="Constant"> pointer </span><span class="Special">%016lx</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)_phfraghead[hdes][i].next);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PHEAP_DEBUG </span><span class="Comment">*/</span>
          }
       }
    }
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Persistent heap exit function (which detaches any persistent heaps) ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> msm_exit(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> flags)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[msm_exit] attempt by non root thread to perform PUPS/P3 global persistent heap operation&quot;</span>);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): detaching persistent heaps</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {  <span class="Statement">if</span>(msm_heap_detach(i,flags) == <span class="Constant">0</span>)
          ++cnt;
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  <span class="Statement">if</span>(cnt &gt; <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> persistent heaps detached</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner,cnt);
       <span class="Statement">else</span> <span class="Statement">if</span>(cnt == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): 1 persistent heap detached</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): no persistent heaps to detach</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if an object already exists ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN msm_phobject_exists(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(hdes &lt;  <span class="Constant">0</span>                ||
       hdes &gt;= appl_max_pheaps  ||
       name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>      )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[hdes].addresses_local == FALSE)
       (<span class="Type">void</span>)msm_isync_heaptables(hdes);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;_phobjects_allocated[hdes]; ++i)
    {  <span class="Statement">if</span>(_phobjectmap[hdes]    != (phobmap_type **)<span class="Constant">NULL</span>    &amp;&amp;
          _phobjectmap[hdes][i] != (phobmap_type *) <span class="Constant">NULL</span>    &amp;&amp;
          strcmp(_phobjectmap[hdes][i]-&gt;name,name) == <span class="Constant">0</span>      )
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(TRUE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Make sure heap addresses are in either absolute (local) or relative ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_map_address_mode(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> mode)

{

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(htable[hdes].fd == (-<span class="Constant">1</span>)                             ||
       hdes            &lt; <span class="Constant">0</span>                                 ||
       hdes            &gt;= appl_max_pheaps                  ||
       (mode != PHM_MAP_LOCAL &amp;&amp; mode != PHM_MAP_GLOBAL)    )
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(htable[hdes].addresses_local == TRUE &amp;&amp; mode == PHM_MAP_GLOBAL)
       (<span class="Type">void</span>)msm_sync_heaptables(hdes);
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(htable[hdes].addresses_local == FALSE &amp;&amp; mode == PHM_MAP_LOCAL)
          (<span class="Type">void</span>)msm_isync_heaptables(hdes);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate heap name to heap table index ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_name2index(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {  <span class="Statement">if</span>(htable[i].fd != (-<span class="Constant">1</span>) &amp;&amp; strcmp(htable[i].name,name) == <span class="Constant">0</span>)
       {  pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Translate heap fdes to heap table index ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_fdes2hdes(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(fdes &gt;= appl_max_files)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {  <span class="Statement">if</span>(htable[i].fd == fdes)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if an address lies within persistent heap ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN msm_addr_in_heap(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> addr;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ptr  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   ||
       hdes &gt;= appl_max_pheaps       )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    addr = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)ptr;
    <span class="Statement">if</span>(addr &lt; htable[hdes].sdata || addr &gt; htable[hdes].edata)
    {

<span class="PreProc">      #ifdef PTHREAD_SUPPORT</span>
      (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">      #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(FALSE);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Resolve address pointer on persistent heap into address space of calling process ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *msm_map_haddr_to_paddr(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> addr;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ptr  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>    ||
       hdes &gt;= appl_max_pheaps        )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    addr = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)ptr;


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that address is valid </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(addr &gt; (htable[hdes].edata - htable[hdes].sdata))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Convert address from (global) heap address space to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (local) process address space                       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    ptr = (<span class="Type">void</span> *)(htable[hdes].sdata + addr);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ptr);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Resolve address pointer on persistent heap into address space of calling process ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *msm_map_paddr_to_haddr(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> addr;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ptr  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>    ||
       hdes &gt;= appl_max_pheaps        )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    addr = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)ptr;


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that address is valid </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(addr &lt; htable[hdes].edata || addr &gt;  htable[hdes].sdata)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Convert address from (global) heap address space to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (local) process address space                       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    ptr = (<span class="Type">void</span> *)(htable[hdes].sdata - addr);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ptr);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Save heap state (Criu state save support routine) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> msm_save_heapstate(<span class="Type">const</span> <span class="Type">char</span> *ssave_dir)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ssave_dir == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save any (attached) heaps </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {  <span class="Statement">if</span>(htable[i].fd != (-<span class="Constant">1</span>))
       {  <span class="Type">char</span> ssave_pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)snprintf(ssave_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssave_dir,htable[i].name);
          (<span class="Type">void</span>)pups_copy_file(PUPS_FILE_COPY, htable[i].name,ssave_pathname);
       }
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span>
<span class="Comment">     Allocate memory on a page boundary.</span>
<span class="Comment">     Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.</span>

<span class="Comment">     This library is free software; you can redistribute it and/or</span>
<span class="Comment">     modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">     published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">     License, or (at your option) any later version.</span>

<span class="Comment">     This library is distributed in the hope that it will be useful,</span>
<span class="Comment">     but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">     Library General Public License for more details.</span>

<span class="Comment">     You should have received a copy of the GNU Library General Public</span>
<span class="Comment">     License along with this library; see the file COPYING.LIB.  If</span>
<span class="Comment">     not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">     Cambridge, MA 02139, USA.</span>

<span class="Comment">     The author may be reached (Email) at the address mike@ai.mit.edu,</span>
<span class="Comment">     or (US mail) as Mike Haertel c/o Free Software Foundation.</span>

<span class="Comment">     Shared heap modifications by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">     (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifndef GLIBC</span>
<span class="PreProc">#if defined (__GNU_LIBRARY__) || defined (_LIBC)</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stddef.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/cdefs.h&gt;</span>
<span class="Type">extern</span> <span class="Type">size_t</span> __getpagesize __P ((<span class="Type">void</span>));
<span class="PreProc">#else</span>
<span class="PreProc">#define	 __getpagesize()	getpagesize()</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> defined (__GNU_LIBRARY__) || defined (_LIBC) </span><span class="Comment">*/</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> GLIBC                                        </span><span class="Comment">*/</span>


<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>
<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>


_PRIVATE __malloc_size_t pagesize;

_PUBLIC __ptr_t phvalloc (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> __malloc_size_t size, <span class="Type">const</span> <span class="Type">char</span> *name)
{

  <span class="Statement">if</span>(pagesize == <span class="Constant">0</span>)
    pagesize = __getpagesize();

  <span class="Statement">return</span> phmemalign (hdes, pagesize, size, name);
}
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">   Memory allocator `phmalloc'.</span>
<span class="Comment">   Copyright 1990, 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.</span>
<span class="Comment">		  Written May 1989 by Mike Haertel.</span>

<span class="Comment">   This library is free software; you can redistribute it and/or</span>
<span class="Comment">   modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">   published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">   License, or (at your option) any later version.</span>

<span class="Comment">   This library is distributed in the hope that it will be useful,</span>
<span class="Comment">   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">   Library General Public License for more details.</span>

<span class="Comment">   You should have received a copy of the GNU Library General Public</span>
<span class="Comment">   License along with this library; see the file COPYING.LIB.  If</span>
<span class="Comment">   not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">   Cambridge, MA 02139, USA.</span>

<span class="Comment">   The author may be reached (Email) at the address mike@ai.mit.edu,</span>
<span class="Comment">   or (US mail) as Mike Haertel c/o Free Software Foundation.</span>

<span class="Comment">   Persistent heap modifications by Mark O'Neill (mao@tumblingdice.co.uk) </span>
<span class="Comment">   (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define _PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Signifies whether heap addresses are local or heap global </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span> addresses_local;

<span class="Comment">// Heap table (for local process)</span>
_IMPORT heap_type *htable;

<span class="Comment">// How to really get more memory</span>
__ptr_t (*__phmorecore) __P ((<span class="Type">int</span>, <span class="Type">ptrdiff_t</span> __size)) = __default_phmorecore;

<span class="Comment">// Debugging hook for `malloc'</span>
__ptr_t (*__phmalloc_hook) __P ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, __malloc_size_t __size, <span class="Type">const</span> <span class="Type">char</span> *));

<span class="Comment">//Number of objects in heap</span>
_IMPORT <span class="Type">int</span> *_phobjects;

<span class="Comment">// Number of objects slots in heap</span>
_IMPORT <span class="Type">int</span> *_phobjects_allocated;

<span class="Comment">// Pointer to table of significant objects on persistent heaps</span>
_IMPORT phobmap_type ***_phobjectmap;

<span class="Comment">// Pointer to persistent heap parameter table (on persistent heap)</span>
_IMPORT <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> **_pheap_parameters;

<span class="Comment">// Pointer to the base of the first block.  */</span>
_IMPORT <span class="Type">char</span> **_pheapbase;

<span class="Comment">// Block information table.  Allocated with align/__free (not malloc/free)</span>
_IMPORT malloc_info **_pheapinfo;

<span class="Comment">// Number of info entries</span>
_IMPORT __malloc_size_t *pheapsize;

<span class="Comment">// Search index in the info table</span>
_IMPORT __malloc_size_t *_pheapindex;

<span class="Comment">// Limit of valid info table indices</span>
_IMPORT __malloc_size_t *_pheaplimit;

<span class="Comment">// Free lists for each fragment size</span>
_IMPORT <span class="Type">struct</span> list **_phfraghead;



<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add persistent object to persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_map_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> intint, <span class="Type">const</span> <span class="Type">void</span> *, <span class="Type">const</span> <span class="Type">char</span> *);


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove persistent object from persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_unmap_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Instrumentation </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

_IMPORT __malloc_size_t *_pheap_chunks_used;
_IMPORT __malloc_size_t *_pheap_bytes_used;
_IMPORT __malloc_size_t *_pheap_chunks_free;
_IMPORT __malloc_size_t *_pheap_bytes_free;


<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Are you experienced? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span> *__phmalloc_initialized;

<span class="Type">void</span> (*__malloc_initialize_hook) __P ((<span class="Type">int</span>));
<span class="Type">void</span> (*__after_phmorecore_hook) __P ((<span class="Type">void</span>));


<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set everything up and remember that we have </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> initialize __P ((<span class="Type">int</span>));


<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Aligned allocation </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PRIVATE  __ptr_t align __P ((<span class="Type">int</span>, __malloc_size_t));
_PRIVATE  __ptr_t align (<span class="Type">int</span> hdes, __malloc_size_t size)
{
  __ptr_t result;
  <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> adj;

  result = (*__phmorecore) (hdes, size);
  adj = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>) ((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>) ((<span class="Type">char</span> *) result -
						  (<span class="Type">char</span> *) <span class="Constant">NULL</span>)) % BLOCKSIZE;
  <span class="Statement">if</span> (adj != <span class="Constant">0</span>)
  {
      adj = BLOCKSIZE - adj;
      (<span class="Type">void</span>) (*__phmorecore) (hdes, adj);
      result = (<span class="Type">char</span> *) result + adj;
  }

  <span class="Statement">if</span>(__after_phmorecore_hook)
     (*__after_phmorecore_hook) ();

  <span class="Statement">return</span> result;
}


<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Heap initialisation - called by heap_attach function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> initialize_heap __P ((<span class="Type">int</span>));
_PUBLIC <span class="Type">int</span> initialize_heap (<span class="Type">int</span> hdes)
{
<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Is heap initialised </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span> (!initialize (hdes))
     {
<span class="PreProc">        #ifdef PTHREAD_SUPPORT</span>
        (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

        <span class="Statement">return</span> (-<span class="Constant">1</span>);
     }


     <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Heap is not initialised </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

     <span class="Statement">else</span> <span class="Statement">if</span>(htable[hdes].exists == FALSE)
     {  <span class="Type">int</span> i;


        <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Create mapped object table </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

        _phobjectmap[hdes]   = (phobmap_type **)phmalloc(hdes,PHOBMAP_QUANTUM*<span class="Statement">sizeof</span>(phobmap_type **),
                                                                                         (<span class="Type">char</span> *)<span class="Constant">NULL</span>);


        <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Initialise the first set of entries in the object table </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PHOBMAP_QUANTUM; ++i)
           _phobjectmap[hdes][i] = (phobmap_type *)<span class="Constant">NULL</span>;


        <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Heap root is always first persistent object </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)msm_map_object(hdes,<span class="Constant">0</span>,(<span class="Type">void</span> *)htable[hdes].sdata,htable[hdes].name);
        (<span class="Type">void</span>)msm_map_setinfo(hdes,<span class="Constant">0</span>,<span class="Constant">&quot;persistent heap root&quot;</span>);
        (<span class="Type">void</span>)msm_map_setsize(hdes,<span class="Constant">0</span>,htable[hdes].segment_size);


        <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Messy - but we must adjust the start and end of heap   </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> pointers to prepare for the first msm_isync_heaptables </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

        htable[hdes].addresses_local = TRUE;
        (<span class="Type">void</span>)msm_sync_heaptables(hdes);
     }

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> <span class="Constant">0</span>;
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set everything up and remember that we have. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> initialize (<span class="Type">int</span> hdes)
{

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> If we are importing a persistent heap which already exists                 </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> we need to pull all of the parameters required by the                      </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> memory allocator from the persistent heap. Mark O'Neill 14th November 1997 </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(htable[hdes].exists == FALSE)
  {

     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Before doing anything else grab some memory on the persistent heap to </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> store parameters. Mark O'Neill 14th November 1997                     </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

     _pheap_parameters[hdes] = msm_sbrk (hdes, N_PARAMETERS*<span class="Statement">sizeof</span>(<span class="Type">long</span>));

     <span class="Statement">if</span> (__malloc_initialize_hook)
        (*__malloc_initialize_hook) (hdes);

     pheapsize[hdes] = HEAP / BLOCKSIZE;
     _pheapinfo[hdes] = (malloc_info *) align (hdes, pheapsize[hdes] * <span class="Statement">sizeof</span> (malloc_info));
     <span class="Statement">if</span> (_pheapinfo[hdes] == <span class="Constant">NULL</span>)
     {
<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

         <span class="Statement">return</span> <span class="Constant">0</span>;
     }

     (<span class="Type">void</span>)memset (_pheapinfo[hdes], <span class="Constant">0</span>, pheapsize[hdes] * <span class="Statement">sizeof</span> (malloc_info));

     _pheapinfo[hdes][<span class="Constant">0</span>].free.size = <span class="Constant">0</span>;
     _pheapinfo[hdes][<span class="Constant">0</span>].free.next = _pheapinfo[hdes][<span class="Constant">0</span>].free.prev = <span class="Constant">0</span>;
     _pheapindex[hdes]             = <span class="Constant">0</span>;
     _pheapbase[hdes]              = (<span class="Type">char</span> *) _pheapinfo[hdes];


     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Account for the _pheapinfo block itself in the statistics </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

     _pheap_bytes_used[hdes]  = pheapsize[hdes] * <span class="Statement">sizeof</span> (malloc_info) + <span class="Constant">8</span>*<span class="Statement">sizeof</span>(<span class="Type">int</span>);
     _pheap_chunks_used[hdes] = <span class="Constant">1</span>;

     _phobjects[hdes]           = <span class="Constant">0</span>;
     _phobjects_allocated[hdes] = PHOBMAP_QUANTUM;


     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Messy - but we must adjust the start and end of heap   </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> pointers to prepare for the first msm_isync_heaptables </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

     <span class="Comment">//htable[hdes].addresses_local = TRUE;     </span>
     <span class="Comment">//(void)msm_sync_heaptables(hdes);</span>
   }



   <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Simply restore existing parameters from persistent heap </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> heap. Mark O'Neill, 14th November 1997                  </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

   <span class="Statement">else</span>
   {

      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> We could have a problem here - if the heap has been extended        </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> (and is bigger than PHM_SBRK_SIZE bytes) we will need to munmap it  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> and then remap it (possibly moving heap to a new location in the    </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> process address space                                               </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

      _pheap_parameters[hdes] = (<span class="Type">void</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span>)htable[hdes].addr + <span class="Statement">sizeof</span>(<span class="Type">long</span>));
      htable[hdes].segment_size   = _pheap_parameters[hdes][<span class="Constant">17</span>];
      <span class="Statement">if</span>(htable[hdes].segment_size &gt; PHM_SBRK_SIZE)
      {

         (<span class="Type">void</span>)msync((caddr_t)htable[hdes].addr,(<span class="Type">size_t</span>)PHM_SBRK_SIZE,MS_SYNC | MS_INVALIDATE);

         (<span class="Type">void</span>)munmap((caddr_t)htable[hdes].addr,(<span class="Type">size_t</span>)PHM_SBRK_SIZE);
         htable[hdes].addr = (<span class="Type">void</span> *)mmap((caddr_t)htable[hdes].addr,
                                          (<span class="Type">size_t</span>)htable[hdes].segment_size,
                                          PROT_READ | PROT_WRITE,
                                          MAP_SHARED,
                                          htable[hdes].fd,
                                          (<span class="Type">off_t</span>)<span class="Constant">0</span>);


         <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Make addresses local if nessessary </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

         <span class="Statement">if</span>(!htable[hdes].addresses_local)
            (<span class="Type">void</span>)msm_isync_heaptables(hdes);

<span class="PreProc">#ifdef PHMALLOC_DEBUG</span>
         (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;initialize: persistent heap </span><span class="Special">%d</span><span class="Constant"> dynamically remapped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,hdes);
         (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PHMALLOC_DEBUG </span><span class="Comment">*/</span>

      }
      <span class="Statement">else</span>
      {

         <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Make addresses local if nessessary </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

         <span class="Statement">if</span>(!htable[hdes].addresses_local)
            (<span class="Type">void</span>)msm_isync_heaptables(hdes);
      }
   }

   __phmalloc_initialized[hdes] = <span class="Constant">1</span>;

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

   <span class="Statement">return</span> <span class="Constant">1</span>;
}


<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get neatly aligned memory, initializing or </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> growing the heap info table as necessary.  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE __ptr_t phmorecore __P ((<span class="Type">int</span>, __malloc_size_t));
_PRIVATE __ptr_t phmorecore (<span class="Type">int</span> hdes, __malloc_size_t size)
{
  __ptr_t result;

  malloc_info *newinfo = (malloc_info *)<span class="Constant">NULL</span>,
              *oldinfo = (malloc_info *)<span class="Constant">NULL</span>;

  __malloc_size_t newsize;

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  result = align (hdes, size);
  <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)
  {
<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> (__ptr_t*)<span class="Constant">NULL</span>;
  }

  <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Check if we need to grow the info table </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span> ((__malloc_size_t) BLOCK (hdes, (<span class="Type">char</span> *) result + size) &gt; pheapsize[hdes])
  {
      newsize = pheapsize[hdes];
      <span class="Statement">while</span> ((__malloc_size_t) BLOCK (hdes, (<span class="Type">char</span> *) result + size) &gt; newsize)
      {

<span class="PreProc">#ifdef PHMALLOC_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BLOCK: </span><span class="Special">%0x%010x</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(__malloc_size_t)BLOCK (hdes, (<span class="Type">char</span> *) result + size));
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PHMALLOC_DEBUG </span><span class="Comment">*/</span>

	newsize *= <span class="Constant">2</span>;
      }

      newinfo = (malloc_info *) align (hdes, newsize * <span class="Statement">sizeof</span> (malloc_info));
      <span class="Statement">if</span> (newinfo == <span class="Constant">NULL</span>)
      {
	  (*__phmorecore) (hdes, -size);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

	  <span class="Statement">return</span> (__ptr_t*)<span class="Constant">NULL</span>;
      }

      (<span class="Type">void</span>)memcpy (newinfo, _pheapinfo[hdes], pheapsize[hdes] * <span class="Statement">sizeof</span> (malloc_info));
      (<span class="Type">void</span>)memset (&amp;newinfo[pheapsize[hdes]], <span class="Constant">0</span>, (newsize - pheapsize[hdes]) * <span class="Statement">sizeof</span> (malloc_info));

      oldinfo = _pheapinfo[hdes];
      newinfo[BLOCK (hdes, oldinfo)].busy.type = <span class="Constant">0</span>;
      newinfo[BLOCK (hdes, oldinfo)].busy.info.size = BLOCKIFY (pheapsize[hdes] * <span class="Statement">sizeof</span> (malloc_info));
      _pheapinfo[hdes] = newinfo;


      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Account for the _pheapinfo block itself in the statistics </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

      _pheap_bytes_used[hdes] += newsize * <span class="Statement">sizeof</span> (malloc_info);
      ++_pheap_chunks_used[hdes];
      _phfree_internal (hdes, oldinfo);
      pheapsize[hdes] = newsize;
    }


  _pheaplimit[hdes] = BLOCK (hdes, (<span class="Type">char</span> *) result + size);

<span class="PreProc">#ifdef PHMALLOC_DEBUG</span>
  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;MORECORE BLOCK: </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,_pheaplimit[hdes],BLOCK (hdes, (<span class="Type">char</span> *)result));
  (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PHMALLOC_DEBUG </span><span class="Comment">*/</span>

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">return</span> result;
}


<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Allocate memory from (persistent) heap. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC __ptr_t phmalloc (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, __malloc_size_t  size, <span class="Type">const</span> <span class="Type">char</span> *name)
{ <span class="Type">int</span>             h_index;
  __ptr_t         result;
  __malloc_size_t block, blocks, lastblocks, start, req_size, i;
  <span class="Type">struct</span> list     *next = (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>;

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Before we do anything else, check whether we have a valid persistent heap descriptor </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(hdes &gt; appl_max_pheaps || htable[hdes].addr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
  {  errno = <span class="Constant">EACCES</span>;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> (__ptr_t*)<span class="Constant">NULL</span>;
  }


  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Does this persistent object already exits? If so, we cannot allocate it! </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(name != (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; msm_phobject_exists(hdes,name))
  {  errno = <span class="Constant">EEXIST</span>;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span>((__ptr_t *)<span class="Constant">NULL</span>);
  }


  <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> ANSI C allows `malloc (0)' to either return NULL, or to return a </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> valid address you can realloc and free (though not dereference). </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#if	0</span>
<span class="Comment">  if (size == 0)</span>
<span class="Comment">  {</span>
<span class="Comment">     #ifdef PTHREAD_SUPPORT</span>
<span class="Comment">     (void)pthread_mutex_unlock(&amp;htab_mutex);</span>
<span class="Comment">     #endif</span><span class="Comment"> /* PTHREAD_SUPPORT */</span>

<span class="Comment">     return (__ptr_t*)NULL;</span>
<span class="Comment">  }</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> 0 </span><span class="Comment">*/</span>


  <span class="Statement">if</span> (__phmalloc_hook != <span class="Constant">NULL</span>)
  {  result = (*__phmalloc_hook) (hdes, size, name);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> result;
  }

  req_size = size;


  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Does this persistent object already exits? If so, we cannot allocate it! </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(name != (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; msm_phobject_exists(hdes,name))
  {  errno = <span class="Constant">EEXIST</span>;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span>((__ptr_t *)<span class="Constant">NULL</span>);
  }

   <span class="Statement">if</span> (size &lt; <span class="Statement">sizeof</span> (<span class="Type">struct</span> list))
      size = <span class="Statement">sizeof</span> (<span class="Type">struct</span> list);


  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Determine the allocation policy based on the request size </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span> (size &lt;= BLOCKSIZE / <span class="Constant">2</span>)
  {

      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Small allocation to receive a fragment of a block.        </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Determine the logarithm to base two of the fragment size. </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Type">register</span> __malloc_size_t log = <span class="Constant">1</span>;

      --size;
      <span class="Statement">while</span> ((size /= <span class="Constant">2</span>) != <span class="Constant">0</span>)
	++log;


      <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Look in the fragment lists for a   </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> free fragment of the desired size. </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

      next = _phfraghead[hdes][log].next;
      <span class="Statement">if</span> (next != <span class="Constant">NULL</span>)
      {

          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> There are free fragments of this size.                 </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Pop a fragment out of the fragment list and return it. </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Update the block's nfree and first counters.           </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

	  result = (__ptr_t) next;
	  next-&gt;prev-&gt;next = next-&gt;next;

	  <span class="Statement">if</span> (next-&gt;next != <span class="Constant">NULL</span>)
	    next-&gt;next-&gt;prev = next-&gt;prev;

	  block = BLOCK (hdes, result);
	  <span class="Statement">if</span> (--_pheapinfo[hdes][block].busy.info.frag.nfree != <span class="Constant">0</span>)
	    _pheapinfo[hdes][block].busy.info.frag.first = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)
	                                                   ((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>) ((<span class="Type">char</span> *) next-&gt;next - (<span class="Type">char</span> *) <span class="Constant">NULL</span>)
	                                                                                          % BLOCKSIZE) &gt;&gt; log;


          <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Update the statistics </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

	  ++_pheap_chunks_used[hdes];
	  _pheap_bytes_used[hdes] += <span class="Constant">1</span> &lt;&lt; log;
	  --_pheap_chunks_free[hdes];
	  _pheap_bytes_free[hdes] -= <span class="Constant">1</span> &lt;&lt; log;
      }
      <span class="Statement">else</span>
      {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> No free fragments of the desired size, so get a new block </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> and break it into fragments, returning the first.         </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(_no_phobject_mapping == <span class="Constant">0</span>)
          {  _no_phobject_mapping = <span class="Constant">1</span>;
	     result = phmalloc (hdes, BLOCKSIZE, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
             _no_phobject_mapping = <span class="Constant">0</span>;
          }
          <span class="Statement">else</span>
             result = phmalloc (hdes, BLOCKSIZE, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);

	  <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)
          {
<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

	     <span class="Statement">return</span> <span class="Constant">NULL</span>;
          }


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Link all fragments but the first into the free list </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

	  <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; (__malloc_size_t) (BLOCKSIZE &gt;&gt; log); ++i)
	  {
	      next = (<span class="Type">struct</span> list *) ((<span class="Type">char</span> *) result + (i &lt;&lt; log));
	      next-&gt;next = _phfraghead[hdes][log].next;
	      next-&gt;prev = &amp;_phfraghead[hdes][log];
	      next-&gt;prev-&gt;next = next;
	      <span class="Statement">if</span> (next-&gt;next != <span class="Constant">NULL</span>)
		next-&gt;next-&gt;prev = next;
	  }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Initialize the nfree and first counters for this block </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

	  block = BLOCK (hdes, result);
	  _pheapinfo[hdes][block].busy.type = log;
	  _pheapinfo[hdes][block].busy.info.frag.nfree = i - <span class="Constant">1</span>;
	  _pheapinfo[hdes][block].busy.info.frag.first = i - <span class="Constant">1</span>;

	  _pheap_chunks_free[hdes] += (BLOCKSIZE &gt;&gt; log) - <span class="Constant">1</span>;
	  _pheap_bytes_free[hdes]  += BLOCKSIZE - (<span class="Constant">1</span> &lt;&lt; log);
	  _pheap_bytes_used[hdes]  -= BLOCKSIZE - (<span class="Constant">1</span> &lt;&lt; log);
	}
  }
  <span class="Statement">else</span>
  {

      <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Large allocation to receive one or more blocks.                      </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Search the free list in a circle starting at the last place visited. </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> If we loop completely around without finding a large enough          </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> space we will have to get more memory from the system.               </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

      blocks = BLOCKIFY (size);
      start = block = _pheapindex[hdes];
      <span class="Statement">while</span> (_pheapinfo[hdes][block].free.size &lt; blocks)
      {
	  block = _pheapinfo[hdes][block].free.next;
	  <span class="Statement">if</span> (block == start)
          {

              <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
	      <span class="Comment">/*</span><span class="Comment"> Need to get more from the system.  Check to see if   </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> the new core will be contiguous with the final free  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> block; if so we don't need to get as much.           </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

	      block = _pheapinfo[hdes][<span class="Constant">0</span>].free.prev;
	      lastblocks = _pheapinfo[hdes][block].free.size;
	      <span class="Statement">if</span> (_pheaplimit[hdes] != <span class="Constant">0</span> &amp;&amp; block + lastblocks == _pheaplimit[hdes]         &amp;&amp;
		  (*__phmorecore) (hdes,<span class="Constant">0</span>) == ADDRESS (hdes, block + lastblocks)            &amp;&amp;
		  (phmorecore (hdes, (blocks - lastblocks) * BLOCKSIZE))              != <span class="Constant">NULL</span>)
              {

                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
 		  <span class="Comment">/*</span><span class="Comment"> Which block we are extending (the `final free    </span><span class="Comment">*/</span>
 		  <span class="Comment">/*</span><span class="Comment"> block' referred to above) might have changed, if </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> it got combined with a freed info table.         </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

 		  block = _pheapinfo[hdes][<span class="Constant">0</span>].free.prev;
  		  _pheapinfo[hdes][block].free.size += (blocks - lastblocks);
		  _pheap_bytes_free[hdes] += (blocks - lastblocks) * BLOCKSIZE;
		  <span class="Statement">continue</span>;
              }

	      result = phmorecore (hdes, blocks * BLOCKSIZE);
	      <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)
              {
<span class="PreProc">                 #ifdef PTHREAD_SUPPORT</span>
                 (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">                 #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

		 <span class="Statement">return</span> <span class="Constant">NULL</span>;
              }

	      block = BLOCK (hdes, result);
	      _pheapinfo[hdes][block].busy.type = <span class="Constant">0</span>;
	      _pheapinfo[hdes][block].busy.info.size = blocks;
	      ++_pheap_chunks_used[hdes];
	      _pheap_bytes_used[hdes] += blocks * BLOCKSIZE;

              <span class="Statement">if</span>(_no_phobject_mapping == <span class="Constant">0</span> &amp;&amp; name != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
              {  h_index = msm_get_free_mapslot(hdes);
                 (<span class="Type">void</span>)msm_map_object(hdes,h_index,result,name);
                 (<span class="Type">void</span>)msm_map_setinfo(hdes,h_index,<span class="Constant">&quot;persistent GMAP object&quot;</span>);
                 (<span class="Type">void</span>)msm_map_setsize(hdes,h_index,req_size);
                 _pheap_parameters[hdes][<span class="Constant">8</span>]     = _phobjects[hdes];
                 _pheap_parameters[hdes][<span class="Constant">9</span>]     = _phobjects_allocated[hdes];
              }

<span class="PreProc">              #ifdef PTHREAD_SUPPORT</span>
              (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

	      <span class="Statement">return</span> result;
           }
	}


      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> At this point we have found a suitable free list entry. </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Figure out how to remove what we need from the list.    </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

      result = ADDRESS (hdes, block);
      <span class="Statement">if</span> (_pheapinfo[hdes][block].free.size &gt; blocks)
      {

          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> The block we found has a bit left over,         </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> so relink the tail end back into the free list. </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

	  _pheapinfo[hdes][block + blocks].free.size                     = _pheapinfo[hdes][block].free.size - blocks;
	  _pheapinfo[hdes][block + blocks].free.next                     = _pheapinfo[hdes][block].free.next;
	  _pheapinfo[hdes][block + blocks].free.prev                     = _pheapinfo[hdes][block].free.prev;
	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.prev].free.next = _pheapindex[hdes] = block + blocks;
          _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.prev = _pheapindex[hdes] = block + blocks;
      }
      <span class="Statement">else</span>
      {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> The block exactly matches our requirements, </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> so just remove it from the list.            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.prev = _pheapinfo[hdes][block].free.prev;
	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.prev].free.next = _pheapindex[hdes] = _pheapinfo[hdes][block].free.next;
	  --_pheap_chunks_free[hdes];
	}

      _pheapinfo[hdes][block].busy.type = <span class="Constant">0</span>;
      _pheapinfo[hdes][block].busy.info.size = blocks;

      ++_pheap_chunks_used[hdes];

      _pheap_bytes_used[hdes] += blocks * BLOCKSIZE;
      _pheap_bytes_free[hdes] -= blocks * BLOCKSIZE;


      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Mark all the blocks of the object just allocated except for the </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> first with a negative number so you can find the first block by </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> adding that adjustment.                                         </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Statement">while</span>(--blocks &gt; <span class="Constant">0</span>)
	_pheapinfo[hdes][block + blocks].busy.info.size = -blocks;
  }

  <span class="Statement">if</span>(_no_phobject_mapping == <span class="Constant">0</span> &amp;&amp; name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
  {  h_index         = msm_get_free_mapslot(hdes);

     (<span class="Type">void</span>)msm_map_object (hdes,h_index,result,name);
     (<span class="Type">void</span>)msm_map_setinfo(hdes,h_index,<span class="Constant">&quot;persistent GMAP object&quot;</span>);
     (<span class="Type">void</span>)msm_map_setsize(hdes,h_index,req_size);

     _pheap_parameters[hdes][<span class="Constant">8</span>] = _phobjects[hdes];
  }

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">return</span> result;
}
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Free a block of memory allocated by `malloc'.</span>
<span class="Comment">    Copyright 1990, 1991, 1992, 1994 Free Software Foundation, Inc.</span>
<span class="Comment">		  Written May 1989 by Mike Haertel.</span>

<span class="Comment">    This library is free software; you can redistribute it and/or</span>
<span class="Comment">    modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">    published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">    License, or (at your option) any later version.</span>

<span class="Comment">    This library is distributed in the hope that it will be useful,</span>
<span class="Comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">    Library General Public License for more details.</span>

<span class="Comment">    You should have received a copy of the GNU Library General Public</span>
<span class="Comment">    License along with this library; see the file COPYING.LIB.  If</span>
<span class="Comment">    not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">    Cambridge, MA 02139, USA.</span>

<span class="Comment">    The author may be reached (Email) at the address mike@ai.mit.edu,</span>
<span class="Comment">    or (US mail) as Mike Haertel c/o Free Software Foundation.</span>

<span class="Comment">    Persistent heap modifications by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">    (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define _PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>


_IMPORT heap_type         *htable;
_IMPORT __malloc_size_t   *pheapsize;


<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add a persistent object to persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_map_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">void</span> *, <span class="Type">const</span> <span class="Type">char</span> *);


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove a persistent object persistent object map within persistent memory segment </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_unmap_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Debugging hook for free </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> (*__phfree_hook) __P ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> __ptr_t __ptr));


<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> List of blocks allocated by memalign. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">struct</span> alignlist *_aligned_blocks = <span class="Constant">NULL</span>;


<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Object mapping switch </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> _no_phobject_mapping;


<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Number of objects in heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span> *_phobjects;


<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return memory to the heap.                                 </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Like `free' but don't call a __free_hook if there is one.  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> _phfree_internal (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> __ptr_t ptr)
{
  <span class="Type">int</span> type,
      h_index;

  __malloc_size_t block,
                  blocks,
                  i;

  <span class="Type">struct</span> list *prev = (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>,
              *next = (<span class="Type">struct</span> list *)<span class="Constant">NULL</span>;

  <span class="Statement">if</span>(_no_phobject_mapping == <span class="Constant">0</span>)
  {  <span class="Statement">if</span>((h_index = msm_find_mapped_object(hdes,ptr)) == (-<span class="Constant">1</span>))
     {  errno = <span class="Constant">EINVAL</span>;
        <span class="Statement">return</span>;
     }
  }

  block = BLOCK (hdes, ptr);

<span class="PreProc">#ifdef DEBUG</span>
  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;SHFREE BLOCK: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,block);
  (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>

  type = _pheapinfo[hdes][block].busy.type;
  <span class="Statement">switch</span> (type)
  {
    <span class="Statement">case</span> <span class="Constant">0</span>:


      <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Get as many statistics as early as we can. </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

      --_pheap_chunks_used[hdes];
      _pheap_bytes_used[hdes] -= _pheapinfo[hdes][block].busy.info.size * BLOCKSIZE;
      _pheap_bytes_free[hdes] += _pheapinfo[hdes][block].busy.info.size * BLOCKSIZE;


      <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Find the free cluster previous to this one in the free list.   </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Start searching at the last block referenced; this may benefit </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> programs with locality of allocation.                          </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

      i = _pheapindex[hdes];
      <span class="Statement">if</span>(i &gt; block)
      {  <span class="Statement">while</span> (i &gt; block)
	   i = _pheapinfo[hdes][i].free.prev;
      }
      <span class="Statement">else</span>
      {  <span class="Statement">do</span> {    i = _pheapinfo[hdes][i].free.next;
	    } <span class="Statement">while</span> (i &gt; <span class="Constant">0</span> &amp;&amp; i &lt; block);
	 i = _pheapinfo[hdes][i].free.prev;
      }


      <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Determine how to link this block into the free list.  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Statement">if</span> (block == i + _pheapinfo[hdes][i].free.size)
      {

          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Coalesce this block with its predecessor.  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

	  _pheapinfo[hdes][i].free.size += _pheapinfo[hdes][block].busy.info.size;
	  block = i;
      }
      <span class="Statement">else</span>
      {

          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Really link this block back into the free list.  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

	  _pheapinfo[hdes][block].free.size = _pheapinfo[hdes][block].busy.info.size;
	  _pheapinfo[hdes][block].free.next = _pheapinfo[hdes][i].free.next;
	  _pheapinfo[hdes][block].free.prev = i;
	  _pheapinfo[hdes][i].free.next = block;
	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.prev = block;
	  ++_pheap_chunks_free[hdes];
      }


      <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Now that the block is linked in, see if we can coalesce it  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> with its successor (by deleting its successor from the list </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> and adding in its size).                                    </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Statement">if</span> (block + _pheapinfo[hdes][block].free.size == _pheapinfo[hdes][block].free.next)
      {
	  _pheapinfo[hdes][block].free.size                             += _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.size;
	  _pheapinfo[hdes][block].free.next                              = _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.next;
	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.prev = block;
	  --_pheap_chunks_free[hdes];
      }


      <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Now see if we can return stuff to the system.  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

      blocks = _pheapinfo[hdes][block].free.size;
      <span class="Statement">if</span> (blocks &gt;= FINAL_FREE_BLOCKS                               &amp;&amp;
          block + blocks == _pheaplimit[hdes]                       &amp;&amp;
	  (*__phmorecore) (hdes, <span class="Constant">0</span>) == ADDRESS (hdes, block + blocks))
      {
	  __malloc_size_t bytes  = blocks * BLOCKSIZE;
	  _pheaplimit[hdes]     -= blocks;

	  (*__phmorecore) (hdes, -bytes);
	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.prev].free.next = _pheapinfo[hdes][block].free.next;
	  _pheapinfo[hdes][_pheapinfo[hdes][block].free.next].free.prev = _pheapinfo[hdes][block].free.prev;
	  block = _pheapinfo[hdes][block].free.prev;
	  --_pheap_chunks_free[hdes];
	  _pheap_bytes_free[hdes] -= bytes;
      }


      <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Set the next search to begin at this block.  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

      _pheapindex[hdes] = block;
      <span class="Statement">break</span>;

    <span class="Statement">default</span>:


      <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Do some of the statistics.  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

      --_pheap_chunks_used[hdes];
      _pheap_bytes_used[hdes] -= <span class="Constant">1</span> &lt;&lt; type;
      ++_pheap_chunks_free[hdes];
      _pheap_bytes_free[hdes] += <span class="Constant">1</span> &lt;&lt; type;


      <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Get the address of the first free fragment in this block.  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

      prev = (<span class="Type">struct</span> list *) ((<span class="Type">char</span> *) ADDRESS (hdes, block) + (_pheapinfo[hdes][block].busy.info.frag.first &lt;&lt; type));

      <span class="Statement">if</span>(_pheapinfo[hdes][block].busy.info.frag.nfree == (BLOCKSIZE &gt;&gt; type) - <span class="Constant">1</span>)
      {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> If all fragments of this block are free, remove them </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> from the fragment list and free the whole block.     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

	  next = prev;
	  <span class="Statement">for</span> (i = <span class="Constant">1</span>; i &lt; (__malloc_size_t) (BLOCKSIZE &gt;&gt; type); ++i)
	  {    next = next-&gt;next;


               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Check for partially relocated addresses which tend to occur </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> when an attached client falls over unexpectedly             </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>((<span class="Type">unsigned</span> <span class="Type">long</span>)next &lt; htable[hdes].sdata   ||
                  (<span class="Type">unsigned</span> <span class="Type">long</span>)next &gt; htable[hdes].edata    )
                  next = (<span class="Type">struct</span> list *)((<span class="Type">unsigned</span> <span class="Type">long</span>)next + (<span class="Type">unsigned</span> <span class="Type">long</span>)htable[hdes].addr);
          }

	  prev-&gt;prev-&gt;next = next;
	  <span class="Statement">if</span>(next != <span class="Constant">NULL</span>)
	     next-&gt;prev = prev-&gt;prev;

	  _pheapinfo[hdes][block].busy.type      = <span class="Constant">0</span>;
	  _pheapinfo[hdes][block].busy.info.size = <span class="Constant">1</span>;


          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> Keep the statistics accurate.  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

	  ++_pheap_chunks_used[hdes];
	  _pheap_bytes_used[hdes]  += BLOCKSIZE;
	  _pheap_chunks_free[hdes] -= BLOCKSIZE &gt;&gt; type;
	  _pheap_bytes_free[hdes]  -= BLOCKSIZE;

	  phfree (hdes, ADDRESS (hdes, block));
      }
      <span class="Statement">else</span> <span class="Statement">if</span> (_pheapinfo[hdes][block].busy.info.frag.nfree != <span class="Constant">0</span>)
      {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> If some fragments of this block are free, link this  </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> fragment into the fragment list after the first free </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> fragment of this block.                              </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

	  next = (<span class="Type">struct</span> list *) ptr;
	  next-&gt;next = prev-&gt;next;
	  next-&gt;prev = prev;
	  prev-&gt;next = next;

	  <span class="Statement">if</span> (next-&gt;next != <span class="Constant">NULL</span>)
	    next-&gt;next-&gt;prev = next;
	  ++_pheapinfo[hdes][block].busy.info.frag.nfree;
      }
      <span class="Statement">else</span>
      {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> No fragments of this block are free, so link this </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> fragment into the fragment list and announce that </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> it is the first free fragment of this block.      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

	  prev = (<span class="Type">struct</span> list *) ptr;
	  _pheapinfo[hdes][block].busy.info.frag.nfree = <span class="Constant">1</span>;
	  _pheapinfo[hdes][block].busy.info.frag.first = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)
	  ((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>) ((<span class="Type">char</span> *) ptr - (<span class="Type">char</span> *) <span class="Constant">NULL</span>) % BLOCKSIZE &gt;&gt; type);

	  prev-&gt;next       = _phfraghead[hdes][type].next;
	  prev-&gt;prev       = &amp;_phfraghead[hdes][type];
	  prev-&gt;prev-&gt;next = prev;

	  <span class="Statement">if</span>(prev-&gt;next != <span class="Constant">NULL</span>)
	    prev-&gt;next-&gt;prev = prev;
      }
      <span class="Statement">break</span>;
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update persistent object table to reflect fact that we have removed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> an object. Mark O'Neill 31/3/98                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)msm_unmap_object(hdes,h_index);

<span class="PreProc">#ifdef DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PHFREE EXIT</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>

}



<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return memory to the heap. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

<span class="Type">void</span> *phfree (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> __ptr_t ptr)

{ <span class="Type">struct</span> alignlist *l;

  <span class="Statement">if</span> (ptr == <span class="Constant">NULL</span>)
    <span class="Statement">return</span>;

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">for</span> (l = _aligned_blocks; l != <span class="Constant">NULL</span>; l = l-&gt;next)
    <span class="Statement">if</span> (l-&gt;aligned == ptr)
      {

                                <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
	l-&gt;aligned = <span class="Constant">NULL</span>;	<span class="Comment">/*</span><span class="Comment"> Mark the slot in the list as free </span><span class="Comment">*/</span>
                                <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

	ptr = l-&gt;exact;
	<span class="Statement">break</span>;
      }

  <span class="Statement">if</span> (__phfree_hook != <span class="Constant">NULL</span>)
    (*__phfree_hook) (hdes, ptr);
  <span class="Statement">else</span>
    _phfree_internal (hdes, ptr);

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span>
<span class="Comment">    Copyright (C) 1991, 1993, 1994 Free Software Foundation, Inc.</span>
<span class="Comment">    This file is part of the GNU C Library.</span>

<span class="Comment">    The GNU C Library is free software; you can redistribute it and/or</span>
<span class="Comment">    modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">    published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">    License, or (at your option) any later version.</span>

<span class="Comment">    The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="Comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">    Library General Public License for more details.</span>

<span class="Comment">    You should have received a copy of the GNU Library General Public</span>
<span class="Comment">    License along with the GNU C Library; see the file COPYING.LIB.  If</span>
<span class="Comment">    not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">    Cambridge, MA 02139, USA.</span>

<span class="Comment">    Shared heap code by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">    (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define _PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>

<span class="PreProc">#ifdef _LIBC</span>
<span class="PreProc">#include </span><span class="Constant">&lt;ansidecl.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;gnu-stabs.h&gt;</span>
<span class="PreProc">#undef	cfree</span>

function_alias(cfree, free, <span class="Type">void</span>, (ptr), DEFUN(cfree, (ptr), PTR ptr))

<span class="PreProc">#else</span>

_PUBLIC <span class="Type">void</span> phcfree (<span class="Type">int</span> hdes,  __ptr_t ptr)
{   phfree (hdes, ptr);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> LIBC </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span>
<span class="Comment">    Change the size of a block allocated by `malloc'.</span>
<span class="Comment">    Copyright 1990, 1991, 1992, 1993, 1994 Free Software Foundation, Inc.</span>
<span class="Comment">    		     Written May 1989 by Mike Haertel.</span>

<span class="Comment">    This library is free software; you can redistribute it and/or</span>
<span class="Comment">    modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">    published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">    License, or (at your option) any later version.</span>

<span class="Comment">    This library is distributed in the hope that it will be useful,</span>
<span class="Comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">    Library General Public License for more details.</span>

<span class="Comment">    You should have received a copy of the GNU Library General Public</span>
<span class="Comment">    License along with this library; see the file COPYING.LIB.  If</span>
<span class="Comment">    not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">    Cambridge, MA 02139, USA.</span>

<span class="Comment">    The author may be reached (Email) at the address mike@ai.mit.edu,</span>
<span class="Comment">    or (US mail) as Mike Haertel c/o Free Software Foundation.</span>

<span class="Comment">    Persistent heap modifications by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">    (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define _PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>


<span class="PreProc">#if (defined (MEMMOVE_MISSING) || !defined(_LIBC) &amp;&amp; !defined(STDC_HEADERS) &amp;&amp; !defined(USG))</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Snarfed directly from Emacs src/dispnew.c:         </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> </span><span class="Todo">XXX</span><span class="Comment"> Should use system bcopy if it handles overlap. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifndef emacs</span>


<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Used to signify an internal heaplib call (which should  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> not use object or heap locking)                         </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span> _pheap_internal;


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Used to signify that we should not update persistent object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> table (as this is an internal operation)                    </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

_IMPORT <span class="Type">int</span> _no_phobject_mapping;


<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add a persistent object to persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_map_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">void</span> *, <span class="Type">const</span> <span class="Type">char</span> *);


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove persistent object from persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_unmap_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Like bcopy except never gets confused by overlap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> safe_bcopy (<span class="Type">char</span> *from, <span class="Type">char</span> *to, <span class="Type">int</span> size)
{
  <span class="Statement">if</span> (size &lt;= <span class="Constant">0</span> || from == to)
    <span class="Statement">return</span>;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the source and destination don't overlap, then bcopy can      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> handle it.  If they do overlap, but the destination is lower in  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> memory than the source, we'll assume bcopy can handle that.      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(to &lt; from || from + size &lt;= to)
     (<span class="Type">void</span>)bcopy (from, to, size);
  <span class="Statement">else</span>
  {

      <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Otherwise, we'll copy from the end </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

      <span class="Type">register</span> <span class="Type">char</span> *endf = from + size;
      <span class="Type">register</span> <span class="Type">char</span> *endt = to + size;


      <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> If TO - FROM is large, then we should break the copy into    </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> nonoverlapping chunks of TO - FROM bytes each.  However, if  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> TO - FROM is small, then the bcopy function call overhead    </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> makes this not worth it.  The crossover point could be about </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> anywhere.  Since I don't think the obvious copy loop is too  </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> bad, I'm trying to err in its favor.                         </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Statement">if</span> (to - from &lt; <span class="Constant">64</span>)
      {
	  <span class="Statement">do</span> {    *--endt = *--endf;
	     } <span class="Statement">while</span> (endf != from);
      }
      <span class="Statement">else</span>
      {  <span class="Statement">for</span> (;;)
	 {
	      endt -= (to - from);
	      endf -= (to - from);

	      <span class="Statement">if</span>(endt &lt; to)
		 <span class="Statement">break</span>;

	      (<span class="Type">void</span>)bcopy (endf, endt, to - from);
	  }


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If SIZE wasn't a multiple of TO - FROM, there will be a </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> little left over.  The amount left over is              </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> (endt + (to - from)) - to, which is endt - from.        </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

	  (<span class="Type">void</span>)bcopy (from, to, endt - from);
	}
    }
}

        <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
<span class="PreProc">#endif</span>	<span class="Comment">/*</span><span class="Comment"> Not emacs </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

<span class="PreProc">#define memmove(to, from, size) safe_bcopy ((from), (to), (size))</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> (defined (MEMMOVE_MISSING) || !defined(_LIBC) &amp;&amp; !defined(STDC_HEADERS) &amp;&amp; !defined(USG)) </span><span class="Comment">*/</span>


<span class="PreProc">#define min(A, B) ((A) &lt; (B) ? (A) : (B))</span>


<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Debugging hook for realloc </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PUBLIC __ptr_t (*__phrealloc_hook) __P ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> __ptr_t __ptr, __malloc_size_t <span class="Type">const</span> __size, <span class="Type">const</span> <span class="Type">char</span> *));


<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Resize the given region to the new size, returning a pointer  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> to the (possibly moved) region.  This is optimized for speed; </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> some benchmarks seem to indicate that greater compactness is  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> achieved by unconditionally allocating and copying to a       </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> new region.  This module has incestuous knowledge of the      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> internals of both free and malloc.                            </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC __ptr_t phrealloc (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> __ptr_t ptr, __malloc_size_t size, <span class="Type">const</span> <span class="Type">char</span> *name)
{
  __ptr_t result;

  <span class="Type">int</span> type,
      mapped,
      h_index;

  __malloc_size_t block,
                  blocks,
                  oldlimit,
                  req_size;


<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Does this persistent object already exits? If so, we cannot allocate it! </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(name != (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; msm_phobject_exists(hdes,name))
  {  errno = <span class="Constant">EEXIST</span>;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span>((__ptr_t *)<span class="Constant">NULL</span>);
  }

  <span class="Statement">if</span>(size == <span class="Constant">0</span>)
  {  (<span class="Type">void</span>)phfree (hdes, ptr);

     result = phmalloc (hdes, <span class="Constant">0</span>, name);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> result;
  }
  <span class="Statement">else</span> <span class="Statement">if</span> (ptr == <span class="Constant">NULL</span>)
  {  result = phmalloc(hdes, size, name);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> result;
  }

  <span class="Statement">if</span>(__phrealloc_hook != <span class="Constant">NULL</span>)
  {
     result = (*__phrealloc_hook) (hdes, ptr, size, name);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> result;
  }

  <span class="Statement">if</span>((h_index = msm_map_objectaddr2index(hdes,ptr)) == (-<span class="Constant">1</span>))
  {  errno = <span class="Constant">EACCES</span>;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> <span class="Constant">NULL</span>;
  }

  block = BLOCK (hdes, ptr);

  req_size = size;
  type     = _pheapinfo[hdes][block].busy.type;
  <span class="Statement">switch</span> (type)
  {
    <span class="Statement">case</span> <span class="Constant">0</span>:

      <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Maybe reallocate a large block to a small fragment </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Statement">if</span> (size &lt;= BLOCKSIZE / <span class="Constant">2</span>)
      {
	  result = phmalloc (hdes, size, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
	  <span class="Statement">if</span>(result != <span class="Constant">NULL</span>)
          {
	      (<span class="Type">void</span>)memcpy (result, ptr, size);

              _no_phobject_mapping = <span class="Constant">1</span>;
	      _phfree_internal (hdes, ptr);
              _no_phobject_mapping = <span class="Constant">1</span>;

              h_index = msm_map_objectname2index(hdes,name);

              (<span class="Type">void</span>)msm_map_setsize(hdes,h_index,req_size);

<span class="PreProc">              #ifdef PTHREAD_SUPPORT</span>
              (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

	      <span class="Statement">return</span> result;
          }
      }


      <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> The new size is a large allocation as well; </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> see if we can hold it in place.             </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

      blocks = BLOCKIFY (size);
      <span class="Statement">if</span> (blocks &lt; _pheapinfo[hdes][block].busy.info.size)
      {

          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> The new size is smaller; return </span><span class="Comment">*/</span>
	  <span class="Comment">/*</span><span class="Comment"> excess memory to the free list. </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

	  _pheapinfo[hdes][block + blocks].busy.type      = <span class="Constant">0</span>;
	  _pheapinfo[hdes][block + blocks].busy.info.size = _pheapinfo[hdes][block].busy.info.size - blocks;
	  _pheapinfo[hdes][block].busy.info.size          = blocks;


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We have just created a new chunk by splitting a chunk in two.       </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Now we will free this chunk; increment the statistics counter       </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> so it doesn't become wrong when _free_pheap_internal decrements it. </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

	  ++_pheap_chunks_used[hdes];

          _no_phobject_mapping = <span class="Constant">1</span>;
	  _phfree_internal (hdes, ADDRESS (hdes, block + blocks));
          _no_phobject_mapping = <span class="Constant">0</span>;

          h_index         = msm_map_objectname2index(hdes,name);

          _phobjectmap[hdes][h_index]-&gt;addr = result;
	  result = ptr;
      }
      <span class="Statement">else</span> <span class="Statement">if</span> (blocks == _pheapinfo[hdes][block].busy.info.size)


         <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> No size change necessary </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

         result = ptr;
      <span class="Statement">else</span>
      {

         <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Won't fit, so allocate a new region that will.             </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Free the old region first in case there is sufficient      </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> adjacent free space to grow without moving.                </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> blocks = _pheapinfo[hdes][block].busy.info.size;           </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Prevent free from actually returning memory to the system. </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

	  oldlimit           = _pheaplimit[hdes];
	  _pheaplimit[hdes] = <span class="Constant">0</span>;

          _no_phobject_mapping = <span class="Constant">1</span>;
	  _phfree_internal (hdes, ptr);
          _no_phobject_mapping = <span class="Constant">0</span>;

	  _pheaplimit[hdes] = oldlimit;
	  result = phmalloc (hdes, size, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
	  <span class="Statement">if</span> (result == <span class="Constant">NULL</span>)
          {

             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Now we're really in trouble.  We have to unfree  </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> the thing we just freed.  Unfortunately it might </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> have been coalesced with its neighbours.         </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

	      <span class="Statement">if</span>(_pheapindex[hdes] == block)
	        (<span class="Type">void</span>) phmalloc (hdes, blocks * BLOCKSIZE, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
	      <span class="Statement">else</span>
              {
		  __ptr_t previous = phmalloc (hdes, (block - _pheapindex[hdes]) * BLOCKSIZE, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
		  (<span class="Type">void</span>) phmalloc (hdes, blocks * BLOCKSIZE, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);

                  _no_phobject_mapping = <span class="Constant">1</span>;
		  _phfree_internal (hdes, previous);
                  _no_phobject_mapping = <span class="Constant">1</span>;
              }

              h_index = msm_map_objectname2index(hdes,name);

              msm_unmap_object(hdes,h_index);

<span class="PreProc">              #ifdef PTHREAD_SUPPORT</span>
              (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

	      <span class="Statement">return</span> <span class="Constant">NULL</span>;
	  }

	  <span class="Statement">if</span>(ptr != result)
	     memmove (result, ptr, blocks * BLOCKSIZE);
	}
        <span class="Statement">break</span>;

    <span class="Statement">default</span>:


         <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Old size is a fragment; type is logarithm </span><span class="Comment">*/</span>
	 <span class="Comment">/*</span><span class="Comment"> to base two of the fragment size.         </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

         <span class="Statement">if</span> (size &gt; (__malloc_size_t) (<span class="Constant">1</span> &lt;&lt; (type - <span class="Constant">1</span>)) &amp;&amp; size &lt;= (__malloc_size_t) (<span class="Constant">1</span> &lt;&lt; type))


             <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
	     <span class="Comment">/*</span><span class="Comment"> The new size is the same kind of fragment </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

	     result = ptr;
         <span class="Statement">else</span>
	 {

            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> The new size is different; allocate a new space, </span><span class="Comment">*/</span>
	    <span class="Comment">/*</span><span class="Comment"> and copy the lesser of the new size and the old. </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

	    result = phmalloc (hdes, size, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);

            <span class="Statement">if</span>(result == <span class="Constant">NULL</span>)
            {  h_index = msm_map_objectname2index(hdes,name);

               msm_unmap_object(hdes,h_index);

<span class="PreProc">               #ifdef PTHREAD_SUPPORT</span>
               (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

	       <span class="Statement">return</span> <span class="Constant">NULL</span>;
            }

	    (<span class="Type">void</span>)memcpy (result, ptr, min (size, (__malloc_size_t) <span class="Constant">1</span> &lt;&lt; type));
	    (<span class="Type">void</span>)phfree (hdes, ptr);
	}
        <span class="Statement">break</span>;
    }

  h_index                           = msm_map_objectname2index(hdes,name);
  _phobjectmap[hdes][h_index]-&gt;addr = result;

  (<span class="Type">void</span>)msm_map_setsize(hdes,h_index,req_size);

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">return</span> result;
}
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span>
<span class="Comment">    Copyright (C) 1991, 1992, 1994 Free Software Foundation, Inc.</span>

<span class="Comment">    This library is free software; you can redistribute it and/or</span>
<span class="Comment">    modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">    published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">    License, or (at your option) any later version.</span>

<span class="Comment">    This library is distributed in the hope that it will be useful,</span>
<span class="Comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">    Library General Public License for more details.</span>

<span class="Comment">    You should have received a copy of the GNU Library General Public</span>
<span class="Comment">    License along with this library; see the file COPYING.LIB.  If</span>
<span class="Comment">    not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">    Cambridge, MA 02139, USA.</span>

<span class="Comment">   The author may be reached (Email) at the address mike@ai.mit.edu,</span>
<span class="Comment">   or (US mail) as Mike Haertel c/o Free Software Foundation.</span>

<span class="Comment">   Shared heap modifications by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">   (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SHMALLOC_INTERNAL </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Allocate an array of NMEMB elements each SIZE bytes long. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> The entire array is initialized to zeros.                 </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC __ptr_t phcalloc (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> __malloc_size_t nmemb, <span class="Type">const</span> __malloc_size_t size, <span class="Type">const</span> <span class="Type">char</span> *name)
{
  <span class="Type">register</span> __ptr_t result;


<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment"> Does this persistent object already exits? If so, we cannot allocate it! </span><span class="Comment">*/</span>
  <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

  <span class="Statement">if</span>(name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; msm_phobject_exists(hdes,name))
  {  errno = <span class="Constant">EEXIST</span>;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span>((__ptr_t *)<span class="Constant">NULL</span>);
  }

  result  = phmalloc (hdes, nmemb * size, name);

  <span class="Statement">if</span> (result != <span class="Constant">NULL</span>)
    (<span class="Type">void</span>) memset (result, <span class="Constant">0</span>, nmemb * size);

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">return</span> result;
}
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Copyright (C) 1991, 1992, 1993, 1994 Free Software Foundation, Inc.</span>
<span class="Comment">    This file is part of the GNU C Library.</span>

<span class="Comment">    The GNU C Library is free software; you can redistribute it and/or modify</span>
<span class="Comment">    it under the terms of the GNU General Public License as published by</span>
<span class="Comment">    the Free Software Foundation; either version 2, or (at your option)</span>
<span class="Comment">    any later version.</span>

<span class="Comment">    The GNU C Library is distributed in the hope that it will be useful,</span>
<span class="Comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="Comment">    GNU General Public License for more details.</span>

<span class="Comment">    You should have received a copy of the GNU General Public License</span>
<span class="Comment">    along with the GNU C Library; see the file COPYING.  If not, write to</span>
<span class="Comment">    the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.</span>

<span class="Comment">    Persistent heap modifications by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">    (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef __GNU_LIBRARY__</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> It is best not to declare this and cast its result on foreign operating </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> systems with potentially hostile include files.                         </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Type">extern</span> <span class="Type">void</span> *msm_sbrk __P ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">size_t</span> increment));
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> __GNU_LIBRARY__ </span><span class="Comment">*/</span>

<span class="PreProc">#ifndef NULL</span>
<span class="PreProc">#define </span><span class="Constant">NULL</span><span class="PreProc"> </span><span class="Constant">0</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> NULL </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Allocate INCREMENT more bytes of data space,           </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> and return the start of data space, or NULL on errors. </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> If INCREMENT is negative, shrink data space.           </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef __STDC__</span>
_PUBLIC __ptr_t __default_phmorecore (<span class="Type">int</span> hdes,  <span class="Type">ptrdiff_t</span> increment)
<span class="PreProc">#else</span>
_PUBLIC __ptr_t __default_phmorecore (<span class="Type">int</span> hdes,  <span class="Type">int</span> increment)
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> __STDC__ </span><span class="Comment">*/</span>
{
  __ptr_t result = (__ptr_t)msm_sbrk(hdes, increment);

  <span class="Statement">if</span>(result == (__ptr_t) -<span class="Constant">1</span>)
    <span class="Statement">return</span> <span class="Constant">NULL</span>;

  <span class="Statement">return</span> result;
}
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Copyright (C) 1991, 1992, 1993, 1994, 1995 Free Software Foundation, Inc.</span>

<span class="Comment">    This library is free software; you can redistribute it and/or</span>
<span class="Comment">    modify it under the terms of the GNU Library General Public License as</span>
<span class="Comment">    published by the Free Software Foundation; either version 2 of the</span>
<span class="Comment">    License, or (at your option) any later version.</span>

<span class="Comment">    This library is distributed in the hope that it will be useful,</span>
<span class="Comment">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="Comment">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="Comment">    Library General Public License for more details.</span>

<span class="Comment">    You should have received a copy of the GNU Library General Public</span>
<span class="Comment">    License along with this library; see the file COPYING.LIB.  If</span>
<span class="Comment">    not, write to the Free Software Foundation, Inc., 675 Mass Ave,</span>
<span class="Comment">    Cambridge, MA 02139, USA.  </span>

<span class="Comment">    Persistent heap modification by Mark O'Neill (mao@tumblingdice.co.uk)</span>
<span class="Comment">    (C) 1998-2022 M.A. O'Neill, Tumbling Dice</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifndef	_PHMALLOC_INTERNAL</span>
<span class="PreProc">#define _PHMALLOC_INTERNAL</span>
<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _PHMALLOC_INTERNAL </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>

<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add a persistent object to persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_map_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">void</span> *, <span class="Type">const</span> <span class="Type">char</span> *);


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove a persistent object from persistent object map </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_unmap_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get free object mapslot </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _EXTERN <span class="Type">int</span> msm_get_free_mapslot(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>);


_PUBLIC __ptr_t (*__phmemalign_hook) __P ((<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span>, <span class="Type">const</span> __malloc_size_t __alignment, <span class="Type">size_t</span> __size, <span class="Type">const</span> <span class="Type">char</span> *));
_PUBLIC __ptr_t phmemalign (<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> hdes, <span class="Type">const</span> __malloc_size_t alignment, __malloc_size_t size, <span class="Type">const</span> <span class="Type">char</span> *name)
{
  <span class="Type">int</span>               h_index;
  __ptr_t           result;
  <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> adj;

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">if</span>(__phmemalign_hook)
  {
     result = (*__phmemalign_hook) (hdes, alignment, size, name);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> result;
  }

  size = ((size + alignment - <span class="Constant">1</span>) / alignment) * alignment;

  result = phmalloc (hdes, size, (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
  <span class="Statement">if</span>(result == <span class="Constant">NULL</span>)
  {

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">return</span> <span class="Constant">NULL</span>;
  }

  adj = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>) ((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>) ((<span class="Type">char</span> *) result - (<span class="Type">char</span> *) <span class="Constant">NULL</span>)) % alignment;

  <span class="Statement">if</span> (adj != <span class="Constant">0</span>)
  {
      <span class="Type">struct</span> alignlist *l = (<span class="Type">struct</span> alignlist *)<span class="Constant">NULL</span>;
      <span class="Statement">for</span>(l = _aligned_blocks; l != <span class="Constant">NULL</span>; l = l-&gt;next)
      {  <span class="Statement">if</span>(l-&gt;aligned == <span class="Constant">NULL</span>)


            <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
	    <span class="Comment">/*</span><span class="Comment"> This slot is free.  Use it. </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

	    <span class="Statement">break</span>;
      }

      <span class="Statement">if</span> (l == <span class="Constant">NULL</span>)
      {
	  l = (<span class="Type">struct</span> alignlist *) phmalloc (hdes, <span class="Statement">sizeof</span> (<span class="Type">struct</span> alignlist), (<span class="Type">char</span> *)<span class="Constant">NULL</span>);
	  <span class="Statement">if</span> (l == <span class="Constant">NULL</span>)
          {
	      phfree (hdes, result);
	      <span class="Statement">return</span> <span class="Constant">NULL</span>;
	  }
	  l-&gt;next         = _aligned_blocks;
	  _aligned_blocks = l;
      }
      l-&gt;exact = result;
      result   = l-&gt;aligned = (<span class="Type">char</span> *) result + alignment - adj;
  }

  <span class="Statement">if</span>(name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
  {  h_index = msm_get_free_mapslot(hdes);
     msm_map_object(hdes,h_index,result,name);
  }

<span class="PreProc">  #ifdef PTHREAD_SUPPORT</span>
  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

  <span class="Statement">return</span> result;
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
