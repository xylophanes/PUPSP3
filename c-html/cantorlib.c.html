<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>/usr/local/src/pupsp3-5.4.9.src.git/pupscore.src/cantorlib.c.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Purpose: Cantor cellular database core library.</span>

<span class="Comment">    Author:  M.A. O'Neill</span>
<span class="Comment">             Tumbling Dice Ltd</span>
<span class="Comment">             Gosforth</span>
<span class="Comment">             Newcastle upon Tyne</span>
<span class="Comment">             NE3 4RT</span>
<span class="Comment">             United Kingdom</span>

<span class="Comment">    Version: 3.00 </span>
<span class="Comment">    Dated:   4th January 2022</span>
<span class="Comment">    E-mail:  mao@@tumblingdice.co.uk</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="PreProc">#include </span><span class="Constant">&lt;stdio.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;me.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utils.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;vstamp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>

<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;phmalloc.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>


<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;tad.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#undef   __NOT_LIB_SOURCE__</span>
<span class="PreProc">#include </span><span class="Constant">&lt;cantor.h&gt;</span>
<span class="PreProc">#define  __NOT_LIB_SOURCE__</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot and usage functions - used by slot manager </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot usage function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> cantorlib_slot(<span class="Type">int</span> level)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;lib cantorlib </span><span class="Special">%s</span><span class="Constant">: [ANSI C]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION);

    <span class="Statement">if</span>(level &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;(C) 1994-2022 Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;Author: M.A. O'Neill</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PUPS/P3 cellular database core library (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Segment identification for cantor (set analysis) library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SLOT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;slotman.h&gt;</span>
_EXTERN <span class="Type">void</span> (* SLOT )() __attribute__ ((aligned(<span class="Constant">16</span>))) = cantorlib_slot;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLOT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Prototypes of functions which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Clear link</span>
_PROTOTYPE _PRIVATE link_type *_clear_link(link_type *, <span class="Type">int</span>);

<span class="Comment">//Clear linklist</span>
_PROTOTYPE _PRIVATE link_type **_clear_linklist(link_type **, <span class="Type">int</span>, <span class="Type">int</span>);

<span class="Comment">// Clear object</span>
_PROTOTYPE _PRIVATE object_type *_clear_object(object_type *, <span class="Type">int</span>);

<span class="Comment">// Clear object</span>
_PROTOTYPE _PRIVATE object_type **_clear_objectlist(object_type **, <span class="Type">int</span>, <span class="Type">int</span>);

<span class="Comment">// Clear node</span>
_PROTOTYPE _PRIVATE node_type *_clear_node(node_type *, <span class="Type">int</span>);

<span class="Comment">// Clear nodelist</span>
_PROTOTYPE _PRIVATE nodelist_type *_clear_nodelist(nodelist_type *, <span class="Type">int</span>);

<span class="Comment">// Add node to nodelist</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _add_node_to_nodelist(nodelist_type *, node_type *, <span class="Type">int</span>, <span class="Type">char</span> *);

<span class="Comment">// Remove node from nodelist</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _remove_node_from_nodelist(nodelist_type *, <span class="Type">char</span> *, <span class="Type">int</span>);

<span class="Comment">// Add object to node</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _add_object_to_node(node_type *, object_type *, <span class="Type">int</span>, <span class="Type">char</span> *);

<span class="Comment">// Remove object from node</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _remove_object_from_node(node_type *, <span class="Type">char</span> *, <span class="Type">int</span>);

<span class="Comment">// Add link to node</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _add_link_to_node(node_type *, link_type *, <span class="Type">int</span>, <span class="Type">char</span> *);

<span class="Comment">// Remove link from node</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _remove_link_from_node(node_type *, <span class="Type">char</span> *, <span class="Type">int</span>);

<span class="Comment">// Add node to link (routelist)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> _add_node_to_link(link_type *, node_type *, <span class="Type">int</span>, <span class="Type">char</span> *);




<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Initialises mutexes ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Node mutex </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> cantor_init_node_mutex(node_type *node)

{   pthread_mutexattr_t attr;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)pthread_mutexattr_init(&amp;attr);
    (<span class="Type">void</span>)pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    (<span class="Type">void</span>)pthread_mutex_init(&amp;node-&gt;mutex, &amp;attr);

    pups_set_errno(OK);
}


<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Object mutex </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> cantor_init_object_mutex(object_type *object)

{    pthread_mutexattr_t attr;

    <span class="Statement">if</span>(object == (object_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)pthread_mutexattr_init(&amp;attr);
    (<span class="Type">void</span>)pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    (<span class="Type">void</span>)pthread_mutex_init(&amp;object-&gt;mutex, &amp;attr);

    pups_set_errno(OK);
}


<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Link mutex </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> cantor_init_link_mutex(link_type *link)

{   pthread_mutexattr_t attr;

    <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)pthread_mutexattr_init(&amp;attr);
    (<span class="Type">void</span>)pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    (<span class="Type">void</span>)pthread_mutex_init(&amp;link-&gt;mutex, &amp;attr);

    pups_set_errno(OK);
}


<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Nodelist mutex </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> cantor_init_nodelist_mutex(nodelist_type *nodelist)

{   pthread_mutexattr_t attr;

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)pthread_mutexattr_init(&amp;attr);
    (<span class="Type">void</span>)pthread_mutexattr_settype(&amp;attr, PTHREAD_MUTEX_RECURSIVE);
    (<span class="Type">void</span>)pthread_mutex_init(&amp;nodelist-&gt;mutex, &amp;attr);

    pups_set_errno(OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Get the index of node (given its name) ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_get_node_index_from_name(nodelist_type *nodelist, <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span> || name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_alloc; ++i)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;nodes[i]-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(nodelist-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>                                          &amp;&amp;
          (nodelist-&gt;nodes[i] = (node_type *)cantor_pointer_live(nodelist-&gt;nodes[i],TRUE)) &amp;&amp;
          strcmp(nodelist-&gt;nodes[i]-&gt;name,name) == <span class="Constant">0</span>                                        )
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;nodes[i]-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;nodes[i]-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear a node ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target node on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC node_type *cantor_clear_node(node_type *node)

{   <span class="Statement">return</span>(_clear_node(node,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target node on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC node_type *cantor_phclear_node(node_type *node, <span class="Type">int</span> hdes)

{   <span class="Statement">return</span>(_clear_node(node,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE node_type *_clear_node(node_type *node, <span class="Type">int</span> hdes)

{   <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((node_type *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_DUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAS_DUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
    {  (<span class="Type">void</span>)cantor_phclear_objectlist(node-&gt;objects,hdes,node-&gt;object_alloc);
       (<span class="Type">void</span>)cantor_phclear_linklist(node-&gt;links,hdes,node-&gt;link_alloc);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((node_type *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
    {  (<span class="Type">void</span>)cantor_clear_objectlist(node-&gt;objects,node-&gt;object_alloc);
       (<span class="Type">void</span>)cantor_clear_linklist(node-&gt;links,node-&gt;link_alloc);
    }

    (<span class="Type">void</span>)strlcpy(node-&gt;name,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(node-&gt;type,<span class="Constant">&quot;notset&quot;</span>,SSIZE);

<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
    {  (<span class="Type">void</span>)strlcpy(node-&gt;link_name,<span class="Constant">&quot;notset&quot;</span>,  SSIZE);
       (<span class="Type">void</span>)strlcpy(node-&gt;object_name,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       node-&gt;links        = (link_type **)  phfree(hdes,(<span class="Type">void</span> *)node-&gt;links);
       node-&gt;objects      = (object_type **)phfree(hdes,(<span class="Type">void</span> *)node-&gt;objects);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((node_type *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
    {  node-&gt;links        = (link_type **)  pups_free((<span class="Type">void</span> *)node-&gt;links);
       node-&gt;objects      = (object_type **)pups_free((<span class="Type">void</span> *)node-&gt;objects);
    }

    node-&gt;link_alloc   = <span class="Constant">0</span>;
    node-&gt;link_cnt     = <span class="Constant">0</span>;
    node-&gt;object_alloc = <span class="Constant">0</span>;
    node-&gt;object_cnt   = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_DUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>((node_type *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear a nodelist ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target nodelist on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PUBLIC nodelist_type *cantor_clear_nodelist(nodelist_type *nodelist)
{   <span class="Statement">return</span>(_clear_nodelist(nodelist,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target nodelist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PUBLIC nodelist_type *cantor_phclear_nodelist(nodelist_type *nodelist, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_clear_nodelist(nodelist,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE nodelist_type *_clear_nodelist(nodelist_type *nodelist, <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((nodelist_type *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (nodelist-&gt;nodes[i] = (node_type *)cantor_pointer_live(nodelist-&gt;nodes[i],TRUE)))

<span class="PreProc">          #ifdef PERSISTENT_HEAP_SUPPORT</span>
          <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
             (<span class="Type">void</span>)_clear_node(nodelist-&gt;nodes[i],hdes);
          <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

            pups_set_errno(<span class="Constant">EINVAL</span>);
            <span class="Statement">return</span>((nodelist_type *)<span class="Constant">NULL</span>);
          }
          <span class="Statement">else</span>
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
             (<span class="Type">void</span>)_clear_node(nodelist-&gt;nodes[i],(-<span class="Constant">1</span>));
    }

<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
    {  (<span class="Type">void</span>)strlcpy(nodelist-&gt;node_name,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       (<span class="Type">void</span>)phfree(hdes,nodelist-&gt;nodes);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((nodelist_type *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)nodelist-&gt;nodes);

    (<span class="Type">void</span>)strlcpy(nodelist-&gt;name,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(nodelist-&gt;type,<span class="Constant">&quot;notset&quot;</span>,SSIZE);

    nodelist-&gt;node_alloc = <span class="Constant">0</span>;
    nodelist-&gt;node_cnt   = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>((nodelist_type *)<span class="Constant">NULL</span>);
}



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Add node to nodelist ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target nodelist (to add node to) on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_add_node_to_nodelist(nodelist_type *nodelist, node_type *node)
{   <span class="Statement">return</span>(_add_node_to_nodelist(nodelist,node,(-<span class="Constant">1</span>),(<span class="Type">char</span> *)<span class="Constant">NULL</span>));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target nodelist (to add node to) on peristent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phadd_node_to_nodelist(nodelist_type *nodelist, node_type *node, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)
{   <span class="Statement">return</span>(_add_node_to_nodelist(nodelist,node,hdes,name));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> _add_node_to_nodelist(nodelist_type *nodelist, node_type *node, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)

{   <span class="Type">int</span> node_index;

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span> || node == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(nodelist-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
    {  nodelist-&gt;node_alloc = ALLOC_QUANTUM;



<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Is this node on a pesistent heap? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {  (<span class="Type">void</span>)snprintf(nodelist-&gt;node_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:nlist&quot;</span>,name);
          nodelist-&gt;nodes = (node_type **)phcalloc(hdes,ALLOC_QUANTUM,<span class="Statement">sizeof</span>(node_type *),name);
          <span class="Statement">if</span>(nodelist-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_nodelist] failed to create node list (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

           pups_set_errno(<span class="Constant">EINVAL</span>);
           <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

       {
          nodelist-&gt;nodes = (node_type **)pups_calloc(ALLOC_QUANTUM,<span class="Statement">sizeof</span>(node_type *));
          <span class="Statement">if</span>(nodelist-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_nodelist] failed to create node list (on local heap/cache)&quot;</span>);
       }


       nodelist-&gt;nodes[nodelist-&gt;node_cnt] = node;
       node_index                          = <span class="Constant">0</span>;
       ++nodelist-&gt;node_cnt;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(nodelist-&gt;node_alloc == nodelist-&gt;node_cnt)
    {  nodelist-&gt;node_alloc                += ALLOC_QUANTUM;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We need to have locked the entire persistent heap before we do reallocation or we </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> may get race conditions                                                           </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

          nodelist-&gt;nodes = (node_type **)phrealloc(hdes,(<span class="Type">void</span> *)nodelist-&gt;nodes,nodelist-&gt;node_alloc*<span class="Statement">sizeof</span>(node_type *),nodelist-&gt;node_name);
          <span class="Statement">if</span>(nodelist-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_nodelist] failed to extend node list (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

           pups_set_errno(<span class="Constant">EINVAL</span>);
           <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {
          nodelist-&gt;nodes = (node_type **)pups_realloc((<span class="Type">void</span> *)nodelist-&gt;nodes,nodelist-&gt;node_alloc*<span class="Statement">sizeof</span>(node_type *));
          <span class="Statement">if</span>(nodelist-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_nodelist] failed to extend node list (on local heap/cache)&quot;</span>);
       }

       nodelist-&gt;nodes[nodelist-&gt;node_cnt] = node;
       node_index                          = nodelist-&gt;node_cnt;
       ++nodelist-&gt;node_cnt;
    }
    <span class="Statement">else</span>
    {  <span class="Type">int</span> i;


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Search nodelist for a free slot </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_cnt; ++i)
       {  <span class="Statement">if</span>(nodelist-&gt;nodes[i] == (node_type *)<span class="Constant">NULL</span>)
             <span class="Statement">break</span>;
       }

       nodelist-&gt;nodes[i] = node;
       node_index         = i;

       ++nodelist-&gt;node_cnt;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(node_index);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Remove node from nodelist ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target nodelist (to remove node from) is on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_remove_node_from_nodelist(nodelist_type *nodelist, <span class="Type">char</span> *name)
{   <span class="Statement">return</span>(_remove_node_from_nodelist(nodelist,name,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT </span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target nodelist (to remove node from) is on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phremove_node_from_nodelist(nodelist_type *nodelist, <span class="Type">char</span> *name, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_remove_node_from_nodelist(nodelist,name,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> _remove_node_from_nodelist(nodelist_type *nodelist, <span class="Type">char</span> *name, <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span> || name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search nodelist for node name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>                                                 &amp;&amp;
          (nodelist-&gt;nodes[i] = (node_type *)cantor_pointer_live(nodelist-&gt;nodes[i]-&gt;name,TRUE))  &amp;&amp;
          strcmp(nodelist-&gt;nodes[i]-&gt;name,name) == <span class="Constant">0</span>                                               )
       {
<span class="PreProc">          #ifdef PERSISTENT_HEAP_SUPPORT</span>
          <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
          {  _clear_node(nodelist-&gt;nodes[i],hdes);
             nodelist-&gt;nodes[i] = (node_type *)phfree(hdes,(<span class="Type">void</span> *)nodelist-&gt;nodes[i]);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
          {
<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EINVAL</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }
          <span class="Statement">else</span>
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
          {  _clear_node(nodelist-&gt;nodes[i],(-<span class="Constant">1</span>));
             nodelist-&gt;nodes[i] = (node_type *)pups_free((<span class="Type">void</span> *)nodelist-&gt;nodes[i]);
          }

          --nodelist-&gt;node_cnt;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">EEXIST</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Set nodelist name ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_nodelist_name(nodelist_type *nodelist, <span class="Type">char</span> *nodelist_name)

{   <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span> || nodelist_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(nodelist-&gt;name,nodelist_name,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Set nodelist type ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_nodelist_type(nodelist_type *nodelist, <span class="Type">char</span> *type)

{   <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span> || type == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(nodelist-&gt;type,type,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Add an object to a node ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target node (to add object to) on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_add_object_to_node(node_type *node, object_type *object)
{   <span class="Statement">return</span>(_add_object_to_node(node,object,(-<span class="Constant">1</span>),(<span class="Type">char</span> *)<span class="Constant">NULL</span>));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target node (to add object to) on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phadd_object_to_node(node_type *node, object_type *object, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)
{   <span class="Statement">return</span>(_add_object_to_node(node,object,hdes,name));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> _add_object_to_node(node_type *node, object_type *object, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)

{   <span class="Type">int</span> object_index = <span class="Constant">0</span>;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || object == (object_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(node-&gt;objects == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  node-&gt;object_alloc = ALLOC_QUANTUM;


<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Is this node on a persistent heap? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {  <span class="Type">char</span> object_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)snprintf(node-&gt;object_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:olist&quot;</span>,node-&gt;name);
          node-&gt;objects = (object_type **)phcalloc(hdes,ALLOC_QUANTUM,<span class="Statement">sizeof</span>(object_type **),node-&gt;object_name);
          <span class="Statement">if</span>(node-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_object_to_node] failed to create node object list (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

       {  node-&gt;objects = (object_type **)pups_calloc(ALLOC_QUANTUM,<span class="Statement">sizeof</span>(object_type **));
          <span class="Statement">if</span>(node-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_object_to_node] failed to create node object list (on local heap/cache)&quot;</span>);
       }

       node-&gt;objects[node-&gt;object_cnt] = object;
       ++node-&gt;object_cnt;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(node-&gt;object_cnt == node-&gt;object_alloc)
    {  node-&gt;object_alloc += ALLOC_QUANTUM;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt;= <span class="Constant">0</span>)
       {  node-&gt;objects = (object_type **)phrealloc(hdes,node-&gt;objects,node-&gt;object_alloc*<span class="Statement">sizeof</span>(object_type **),node-&gt;object_name);
          <span class="Statement">if</span>(node-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_object_to_node] failed to extend object list (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {  node-&gt;objects = (object_type **)pups_realloc(node-&gt;objects,node-&gt;object_alloc*<span class="Statement">sizeof</span>(object_type **));
          <span class="Statement">if</span>(node-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_object_to_node] failed to extend object list (on local heap/cache)&quot;</span>);
       }

       node-&gt;objects[node-&gt;object_cnt] = object;
       ++node-&gt;object_cnt;
    }
    <span class="Statement">else</span>
    {  <span class="Type">int</span> i;


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Search node object list for a free slot </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_cnt; ++i)
       {  <span class="Statement">if</span>(node-&gt;objects[i] == (object_type *)<span class="Constant">NULL</span>)
             <span class="Statement">break</span>;
       }

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {  node-&gt;objects[i] = (object_type *)phmalloc(hdes,<span class="Statement">sizeof</span>(object_type),name);

          <span class="Statement">if</span>(node-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_object_to_node] failed to extend object list (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {
          node-&gt;objects[i] = (object_type *)pups_malloc(<span class="Statement">sizeof</span>(object_type));

          <span class="Statement">if</span>(node-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_object_to_node] failed to extend object list (on local heap/cache)&quot;</span>);
       }

       node-&gt;objects[i] = object;
       object_index     = i;
       ++node-&gt;object_cnt;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(object_index);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Remove an object from a node ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target node (containing object) node on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_remove_object_from_node(node_type *node, <span class="Type">char</span> *object_tag)
{   <span class="Statement">return</span>(_remove_object_from_node(node,object_tag,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target node (containing object) node on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phremove_object_from_node(node_type *node, <span class="Type">char</span> *object_tag, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_remove_object_from_node(node,object_tag,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> _remove_object_from_node(node_type *node, <span class="Type">char</span> *object_tag, <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || object_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search object list for tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span> &amp;&amp; strcmp(node-&gt;objects[i]-&gt;tag,object_tag) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PERSISTENT_HEAP_SUPPORT</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If an object is on a persistent heap its name is its handle </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
          { cantor_clear_object(node-&gt;objects[i]);
             node-&gt;objects[i] = (object_type *)phfree(hdes,node-&gt;objects[i]);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
          {
<span class="PreProc">              #ifdef PTHREAD_SUPPORT</span>
              (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

              pups_set_errno(<span class="Constant">EINVAL</span>);
              <span class="Statement">return</span>((link_type *)<span class="Constant">NULL</span>);
          }
          <span class="Statement">else</span>
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
          {  cantor_clear_object(node-&gt;objects[i]);
             node-&gt;objects[i] = (object_type *)pups_free(node-&gt;objects[i]);
          }

          --node-&gt;object_cnt;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if node name is unique (within given nodelist) ...</span>
<span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cantor_node_name_unique(nodelist_type *nodelist, <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span> || name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist-&gt;nodes[i]  != (node_type *)<span class="Constant">NULL</span>                                           &amp;&amp;
          (nodelist-&gt;nodes[i] != (node_type *)cantor_pointer_live(nodelist-&gt;nodes[i],TRUE))  &amp;&amp;
          strcmp(nodelist-&gt;nodes[i]-&gt;name,name) == <span class="Constant">0</span>                                          )
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(TRUE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if an object tag associated with given node is unique ...</span>
<span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cantor_object_tag_unique(node_type *node, <span class="Type">char</span> *object_tag)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || object_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search object list for tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node-&gt;objects[i]  != (object_type *)<span class="Constant">NULL</span>                                         &amp;&amp;
          (node-&gt;objects[i] != (object_type *)cantor_pointer_live(node-&gt;objects[i],TRUE))  &amp;&amp;
          strcmp(node-&gt;objects[i]-&gt;tag,object_tag) == <span class="Constant">0</span>                                     )
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(TRUE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Get index of an object (given its name) ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cantor_get_object_index_from_tag(node_type *node, <span class="Type">char</span> *object_tag)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || object_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search object list for tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>                                         &amp;&amp;
          (node-&gt;objects[i] = (object_type *)cantor_pointer_live(node-&gt;objects[i],TRUE))  &amp;&amp;
          strcmp(node-&gt;objects[i]-&gt;tag,object_tag) == <span class="Constant">0</span>                                    )
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Get tag of an object (given its index) ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_get_object_tag_from_index(<span class="Type">char</span> *tag, node_type *node, <span class="Type">int</span> object_index)

{   <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span> ||  object_index &lt; <span class="Constant">0</span> || object_index &gt; node-&gt;object_alloc)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(tag,node-&gt;objects[object_index]-&gt;tag,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Associate a link with a node ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Link on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_add_link_to_node(node_type *node, link_type *link)
{   <span class="Statement">return</span>(_add_link_to_node(node,link,(-<span class="Constant">1</span>),(<span class="Type">char</span> *)<span class="Constant">NULL</span>));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Link on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phadd_link_to_node(node_type *node, link_type *link, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)
{   <span class="Statement">return</span>(_add_link_to_node(node,link,hdes,name));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> _add_link_to_node(node_type *node, link_type *link, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)

{   <span class="Type">int</span> link_index;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || link == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(node-&gt;links == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  node-&gt;link_alloc            = ALLOC_QUANTUM;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {  (<span class="Type">void</span>)snprintf(node-&gt;link_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:link&quot;</span>,name);
          node-&gt;links = (link_type **)phcalloc(hdes,ALLOC_QUANTUM,<span class="Statement">sizeof</span>(link_type *),node-&gt;link_name);
          <span class="Statement">if</span>(node-&gt;links == (link_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_link_to_node] failed to extend node link array (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>((link_type *)<span class="Constant">NULL</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {  node-&gt;links = (link_type **)pups_calloc(ALLOC_QUANTUM,<span class="Statement">sizeof</span>(link_type *));
          <span class="Statement">if</span>(node-&gt;links == (link_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_link_to_node] failed to create node link array (on local heap/cache)&quot;</span>);
       }

       node-&gt;links[node-&gt;link_cnt] = link;
       link_index = <span class="Constant">0</span>;
       ++node-&gt;link_cnt;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(node-&gt;link_alloc == node-&gt;link_cnt)
    {  node-&gt;link_alloc += ALLOC_QUANTUM;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {  node-&gt;links = (link_type **)phrealloc(hdes,(<span class="Type">void</span> *)node-&gt;links,node-&gt;link_alloc*<span class="Statement">sizeof</span>(link_type *),node-&gt;link_name);
          <span class="Statement">if</span>(node-&gt;links == (link_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_link_to_node] failed to extend node link array (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {  node-&gt;links = (link_type **)pups_realloc((<span class="Type">void</span> *)node-&gt;links,node-&gt;link_alloc*<span class="Statement">sizeof</span>(link_type *));
          <span class="Statement">if</span>(node-&gt;links == (link_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_link_to_node] failed to extend node link array (local heap/cache)&quot;</span>);
       }

       node-&gt;links[node-&gt;object_cnt] = link;
       link_index                    = node-&gt;link_cnt;
       ++node-&gt;link_cnt;
    }
    <span class="Statement">else</span>
    {  <span class="Type">int</span> i;


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Search node link list for a free slot </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;link_cnt; ++i)
       {  <span class="Statement">if</span>(node-&gt;links[i] == (link_type *)<span class="Constant">NULL</span>)
             <span class="Statement">break</span>;
       }

       node-&gt;links[i] = link;
       link_index     = i;
       ++node-&gt;link_cnt;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(link_index);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Dissociate a link from a node ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target link on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_remove_link_from_node(node_type *node, <span class="Type">char</span> *link_tag)
{   <span class="Statement">return</span>(_remove_link_from_node(node,link_tag,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target link on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phremove_link_from_node(node_type *node, <span class="Type">char</span> *link_tag, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_remove_link_from_node(node,link_tag,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> _remove_link_from_node(node_type *node, <span class="Type">char</span> *link_tag, <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || link_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search object list for tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;link_alloc; ++i)
    {  <span class="Statement">if</span>(node-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>                                       &amp;&amp;
          (node-&gt;links[i] = (link_type *)cantor_pointer_live(node-&gt;links[i],TRUE))  &amp;&amp;
          strcmp(node-&gt;links[i]-&gt;tag,link_tag) == <span class="Constant">0</span>                                  )
       {
<span class="PreProc">          #ifdef PERSISTENT_HEAP_SUPPORT</span>
          <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
          {  _clear_link(node-&gt;links[i],hdes);
             node-&gt;links[i] = (link_type *)phfree(hdes,(<span class="Type">void</span> *)node-&gt;links[i]);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EINVAL</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }
          <span class="Statement">else</span>
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
          {  _clear_link(node-&gt;links[i],(-<span class="Constant">1</span>));
             node-&gt;links[i] = (link_type *)pups_free((<span class="Type">void</span> *)node-&gt;links[i]);
          }

          --node-&gt;link_cnt;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Is a link tag associated with given node unique? ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cantor_link_tag_unique(node_type *node, <span class="Type">char</span> *link_tag)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || link_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search object list for tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;link_alloc; ++i)
    {  <span class="Statement">if</span>(node-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>                                       &amp;&amp;
          (node-&gt;links[i] = (link_type *)cantor_pointer_live(node-&gt;links[i],TRUE))  &amp;&amp;
          strcmp(node-&gt;links[i]-&gt;tag,link_tag) == <span class="Constant">0</span>                                  )
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(TRUE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get link index given link tag and node containing that tag ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_get_link_index_from_tag(node_type *node, <span class="Type">char</span> *link_tag)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || link_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search object list for tag </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;link_alloc; ++i)
    {  <span class="Statement">if</span>(node-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>                                       &amp;&amp;
          (node-&gt;links[i] = (link_type *)cantor_pointer_live(node-&gt;links[i],TRUE))  &amp;&amp;
          strcmp(node-&gt;links[i]-&gt;tag,link_tag) == <span class="Constant">0</span>                                  )
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get link tag given link index ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_get_link_tag_from_index(<span class="Type">char</span> *tag, node_type *node, <span class="Type">int</span> link_index)

{

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || link_index &lt; <span class="Constant">0</span> || link_index &gt; node-&gt;link_alloc)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)strlcpy(tag,node-&gt;links[link_index]-&gt;tag,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Name a node ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_node_name(node_type *node, <span class="Type">char</span> *node_name)

{   <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || node_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(node-&gt;name,node_name,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Set type of a node ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_node_type(node_type *node, <span class="Type">char</span> *type)

{   <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || type  == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(node-&gt;type,type,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">   Display (limited) information about node (print it to file) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_show_node_info(<span class="Type">FILE</span> *stream, node_type *node)

{   <span class="Type">int</span> i;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cantor_show_node_info] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || node == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(strcmp(node-&gt;name,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Node </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (type </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>, node-&gt;name, node-&gt;type);
    <span class="Statement">if</span>(node-&gt;object_alloc &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    objects:    </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,node-&gt;object_cnt,node-&gt;object_alloc);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    objects:    non allocated</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(node-&gt;link_alloc &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Links:   </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,node-&gt;link_cnt,node-&gt;link_alloc);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Links:   non allocated</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(node-&gt;object_alloc &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Print list of objects associated with node </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Object list</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ===========</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_alloc; ++i)
       {  <span class="Statement">if</span>(node-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>(node-&gt;objects[i] = (object_type *)cantor_pointer_live(node-&gt;objects[i],TRUE))
             {  <span class="Statement">if</span>(node-&gt;objects[i]-&gt;olink != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%4d</span><span class="Constant"> object </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [type </span><span class="Special">%-16s</span><span class="Constant">] attached to node (object pointer at 0x</span><span class="Special">%010x</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                  i,
                                                                                                              node-&gt;objects[i]-&gt;tag,
                                                                                                             node-&gt;objects[i]-&gt;type,
                                                                                         (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)node-&gt;objects[i]-&gt;olink);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%4d</span><span class="Constant"> object </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [type </span><span class="Special">%-16s</span><span class="Constant">] attached to node (object pointer not set)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                       i,
                                                                                                   node-&gt;objects[i]-&gt;tag,
                                                                                                  node-&gt;objects[i]-&gt;type);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%4d</span><span class="Constant"> object: is stale (and has been removed)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i);
                (<span class="Type">void</span>)fflush(stream);
             }
          }
       }
    }

    <span class="Statement">if</span>(node-&gt;link_alloc &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Print list of links associated with node </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Link list</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =========</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_alloc; ++i)
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;link_alloc; ++i)
       {  <span class="Statement">if</span>(node-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>(node-&gt;links[i] = (link_type *)cantor_pointer_live(node-&gt;links[i],TRUE))
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%4d</span><span class="Constant"> link </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> [nodes </span><span class="Special">%04d</span><span class="Constant">, type </span><span class="Special">%-16s</span><span class="Constant">] associated with node (length </span><span class="Special">%6.3F</span><span class="Constant">, flux </span><span class="Special">%6.3F</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                       i,
                                                                                                                     node-&gt;links[i]-&gt;tag,
                                                                                                              node-&gt;links[i]-&gt;node_alloc,
                                                                                                                    node-&gt;links[i]-&gt;type,
                                                                                                                  node-&gt;links[i]-&gt;length,
                                                                                                                    node-&gt;links[i]-&gt;flux);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant"> link: is stale (and has been removed)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i);
                (<span class="Type">void</span>)fflush(stream);
             }
          }
       }
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear a link ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target link on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC link_type *cantor_clear_link(link_type *link)
{   <span class="Statement">return</span>(_clear_link(link,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target link on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC link_type *cantor_phclear_link(link_type *link, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_clear_link(link,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE link_type *_clear_link(link_type *link, <span class="Type">int</span> hdes)

{   <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((link_type *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       link-&gt;routelist  = (node_type **)phfree(hdes,(<span class="Type">void</span> *)link-&gt;routelist);
    <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">        #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((link_type *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((link_type *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       link-&gt;routelist  = (node_type **)pups_free((<span class="Type">void</span> *)link-&gt;routelist);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>((link_type *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear linklist ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target linklist on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PUBLIC link_type **cantor_clear_linklist(link_type **link, <span class="Type">int</span> size)
{   <span class="Statement">return</span>(_clear_linklist(link,size,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Target linklist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PUBLIC link_type **cantor_phclear_linklist(link_type **link, <span class="Type">int</span> size, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_clear_linklist(link,size,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE link_type **_clear_linklist(link_type **link, <span class="Type">int</span> size, <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(link == (link_type **)<span class="Constant">NULL</span> || size &lt;= <span class="Constant">0</span> || hdes &lt; <span class="Constant">0</span> || hdes &gt; appl_max_pheaps)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((link_type **)<span class="Constant">NULL</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
    {  <span class="Statement">if</span>(link[i] == (link_type *)<span class="Constant">NULL</span> || (link[i] == (link_type *)cantor_pointer_live(link[i],TRUE)))
       {

<span class="PreProc">          #ifdef PERSISTENT_HEAP_SUPPORT</span>
          <span class="Statement">if</span>(hdes &gt;= <span class="Constant">0</span>)
             (<span class="Type">void</span>)cantor_phclear_link(link[i],hdes);
          <span class="Statement">else</span>
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
             (<span class="Type">void</span>)cantor_clear_link(link[i]);
       }
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>((link_type **)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Add an object to a link ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desitnation link on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_add_node_to_link(link_type *link, node_type *node)
{   <span class="Statement">return</span>( _add_node_to_link(link,node,(-<span class="Constant">1</span>),(<span class="Type">char</span> *)<span class="Constant">NULL</span>));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination link on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phadd_node_to_link(link_type *link, node_type *node, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)
{   <span class="Statement">return</span>( _add_node_to_link(link,node,hdes,name));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> _add_node_to_link(link_type *link, node_type *node, <span class="Type">int</span> hdes, <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span> || node == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(link-&gt;node_cnt == <span class="Constant">0</span>)
    {  link-&gt;node_alloc = ALLOC_QUANTUM;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       {  (<span class="Type">void</span>)snprintf(link-&gt;node_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:routelist&quot;</span>,name);
          link-&gt;routelist = (node_type **)phcalloc(hdes,ALLOC_QUANTUM,<span class="Statement">sizeof</span>(node_type **),link-&gt;node_name);
          <span class="Statement">if</span>(link-&gt;routelist == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_link] failed to create link routelist (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

           pups_set_errno(<span class="Constant">EINVAL</span>);
           <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {  link-&gt;routelist = (node_type **)pups_calloc(ALLOC_QUANTUM,<span class="Statement">sizeof</span>(node_type **));
          <span class="Statement">if</span>(link-&gt;routelist == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_link] failed to create link routelist (on local heap/cache)&quot;</span>);
       }

       link-&gt;routelist[<span class="Constant">0</span>] = node;
       ++link-&gt;node_cnt;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(link-&gt;node_cnt == link-&gt;node_alloc)
    {  link-&gt;node_alloc += ALLOC_QUANTUM;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">if</span>(hdes &gt;= <span class="Constant">0</span>)
       {  link-&gt;routelist = (node_type **)phrealloc(hdes,(<span class="Type">void</span> *)link-&gt;routelist,ALLOC_QUANTUM*<span class="Statement">sizeof</span>(node_type **),link-&gt;node_name);
          <span class="Statement">if</span>(link-&gt;routelist == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_link] failed to extend link routelist (on persistent heap)&quot;</span>);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       {  link-&gt;routelist                 = (node_type **)pups_realloc((<span class="Type">void</span> *)link-&gt;routelist,ALLOC_QUANTUM*<span class="Statement">sizeof</span>(node_type **));
          <span class="Statement">if</span>(link-&gt;routelist == (node_type **)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[_add_node_to_link] failed to extend link routelist (on local heap)&quot;</span>);
       }

       link-&gt;routelist[link-&gt;node_cnt] = node;
       ++link-&gt;node_cnt;
    }
    <span class="Statement">else</span>
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link-&gt;node_alloc; ++i)
       {  <span class="Statement">if</span>(link-&gt;routelist[i] == (node_type *)<span class="Constant">NULL</span>)
          {  link-&gt;routelist[i] = node;
             ++link-&gt;node_cnt;
             <span class="Statement">break</span>;
          }
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Remove node from a link ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_remove_node_from_link(link_type *link, <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span> || name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(link-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>                                            &amp;&amp;
          (link-&gt;routelist[i] != (node_type *)cantor_pointer_live(link-&gt;routelist[i],TRUE))  &amp;&amp;
          strcmp(link-&gt;routelist[i]-&gt;name,name) == <span class="Constant">0</span>                                          )
       {  link-&gt;routelist[i] = (node_type *)<span class="Constant">NULL</span>;
          <span class="Statement">break</span>;
       }
    }

    --link-&gt;node_cnt;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Show link information (print to file)) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> cantor_show_link_info(<span class="Type">FILE</span> *stream, link_type *link)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cantor_show_link_info] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || link == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(link-&gt;node_cnt &gt; <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Link (for link </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">, [type </span><span class="Special">%s</span><span class="Constant">])</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,link-&gt;tag,link-&gt;type);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    length:  </span><span class="Special">%6.3F</span><span class="Special">\n</span><span class="Constant">&quot;</span>,link-&gt;length);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    flux:    </span><span class="Special">%6.3F</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,link-&gt;flux);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    &quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link-&gt;node_alloc; ++i)
       {  <span class="Statement">if</span>(link-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>((link-&gt;routelist[i] = (node_type *)cantor_pointer_live(link-&gt;routelist[i],TRUE)))
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant">: [</span><span class="Special">%-24s</span><span class="Constant">]  &quot;</span>,i,link-&gt;routelist[i]-&gt;name);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant">: [stale]  &quot;</span>,i);
                (<span class="Type">void</span>)fflush(stream);
             }

             <span class="Statement">if</span>(cnt == <span class="Constant">5</span>)
             {  cnt == <span class="Constant">0</span>;
                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    &quot;</span>);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
                ++cnt;
          }
       }

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Copy link ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination link on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_copy_link(<span class="Type">char</span> *tag, link_type *from, link_type *to)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || from == (link_type *)<span class="Constant">NULL</span> || to == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear any existing link data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    cantor_clear_link(to);

    (<span class="Type">void</span>)strlcpy(to-&gt;tag,tag,SSIZE);
    (<span class="Type">void</span>)strlcpy(to-&gt;type,from-&gt;type,SSIZE);

    to-&gt;node_cnt   = from-&gt;node_cnt;
    to-&gt;node_alloc = from-&gt;node_alloc;
    to-&gt;flux       = from-&gt;flux;
    to-&gt;length     = from-&gt;length;

    to-&gt;routelist  = (node_type **)pups_realloc((<span class="Type">void</span> *)to-&gt;routelist,to-&gt;node_alloc*<span class="Statement">sizeof</span>(node_type *));
    <span class="Statement">if</span>(to-&gt;routelist == (node_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor_copy_link] could not extend </span><span class="Special">\&quot;</span><span class="Constant">to node</span><span class="Special">\&quot;</span><span class="Constant"> route list (on local heap/cache)&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (from-&gt;routelist[i] = (node_type *)cantor_pointer_live(from-&gt;routelist[i],TRUE)))
       {  to-&gt;routelist[cnt] = from-&gt;routelist[i];
          ++cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination link on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phcopy_link(<span class="Type">int</span> hdes, <span class="Type">char</span> *tag, link_type *from, link_type *to)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || from == (link_type *)<span class="Constant">NULL</span> || to == (link_type *)<span class="Constant">NULL</span> || hdes &lt; <span class="Constant">0</span> || hdes &gt; appl_max_pheaps)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear any existing link data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    cantor_phclear_link(to,hdes);

    (<span class="Type">void</span>)strlcpy(to-&gt;tag,tag,        SSIZE);
    (<span class="Type">void</span>)strlcpy(to-&gt;type,from-&gt;type,SSIZE);

    to-&gt;node_cnt   = from-&gt;node_cnt;
    to-&gt;node_alloc = from-&gt;node_alloc;
    to-&gt;flux       = from-&gt;flux;
    to-&gt;length     = from-&gt;length;

    to-&gt;routelist  = (node_type **)phrealloc(hdes,(<span class="Type">void</span> *)to-&gt;routelist,to-&gt;node_alloc*<span class="Statement">sizeof</span>(node_type *),tag);
    <span class="Statement">if</span>(to-&gt;routelist == (node_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor_phcopy_link] could not extend </span><span class="Special">\&quot;</span><span class="Constant">to node</span><span class="Special">\&quot;</span><span class="Constant"> route list (on persistent heap)&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (from-&gt;routelist[i] = (node_type *)cantor_pointer_live(from-&gt;routelist[i],TRUE)))
       {  to-&gt;routelist[cnt] = from-&gt;routelist[i];
          ++cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Copy a node ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination node on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_copy_node(<span class="Type">char</span> *name, node_type *from, node_type *to)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || from == (node_type *)<span class="Constant">NULL</span> || to == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove any existing object data on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    cantor_clear_node(to);


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy node variables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(to-&gt;name,name,      SSIZE);
    (<span class="Type">void</span>)strlcpy(to-&gt;type,from-&gt;type,SSIZE);

    to-&gt;object_cnt   = from-&gt;object_cnt;
    to-&gt;object_alloc = from-&gt;object_alloc;
    to-&gt;link_cnt     = from-&gt;link_cnt;
    to-&gt;link_alloc   = from-&gt;link_alloc;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure we have sufficient dataspace on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    to-&gt;objects = (object_type **)pups_realloc((<span class="Type">void</span> *)to-&gt;objects,to-&gt;object_alloc*<span class="Statement">sizeof</span>(object_type *));
    <span class="Statement">if</span>(to-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor copy node] could not extend </span><span class="Special">\&quot;</span><span class="Constant">to node</span><span class="Special">\&quot;</span><span class="Constant"> object array (on local heap/cache)&quot;</span>);

    to-&gt;links   =  (link_type **) pups_realloc((<span class="Type">void</span> *)to-&gt;links,  to-&gt;link_alloc*<span class="Statement">sizeof</span>(link_type *));
    <span class="Statement">if</span>(to-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor copy node] could not extend </span><span class="Special">\&quot;</span><span class="Constant">to node</span><span class="Special">\&quot;</span><span class="Constant"> link array (on local heap/cache)&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy object data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span> &amp;&amp; (from-&gt;objects[i] == (object_type *)cantor_pointer_live(from-&gt;objects[i],TRUE)))
       {  to-&gt;objects[cnt] = from-&gt;objects[i];
          ++cnt;
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy link data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    cnt = <span class="Constant">0</span>;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;link_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>)
       {  to-&gt;links[cnt] = from-&gt;links[i];
          ++cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination node on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phcopy_node(<span class="Type">int</span> hdes, <span class="Type">char</span> *name, node_type *from, node_type *to)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(from == (node_type *)<span class="Constant">NULL</span> || to == (node_type *)<span class="Constant">NULL</span> || hdes &lt; <span class="Constant">0</span> || hdes &gt; appl_max_pheaps)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove any existing object data on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    cantor_phclear_node(to,hdes);


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy node variables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(to-&gt;name,name,      SSIZE);
    (<span class="Type">void</span>)strlcpy(to-&gt;type,from-&gt;type,SSIZE);

    to-&gt;object_cnt   = from-&gt;object_cnt;
    to-&gt;object_alloc = from-&gt;object_alloc;
    to-&gt;link_cnt     = from-&gt;link_cnt;
    to-&gt;link_alloc   = from-&gt;link_alloc;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure we have sufficient dataspace on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    to-&gt;objects = (object_type **)phrealloc(hdes,(<span class="Type">void</span> *)to-&gt;objects,to-&gt;object_alloc*<span class="Statement">sizeof</span>(object_type *),name);
    <span class="Statement">if</span>(to-&gt;objects == (object_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor_phcopy_node] could not extend </span><span class="Special">\&quot;</span><span class="Constant">to node</span><span class="Special">\&quot;</span><span class="Constant"> object array (on persistent heap)&quot;</span>);

    to-&gt;links   =  (link_type **) phrealloc(hdes,(<span class="Type">void</span> *)to-&gt;links,  to-&gt;link_alloc*<span class="Statement">sizeof</span>(link_type *),name);
    <span class="Statement">if</span>(to-&gt;links == (link_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor_phcopy_node] could not extend </span><span class="Special">\&quot;</span><span class="Constant">to node</span><span class="Special">\&quot;</span><span class="Constant"> link array (on persistent heap)&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy object data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span> &amp;&amp; (from-&gt;objects[i] == (object_type *)cantor_pointer_live(from-&gt;objects[i],TRUE)))
       {  to-&gt;objects[cnt] = from-&gt;objects[i];
          ++cnt;
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy link data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    cnt = <span class="Constant">0</span>;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;link_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>)
       {  to-&gt;links[cnt] = from-&gt;links[i];
          ++cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">     Copy a nodelist ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination nodelist on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_copy_nodelist(<span class="Type">char</span> *name, nodelist_type *from, nodelist_type *to)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || from == (nodelist_type *)<span class="Constant">NULL</span> || to == (nodelist_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove any existing object data on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    cantor_clear_nodelist(to);


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy node variables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(to-&gt;name,name,      SSIZE);
    (<span class="Type">void</span>)strlcpy(to-&gt;type,from-&gt;type,SSIZE);

    to-&gt;node_cnt   = from-&gt;node_cnt;
    to-&gt;node_alloc = from-&gt;node_alloc;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure we have sufficient dataspace on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    to-&gt;nodes = (node_type **)pups_realloc((<span class="Type">void</span> *)to-&gt;nodes,to-&gt;node_alloc*<span class="Statement">sizeof</span>(node_type *));
    <span class="Statement">if</span>(to-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor_copy_nodelist] failed to extend </span><span class="Special">\&quot;</span><span class="Constant">to nodelist</span><span class="Special">\&quot;</span><span class="Constant"> (on local heap)&quot;</span>);

    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy node data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (from-&gt;nodes[i] == (node_type *)cantor_pointer_live(from-&gt;nodes[i],TRUE)))
       {  to-&gt;nodes[cnt] = from-&gt;nodes[i];
          ++cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination nodelist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phcopy_nodelist(<span class="Type">int</span> hdes, <span class="Type">char</span> *name, nodelist_type *from, nodelist_type *to)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(from == (nodelist_type *)<span class="Constant">NULL</span> || to == (nodelist_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove any existing_object data on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    cantor_phclear_nodelist(to,hdes);


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy node variables </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(to-&gt;name,name,SSIZE);
    (<span class="Type">void</span>)strlcpy(to-&gt;type,from-&gt;type,SSIZE);

    to-&gt;node_cnt   = from-&gt;node_cnt;
    to-&gt;node_alloc = from-&gt;node_alloc;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure we have sufficient dataspace on &quot;to&quot; node </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    to-&gt;nodes = (node_type **)phrealloc(hdes,(<span class="Type">void</span> *)to-&gt;nodes,to-&gt;node_alloc*<span class="Statement">sizeof</span>(node_type *), name);
    <span class="Statement">if</span>(to-&gt;nodes == (node_type **)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[cantor_phcopy_nodelist] failed to extend </span><span class="Special">\&quot;</span><span class="Constant">to nodelist</span><span class="Special">\&quot;</span><span class="Constant"> (on persistent heap)&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy node data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;from-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(from-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (from-&gt;nodes[i] == (node_type *)cantor_pointer_live(from-&gt;nodes[i],TRUE)))
       {  to-&gt;nodes[cnt] = from-&gt;nodes[i];
          ++cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;from-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;to-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Set link tag ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_link_tag(link_type *link, <span class="Type">char</span> *tag)

{   <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span> || tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(link-&gt;tag,tag,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Set link type ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_link_type(link_type *link, <span class="Type">char</span> *type)

{   <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span> || type == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(link-&gt;type,type,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Set link flux ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_link_flux(link_type *link, FTYPE flux)

{   <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    link-&gt;flux = flux;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Set link length ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_link_length(link_type *link, FTYPE length)

{   <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    link-&gt;length = length;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Compare a pair of nodes ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN cantor_compare_nodes(node_type *n1, node_type *n2)

{   <span class="Type">int</span> i,
        matched = <span class="Constant">0</span>;

    <span class="Statement">if</span>(n1 == (node_type *)<span class="Constant">NULL</span> || n2 == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;n1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;n2-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n1-&gt;object_cnt != n2-&gt;object_cnt    ||
       n1-&gt;link_cnt   != n2-&gt;link_cnt       )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Compare objects </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n1-&gt;object_alloc; ++i)
    {  <span class="Type">int</span> j;

       <span class="Statement">for</span>(j=i; j&lt;n2-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(n1-&gt;objects[i] == n2-&gt;objects[j])
             ++matched;
       }
    }

    <span class="Statement">if</span>(matched != n1-&gt;object_cnt &amp;&amp; matched != n2-&gt;object_cnt)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;n1-&gt;mutex);
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;n2-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Compare links </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    matched = <span class="Constant">0</span>;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n1-&gt;link_alloc; ++i)
    {  <span class="Type">int</span> j;

       <span class="Statement">for</span>(j=i; j&lt;n2-&gt;link_alloc; ++j)
       {  <span class="Statement">if</span>(n1-&gt;links[i] == n2-&gt;links[j])
             ++matched;
       }
    }

    <span class="Statement">if</span>(matched != n1-&gt;link_cnt &amp;&amp; matched != n2-&gt;link_cnt)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;n1-&gt;mutex);
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;n2-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;n1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;n2-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear an object ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Object on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PUBLIC object_type *cantor_clear_object(object_type *object)
{   <span class="Statement">return</span>(_clear_object(object,(-<span class="Constant">1</span>)));
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Object on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC object_type *cantor_phclear_object(object_type *object, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_clear_object(object,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE object_type *_clear_object(object_type *object, <span class="Type">int</span> hdes)


{   <span class="Statement">if</span>(object == (object_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((object_type *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
       (<span class="Type">void</span>)phfree(hdes,(<span class="Type">void</span> *)object);
    <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;object-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((object_type *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)object);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>((object_type *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear an object list ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Object list on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC object_type **cantor_clear_objectlist(object_type **object, <span class="Type">int</span> size)
{   <span class="Statement">return</span>(_clear_objectlist(object,size,(-<span class="Constant">1</span>)));
}

<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Object list on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC  object_type **cantor_phclear_objectlist(object_type **object, <span class="Type">int</span> size, <span class="Type">int</span> hdes)
{   <span class="Statement">return</span>(_clear_objectlist(object,size,hdes));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


_PRIVATE object_type **_clear_objectlist(object_type **object, <span class="Type">int</span> size, <span class="Type">int</span> hdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(object == (object_type **)<span class="Constant">NULL</span> || size &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((object_type **)<span class="Constant">NULL</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
    {  <span class="Statement">if</span>(object[i] != (object_type *)<span class="Constant">NULL</span> &amp;&amp; (object[i] = (object_type *)cantor_pointer_live(object[i],TRUE)))

<span class="PreProc">          #ifdef PERSISTENT_HEAP_SUPPORT</span>
          <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span> &amp;&amp; hdes &lt; appl_max_pheaps)
             (<span class="Type">void</span>)cantor_phclear_object(object[i],hdes);
          <span class="Statement">else</span> <span class="Statement">if</span>(hdes &gt; <span class="Constant">0</span>)
          {  pups_set_errno(<span class="Constant">EINVAL</span>);
             <span class="Statement">return</span>((object_type **)<span class="Constant">NULL</span>);
          }
          <span class="Statement">else</span>
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
             (<span class="Type">void</span>)cantor_clear_object(object[i]);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>((object_type **)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Set object name ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_object_tag(object_type *object, <span class="Type">char</span> *tag)

{   <span class="Statement">if</span>(object == (object_type *)<span class="Constant">NULL</span> || tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(object-&gt;tag,tag,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Set object type ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_object_type(object_type *object, <span class="Type">char</span> *type)

{   <span class="Statement">if</span>(object == (object_type *)<span class="Constant">NULL</span> || type == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(object-&gt;type,type,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Add a databag or DLL to an object ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_set_olink(object_type *object,  <span class="Comment">// Object</span>
                             <span class="Type">void</span>        *olink)   <span class="Comment">// Link data or DLL</span>

{   <span class="Statement">if</span>(object == (object_type *)<span class="Constant">NULL</span> || olink == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    object-&gt;olink = olink;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;object-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Is the pointer live?  ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *cantor_pointer_live(<span class="Type">void</span>     *pointer,                <span class="Comment">// Pointer to test (returns NULL if pointer invalid)</span>
                                  _BOOLEAN restore_default_handler) <span class="Comment">// Restore default handlers post test</span>

{   <span class="Type">void</span>  *ret = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    _BYTE test;

    <span class="Statement">if</span>(pointer == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set a (temporary) handler for SIGSEGV. If pointer is dead </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> it will cause SIGSEGV to be raised, in which case we need </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to clear the pointer and return                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_backtrack(TRUE) == PUPS_BACKTRACK)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stale pointer (at 0x</span><span class="Special">%010x</span><span class="Constant"> virtual) -- clearing</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                 date,appl_name,appl_pid,appl_host,appl_owner,(<span class="Type">unsigned</span> <span class="Type">long</span>)pointer);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       ret = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       pups_set_errno(<span class="Constant">EACCES</span>);
    }
    <span class="Statement">else</span>
    {  test = *(_BYTE *)pointer;
       ret  =  (<span class="Type">void</span>  *)pointer;
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restore signal handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(restore_default_handler == TRUE)
       (<span class="Type">void</span>)pups_backtrack(FALSE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">   Show (limited) node information (HTML) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_vhtml_node_info(_BOOLEAN  full_node_info,  <span class="Comment">// TRUE if full link information required </span>
                                   <span class="Type">char</span>      *dir,            <span class="Comment">// Directory containing (virtual) HTML file</span>
                                   <span class="Type">char</span>      *filename,       <span class="Comment">// Name of virtual HTML file</span>
                                   node_type *node)           <span class="Comment">// Node containing data</span>

{   <span class="Type">int</span> i;

    <span class="Type">char</span> current_dir[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">FILE</span> *stream            = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cantor_vhtml_node_info] attempt by non root thread to perform PUPS/P3 cantor operation&quot;</span>);


    <span class="Statement">if</span>(filename == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || strin(filename,<span class="Constant">&quot;.html&quot;</span>) == FALSE)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || strcmp(node-&gt;name,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)getcwd(current_dir,SSIZE);
       <span class="Statement">if</span>(chdir(dir) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ENOENT</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(filename,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)pups_creat(filename,<span class="PreProc">0</span><span class="Constant">600</span>);

    stream = pups_fopen(filename,<span class="Constant">&quot;w&quot;</span>,LIVE);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Node information page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(node == (node_type *)<span class="Constant">NULL</span> || node-&gt;object_cnt == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(node-&gt;object_cnt == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Node </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [type </span><span class="Special">%s</span><span class="Constant">] is empty&lt;hr&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                             CANTOR_VERSION,node-&gt;name, node-&gt;type);

          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h5&gt;&quot;</span>);

          <span class="Statement">if</span>(node-&gt;object_alloc &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;objects:    </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,node-&gt;object_cnt,node-&gt;object_alloc);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;objects:    non allocated&lt;br&gt;&quot;</span>);

          <span class="Statement">if</span>(node-&gt;link_alloc &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;links:   </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,node-&gt;link_cnt,node-&gt;link_alloc);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;links:   non allocated&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&lt;/center&gt;&quot;</span>);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Node is NULL&lt;/h3&gt;&lt;/center&gt;&lt;hr&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;hr&gt;&lt;br&gt;&lt;center&gt;&lt;h6&gt;Web page generated automatically by &lt;b&gt;cantor&lt;/b&gt; vhtml generator (version 1.00)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;(C) M.A. O'Neill, Tumbling Dice, 2022 (mao@@tumblingdice.co.uk)&lt;/center&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/body&gt;&lt;/html&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       (<span class="Type">void</span>)pups_fclose(stream);

       <span class="Statement">if</span>(dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)chdir(current_dir);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">)&lt;br&gt;Node &lt;b&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/b&gt; [type </span><span class="Special">%s</span><span class="Constant">]&lt;/h3&gt;&lt;/center&gt;&lt;hr&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                CANTOR_VERSION,node-&gt;name, node-&gt;type);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h5&gt;&quot;</span>);
    <span class="Statement">if</span>(node-&gt;object_alloc &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;objects:    </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,node-&gt;object_cnt,node-&gt;object_alloc);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;objects:    non allocated&quot;</span>);

    <span class="Statement">if</span>(node-&gt;link_alloc &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;links:   </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,node-&gt;link_cnt,node-&gt;link_alloc);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;links:   non allocated&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&lt;/center&gt;&quot;</span>);

    <span class="Statement">if</span>(node-&gt;object_alloc &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Print list of objects associated with node </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;hr&gt;&lt;h4&gt;&lt;center&gt;&lt;b&gt;Object list&lt;/b&gt;&lt;/center&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;h5&gt;&quot;</span>);
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;object_alloc; ++i)
       {  <span class="Statement">if</span>(node-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>(node-&gt;objects[i] = (object_type *)cantor_pointer_live(node-&gt;objects[i],TRUE))
             {  <span class="Statement">if</span>(node-&gt;objects[i]-&gt;olink != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                {  <span class="Type">char</span> object_info[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                   <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Can we produce a live link to specified object? </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

                   <span class="Statement">if</span>(node-&gt;objects[i]-&gt;infopage != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; access(node-&gt;objects[i]-&gt;infopage,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
                      (<span class="Type">void</span>)snprintf(object_info,SSIZE,<span class="Constant">&quot;, (see &lt;a href=</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/a&gt;)&quot;</span>,node-&gt;objects[i]-&gt;infopage,node-&gt;objects[i]-&gt;infopage);
                   <span class="Statement">else</span>
                      (<span class="Type">void</span>)snprintf(object_info,SSIZE,<span class="Constant">&quot;&quot;</span>);


                   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant"> object &lt;b&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/b&gt; [type </span><span class="Special">%s%s</span><span class="Constant">] attached to node object pointer at 0x</span><span class="Special">%010x</span><span class="Constant"> virtual)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                    i,
                                                                                                                node-&gt;objects[i]-&gt;tag,
                                                                                                                          object_info,
                                                                                                               node-&gt;objects[i]-&gt;type,
                                                                                               (<span class="Type">unsigned</span> <span class="Type">long</span>)node-&gt;objects[i]-&gt;olink);
                }
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant"> object &lt;b&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/b&gt; [type </span><span class="Special">%-16s</span><span class="Constant">] attached to node (object pointer not set)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                           i,
                                                                                                       node-&gt;objects[i]-&gt;tag,
                                                                                                      node-&gt;objects[i]-&gt;type);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant"> object: is stale (and has been removed)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i);
                (<span class="Type">void</span>)fflush(stream);
             }
          }
       }
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&quot;</span>);
    }

    <span class="Statement">if</span>(node-&gt;link_alloc &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Print list of links associated with node </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;center&gt;&lt;h4&gt;Link list&lt;br&gt;&lt;/center&gt;&lt;hr&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;h5&gt;&quot;</span>);
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node-&gt;link_alloc; ++i)
       {  <span class="Statement">if</span>(node-&gt;links[i] != (link_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>(node-&gt;links[i] = (link_type *)cantor_pointer_live(node-&gt;links[i],TRUE))
             {  <span class="Type">char</span> link_info[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
                     link_info_filename[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Generate full link info (if user has asked for it) </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(full_node_info == TRUE)
                {  (<span class="Type">void</span>)snprintf(link_info_filename,SSIZE,<span class="Constant">&quot;link.</span><span class="Special">%s</span><span class="Constant">.html&quot;</span>,node-&gt;links[i]-&gt;tag);
                   (<span class="Type">void</span>)cantor_vhtml_link_info((<span class="Type">char</span> *)<span class="Constant">NULL</span>,link_info_filename,node-&gt;links[i]);
                   (<span class="Type">void</span>)snprintf(link_info,SSIZE,<span class="Constant">&quot;&lt;a href=</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/a&gt;&quot;</span>,link_info_filename,node-&gt;links[i]-&gt;tag);
                }
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)snprintf(link_info,SSIZE,<span class="Constant">&quot;&lt;b&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/b&gt;&quot;</span>,node-&gt;links[i]-&gt;tag);

                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant"> link </span><span class="Special">%s</span><span class="Constant"> [nodes </span><span class="Special">%04d</span><span class="Constant">, type </span><span class="Special">%-16s</span><span class="Constant">] associated with node (length </span><span class="Special">%6.3F</span><span class="Constant">, flux </span><span class="Special">%6.3F</span><span class="Constant">)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                 i,
                                                                                                                         link_info,
                                                                                                        node-&gt;links[i]-&gt;node_alloc,
                                                                                                              node-&gt;links[i]-&gt;type,
                                                                                                            node-&gt;links[i]-&gt;length,
                                                                                                              node-&gt;links[i]-&gt;flux);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant"> link: is stale (and has been removed)&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i);
                (<span class="Type">void</span>)fflush(stream);
             }
          }
       }
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&quot;</span>);
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;hr&gt;&lt;br&gt;&lt;center&gt;&lt;h6&gt;Web page generated automatically by &lt;b&gt;cantor&lt;/b&gt; vhtml generator (version 1.00)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;(C) M.A. O'Neill, Tumbling Dice, 2022 (mao@@tumblingdice.co.uk)&lt;/center&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/body&gt;&lt;/html&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    (<span class="Type">void</span>)pups_fclose(stream);

    <span class="Statement">if</span>(dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)chdir(current_dir);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Show link information (HTML) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_vhtml_link_info(<span class="Type">char</span> *dir,         <span class="Comment">// Directory of generated (virtual) HTML file</span>
                                   <span class="Type">char</span> *filename,    <span class="Comment">// Filename of (virtual) HTML file</span>
                                   link_type *link)   <span class="Comment">// Link data</span>

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Type">char</span> current_dir[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">FILE</span> *stream            = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cantor_vhtml_link_info] attempt by non root thread to perform PUPS/P3 cantor operation&quot;</span>);

    <span class="Statement">if</span>(filename == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || strin(filename,<span class="Constant">&quot;.html&quot;</span>) == FALSE)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)getcwd(current_dir,SSIZE);
       <span class="Statement">if</span>(chdir(dir) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ENOENT</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(filename,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)pups_creat(filename,<span class="PreProc">0</span><span class="Constant">600</span>);

    stream = pups_fopen(filename,<span class="Constant">&quot;w&quot;</span>,LIVE);

    <span class="Statement">if</span>(link == (link_type *)<span class="Constant">NULL</span> || link-&gt;node_cnt == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Link information page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       <span class="Statement">if</span>(link-&gt;node_cnt == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;&lt;b&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Link </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [type </span><span class="Special">%s</span><span class="Constant">] is empty&lt;/center&gt;&lt;/b&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION,link-&gt;tag,link-&gt;type);
          <span class="Statement">if</span>(link-&gt;node_alloc &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h5&gt;Link nodes:    (</span><span class="Special">%04d</span><span class="Constant"> allocated)&lt;/h5&gt;&lt;/center&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,link-&gt;node_alloc);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h5&gt;Link nodes:    non allocated&lt;/h5&gt;&lt;/center&gt;&quot;</span>);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;&lt;b&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Link is NULL&lt;/h3&gt;&lt;/center&gt;&lt;/b&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h6&gt;Web page generated automatically by &lt;b&gt;cantor&lt;/b&gt; vhtml generator version 1.00&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;(C) M.A. O'Neill, Tumbling Dice, 2022 (mao@@tumblingdice.co.uk)&lt;/center&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/body&gt;&lt;/html&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       (<span class="Type">void</span>)pups_fclose(stream);
       <span class="Statement">if</span>(dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)chdir(current_dir);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(link-&gt;node_cnt &gt; <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Link information page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;&lt;b&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Link (for link </span><span class="Special">%s</span><span class="Constant">, [type </span><span class="Special">%s</span><span class="Constant">])&lt;/center&gt;&lt;/b&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION,link-&gt;tag,link-&gt;type);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h5&gt;&quot;</span>);
       <span class="Statement">if</span>(link-&gt;node_alloc &gt; <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;Link nodes:    </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%04d</span><span class="Constant"> allocated)&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,link-&gt;node_cnt,link-&gt;node_alloc);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;Link nodes:    non allocated&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;length:  </span><span class="Special">%6.3F</span><span class="Constant">&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,link-&gt;length);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;flux:    </span><span class="Special">%6.3F</span><span class="Constant">&lt;br&gt;&lt;br&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,link-&gt;flux);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&lt;/center&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h4&gt;Nodes associated with link&lt;/center&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;h5&gt;&quot;</span>);
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link-&gt;node_alloc; ++i)
       {  <span class="Statement">if</span>(link-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>)
          {  <span class="Statement">if</span>((link-&gt;routelist[i] = (node_type *)cantor_pointer_live(link-&gt;routelist[i],TRUE)))
             {  <span class="Type">char</span> node_info[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
                     node_info_filename[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Do we have a live link to the link node? </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

                (<span class="Type">void</span>)snprintf(node_info_filename,SSIZE,<span class="Constant">&quot;node.</span><span class="Special">%s</span><span class="Constant">.html&quot;</span>,link-&gt;routelist[i]-&gt;name);

                <span class="Statement">if</span>(access(node_info_filename,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
                   (<span class="Type">void</span>)snprintf(node_info,SSIZE,<span class="Constant">&quot;&lt;a href=</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/a&gt;&quot;</span>,node_info_filename,link-&gt;routelist[i]-&gt;name);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)snprintf(node_info,SSIZE,<span class="Constant">&quot;&lt;b&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/b&gt;&quot;</span>,link-&gt;routelist[i]-&gt;name);

                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant">]    &quot;</span>,i,node_info);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant">: stale]    &quot;</span>,i);
                (<span class="Type">void</span>)fflush(stream);
             }

             <span class="Statement">if</span>(cnt == <span class="Constant">5</span>)
             {  cnt == <span class="Constant">0</span>;
                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(stream);
             }
             <span class="Statement">else</span>
                ++cnt;
          }
       }
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&quot;</span>);

       <span class="Statement">if</span>(cnt != <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(stream);
       }

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h6&gt;Web page generated automatically by &lt;b&gt;cantor&lt;/b&gt; vhtml generator version 1.00&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;(C) M.A. O'Neill, Tumbling Dice, 2022 (mao@@tumblingdice.co.uk)&lt;/center&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/body&gt;&lt;/html&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);
    }

    <span class="Statement">if</span>(dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)chdir(current_dir);

    (<span class="Type">void</span>)pups_fclose(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span>
<span class="Comment">    Display node (as VHTML page) ...</span>
<span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_vhtml_node_browse(_BOOLEAN   full_node_info,  <span class="Comment">// TRUE if full node data required </span>
                                     <span class="Type">char</span>      *browser,         <span class="Comment">// Browser to display (virtual) HTML</span>
                                     node_type *node)            <span class="Comment">// Node containing data</span>

{   <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> vhtml_filename[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         vhtml_dirname[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         browser_command[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         rm_command[SSIZE]      = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">static</span> _BOOLEAN in_vhtml_node_browse = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cantor_vhtml_node_browse] attempt by non root thread to perform PUPS/P3 cantor operation&quot;</span>);

    <span class="Statement">if</span>(browser == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || node == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(in_vhtml_node_browse == TRUE)
    {  pups_set_errno(<span class="Constant">EBUSY</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       in_vhtml_node_browse = TRUE;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate HTML </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(vhtml_dirname,SSIZE,<span class="Constant">&quot;vhtml.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.dir.tmp&quot;</span>,appl_name,appl_pid,appl_host);
    (<span class="Type">void</span>)mkdir(vhtml_dirname,<span class="PreProc">0</span><span class="Constant">770</span>);
    (<span class="Type">void</span>)snprintf(vhtml_filename,SSIZE,<span class="Constant">&quot;node.</span><span class="Special">%s</span><span class="Constant">.html&quot;</span>,node-&gt;name);
    (<span class="Type">void</span>)cantor_vhtml_node_info(full_node_info,vhtml_dirname,vhtml_filename,node);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Run browser (and display HTML we have generated) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(browser_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -geometry 600x800 </span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,browser,vhtml_dirname,vhtml_filename);
    <span class="Statement">if</span>(WEXITSTATUS(system(browser_command)) &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove junk </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(rm_command,SSIZE,<span class="Constant">&quot;rm -rf </span><span class="Special">%s</span><span class="Constant">&quot;</span>,vhtml_dirname);
    <span class="Statement">if</span>(WEXITSTATUS(system(rm_command)) &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    in_vhtml_node_browse = FALSE;
    pups_set_errno(OK);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Display a list of nodes (with their associated links) as HTML ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_vhtml_nodelist_browse(_BOOLEAN        full_node_info,  <span class="Comment">// TRUE if full node information required</span>
                                          <span class="Type">char</span>          *browser,         <span class="Comment">// Browser to display (virtual) HTML</span>
                                          nodelist_type *nodelist)        <span class="Comment">// Nodelist containing data nodes</span>

{   <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> vhtml_filename[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
         vhtml_nodelist_filename[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         vhtml_dirname[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         browser_command[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         rm_command[SSIZE]              = <span class="Constant">&quot;&quot;</span>,
         current_dir[SSIZE]             = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> i,
        ret,
        cnt          = <span class="Constant">0</span>,
        active_nodes = <span class="Constant">0</span>;

    <span class="Type">static</span> _BOOLEAN in_vhtml_node_browse = FALSE;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[cantor_vhtml_nodelist_browse] attempt by non root thread to perform PUPS/P3 cantor operation&quot;</span>);

    <span class="Statement">if</span>(browser == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(in_vhtml_node_browse == TRUE)
    {  pups_set_errno(<span class="Constant">EBUSY</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       in_vhtml_node_browse = TRUE;

    (<span class="Type">void</span>)snprintf(vhtml_dirname,SSIZE,<span class="Constant">&quot;vhtml.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.dir.tmp&quot;</span>,appl_name,appl_pid,appl_host);
    (<span class="Type">void</span>)mkdir(vhtml_dirname,<span class="PreProc">0</span><span class="Constant">770</span>);
    (<span class="Type">void</span>)getcwd(current_dir,SSIZE);
    (<span class="Type">void</span>)chdir(vhtml_dirname);

    (<span class="Type">void</span>)snprintf(vhtml_nodelist_filename,SSIZE,<span class="Constant">&quot;nodelist.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.html&quot;</span>,appl_pid,appl_host);
    <span class="Statement">if</span>(access(vhtml_nodelist_filename,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)pups_creat(vhtml_nodelist_filename,<span class="PreProc">0</span><span class="Constant">600</span>);
    stream = pups_fopen(vhtml_nodelist_filename,<span class="Constant">&quot;w&quot;</span>,LIVE);


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate HTML </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(nodelist == (nodelist_type *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Nodelist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;&lt;b&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Nodelist is empty&lt;/b&gt;&lt;/h3&gt;&lt;/center&gt;&lt;hr&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION);
       (<span class="Type">void</span>)fflush(stream);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;Nodelist&lt;/title&gt;&lt;/head&gt;&lt;body&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;hr&gt;&lt;center&gt;&lt;h3&gt;&lt;b&gt;Cantor version </span><span class="Special">%s</span><span class="Constant">&lt;br&gt;Nodelist </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [type </span><span class="Special">%s</span><span class="Constant">] Information Page&lt;/b&gt;&lt;/center&gt;&lt;hr&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                               CANTOR_VERSION,nodelist-&gt;name,nodelist-&gt;type);
       (<span class="Type">void</span>)fflush(stream);


       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;h5&gt;&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Create (empty) files for all nodes -- we do this to ensure all </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> active nodes are properly linked within HTML                   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_alloc; ++i)
       {  (<span class="Type">void</span>)snprintf(vhtml_filename,SSIZE,<span class="Constant">&quot;node.</span><span class="Special">%s</span><span class="Constant">.html&quot;</span>,nodelist-&gt;nodes[i]-&gt;name);

          <span class="Statement">if</span>(access(vhtml_filename,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
             (<span class="Type">void</span>)pups_creat(vhtml_filename,<span class="PreProc">0</span><span class="Constant">600</span>);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Create actual HTML information </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist-&gt;node_alloc; ++i)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Does next node contain valid data? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(nodelist-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>                                           &amp;&amp;
             (nodelist-&gt;nodes[i] = (node_type *)cantor_pointer_live(nodelist-&gt;nodes[i],TRUE))  &amp;&amp;
             strcmp(nodelist[i].name,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>                                             )
          {  (<span class="Type">void</span>)snprintf(vhtml_filename,SSIZE,<span class="Constant">&quot;node.</span><span class="Special">%s</span><span class="Constant">.html&quot;</span>,nodelist-&gt;nodes[i]-&gt;name);
             (<span class="Type">void</span>)cantor_vhtml_node_info(full_node_info,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,vhtml_filename,nodelist-&gt;nodes[i]);


             <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Generate link to next node </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;[</span><span class="Special">%d</span><span class="Constant"> &lt;a href=</span><span class="Special">%s</span><span class="Constant">&gt;</span><span class="Special">%s</span><span class="Constant">&lt;/a&gt;]  &quot;</span>,i,vhtml_filename,nodelist-&gt;nodes[i]-&gt;name);

             <span class="Statement">if</span>(cnt == <span class="Constant">5</span>)
             {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(stream);

                cnt = <span class="Constant">0</span>;
             }
             <span class="Statement">else</span>
                cnt = <span class="Constant">0</span>;

             ++active_nodes;
          }
       }

       <span class="Statement">if</span>(cnt != <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(stream);
       }

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/h5&gt;&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       <span class="Statement">if</span>(active_nodes == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;h5&gt;No active nodes (</span><span class="Special">%d</span><span class="Constant"> nodes allocated)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,nodelist-&gt;node_alloc);
        <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;h5&gt;</span><span class="Special">%d</span><span class="Constant"> active nodes (</span><span class="Special">%d</span><span class="Constant"> nodes allocated)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,active_nodes,nodelist-&gt;node_alloc);
        (<span class="Type">void</span>)fflush(stream);
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;br&gt;&lt;hr&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;center&gt;&lt;h6&gt;Web page generated automatically by &lt;b&gt;cantor&lt;/b&gt; vhtml generator version 1.00&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;(C) M.A. O'Neill, Tumbling Dice, 2022 (mao@@tumblingdice.co.uk)&lt;/center&gt;&lt;br&gt;&lt;br&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;&lt;/body&gt;&lt;/html&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">if</span>(vhtml_dirname != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)chdir(current_dir);

    (<span class="Type">void</span>)pups_fclose(stream);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Run browser (and display HTML we have generated) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(browser_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -geometry 600x800 </span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,browser,vhtml_dirname,vhtml_nodelist_filename);
    ret = system(browser_command);
    <span class="Statement">if</span>(WEXITSTATUS(ret) &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove junk </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(rm_command,SSIZE,<span class="Constant">&quot;rm -rf </span><span class="Special">%s</span><span class="Constant">&quot;</span>,vhtml_dirname);
    ret = system(rm_command);
    <span class="Statement">if</span>(WEXITSTATUS(ret) &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    in_vhtml_node_browse = FALSE;
    pups_set_errno(OK);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert a link to a set of pairwise rules. These are passed to an enslaved</span>
<span class="Comment">    rgen ruleset convertor and hence to a subslaved cluster object clusterer with</span>
<span class="Comment">    sybiotic xtopol network visualiser ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_rulefile_from_clustered_link(<span class="Type">char</span>      *filename,  <span class="Comment">// Filename for rgen file</span>
                                                <span class="Type">int</span>       n_links,    <span class="Comment">// Number of link lists</span>
                                                link_type **links)    <span class="Comment">// List of link lists</span>

{  <span class="Type">int</span> i,
       j,
       k;

   node_type **routelist = (node_type **)<span class="Constant">NULL</span>;

   <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

   <span class="Type">char</span> rule_filename[SSIZE] = <span class="Constant">&quot;&quot;</span>,
        *rgen_pathname       = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
        *cluster_pathname    = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

   <span class="Statement">if</span>(filename == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || n_links == <span class="Constant">0</span> || links == (link_type **)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }


   <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Filename (pairwise rules) </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

   <span class="Statement">if</span>(filename == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
      (<span class="Type">void</span>)snprintf(rule_filename,SSIZE,<span class="Constant">&quot;cantor.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.rules&quot;</span>,appl_pid,appl_host);
   <span class="Statement">else</span>
      (<span class="Type">void</span>)strlcpy(rule_filename,filename,SSIZE);

   <span class="Statement">if</span>(access(rule_filename,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
     (<span class="Type">void</span>)pups_creat(rule_filename,<span class="PreProc">0</span><span class="Constant">600</span>);

   stream = pups_fopen(rule_filename,<span class="Constant">&quot;w&quot;</span>,LIVE);

   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#----------------------------------------------------------------------------------</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#  Rgen (binary) rule file automatically generated from link data by</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#  Cantor version </span><span class="Special">%s</span><span class="Constant">, (C) M.A. O'Neill, Tumbling Dice, 2022</span><span class="Special">\n</span><span class="Constant">&quot;</span>,CANTOR_VERSION);
   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#-----------------------------------------------------------------------------------</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
   (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">#  Format is node1, node2, link, link_flux, link_length</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
   (<span class="Type">void</span>)fflush(stream);


   <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Process each link generating a set of binary connection rule pairs </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> for rgen rule convertor                                            </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

   <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_links; ++i)
   {

<span class="PreProc">      #ifdef PTHREAD_SUPPORT</span>
      (<span class="Type">void</span>)pthread_mutex_lock(&amp;links[i]-&gt;mutex);
<span class="PreProc">      #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

      <span class="Statement">if</span>(links[i] != (link_type *)<span class="Constant">NULL</span> &amp;&amp; (links[i] = (link_type *)cantor_pointer_live(links[i],TRUE)) != (link_type *)<span class="Constant">NULL</span>)
      {  <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;links[i]-&gt;node_alloc; ++j)
         {

            routelist = links[i]-&gt;routelist;

            <span class="Statement">if</span>(routelist[j] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (routelist[j] = (node_type *)cantor_pointer_live(routelist[j],TRUE)) != (node_type *)<span class="Constant">NULL</span>)
            {  <span class="Statement">for</span>(k=j+<span class="Constant">1</span>; k&lt;links[i]-&gt;node_alloc; ++k)
               {  <span class="Statement">if</span>(routelist[k] != (node_type *)<span class="Constant">NULL</span> &amp;&amp; (routelist[k] = (node_type *)cantor_pointer_live(routelist[k],TRUE)) != (node_type *)<span class="Constant">NULL</span>)


                  <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> We have live data -- lets extract it </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%-16s</span><span class="Constant"> </span><span class="Special">%-16s</span><span class="Constant"> </span><span class="Special">%4d</span><span class="Constant"> </span><span class="Special">%6.3F</span><span class="Constant"> </span><span class="Special">%6.3F</span><span class="Special">\n</span><span class="Constant">&quot;</span>,routelist[j],routelist[k],(i+<span class="Constant">1</span>),links[i]-&gt;flux,links[i]-&gt;length);
                  (<span class="Type">void</span>)fflush(stream);
               }
            }
         }
      }

<span class="PreProc">      #ifdef PTHREAD_SUPPORT</span>
      (<span class="Type">void</span>)pthread_mutex_unlock(&amp;links[i]-&gt;mutex);
<span class="PreProc">      #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    }
    (<span class="Type">void</span>)pups_fclose(stream);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Intersection of a pair of links ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desintation linklists on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_link_intersection(<span class="Type">char</span>      *name,     <span class="Comment">// Name of intersection set1</span>
                                     link_type *link_1,   <span class="Comment">// Insersection of link set2 and set3</span>
                                     link_type *link_2,   <span class="Comment">// Set2</span>
                                     link_type *link_3)   <span class="Comment">// Set3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> ||
       link_1 == (link_type *)<span class="Constant">NULL</span> ||
       link_2 == (link_type *)<span class="Constant">NULL</span> ||
       link_3 == (link_type *)<span class="Constant">NULL</span>  )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_link  (link_1);
    (<span class="Type">void</span>)cantor_set_link_tag(link_1, name);
    (<span class="Type">void</span>)cantor_set_link_type(link_1,<span class="Constant">&quot;intersection&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;link_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>      &amp;&amp;
             link_3-&gt;routelist[j] != (node_type *)<span class="Constant">NULL</span>      &amp;&amp;
             link_2-&gt;routelist[i] == link_3-&gt;routelist[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          (<span class="Type">void</span>)cantor_add_node_to_link(link_1,link_2-&gt;routelist[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination linklist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phlink_intersection(<span class="Type">int</span>       hdes,     <span class="Comment">// Heap descriptor set1</span>
                                       <span class="Type">char</span>      *name,    <span class="Comment">// name of intersection set1</span>
                                       link_type *link_1,  <span class="Comment">// Insersection of set2 and set3</span>
                                       link_type *link_2,  <span class="Comment">// Set2</span>
                                       link_type *link_3)  <span class="Comment">// Set3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       link_1 == (link_type *)<span class="Constant">NULL</span>  ||
       link_2 == (link_type *)<span class="Constant">NULL</span>  ||
       link_3 == (link_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_link(link_1,hdes);
    (<span class="Type">void</span>)cantor_set_link_tag(link_1,name);
    (<span class="Type">void</span>)cantor_set_link_type(link_1,<span class="Constant">&quot;intersection&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;link_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>      &amp;&amp;
             link_3-&gt;routelist[j] != (node_type *)<span class="Constant">NULL</span>      &amp;&amp;
             link_2-&gt;routelist[i] == link_3-&gt;routelist[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          (<span class="Type">void</span>)cantor_phadd_node_to_link(link_1,link_2-&gt;routelist[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Union of a pair of links ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desination linklist on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_link_union(<span class="Type">char</span>      *name,    <span class="Comment">// Name of union set1</span>
                              link_type *link_1,  <span class="Comment">// Union of set2 &amp; set3</span>
                              link_type *link_2,  <span class="Comment">// Set2</span>
                              link_type *link_3)  <span class="Comment">// Set3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || link_1 == (link_type *)<span class="Constant">NULL</span> || link_2 == (link_type *)<span class="Constant">NULL</span> || link_3 == (link_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_link(link_1);
    (<span class="Type">void</span>)cantor_set_link_tag(link_1,name);
    (<span class="Type">void</span>)cantor_set_link_type(link_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_add_node_to_link(link_1,link_2-&gt;routelist[i]);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(link_3-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_add_node_to_link(link_1,link_3-&gt;routelist[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination rlLinklist on peristent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phlink_union(<span class="Type">int</span>          hdes,  <span class="Comment">// Heap descriptor set1</span>
                                <span class="Type">char</span>        *name,  <span class="Comment">// Name of set1</span>
                                link_type *link_1,  <span class="Comment">// Unions of set2 and set3</span>
                                link_type *link_2,  <span class="Comment">// Set2</span>
                                link_type *link_3)  <span class="Comment">// Set3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>         ||
       link_1 == (link_type *)<span class="Constant">NULL</span>  ||
       link_2 == (link_type *)<span class="Constant">NULL</span>  ||
       link_3 == (link_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_link(link_1,hdes);
    (<span class="Type">void</span>)cantor_set_link_tag(link_1,name);
    (<span class="Type">void</span>)cantor_set_link_type(link_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_phadd_node_to_link(link_1,link_2-&gt;routelist[i],hdes,name);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(link_3-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_phadd_node_to_link(link_1,link_3-&gt;routelist[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Difference of a pair of links ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination linklists on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_link_difference(<span class="Type">char</span>      *name,    <span class="Comment">// Name of difference set1</span>
                                   link_type *link_1,  <span class="Comment">// Difference of set2 and set3</span>
                                   link_type *link_2,  <span class="Comment">// Set2</span>
                                   link_type *link_3)  <span class="Comment">// Set3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       link_1 == (link_type *)<span class="Constant">NULL</span>  ||
       link_2 == (link_type *)<span class="Constant">NULL</span>  ||
       link_3 == (link_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_link(link_1);
    (<span class="Type">void</span>)cantor_set_link_tag(link_1,name);
    (<span class="Type">void</span>)cantor_set_link_type(link_1,<span class="Constant">&quot;difference&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;link_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>                  &amp;&amp;
             link_3-&gt;routelist[j] != (node_type *)<span class="Constant">NULL</span>                  &amp;&amp;
             link_2-&gt;routelist[i]-&gt;name == link_3-&gt;routelist[j]-&gt;name    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_add_node_to_link(link_1,link_2-&gt;routelist[i]);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_3-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;link_2-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>                  &amp;&amp;
             link_3-&gt;routelist[j] != (node_type *)<span class="Constant">NULL</span>                  &amp;&amp;
             link_2-&gt;routelist[i]-&gt;name == link_3-&gt;routelist[j]-&gt;name    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_add_node_to_link(link_1,link_3-&gt;routelist[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination linklist on pesistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phlink_difference(<span class="Type">int</span>       hdes,     <span class="Comment">// Heap descriptor for set1</span>
                                     <span class="Type">char</span>      *name,    <span class="Comment">// Name of set1</span>
                                     link_type *link_1,  <span class="Comment">// Difference of set2 and set3</span>
                                     link_type *link_2,  <span class="Comment">// Set2</span>
                                     link_type *link_3)  <span class="Comment">// Set3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       link_1 == (link_type *)<span class="Constant">NULL</span>  ||
       link_2 == (link_type *)<span class="Constant">NULL</span>  ||
       link_3 == (link_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_link(link_1,hdes);
    (<span class="Type">void</span>)cantor_set_link_tag(link_1,name);
    (<span class="Type">void</span>)cantor_set_link_type(link_1,<span class="Constant">&quot;difference&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;link_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>      &amp;&amp;
             link_3-&gt;routelist[j] != (node_type *)<span class="Constant">NULL</span>      &amp;&amp;
             link_2-&gt;routelist[i] == link_3-&gt;routelist[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_phadd_node_to_link(link_1,link_2-&gt;routelist[i],hdes,name);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;link_3-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;link_2-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(link_2-&gt;routelist[i] != (node_type *)<span class="Constant">NULL</span>                  &amp;&amp;
             link_3-&gt;routelist[j] != (node_type *)<span class="Constant">NULL</span>                  &amp;&amp;
             link_2-&gt;routelist[i]-&gt;name == link_3-&gt;routelist[j]-&gt;name    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_phadd_node_to_link(link_1,link_3-&gt;routelist[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;link_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    (Object) intersection of a pair of nodes ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination node on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_object_intersection(<span class="Type">char</span>      *name,    <span class="Comment">// Name of intersection node1      </span>
                                       node_type *node_1,  <span class="Comment">// Intersection of nodes1 and node2</span>
                                       node_type *node_2,  <span class="Comment">// Node2</span>
                                       node_type *node_3)  <span class="Comment">// Node3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       node_1 == (node_type *)<span class="Constant">NULL</span>  ||
       node_2 == (node_type *)<span class="Constant">NULL</span>  ||
       node_3 == (node_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_node(node_1);
    (<span class="Type">void</span>)cantor_set_node_name(node_1,name);
    (<span class="Type">void</span>)cantor_set_node_type(node_1,<span class="Constant">&quot;intersection&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_2-&gt;object_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;node_3-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_3-&gt;objects[j] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_2-&gt;objects[i] ==  node_3-&gt;objects[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          (<span class="Type">void</span>)cantor_add_object_to_node(node_1,node_2-&gt;objects[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desitnation node on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phobject_intersection(<span class="Type">int</span>        hdes,    <span class="Comment">// Heap descriptor for node1</span>
                                         <span class="Type">char</span>      *name,    <span class="Comment">// Name of node1</span>
                                         node_type *node_1,  <span class="Comment">// Intersection of node2 and node3</span>
                                         node_type *node_2,  <span class="Comment">// Node2</span>
                                         node_type *node_3)  <span class="Comment">// Node3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       node_1 == (node_type *)<span class="Constant">NULL</span>  ||
       node_2 == (node_type *)<span class="Constant">NULL</span>  ||
       node_3 == (node_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_node(node_1,hdes);
    (<span class="Type">void</span>)cantor_set_node_name(node_1,name);
    (<span class="Type">void</span>)cantor_set_node_type(node_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_2-&gt;object_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;node_3-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_3-&gt;objects[j] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_2-&gt;objects[i] ==  node_3-&gt;objects[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          (<span class="Type">void</span>)cantor_phadd_object_to_node(node_1,node_2-&gt;objects[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    (Object) union  of a pair of nodes ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination node on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_object_union(<span class="Type">char</span>      *name,    <span class="Comment">// Name of node1</span>
                                node_type *node_1,  <span class="Comment">// Union of node1 and node2</span>
                                node_type *node_2,  <span class="Comment">// Node2</span>
                                node_type *node_3)  <span class="Comment">// Node3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       node_1 == (node_type *)<span class="Constant">NULL</span>  ||
       node_2 == (node_type *)<span class="Constant">NULL</span>  ||
       node_3 == (node_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_node(node_1);
    (<span class="Type">void</span>)cantor_set_node_name(node_1,name);
    (<span class="Type">void</span>)cantor_set_node_type(node_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_2-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_add_object_to_node(node_1,node_2-&gt;objects[i]);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_3-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node_3-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_add_object_to_node(node_1,node_3-&gt;objects[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desintantion node on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phobject_union(<span class="Type">int</span>        hdes,    <span class="Comment">// Heap descriptor for node1</span>
                                  <span class="Type">char</span>      *name,    <span class="Comment">// Name of node1</span>
                                  node_type *node_1,  <span class="Comment">// Union of node2 and node3</span>
                                  node_type *node_2,  <span class="Comment">// Node2</span>
                                  node_type *node_3)  <span class="Comment">// Node3</span>

{   <span class="Type">int</span> i,
        j;

    _BOOLEAN  matched;
    link_type *ret = (link_type *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || node_1 == (node_type *)<span class="Constant">NULL</span> || node_2 == (node_type *)<span class="Constant">NULL</span> || node_3 == (node_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_node(node_1,hdes);
    (<span class="Type">void</span>)cantor_set_node_name(node_1,name);
    (<span class="Type">void</span>)cantor_set_node_type(node_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_2-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_phadd_object_to_node(node_1,node_2-&gt;objects[i],hdes,name);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_3-&gt;object_alloc; ++i)
    {  <span class="Statement">if</span>(node_3-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_phadd_object_to_node(node_1,node_3-&gt;objects[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    (Object) difference of a pair of nodes ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination node on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_object_difference(<span class="Type">char</span>      *name,    <span class="Comment">// Name of difference node1</span>
                                     node_type *node_1,  <span class="Comment">// Difference of node2 and node3</span>
                                     node_type *node_2,  <span class="Comment">// Node2</span>
                                     node_type *node_3)  <span class="Comment">// Node3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       node_1 == (node_type *)<span class="Constant">NULL</span>  ||
       node_2 == (node_type *)<span class="Constant">NULL</span>  ||
       node_3 == (node_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_node(node_1);
    (<span class="Type">void</span>)cantor_set_node_name(node_1,name);
    (<span class="Type">void</span>)cantor_set_node_type(node_1,<span class="Constant">&quot;difference&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_2-&gt;object_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;node_3-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_3-&gt;objects[j] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_2-&gt;objects[i] ==  node_3-&gt;objects[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_add_object_to_node(node_1,node_2-&gt;objects[i]);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_3-&gt;object_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;node_2-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_3-&gt;objects[j] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_2-&gt;objects[i] ==  node_3-&gt;objects[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_add_object_to_node(node_1,node_3-&gt;objects[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination node on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phobject_difference(<span class="Type">int</span>        hdes,    <span class="Comment">// Heap descriptor for node1</span>
                                       <span class="Type">char</span>      *name,    <span class="Comment">// Name of node1</span>
                                       node_type *node_1,  <span class="Comment">// Difference of node2 and node3</span>
                                       node_type *node_2,  <span class="Comment">// Node2</span>
                                       node_type *node_3)  <span class="Comment">// Node3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>       ||
       node_1 == (node_type *)<span class="Constant">NULL</span>  ||
       node_2 == (node_type *)<span class="Constant">NULL</span>  ||
       node_3 == (node_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_node(node_1,hdes);
    (<span class="Type">void</span>)cantor_set_node_name(node_1,name);
    (<span class="Type">void</span>)cantor_set_node_type(node_1,<span class="Constant">&quot;difference&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_2-&gt;object_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;node_3-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_3-&gt;objects[j] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_2-&gt;objects[i] ==  node_3-&gt;objects[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_phadd_object_to_node(node_1,node_2-&gt;objects[i],hdes,name);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;node_3-&gt;object_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;node_2-&gt;object_alloc; ++j)
       {  <span class="Statement">if</span>(node_2-&gt;objects[i] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_3-&gt;objects[j] != (object_type *)<span class="Constant">NULL</span>   &amp;&amp;
             node_2-&gt;objects[i] ==  node_3-&gt;objects[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_phadd_object_to_node(node_1,node_3-&gt;objects[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;node_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    (Node) intersection of a pair of nodelists ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination nodelist on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> nodelist_intersection(<span class="Type">char</span>          *name,        <span class="Comment">// Name of nodelist1</span>
                                  nodelist_type *nodelist_1,  <span class="Comment">// Intersection of nodelist1 and nodelist2</span>
                                  nodelist_type *nodelist_2,  <span class="Comment">// Nodelist2</span>
                                  nodelist_type *nodelist_3)  <span class="Comment">// Nodelist3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name       == (<span class="Type">char</span> *)<span class="Constant">NULL</span>           ||
       nodelist_1 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_2 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_3 == (nodelist_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_nodelist(nodelist_1);
    (<span class="Type">void</span>)cantor_set_nodelist_name(nodelist_1,name);
    (<span class="Type">void</span>)cantor_set_nodelist_type(nodelist_1,<span class="Constant">&quot;intersection&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;nodelist_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_3-&gt;nodes[j] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_2-&gt;nodes[i] ==  nodelist_3-&gt;nodes[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          (<span class="Type">void</span>)cantor_add_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desitnation nodelist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phnodelist_intersection(<span class="Type">int</span>            hdes,        <span class="Comment">// Heap descriptor for nodelist1</span>
                                           <span class="Type">char</span>          *name,        <span class="Comment">// Name of nodelist1</span>
                                           nodelist_type *nodelist_1,  <span class="Comment">// Intersection of nodelist2 and nodelist3</span>
                                           nodelist_type *nodelist_2,  <span class="Comment">// Nodelist2</span>
                                           nodelist_type *nodelist_3)  <span class="Comment">// Nodelist3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name       == (<span class="Type">char</span> *)<span class="Constant">NULL</span>           ||
       nodelist_1 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_2 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_3 == (nodelist_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_nodelist(nodelist_1,hdes);
    (<span class="Type">void</span>)cantor_set_nodelist_name(nodelist_1,name);
    (<span class="Type">void</span>)cantor_set_nodelist_type(nodelist_1,<span class="Constant">&quot;intersection&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;nodelist_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_3-&gt;nodes[j] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_2-&gt;nodes[i] ==  nodelist_3-&gt;nodes[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          cantor_phadd_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    (Node) union of a pair of nodelists ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Nodelists on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> nodelist_union(<span class="Type">char</span>          *name,        <span class="Comment">// Name of nodelist1</span>
                           nodelist_type *nodelist_1,  <span class="Comment">// Intersection of nodelist2 and nodelist3</span>
                           nodelist_type *nodelist_2,  <span class="Comment">// Nodelist2</span>
                           nodelist_type *nodelist_3)  <span class="Comment">// Nodelist3</span>

{   <span class="Type">int</span> i,
        j;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || nodelist_1 == (nodelist_type *)<span class="Constant">NULL</span> || nodelist_2 == (nodelist_type *)<span class="Constant">NULL</span> || nodelist_3 == (nodelist_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_nodelist(nodelist_1);
    (<span class="Type">void</span>)cantor_set_nodelist_name(nodelist_1,name);
    (<span class="Type">void</span>)cantor_set_nodelist_type(nodelist_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_2-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_add_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i]);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_3-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist_3-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_add_node_to_nodelist(nodelist_1,nodelist_3-&gt;nodes[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination nodelist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phnodelist_union(<span class="Type">int</span>            hdes,        <span class="Comment">// Heap descriptor for nodelist1</span>
                                    <span class="Type">char</span>          *name,        <span class="Comment">// Name of nodelist1</span>
                                    nodelist_type *nodelist_1,  <span class="Comment">// Union of nodelist2 and nodelist3</span>
                                    nodelist_type *nodelist_2,  <span class="Comment">// Nodelist2</span>
                                    nodelist_type *nodelist_3)  <span class="Comment">// Nodelist3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name       == (<span class="Type">char</span> *)<span class="Constant">NULL</span>           ||
       nodelist_1 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_2 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_3 == (nodelist_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_nodelist(nodelist_1,hdes);
    (<span class="Type">void</span>)cantor_set_nodelist_name(nodelist_1,name);
    (<span class="Type">void</span>)cantor_set_nodelist_type(nodelist_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_2-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_phadd_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i],hdes,name);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_3-&gt;node_alloc; ++i)
    {  <span class="Statement">if</span>(nodelist_3-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)cantor_phadd_node_to_nodelist(nodelist_1,nodelist_3-&gt;nodes[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    (Node) difference of a pair of nodelists ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Desination Nodelist on local heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_nodelist_difference(<span class="Type">char</span>          *name,        <span class="Comment">// Name of nodelist1</span>
                                       nodelist_type *nodelist_1,  <span class="Comment">// Difference of nodelist2 and nodelist3</span>
                                       nodelist_type *nodelist_2,  <span class="Comment">// Nodelist2</span>
                                       nodelist_type *nodelist_3)  <span class="Comment">// Nodelist3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name       == (<span class="Type">char</span> *)<span class="Constant">NULL</span>           ||
       nodelist_1 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_2 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_3 == (nodelist_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_clear_nodelist(nodelist_1);
    (<span class="Type">void</span>)cantor_set_nodelist_name(nodelist_1,name);
    (<span class="Type">void</span>)cantor_set_nodelist_type(nodelist_1,<span class="Constant">&quot;difference&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;nodelist_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_3-&gt;nodes[j] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_2-&gt;nodes[i] ==  nodelist_3-&gt;nodes[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_add_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i]);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_3-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;nodelist_2-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_3-&gt;nodes[j] != (node_type *)<span class="Constant">NULL</span>        &amp;&amp;
             nodelist_2-&gt;nodes[i] ==  nodelist_3-&gt;nodes[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_add_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i]);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destination nodelist on persistent heap </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> cantor_phnodelist_difference(<span class="Type">int</span>            hdes,        <span class="Comment">// Heap descriptor nodelist1</span>
                                         <span class="Type">char</span>          *name,        <span class="Comment">// Name of nodelist1</span>
                                         nodelist_type *nodelist_1,  <span class="Comment">// Difference of nodelist2 and nodelist3</span>
                                         nodelist_type *nodelist_2,  <span class="Comment">// Nodelist2</span>
                                         nodelist_type *nodelist_3)  <span class="Comment">// Nodelist3</span>

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name       == (<span class="Type">char</span> *)<span class="Constant">NULL</span>           ||
       nodelist_1 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_2 == (nodelist_type *)<span class="Constant">NULL</span>  ||
       nodelist_3 == (nodelist_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)cantor_phclear_nodelist(nodelist_1,hdes);
    (<span class="Type">void</span>)cantor_set_nodelist_name(nodelist_1,name);
    (<span class="Type">void</span>)cantor_set_nodelist_type(nodelist_1,<span class="Constant">&quot;union&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_2-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=i; j&lt;nodelist_3-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>       &amp;&amp;
             nodelist_3-&gt;nodes[j] != (node_type *)<span class="Constant">NULL</span>       &amp;&amp;
             nodelist_2-&gt;nodes[i] ==  nodelist_3-&gt;nodes[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == TRUE)
          (<span class="Type">void</span>)cantor_phadd_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i],hdes,name);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;nodelist_3-&gt;node_alloc; ++i)
    {  <span class="Type">int</span>      j;
       _BOOLEAN matched = FALSE;

       <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;nodelist_2-&gt;node_alloc; ++j)
       {  <span class="Statement">if</span>(nodelist_2-&gt;nodes[i] != (node_type *)<span class="Constant">NULL</span>       &amp;&amp;
             nodelist_3-&gt;nodes[j] != (node_type *)<span class="Constant">NULL</span>       &amp;&amp;
             nodelist_2-&gt;nodes[i] ==  nodelist_3-&gt;nodes[j]    )
             matched = TRUE;
       }

       <span class="Statement">if</span>(matched == FALSE)
          (<span class="Type">void</span>)cantor_phadd_node_to_nodelist(nodelist_1,nodelist_2-&gt;nodes[i],hdes,name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_1-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_2-&gt;mutex);
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;nodelist_3-&gt;mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
