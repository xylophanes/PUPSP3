<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>/usr/local/src/pupsp3-5.4.9.src.git/pupscore.src/psrplib.c.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Error { color: #ffffff; background-color: #ff6060; padding-bottom: 1px; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Purpose: Support library for PSRP enabled applications.</span>

<span class="Comment">    Author:  M.A. O'Neill</span>
<span class="Comment">             Tumbling Dice Ltd</span>
<span class="Comment">             Gosforth</span>
<span class="Comment">             Newcastle upon Tyne</span>
<span class="Comment">             NE3 4RT</span>
<span class="Comment">             United Kingdom</span>

<span class="Comment">    Version: 5.06 </span>
<span class="Comment">    Dated:   6th October 2023 </span>
<span class="Comment">    E-mail:  mao@tumblingdice.co.uk</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;me.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utils.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;setjmp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;netlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/wait.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/socket.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/resource.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dirent.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;limits.h&gt;</span>

<span class="PreProc">#define SSIZE SSIZE</span>

<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> If we have OpenMP support then we also have pthread support </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (OpenMP is built on pthreads for Linux distributions).      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#if defined(_OPENMP) &amp;&amp; !defined(PTHREAD_SUPPORT)</span>
<span class="PreProc">#define PTHREAD_SUPPORT</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef BUBBLE_MEMORY_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;bubble.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dll.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef DLL_SUPPORT </span>
<span class="PreProc">#include </span><span class="Constant">&lt;dlfcn.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dll.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;tad.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifndef NO_SCHED_YIELD</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sched.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> NO_SCHED_YIELD </span><span class="Comment">*/</span>

<span class="PreProc">#undef  __NOT_LIB_SOURCE__</span>
<span class="PreProc">#include </span><span class="Constant">&lt;psrp.h&gt;</span>
<span class="PreProc">#define __NOT_LIB_SOURCE__</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get signal mapping appropriate to OS and hardware architecture </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define __DEFINE__</span>
<span class="PreProc">#if defined(I386) || defined(X86_64)</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.x86.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> I386 || X86_64 </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV6L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV6L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV7L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV7L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef AARCH64</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> AARCH64 </span><span class="Comment">*/</span>
<span class="PreProc">#undef __DEFINE__</span>



<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are imported by this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>


                                                        <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
_IMPORT <span class="Type">int</span>  pupsighold_cnt[];                          <span class="Comment">/*</span><span class="Comment"> Counter for signal hold count                   </span><span class="Comment">*/</span>
_IMPORT <span class="Type">int</span>  rkill_pid;                                 <span class="Comment">/*</span><span class="Comment"> Xkill PID                                       </span><span class="Comment">*/</span>
_IMPORT <span class="Type">int</span>  n_abort_funcs_alloc;                       <span class="Comment">/*</span><span class="Comment"> Number of abort functions allocated             </span><span class="Comment">*/</span>
_IMPORT <span class="Type">void</span> (*pups_abort_f[MAX_FUNCS])(<span class="Type">char</span> *);        <span class="Comment">/*</span><span class="Comment"> Abort function point array                      </span><span class="Comment">*/</span>
_IMPORT <span class="Type">char</span> *pups_abort_arg[MAX_FUNCS];                <span class="Comment">/*</span><span class="Comment"> Abort function argument pointer array           </span><span class="Comment">*/</span>
                                                        <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are exported by this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_child_instance            = FALSE;
_PUBLIC _BOOLEAN psrp_mode                      = FALSE;
_PUBLIC <span class="Type">int</span>      psrp_instances                 = <span class="Constant">0</span>;
_PUBLIC <span class="Type">int</span>      max_trys                       = MAX_TRYS;
_PUBLIC <span class="Type">int</span>      psrp_seg_cnt                   = <span class="Constant">0</span>;
_PUBLIC <span class="Type">int</span>      chlockdes                      = (-<span class="Constant">1</span>);
_PUBLIC <span class="Type">char</span>     channel_name[SSIZE]            = <span class="Constant">&quot;&quot;</span>;
_PUBLIC <span class="Type">char</span>     channel_name_in[SSIZE]         = <span class="Constant">&quot;&quot;</span>;
_PUBLIC <span class="Type">char</span>     channel_name_out[SSIZE]        = <span class="Constant">&quot;&quot;</span>;
_PUBLIC psrp_channel_type *psrp_current_sic     = (psrp_channel_type *)<span class="Constant">NULL</span>;
_PUBLIC psrp_object_type  *psrp_object_list     = (psrp_object_type *)<span class="Constant">NULL</span>;



<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span>      segmentation_delay            = SEGMENTATION_DELAY;
_PRIVATE _BOOLEAN terminate_current_instance    = FALSE;
_PRIVATE <span class="Type">char</span>     psrp_c_code[SSIZE]            = <span class="Constant">&quot;&quot;</span>;
_PRIVATE _BOOLEAN psrp_requests_ignored         = TRUE;
_PRIVATE _BOOLEAN overforking                   = FALSE;
_PRIVATE _BOOLEAN psrp_abrtflag_enable          = FALSE;
_PRIVATE _BOOLEAN psrp_abrtflag                 = FALSE;
_PRIVATE _BOOLEAN psrp_error_handling           = TRUE;
_PRIVATE <span class="Type">int</span>      overforked_child_pid          = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">int</span>      ssh_pid                       = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">int</span>      ssh_sic_index                 = (-<span class="Constant">1</span>);
_PRIVATE <span class="Type">char</span>     psrp_password[SSIZE]          = <span class="Constant">&quot;&quot;</span>;



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot and usage functions - used by slot manager </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrplib_slot(<span class="Type">int</span> level)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;lib psrplib </span><span class="Special">%s</span><span class="Constant">: [ANSI C]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PSRPLIB_VERSION);

    <span class="Statement">if</span>(level &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;(C) 1995-2022 Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;Author: M.A. O'Neill</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PUPS/P3 multiuser threadsafe PSRP [SUPUPS] library (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
}


<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Segment identification for psrp library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SLOT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;slotman.h&gt;</span>
_EXTERN <span class="Type">void</span> (* SLOT )() __attribute__ ((aligned(<span class="Constant">16</span>))) = psrplib_slot;
<span class="PreProc">#endif</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables imported by this library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Public variables exported by the multithread dynamic link library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> support library                                                   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">FILE</span>     *psrp_in                  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;  <span class="Comment">// I/P from PSRP client</span>
_PUBLIC <span class="Type">FILE</span>     *psrp_out                 = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;  <span class="Comment">// O/P to PSRP client </span>
_PUBLIC _BOOLEAN psrp_reactivate_client    = FALSE;         <span class="Comment">// Reactivate attached client</span>
_PUBLIC _BOOLEAN connected_once            = FALSE;         <span class="Comment">// TRUE if connection made</span>
_PUBLIC _BOOLEAN in_psrp_new_segment       = FALSE;         <span class="Comment">// TRUE if in segment code </span>
_PUBLIC _BOOLEAN in_psrp_handler           = FALSE;         <span class="Comment">// TRUE if in PSRP handler code</span>
_PUBLIC _BOOLEAN in_chan_handler           = FALSE;         <span class="Comment">// TRUE if in chan_handler code</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Multiple client access database tables </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span>      n_clients = MAX_CLIENTS;                   <span class="Comment">// Number of clients</span>
_PUBLIC <span class="Type">int</span>      c_client  = <span class="Constant">0</span>;                             <span class="Comment">// Active client</span>
_PUBLIC <span class="Type">char</span>     psrp_client_name[MAX_CLIENTS][SSIZE];      <span class="Comment">// Name of client application</span>
_PUBLIC <span class="Type">char</span>     psrp_client_host[MAX_CLIENTS][SSIZE];      <span class="Comment">// Name of localhost</span>
_PUBLIC <span class="Type">char</span>     psrp_remote_hostpath[MAX_CLIENTS][SSIZE];  <span class="Comment">// Path to basal client</span>
_PUBLIC <span class="Type">int</span>      psrp_client_pid[MAX_CLIENTS];              <span class="Comment">// Clients pid</span>
_PUBLIC <span class="Type">int</span>      psrp_transactions[MAX_CLIENTS];            <span class="Comment">// PSRP transaction count</span>
_PUBLIC <span class="Type">char</span>     psrp_client_efname[MAX_CLIENTS][SSIZE];    <span class="Comment">// Name of client exit func</span>
_PUBLIC <span class="Type">int</span>      (*psrp_client_exitf[MAX_CLIENTS])(<span class="Type">int</span>);    <span class="Comment">// Client exit function</span>



<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_channel_open        = FALSE;         <span class="Comment">// TRUE if PSRP channel open</span>
_PRIVATE _BOOLEAN siginit_pending          = FALSE;         <span class="Comment">// TRUE if SIGINIT pending</span>
_PRIVATE _BOOLEAN sigchan_pending          = FALSE;         <span class="Comment">// TRUE if SIGCHAN pending</span>



<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Functions which are imported by this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Handler for PUPS virtual interval timers</span>
_PROTOTYPE _IMPORT <span class="Type">int</span> vt_handler(<span class="Type">const</span> <span class="Type">int</span>);




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Functions which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Clear a SIC channel descriptor slot</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_clear_channel_slot(psrp_channel_type *);

<span class="Comment">// Set stdio background detach state</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_nodetach(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set PSRP (vitimer) quantum</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_vitimer_quantum(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set (secure) server authentication token</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_secure(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Reactivate connected clients</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_reactivate_clients(<span class="Type">void</span>);

<span class="Comment">// Handler for SIGCLIENT</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> cdoss_handler(<span class="Type">int</span>);

<span class="PreProc">#ifdef MAIL_SUPPORT</span>

<span class="Comment">// Save PSRP channels</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_save_channels(<span class="Type">void</span>);

<span class="Comment">// Restore PSRP channels</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_restore_channels(<span class="Type">void</span>);

<span class="Comment">// Parse PRSP commands (from MIME mail interface)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_parse_requests(<span class="Type">char</span> *);

<span class="Comment">// Set parts of MIME message to be saved from PSRP API</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_mime_type(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>


<span class="Comment">// Display (fast) caches mapped into the address space of caller</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_caches(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Parse a PSRP request (noting which interface originated it)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_parse_request(<span class="Type">char</span> *, <span class="Type">int</span>);

<span class="Comment">// Show host information</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_hinfo(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);


<span class="PreProc">#ifdef BUBBLE_MEMORY_SUPPORT </span>
<span class="Comment">// Set (J)malloc options</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_mbubble_utilisation_threshold(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Display (J)malloc statistics</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_malloc_stats(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef CRIU_SUPPORT</span>
<span class="Comment">// Enable/disable (Criu) state saving</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_ssave(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


<span class="Comment">// Process exits if its effective parent is terminated</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_pexit(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Process does not exit if its effective parent is terminated</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_unpexit(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set (effective) parent</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_parent(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set system context to rooted (system context cannot migrate)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_rooted(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set system context to unrooted (system context can migrate)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_unrooted(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set current working directory for PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_cwd(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set number of times operation is retryed (before aborting)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_trys(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Create trailfile and associated destructor lyosome</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_create_trailfile(<span class="Type">char</span> *, <span class="Type">char</span> *, <span class="Type">char</span> *, <span class="Type">char</span> *);

<span class="Comment">// Protect a file</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_file_live(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *argv[]);

<span class="Comment">// Unprotect a file</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_file_dead(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *argv[]);

<span class="Comment">// Show resource usage for this server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_rusage(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set resource usage for this server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_set_rlimit(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Builtin to display crontab contents</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_crontab(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Builtin to schedule a crontab operation</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_crontab_schedule(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Builtin to unschedule a crontab operation</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_crontab_unschedule(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Check to see if any cron operations are pending</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_crontab_checkschedule(<span class="Type">char</span> *);

<span class="Comment">// Add an alias to a PSRP object</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_alias(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Builtin to show process status</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_procstatus(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show the (current) clients attached to PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_clients(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Create a new proces instance of PSRP server process</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_new_instance(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Return number of clients connected to server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_connected_clients(<span class="Type">void</span>);

<span class="Comment">// Get index in connected client array</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_get_client_slot(<span class="Type">int</span>);

<span class="Comment">// Clear index in connected client array</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_clear_client_slot(<span class="Type">int</span>);

<span class="Comment">// Show clients attached to server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_show_clients(<span class="Type">void</span>);

<span class="Comment">// Flag end of (interrupt driven) PSRP operation</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_endop(<span class="Type">char</span> *op_tag);

<span class="Comment">// Show clients connected to this server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_clients(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Remove a tag from a tag list (alias)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_unalias(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show aliases for objects bound to this PRSP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_showaliases(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Detach an object from the PSRP dispatch list</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_detach_object(<span class="Type">unsigned</span> <span class="Type">int</span>);

<span class="Comment">// Get argument vector from request string</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_argvec(<span class="Type">int</span> *, <span class="Type">char</span> *);

<span class="Comment">// Switch transaction/error logging on/off</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_appl_verbose(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Toggle (client) error handling on/off</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_error_handling(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Delete object from PSRP dispatch table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_transactions(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Delete object from PSRP dispatch table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_detach_object(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show state of PSRP bindings (to client)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_psrp_state(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show bindings of all PSRP objects</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_psrp_bind_type(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Terminate PSRP server process</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_terminate_process(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);


<span class="PreProc">#ifdef SSH_SUPPORT</span>
<span class="Comment">// Set ssh compression</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_ssh_compress(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Set remote ssh port</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_ssh_port(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

<span class="Comment">// Display help for psrp_handler</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_help(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="Comment">// Show DLL orifices which are bound to this application</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_attached_orifices(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="Comment">// Show threads running in PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_threads(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Start thread running in PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_launch_thread(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Pause thread runnin in PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_pause_thread(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Pause thread runnin in PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_restart_thread(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Kill thread running in PSRP server</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_kill_thread(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="Comment">// Show this applications concurrently held link file locks</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_link_file_locks(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show this applications flock locks</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_flock_locks(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show this applications non-default signal handlers</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_sigstatus(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show this applications signal mask/ pending signal status</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_sigmaskstatus(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show streams/file descriptors opened by this application</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_open_fdescriptors(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show (active) children of this application</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_children(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show slaved interation client channels open</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_open_sics(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show exit functions registered for this application </span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_exit_f(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show abort functions registered for this application</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_abort_f(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show entrance functions registered for this application</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_entrance_f(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Show status of PUPS virtual timers</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_vitimers(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// show persistent heaps mapped into process address space</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_persistent_heaps(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// show persistent heaps mapped into process address space</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_htobjects(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Load a new dispatch table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_autosave_dispatch_table(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Load a new dispatch table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_load_dispatch_table(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Save dispatch table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_save_dispatch_table(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Reset dispatch table to it initial state */</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_reset_dispatch_table(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Extend the child table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_extend_chtab(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">// Attach a persistent heap to PSRP handler</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_attach_persistent_heap(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Extend persistent heap table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_extend_htab(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="Comment">// Attach dynamic function to PSRP handler</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_attach_dynamic_function(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Extend orifice [DLL] table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_extend_ortab(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


<span class="Comment">// Show number of (fast) caches memory mapped into process address space</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_show_caches(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Display statistics of a mapped (fast) cache</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_display_cache(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Extend virtual timer table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_extend_vitab(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Extend the file table</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_extend_ftab(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Overlay PSRP server with new command </span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_overlay_server_process(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Overfork PSRP server with new command</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_overfork_server_process(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Attach dynamic function to PSRP handler</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_builtin_attach_dbag(<span class="Type">const</span> <span class="Type">int</span>, <span class="Type">const</span> <span class="Type">char</span> *[]);

<span class="Comment">// Handler for SIGALRM</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_homeostat(<span class="Type">void</span> *, <span class="Type">char</span> *);

<span class="Comment">// Handler for SIGCHAN</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> chan_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGPSRP </span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> psrp_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for propagated SIGABRT</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> abrt_handler(<span class="Type">int</span>);

<span class="Comment">// Initialise channel table for slaved interation clients</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> psrp_initsic(<span class="Type">void</span>);


<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this module </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE sigjmp_buf        chan_env;                                         <span class="Comment">// Env at chan_handler entry</span>
_PRIVATE sigjmp_buf        psrp_env;                                         <span class="Comment">// Env at psrp_handler entry</span>
_PRIVATE <span class="Type">int</span>               req_r_cnt[MAX_CLIENTS];                           <span class="Comment">// Attached client request counts</span>
_PRIVATE <span class="Type">char</span>              old_request_str[MAX_CLIENTS][SSIZE];              <span class="Comment">// Last request for each attached client</span>
_PRIVATE _BOOLEAN          psrp_log[MAX_CLIENTS]              =  { FALSE };  <span class="Comment">// Per client transaction logging flags</span>


<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to the PSRP subsystem </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span>               psrp_object_list_size;
_PRIVATE <span class="Type">int</span>               psrp_object_list_used;
_PRIVATE <span class="Type">int</span>               psrp_bind_status  = PSRP_STATIC_FUNCTION;
_PRIVATE _BOOLEAN          psrp_ignore       = FALSE;
_PRIVATE psrp_channel_type channel[PSRP_MAX_SIC_CHANNELS];
_PRIVATE psrp_crontab_type crontab[MAX_CRON_SLOTS];



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Ignore PSRP requests (this routine also sets the appl_psrp flag to </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> TRUE)                                                              </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_ignore_requests(<span class="Type">void</span>)

{   <span class="Statement">if</span>(appl_root_thread != <span class="Constant">0</span> &amp;&amp; pupsthread_is_root_thread() == FALSE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;psrp_ignore_requests: attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       pups_exit(<span class="Constant">255</span>);
    }

    ignore_pups_signals   = TRUE;
    (<span class="Type">void</span>)pupshold(PSRP_SIGS);
    appl_psrp             = TRUE;
    psrp_requests_ignored = TRUE;
}




<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Accept PSRP requests </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_accept_requests(<span class="Type">void</span>)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_accept_requests] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(psrp_requests_ignored == FALSE)
       <span class="Statement">return</span>;
    <span class="Statement">else</span>
       psrp_requests_ignored = FALSE;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unlink channel segment lock (if any)  - each client will then grab the seglock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> reconnect and release (via its client handler)                                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_reactivate_client == TRUE &amp;&amp; chlockdes != (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_release_fd_lock(chlockdes);
       (<span class="Type">void</span>)close(chlockdes);

<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB LOCK RELEASE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

       psrp_reactivate_client = FALSE;
    }

    ignore_pups_signals = FALSE;
    (<span class="Type">void</span>)pupsrelse(PSRP_SIGS);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB PSRP ACTIVATED</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Import PSRP dispatch table items </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_load_dispatch_table(<span class="Type">const</span> _BOOLEAN          search,    <span class="Comment">// If TRUE search for objects</span>
                                     <span class="Type">const</span> <span class="Type">char</span> *autoload_file_name)    <span class="Comment">// Dispatch table file name</span>

{   <span class="Type">int</span> i,
        tag_index,
        h_mode,
        cnt           = <span class="Constant">0</span>,
        aliases       = <span class="Constant">0</span>,
        psrp_objects  = <span class="Constant">0</span>;

    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> f_pos = <span class="Constant">0</span>;

    <span class="Type">char</span> object_tag[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         object_type[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         object_f_name[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         homeostasis_mode[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         alias_name[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         next_line[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         tmp_f_name[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         tmp_str[SSIZE]           = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *raw_autoload_file_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>,
         *autoload_file_stream     = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">struct</span> stat buf;


    <span class="Statement">if</span>(autoload_file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(access(autoload_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(search == TRUE)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we can't find the dispatch table file </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> look for it in /usr/local/lib            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Firstly, we must strip the path (if any) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> from the dispatch table file name        </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strrextr(autoload_file_name,tmp_str,<span class="Constant">'/'</span>) == TRUE)
            (<span class="Type">void</span>)strlcpy(autoload_file_name,tmp_str,SSIZE);


          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Get pathname to dispatch table </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strccpy(tmp_str,(<span class="Type">char</span> *)pups_search_path(<span class="Constant">&quot;DISPATCH_PATH&quot;</span>,autoload_file_name)) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(autoload_file_name,tmp_str,SSIZE);
       }

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)stat(autoload_file_name,&amp;buf);
    <span class="Statement">if</span>(buf.st_mode &amp; !S_IFREG)
    {  pups_set_errno(<span class="Constant">ESPIPE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We need to lock the disparch table file as multiple processes </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> could be accessing the same file                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_get_link_file_lock(WAIT_FOREVER,autoload_file_name);
    raw_autoload_file_stream = fopen(autoload_file_name,<span class="Constant">&quot;r&quot;</span>);

    (<span class="Type">void</span>)snprintf(tmp_f_name,SSIZE,<span class="Constant">&quot;/tmp/psrp.autoload.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,appl_pid);
    autoload_file_stream = pups_strp_commnts(<span class="Constant">'#'</span>,raw_autoload_file_stream,tmp_f_name);

    (<span class="Type">void</span>)fgets(tmp_str,SSIZE,autoload_file_stream);

    <span class="Statement">if</span>(sscanf(tmp_str,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;psrp_objects) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
       pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] corrupt PSRP resource file&quot;</span>);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);

       <span class="Statement">if</span>(psrp_objects == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): 1 PSRP object definition to process</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                    appl_name,
                                                                                     appl_pid,
                                                                                    appl_host,
                                                                                   appl_owner);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> PSRP object definitions to process</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                       appl_name,
                                                                                        appl_pid,
                                                                                       appl_host,
                                                                                      appl_owner,
                                                                                    psrp_objects);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">do</span> {    <span class="Type">int</span> ret;


            <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Have all objects been processed? </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(cnt &lt; psrp_objects)
            {

	       ret = fscanf(autoload_file_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,object_type,homeostasis_mode);

               <span class="Statement">if</span>(ret == <span class="Constant">0</span> || ret &gt; <span class="Constant">2</span>)
               {  (<span class="Type">void</span>)fclose(autoload_file_stream);
                  (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
                  (<span class="Type">void</span>)unlink(tmp_f_name);
                  pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] corrupt PSRP resource file&quot;</span>);
               }

               <span class="Statement">if</span>(strcmp(homeostasis_mode,<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span>)
                  h_mode = LIVE;
               <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(homeostasis_mode,<span class="Constant">&quot;DEAD&quot;</span>) == <span class="Constant">0</span>)
                  h_mode = DEAD;
               <span class="Statement">else</span>
               {  (<span class="Type">void</span>)strlcpy(object_f_name,homeostasis_mode,SSIZE);
                  (<span class="Type">void</span>)strlcpy(homeostasis_mode,<span class="Constant">&quot;UNDEFINED&quot;</span>,SSIZE);
               }

               <span class="Statement">if</span>(strcmp(homeostasis_mode,<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span>)
               {  <span class="Statement">if</span>(fscanf(autoload_file_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,object_f_name) != <span class="Constant">1</span>)
                  {  (<span class="Type">void</span>)fclose(autoload_file_stream);
                     (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
                     (<span class="Type">void</span>)unlink(tmp_f_name);
                     pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] corrupt PSRP resource file&quot;</span>);
                  }
               }

               <span class="Statement">if</span>(fscanf(autoload_file_stream,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;aliases) != <span class="Constant">1</span> || feof(autoload_file_stream) == <span class="Constant">1</span>)
               {  (<span class="Type">void</span>)fclose(autoload_file_stream);
                  (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
                  (<span class="Type">void</span>)unlink(tmp_f_name);
                  pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] corrupt PSRP resource file&quot;</span>);
               }

               <span class="Statement">if</span>(fscanf(autoload_file_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,object_tag) != <span class="Constant">1</span>)
               {  (<span class="Type">void</span>)fclose(autoload_file_stream);
                  (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
                  (<span class="Type">void</span>)unlink(tmp_f_name);
                  pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] corrupt PSRP resource file&quot;</span>);
               }

               (<span class="Type">void</span>)strdate(date);

<span class="PreProc">               #ifdef DLL_SUPPORT</span>
               <span class="Statement">if</span>(strcmp(object_type,<span class="Constant">&quot;dynamic_function&quot;</span>) == <span class="Constant">0</span>)
                  (<span class="Type">void</span>)psrp_attach_dynamic_function(search,object_tag,object_f_name);
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

               <span class="Statement">if</span>(strcmp(object_type,<span class="Constant">&quot;dynamic_databag&quot;</span>) == <span class="Constant">0</span>)
                  (<span class="Type">void</span>)psrp_attach_dynamic_databag(search,object_tag,object_f_name,h_mode);

<span class="PreProc">               #ifdef PERSISTENT_HEAP_SUPPORT</span>
               <span class="Statement">if</span>(strcmp(object_type,<span class="Constant">&quot;persistent_heap&quot;</span>) == <span class="Constant">0</span>)
                  (<span class="Type">void</span>)psrp_attach_persistent_heap(search,object_tag,object_f_name,h_mode);
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


               <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Display loaded object </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(appl_verbose == TRUE)
               {  <span class="Statement">if</span>(aliases - <span class="Constant">1</span> == <span class="Constant">1</span>)
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): processing </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) (1 alias)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                           date,
                                                                                      appl_name,
                                                                                       appl_pid,
                                                                                      appl_host,
                                                                                     appl_owner,
                                                                                    object_type,
                                                                                     object_tag,
                                                                               homeostasis_mode);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): processing </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) (</span><span class="Special">%d</span><span class="Constant"> aliases)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                              date,
                                                                                         appl_name,
                                                                                          appl_pid,
                                                                                         appl_host,
                                                                                        appl_owner,
                                                                                       object_type,
                                                                                        object_tag,
                                                                                  homeostasis_mode,
                                                                                         aliases-<span class="Constant">1</span>);
                  (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
               }

               <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Add aliases - this is possibly not the most efficient way of aliasing </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(aliases &gt; <span class="Constant">1</span>)
               {  <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;aliases; ++i)
                  {  <span class="Statement">if</span>(fscanf(autoload_file_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,alias_name) != <span class="Constant">1</span>)
                     {  (<span class="Type">void</span>)fclose(autoload_file_stream);
                        (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
                        (<span class="Type">void</span>)unlink(tmp_f_name);
                        pups_error(<span class="Constant">&quot;[psrp_load_dispatch_table] corrupt PSRP resource file&quot;</span>);
                     }

                     psrp_alias(object_tag,alias_name);
                  }
               }
            }

            ++cnt;
        } <span class="Statement">while</span>(cnt &lt; psrp_objects);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP resource file </span><span class="Special">%s</span><span class="Constant"> loaded</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                          appl_name,
                                                                           appl_pid,
                                                                          appl_host,
                                                                         appl_owner,
                                                                 autoload_file_name);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fclose(autoload_file_stream);
    (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);
    (<span class="Type">void</span>)unlink(tmp_f_name);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Initialise PSRP action handler system ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_init(<span class="Type">const</span> <span class="Type">int</span> bind_status, <span class="Type">const</span> <span class="Type">int</span> (*psrp_process_status)(<span class="Type">const</span> <span class="Type">int</span>,  <span class="Type">const</span> <span class="Type">char</span> *argv[]))

{   <span class="Type">int</span> i,
        authentication;

    <span class="Type">char</span> strdum[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *autoload_file_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    sigset_t init_set,
             chan_set,
             psrp_set,
             abrt_set;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_init] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    psrp_object_list_size = <span class="Constant">0</span>;
    psrp_object_list_used = <span class="Constant">0</span>;
    psrp_bind_status      = bind_status;
    appl_psrp             = TRUE;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise multiple access client database. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Comment">/*</span><span class="Comment"> Initialise slots for PSRP client connections </span><span class="Comment">*/</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CLIENTS; ++i)
        (<span class="Type">void</span>)psrp_clear_client_slot(i);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create communication channels for this process. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(channel_name_out,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);
    (<span class="Type">void</span>)snprintf(channel_name_in,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);
    (<span class="Type">void</span>)snprintf(channel_name,SSIZE,    <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#IO#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);

    <span class="Statement">if</span>(access((<span class="Type">char</span> *)channel_name_in,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)mkfifo(channel_name_in,<span class="PreProc">0</span><span class="Constant">600</span>);

    <span class="Statement">if</span>(access((<span class="Type">char</span> *)channel_name_out,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)mkfifo(channel_name_out,<span class="PreProc">0</span><span class="Constant">600</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure that we delete the communications channel pipes when this </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> process exits.                                                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                     <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) handler initialised on channel </span><span class="Special">%s</span><span class="Constant">/psrp:</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">:fifo:IO:</span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                    date,
                                                                                                               appl_name,
                                                                                                                appl_pid,
                                                                                                               appl_host,
                                                                                                              appl_owner,
                                                                                                   PSRP_PROTOCOL_VERSION,
                                                                                                           appl_fifo_dir,
                                                                                                               appl_name,
                                                                                                               appl_host,
                                                                                                                appl_pid);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_HOMEOSTATIC_STREAMS)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Streams: PSRP streams are homeostatic</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                              date,appl_name,appl_pid,appl_host,appl_owner);
       }

       (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;psrp_homeostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)psrp_homeostat);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; psrp_bind_status &amp; PSRP_PERSISTENT_HEAP)
    {  (<span class="Type">void</span>)strdate(date);

       <span class="Statement">if</span>(appl_verbose == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Heaps: can import persistent heaps</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_host,appl_owner);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; psrp_bind_status &amp; PSRP_STATIC_DATABAG)
    {  (<span class="Type">void</span>)strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Databags:  static binding enabled (cannot import databags)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                date,appl_name,appl_pid,appl_host,appl_owner);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; psrp_bind_status &amp; PSRP_DYNAMIC_DATABAG)
    {  (<span class="Type">void</span>)strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Databags:  dynamic binding enabled (can import databags)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                              date,appl_name,appl_pid,appl_host,appl_owner);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; psrp_bind_status &amp; PSRP_STATIC_FUNCTION)
    {  (<span class="Type">void</span>)strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Functions: static binding enabled (cannot import DLL functions)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                     date,appl_name,appl_pid,appl_host,appl_owner);
    }

<span class="PreProc">    #ifdef DLL_SUPPORT</span>
    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; psrp_bind_status &amp; PSRP_DYNAMIC_FUNCTION)
    {  (<span class="Type">void</span>)strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Functions: dynamic binding enabled (can import DLL functions)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                   date,appl_name,appl_pid,appl_host,appl_owner);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; psrp_bind_status &amp; PSRP_PERSISTENT_HEAP)
    {  (<span class="Type">void</span>)strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Functions: persistent heap  binding enabled (can attach persistent heaps)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                 date,appl_name,appl_pid,appl_host,appl_owner);

    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise slaved PSRP client channel table (thse slaved clients are </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> used for peer-to-peer communication between PSRP servers).           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    psrp_initsic();


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise handler and error functions. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    pups_register_exit_f(<span class="Constant">&quot;psrp_exit&quot;</span>,&amp;psrp_exit,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Signals blocked while CHAN handler is running </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;chan_set);
    (<span class="Type">void</span>)sigaddset(&amp;chan_set,SIGINIT);
    (<span class="Type">void</span>)sigaddset(&amp;chan_set,SIGCHAN);
    (<span class="Type">void</span>)sigaddset(&amp;chan_set,SIGPSRP);
    (<span class="Type">void</span>)sigaddset(&amp;chan_set,<span class="Constant">SIGCHLD</span>);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,<span class="Constant">SIGABRT</span>);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,<span class="Constant">SIGALRM</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Signals blocked while PSRP handler is running </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;psrp_set);
    (<span class="Type">void</span>)sigaddset(&amp;psrp_set,SIGINIT);
    (<span class="Type">void</span>)sigaddset(&amp;psrp_set,SIGCHAN);
    (<span class="Type">void</span>)sigaddset(&amp;chan_set,SIGPSRP);
    (<span class="Type">void</span>)sigaddset(&amp;psrp_set,<span class="Constant">SIGCHLD</span>);
    (<span class="Type">void</span>)sigaddset(&amp;psrp_set,<span class="Constant">SIGABRT</span>);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,<span class="Constant">SIGALRM</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Signals blocked when connection is being intialised </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;init_set);
    (<span class="Type">void</span>)sigaddset(&amp;chan_set,SIGINIT);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,SIGCHAN);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,SIGPSRP);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,<span class="Constant">SIGCHLD</span>);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,<span class="Constant">SIGABRT</span>);
    (<span class="Type">void</span>)sigaddset(&amp;init_set,<span class="Constant">SIGALRM</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Signals blecked while SIGABRT - client interrupt is </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> being serviced                                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigfillset(&amp;abrt_set);
    (<span class="Type">void</span>)sigdelset(&amp;abrt_set,<span class="Constant">SIGSEGV</span>);
    (<span class="Type">void</span>)sigdelset(&amp;abrt_set,<span class="Constant">SIGTERM</span>);

    (<span class="Type">void</span>)pups_sighandle(SIGINIT,  <span class="Constant">&quot;chan_handler&quot;</span>, (<span class="Type">void</span> *)chan_handler, &amp;init_set);
    (<span class="Type">void</span>)pups_sighandle(SIGCHAN,  <span class="Constant">&quot;chan_handler&quot;</span>, (<span class="Type">void</span> *)chan_handler, &amp;chan_set);
    (<span class="Type">void</span>)pups_sighandle(SIGPSRP,  <span class="Constant">&quot;psrp_handler&quot;</span>, (<span class="Type">void</span> *)psrp_handler, &amp;psrp_set);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGABRT</span>,  <span class="Constant">&quot;abrt_handler&quot;</span>, (<span class="Type">void</span> *)abrt_handler, &amp;abrt_set);
    (<span class="Type">void</span>)pups_sighandle(SIGCLIENT,<span class="Constant">&quot;cdoss_handler&quot;</span>,(<span class="Type">void</span> *)cdoss_handler,&amp;abrt_set);
    (<span class="Type">void</span>)pups_sighandle(SIGALIVE, <span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Otherwise attach status function if server is running status only </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((<span class="Type">void</span> *)psrp_process_status != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       psrp_attach_static_function(<span class="Constant">&quot;status&quot;</span>,psrp_process_status);


<span class="PreProc">    #ifdef MAIL_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the process is mailable start the mail hoemostat so we check our </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> mailbox regularly                                                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_mailable == TRUE)
       (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;mail_hoemostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">100</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)&amp;psrp_mail_homeostat);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>


    psrp_mode = TRUE;
    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    If an autoload file exists for this PSRP server load the objects</span>
<span class="Comment">    in it and their (user defined attributes) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_load_default_dispatch_table(<span class="Type">void</span>)

{   <span class="Type">char</span> autoload_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_load_default_dispatch_table] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(appl_psrp_load == FALSE)
       <span class="Statement">return</span>(FALSE);

    (<span class="Type">void</span>)strdate(date);
    (<span class="Type">void</span>)snprintf(autoload_file_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.</span><span class="Special">%s</span><span class="Constant">.psrp&quot;</span>,appl_home,appl_name);
    <span class="Statement">if</span>(access(autoload_file_name, F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">ENFILE</span>);
       <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">if</span>(psrp_load_dispatch_table(TRUE,autoload_file_name) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(FALSE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">   Find action slot index by name ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_find_action_slot_index(<span class="Type">const</span> <span class="Type">char</span> *object_tag)

{   <span class="Type">int</span> i,
        j;


    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_find_action_slot_index] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].aliases &gt; <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Search tag list for object_tag </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;psrp_object_list[i].aliases_allocated; ++j)
          {  <span class="Statement">if</span>(psrp_object_list[i].object_tag[j] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>           &amp;&amp;
                strcmp(psrp_object_list[i].object_tag[j],object_tag) == <span class="Constant">0</span>    )
             {  pups_set_errno(OK);
                <span class="Statement">return</span>(i);
             }
          }
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">   Get the first free slot in the dispatch table allocating more space if</span>
<span class="Comment">   necessary ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_get_action_slot_index(<span class="Type">void</span>)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_action_slot_index] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(psrp_object_list_size == psrp_object_list_used)
    {  psrp_object_list_used += PSRP_DISPATCH_TABLE_SIZE;
       psrp_object_list = (psrp_object_type *)pups_realloc((<span class="Type">void</span> *)psrp_object_list,
                                                           psrp_object_list_used*<span class="Statement">sizeof</span>(psrp_object_type));


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clean out the newly allocated entries </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=psrp_object_list_used-PSRP_DISPATCH_TABLE_SIZE; i&lt;psrp_object_list_used; ++i)
       {   psrp_object_list[i].aliases_allocated = <span class="Constant">0</span>;
           psrp_object_list[i].aliases           = <span class="Constant">0</span>;
           psrp_object_list[i].object_tag        = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;
           psrp_object_list[i].object_f_name     = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
           psrp_object_list[i].hid               = (-<span class="Constant">1</span>);
           psrp_object_list[i].object_type       = (-<span class="Constant">1</span>);
           psrp_object_list[i].object_size       = (-<span class="Constant">1</span>);
           psrp_object_list[i].object_handle     = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       }

       ++psrp_object_list_size;

       pups_set_errno(OK);
       <span class="Statement">return</span>(psrp_object_list_size-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle == <span class="Constant">NULL</span>)
       {  ++psrp_object_list_size;

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">   Attach a static databag to the PSRP handler dispatch list ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_attach_static_databag(<span class="Type">const</span> <span class="Type">char</span>               *object_tag,
                                       <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span>  <span class="Type">int</span> databag_size,
                                       <span class="Type">const</span> _BYTE              *databag_handle)

{   <span class="Type">int</span> slot_index,
        tag_index;


    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || databag_handle == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_attach_static_databag] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Statement">if</span>((slot_index = psrp_find_action_slot_index(object_tag)) == (-<span class="Constant">1</span>))
        slot_index = psrp_get_action_slot_index();
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overwriting existing object </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,object_tag);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }

    psrp_object_list[slot_index].aliases           = <span class="Constant">0</span>;
    psrp_object_list[slot_index].aliases_allocated = <span class="Constant">0</span>;
    tag_index = psrp_get_tag_index(slot_index);

    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_tag[tag_index],object_tag,SSIZE);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[tag_index] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_tag[tag_index] = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    psrp_object_list[slot_index].object_handle     = (<span class="Type">void</span> *)databag_handle;
    psrp_object_list[slot_index].object_size       = databag_size;
    psrp_object_list[slot_index].object_type       = PSRP_STATIC_DATABAG;

    <span class="Statement">if</span>(appl_verbose == TRUE )
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): static databag </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> attached (at offset </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                          date,
                                                                                                     appl_name,
                                                                                                      appl_pid,
                                                                                                     appl_host,
                                                                                                    appl_owner,
                                                                                                    object_tag,
                                                                             (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)databag_handle);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Attach a dynamic databag to the PSRP handler dispatch list ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_attach_dynamic_databag(<span class="Type">const</span> _BOOLEAN     search,  <span class="Comment">// If TRUE search DISPATCH_PATH directories</span>
                                        <span class="Type">const</span> <span class="Type">char</span>    *object_tag,  <span class="Comment">// Object (root) tag</span>
                                        <span class="Type">const</span> <span class="Type">char</span> *bag_file_name,  <span class="Comment">// Name of file containing bag data</span>
                                        <span class="Type">const</span> <span class="Type">int</span>          h_mode)  <span class="Comment">// Databag homeostasis mode</span>

{   <span class="Type">int</span>  slot_index,
         tag_index,
         bag_size,
         bag_bytes_read,
         bag_des;

    _BYTE *bag_handle = (_BYTE *)<span class="Constant">NULL</span>;


    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || bag_file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_attach_dynamic_databag] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if object exists on specified path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> if it doesn't search the directories specified  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in the DISPATCH_PATH environment variable       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(bag_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(search == TRUE)
       {  <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(strrext(bag_file_name,tmp_str,<span class="Constant">'/'</span>) == TRUE)
             (<span class="Type">void</span>)strlcpy(bag_file_name,tmp_str,SSIZE);

          <span class="Statement">if</span>(strccpy(tmp_str,(<span class="Type">char</span> *)pups_search_path(<span class="Constant">&quot;DISPATCH_PATH&quot;</span>,bag_file_name)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          {  pups_set_errno(<span class="Constant">EEXIST</span>);
             <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
          }
          (<span class="Type">void</span>)strlcpy(bag_file_name,tmp_str,SSIZE);
       }
       <span class="Statement">else</span>
       {  pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
       }
    }

    <span class="Statement">if</span>((slot_index = psrp_find_action_slot_index(object_tag)) == (-<span class="Constant">1</span>))
        slot_index = psrp_get_action_slot_index();
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_verbose == FALSE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overwriting existing object </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,object_tag);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }


    psrp_object_list[slot_index].aliases           = <span class="Constant">0</span>;
    psrp_object_list[slot_index].aliases_allocated = <span class="Constant">0</span>;
    tag_index                                      = psrp_get_tag_index(slot_index);
    bag_des                                        = pups_open(bag_file_name,<span class="Constant">0</span>,FALSE);

    <span class="Statement">if</span>(h_mode == LIVE)
    {  <span class="Type">char</span> homeostat_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)snprintf(homeostat_name,SSIZE,<span class="Constant">&quot;default_fd_homeostat: </span><span class="Special">%s</span><span class="Constant">&quot;</span>,bag_file_name);
       (<span class="Type">void</span>)pups_creator(bag_des);
       (<span class="Type">void</span>)pups_fd_alive(bag_des,homeostat_name,&amp;pups_default_fd_homeostat);
    }

    bag_size = <span class="Constant">0</span>;
    <span class="Statement">do</span> {

           <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Read the contents into bag allocating memory dynamically </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

           bag_size += PSRP_BAG_TABLE_SIZE;
           bag_handle     = (_BYTE *)pups_realloc((<span class="Type">void</span> *)bag_handle,bag_size);
           bag_bytes_read = pups_pipe_read(bag_des,bag_handle,PSRP_BAG_TABLE_SIZE);
       } <span class="Statement">while</span>(bag_bytes_read == PSRP_BAG_TABLE_SIZE);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[tag_index] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_tag[tag_index] = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_f_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_handle == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_handle = (<span class="Type">void</span> *)bag_handle;

    psrp_object_list[slot_index].object_size = bag_size;
    psrp_object_list[slot_index].object_type = PSRP_DYNAMIC_DATABAG;

    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_tag[tag_index],object_tag,SSIZE);
    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_f_name,bag_file_name,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): dynamic databag </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> attached (from </span><span class="Special">%s</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                            date,
                                                                                                       appl_name,
                                                                                                        appl_pid,
                                                                                                       appl_host,
                                                                                                      appl_owner,
                                                                                                      object_tag,
                                                                                                   bag_file_name,
                                                                                   (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)bag_handle);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}





<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Attach a persistent heap to the PSRP handler dispatch list ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_attach_persistent_heap(<span class="Type">const</span> _BOOLEAN      search,    <span class="Comment">// If TRUE search DISPATCH_PATH directories for heap</span>
                                        <span class="Type">const</span> <span class="Type">char</span>       *heap_tag,    <span class="Comment">// (Root) tag of persistent heap</span>
                                        <span class="Type">const</span> <span class="Type">char</span> *heap_file_name,    <span class="Comment">// Name of file containing heap data</span>
                                        <span class="Type">const</span> <span class="Type">int</span>           h_mode)    <span class="Comment">// Heap homeostatsis mode</span>

{   <span class="Type">int</span>  slot_index,
         tag_index;

    <span class="Statement">if</span>(heap_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || heap_file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_attach_persistent_heap] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if object exists on specified path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> if it doesn't search the directories specified  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in the DISPATCH_PATH environment variable       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(heap_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(search == TRUE)
       {  <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(strrext(heap_file_name,tmp_str,<span class="Constant">'/'</span>) == TRUE)
             (<span class="Type">void</span>)strlcpy(heap_file_name,tmp_str,SSIZE);

          <span class="Statement">if</span>(strccpy(tmp_str,(<span class="Type">char</span> *)pups_search_path(<span class="Constant">&quot;DISPATCH_PATH&quot;</span>,heap_file_name)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          {  pups_set_errno(<span class="Constant">EEXIST</span>);
             <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
          }
          (<span class="Type">void</span>)strlcpy(heap_file_name,tmp_str,SSIZE);
       }
       <span class="Statement">else</span>
       {  pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
       }
    }

    <span class="Statement">if</span>((slot_index = psrp_find_action_slot_index(heap_tag)) == (-<span class="Constant">1</span>))
        slot_index = psrp_get_action_slot_index();
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_verbose == FALSE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overwriting existing object </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                 date,appl_name,appl_pid,appl_host,appl_owner,heap_tag);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }


    <span class="Statement">if</span>(access(heap_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>) || heap_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    psrp_object_list[slot_index].aliases           = <span class="Constant">0</span>;
    psrp_object_list[slot_index].aliases_allocated = <span class="Constant">0</span>;

    tag_index   = psrp_get_tag_index(slot_index);

    <span class="Statement">if</span>((psrp_object_list[slot_index].hid = msm_heap_attach(heap_file_name,h_mode)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[tag_index] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_tag[tag_index] = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_f_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    psrp_object_list[slot_index].object_handle         = (<span class="Type">void</span> *)htable[psrp_object_list[slot_index].hid].addr;
    psrp_object_list[slot_index].object_size           = (-<span class="Constant">1</span>);
    psrp_object_list[slot_index].object_type           = PSRP_PERSISTENT_HEAP;

    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_tag[tag_index],heap_tag,SSIZE);
    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_f_name,heap_file_name,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): persistent heap </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> attached (from </span><span class="Special">%s</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                            date,
                                                                                                       appl_name,
                                                                                                        appl_pid,
                                                                                                       appl_host,
                                                                                                      appl_owner,
                                                                                                        heap_tag,
                                                                                                  heap_file_name,
                                                (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[psrp_object_list[slot_index].hid].addr);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPPRT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Attach an action function to the PSRP handler dispatch list ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_attach_static_function(<span class="Type">const</span> <span class="Type">char</span>    *object_tag,
                                        <span class="Type">const</span> <span class="Type">void</span> *object_handle)

{   <span class="Type">int</span> slot_index,
        tag_index;


    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || object_handle == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_attach_static_function] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>((slot_index = psrp_find_action_slot_index(object_tag)) == (-<span class="Constant">1</span>))
        slot_index = psrp_get_action_slot_index();
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_verbose == FALSE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overwriting existing object </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,object_tag);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }

    psrp_object_list[slot_index].aliases               = <span class="Constant">0</span>;
    psrp_object_list[slot_index].aliases_allocated     = <span class="Constant">0</span>;
    tag_index                                          = psrp_get_tag_index(slot_index);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[tag_index] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_tag[tag_index] = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    psrp_object_list[slot_index].object_handle         = object_handle;
    psrp_object_list[slot_index].object_size           = <span class="Constant">0</span>;
    psrp_object_list[slot_index].object_type           = PSRP_STATIC_FUNCTION;

    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_tag[tag_index],object_tag,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): static function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> attached (at offset </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                           date,
                                                                                                      appl_name,
                                                                                                       appl_pid,
                                                                                                      appl_host,
                                                                                                     appl_owner,
                                                                                                     object_tag,
                                                                               (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)object_handle);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to load a dynamic object into one of the slots of the PSRP</span>
<span class="Comment">    system. This object must conform to PSRP semantics - e.g it must</span>
<span class="Comment">    be a pointer to an int function with arguments of int argc and</span>
<span class="Comment">    char **argv ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_attach_dynamic_function(<span class="Type">const</span> _BOOLEAN  search,  <span class="Comment">// Search for DLL containing object</span>
                                         <span class="Type">const</span> <span class="Type">char</span> *object_tag,  <span class="Comment">// Tag of dyanmic object (function)</span>
                                         <span class="Type">const</span> <span class="Type">char</span>   *dll_name)  <span class="Comment">// Name of DLL contaaining object</span>

{   <span class="Type">int</span>  slot_index,
         tag_index;

    <span class="Type">char</span> dll_path_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">void</span> *object_handle = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || dll_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_attach_dynamic_function] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if object exist on specified path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> if it doesn't search the directories specified </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in the DISPATCH_PATH environment variable      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(dll_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(search == TRUE)
       {  <span class="Type">char</span> tmp_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(strrext(dll_name,tmp_str,<span class="Constant">'/'</span>) == TRUE)
             (<span class="Type">void</span>)strlcpy(dll_path_name,tmp_str,SSIZE);
          <span class="Statement">else</span>
          {  pups_set_errno(<span class="Constant">EEXIST</span>);
             <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
          }

          <span class="Statement">if</span>(strccpy(tmp_str,pups_search_path(<span class="Constant">&quot;DISPATCH_PATH&quot;</span>,dll_path_name)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          {  pups_set_errno(<span class="Constant">EEXIST</span>);
             <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
          }
          (<span class="Type">void</span>)strlcpy(dll_path_name,tmp_str,SSIZE);
       }
       <span class="Statement">else</span>
       {  pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
       }
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(dll_path_name,dll_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Try to load the dynamic object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>


    <span class="Statement">if</span>((object_handle = pups_bind_orifice_handle(dll_path_name,
                                                 object_tag,
                                                 <span class="Constant">&quot;int (*)(int, char *[])&quot;</span>)) == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Statement">if</span>((slot_index = psrp_find_action_slot_index(object_tag)) == (-<span class="Constant">1</span>))
        slot_index = psrp_get_action_slot_index();
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overwriting existing object </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,object_tag);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }


    psrp_object_list[slot_index].aliases               = <span class="Constant">0</span>;
    psrp_object_list[slot_index].aliases_allocated     = <span class="Constant">0</span>;
    tag_index                                          = psrp_get_tag_index(slot_index);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[tag_index] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_tag[tag_index] = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       psrp_object_list[slot_index].object_f_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    psrp_object_list[slot_index].object_handle         = object_handle;
    psrp_object_list[slot_index].object_size           = <span class="Constant">0</span>;
    psrp_object_list[slot_index].object_type           = PSRP_DYNAMIC_FUNCTION;

    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_tag[tag_index],object_tag,SSIZE);
    (<span class="Type">void</span>)strlcpy(psrp_object_list[slot_index].object_f_name,dll_name,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): dynamic function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> attached (from </span><span class="Special">%s</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                             date,
                                                                                                        appl_name,
                                                                                                         appl_pid,
                                                                                                        appl_host,
                                                                                                       appl_owner,
                                                                                                       object_tag,
                                                                                                         dll_name,
                                                                                 (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)object_handle);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span>  <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Show function currently bound to PSRP action list ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_show_object_list(<span class="Type">void</span>)

{   <span class="Type">int</span>  i;
    <span class="Type">char</span> pname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_show_object_list] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    PSRP server status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ==================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

<span class="PreProc">    #ifdef SECURE</span>
    <span class="Statement">if</span>(strcmp(HD_DEVICE,<span class="Constant">&quot;/dev/dummy&quot;</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) using soft dongle authentication (for licencing)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                         appl_name,
                                                                                          appl_pid,
                                                                                         appl_host);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) using disk serial number authentication (for licensing)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                appl_name,
                                                                                                 appl_pid,
                                                                                                appl_host);

<span class="PreProc">    #ifdef SINGLE_HOST_LICENSE</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has single copy single host license</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                        appl_name,
                                                                         appl_pid,
                                                                        appl_host);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has single copy multiple host license</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                           appl_name,
                                                                            appl_pid,
                                                                           appl_host);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SINGLE_HOST_LICENSE </span><span class="Comment">*/</span>

<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has multiple copy multiple host (unrestricted) license</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                            appl_name,
                                                                                             appl_pid,
                                                                                            appl_host);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SECURE </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef PSRP_AUTHENTICATE</span>
    <span class="Statement">if</span>(appl_secure == TRUE)
    {  (<span class="Type">void</span>)fprintf(psrp_out,
                  <span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) is secure (client authentication enabled)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                     appl_name,
                                                                      appl_pid,
                                                                     appl_host);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUNTHENTICATE </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef MAIL_SUPPORT</span>


    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Postbox </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_mailable == TRUE)
    {  <span class="Statement">if</span>(strcmp(appl_mime_type,<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has postbox </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (extracting all MIME message parts)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                  appl_name,
                                                                                                   appl_pid,
                                                                                                  appl_host,
                                                                                                  appl_mdir);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has postbox </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (extracting MIME message part </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                    appl_name,
                                                                                                     appl_pid,
                                                                                                    appl_host,
                                                                                                    appl_mdir,
                                                                                               appl_mime_type);
    }


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No postbox </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) does not have a postbox (does not support e-mail interaction)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>



<span class="PreProc">    #ifndef NO_NET</span>
    <span class="Statement">if</span>(appl_rooted == TRUE)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) is rooted (system context cannot migrate)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) is not rooted (system context can migrate via tunnel daemon)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> NO_NET </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_pid_to_pname(appl_ppid,pname);
    <span class="Statement">if</span>(appl_ppid_exit == TRUE)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) will exit when parent process </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) terminates</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host,appl_ppid,pname);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) will not exit when parent process </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) terminates</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host,appl_ppid,pname);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">if</span>(psrp_object_list_size == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    No PSRP objects bound to dispatch handler (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_object_list_used);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%d</span><span class="Constant"> PSRP object slots in use</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_object_list_size);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    PSRP objects bound to </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
       {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (entry at </span><span class="Special">%016lx</span><span class="Constant"> virtual)    &quot;</span>,i,
                                                        psrp_object_list[i].object_tag[<span class="Constant">0</span>],
                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)psrp_object_list[i].object_handle);
              (<span class="Type">void</span>)fflush(psrp_out);

              <span class="Statement">switch</span>(psrp_object_list[i].object_type)
              {   <span class="Statement">case</span> PSRP_STATIC_DATABAG:    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;  Static databag (</span><span class="Special">%d</span><span class="Constant"> bytes)&quot;</span>,
                                                                    psrp_object_list[i].object_size);

                                               <span class="Statement">break</span>;

                  <span class="Statement">case</span> PSRP_PERSISTENT_HEAP:   (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;  Persistent heap(</span><span class="Special">%d</span><span class="Constant"> bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                      psrp_object_list[i].object_size);
                                               <span class="Statement">break</span>;

                  <span class="Statement">case</span> PSRP_DYNAMIC_DATABAG:   (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;  Dynamic databag (</span><span class="Special">%d</span><span class="Constant"> bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                       psrp_object_list[i].object_size);
                                               <span class="Statement">break</span>;

                  <span class="Statement">case</span> PSRP_DYNAMIC_FUNCTION:  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;  Dynamic function</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                                               <span class="Statement">break</span>;

                  <span class="Statement">case</span> PSRP_STATIC_FUNCTION:   (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;  Static function</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
                                               <span class="Statement">break</span>;

                  <span class="Statement">default</span>:                     <span class="Statement">break</span>;
              }
          }

          (<span class="Type">void</span>)fflush(psrp_out);
       }

       <span class="Statement">if</span>(psrp_object_list_used &gt; <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> PSRP objects bound to dispatch handler (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_object_list_used,psrp_object_list_used - psrp_object_list_size);
       <span class="Statement">else</span> <span class="Statement">if</span>(psrp_object_list_used  == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> PSRP object bound to dispatch handler (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,psrp_object_list_used - <span class="Constant">1</span>);

       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">if</span>(appl_wait == TRUE)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Server state is </span><span class="Special">\&quot;</span><span class="Constant">wait</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Server state is </span><span class="Special">\&quot;</span><span class="Constant">run</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)fflush(psrp_out);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to re-initialise the dispatch table -- all dynamic objects are</span>
<span class="Comment">    detached and all static objects are restored to their initial states</span>
<span class="Comment">    (e.g. any aliases associated with static objects are removed) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_reset_dispatch_table(<span class="Type">void</span>)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_reset_dispatch_table] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_object_list[i].aliases &gt; <span class="Constant">0</span>)
          (<span class="Type">void</span>)psrp_detach_object(i);

    }
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to detach object from dispatch list by name ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_detach_object_by_name(<span class="Type">const</span> <span class="Type">char</span> *object_tag)

{    <span class="Type">int</span> i,
         slot_index;


    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_detach_object_by_name] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; (slot_index = psrp_isearch_tag_list(object_tag,i)) &gt;= <span class="Constant">0</span>)
       {

          <span class="Statement">if</span>(appl_verbose == FALSE)
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): object </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (index </span><span class="Special">%d</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual) detached</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                     date,appl_name,appl_pid,appl_host,appl_owner,
                                                                          psrp_object_list[slot_index].object_tag,
                                                                                                       slot_index,
                                                    (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)psrp_object_list[slot_index].object_handle);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(psrp_detach_object(i));
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to detach object from dispatch list by name ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_detach_object_by_handle(<span class="Type">const</span> <span class="Type">void</span> *object_handle)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(object_handle == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_detach_object_by_handle] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_object_list[i].object_handle == object_handle)
       {

          <span class="Statement">if</span>(appl_verbose == FALSE)
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): object </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (index </span><span class="Special">%d</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual) detached</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                     date,appl_name,appl_pid,appl_host,appl_owner,
                                                                                   psrp_object_list[i].object_tag,
                                                                                                                i,
                                                             (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)psrp_object_list[i].object_handle);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(psrp_detach_object(i));
       }
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to detach an object taking note of its type and contextual </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> information                                                        </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_detach_object(<span class="Type">unsigned</span> <span class="Type">int</span> slot_index)

{   <span class="Type">int</span> i,
        type;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_detach_object] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(slot_index &gt; psrp_object_list_used)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Log object deletion (note wrapper function has already checked index  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> validity)                                                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);

       <span class="Statement">if</span>(psrp_object_list[slot_index].object_type == PSRP_STATIC_FUNCTION ||
          psrp_object_list[slot_index].object_type == PSRP_STATIC_DATABAG   )
       {  <span class="Statement">if</span>(psrp_object_list[slot_index].aliases &gt; <span class="Constant">1</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): static PSRP object </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> reinitialised (</span><span class="Special">%d</span><span class="Constant"> alias(es) deleted)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                  date,
                                                                                                             appl_name,
                                                                                                              appl_pid,
                                                                                                             appl_host,
                                                                                                            appl_owner,
                                                                            psrp_object_list[slot_index].object_tag[<span class="Constant">0</span>],
                                                                              psrp_object_list[slot_index].aliases - <span class="Constant">1</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): static PSRP object </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is in intial state (no aliases)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                             date,
                                                                                                        appl_name,
                                                                                                         appl_pid,
                                                                                                        appl_host,
                                                                                                       appl_owner,
                                                                       psrp_object_list[slot_index].object_tag[<span class="Constant">0</span>]);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): dynamic PSRP object </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> detached</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                    date,
                                                                               appl_name,
                                                                                appl_pid,
                                                                               appl_host,
                                                                              appl_owner,
                                              psrp_object_list[slot_index].object_tag[<span class="Constant">0</span>]);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> In the case of a static object - we simply reset it to its initial </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> state. That means all aliases must be removed                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_object_list[slot_index].object_type == PSRP_STATIC_FUNCTION ||
       psrp_object_list[slot_index].object_type == PSRP_STATIC_DATABAG   )
    {  <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt; psrp_object_list[slot_index].aliases_allocated; ++i)
           <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
              psrp_object_list[slot_index].object_tag[i] = pups_free((<span class="Type">void</span> *)psrp_object_list[slot_index].object_tag[i]);

       psrp_object_list[slot_index].aliases = <span class="Constant">1</span>;

       pups_set_errno(OK);
       <span class="Statement">return</span>(psrp_object_list[slot_index].object_type);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Object is dynamic - process it according to its type. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the object is dynamic, the type of processing is dependent on         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> whether it is a dynamic function, a dynamic databag of a persistentheap. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> In all cases the slot in the dispatch table is cleared, and any          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> resources associated with the object are released.                       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

    type = psrp_object_list[slot_index].object_type;
    <span class="Statement">switch</span>(type)
    {

<span class="PreProc">       #ifdef DLL_SUPPORT</span>
       <span class="Statement">case</span> PSRP_DYNAMIC_FUNCTION:  <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment"> Only dynamic objects can be detached </span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

                                    <span class="Statement">if</span>(pups_free_orifice_handle(psrp_object_list[slot_index].object_handle) != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                                       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

                                    <span class="Statement">break</span>;
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">case</span> PSRP_DYNAMIC_DATABAG:   <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment"> A databag can always be detached given that we have permission </span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment"> To allocate it in the first place                              </span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

                                    (<span class="Type">void</span>)pups_free((<span class="Type">char</span> *)psrp_object_list[slot_index].object_handle);
                                    <span class="Statement">break</span>;

<span class="PreProc">       #ifdef PERSISTENT_HEAP_SUPPORT</span>
       <span class="Statement">case</span> PSRP_PERSISTENT_HEAP:   <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment"> Detach persistent heap </span><span class="Comment">*/</span>
                                    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

                                    (<span class="Type">void</span>)msm_heap_detach(psrp_object_list[slot_index].hid,O_DESTROY);
                                    <span class="Statement">break</span>;
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">default</span>:                     <span class="Statement">break</span>;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Delete other attributes associated with the object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt; psrp_object_list[slot_index].aliases_allocated; ++i)
        <span class="Statement">if</span>(psrp_object_list[slot_index].object_tag[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
           (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)psrp_object_list[slot_index].object_tag[i]);

    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)psrp_object_list[slot_index].object_tag);
    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)psrp_object_list[slot_index].object_f_name);

    psrp_object_list[slot_index].object_tag        = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;
    psrp_object_list[slot_index].object_f_name     = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
    psrp_object_list[slot_index].object_handle     = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    psrp_object_list[slot_index].object_type       = PSRP_NONE;
    psrp_object_list[slot_index].object_size       = <span class="Constant">0</span>;
    psrp_object_list[slot_index].object_state      = PSRP_NONE;
    psrp_object_list[slot_index].aliases           = <span class="Constant">0</span>;
    psrp_object_list[slot_index].aliases_allocated = <span class="Constant">0</span>;
    psrp_object_list[slot_index].hid               = (-<span class="Constant">1</span>);

    --psrp_object_list_size;

    pups_set_errno(OK);
    <span class="Statement">return</span>(type);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for client disconnect in response to server stop </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> cdoss_handler(<span class="Type">int</span> signum)
{   psrp_chbrk_handler(c_client,PSRP_CLIENT_TERMINATED);

    <span class="Statement">if</span>(in_psrp_handler == TRUE)
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;psrp_env);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for client disconnect in response to server stop </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_cont_handler(<span class="Type">const</span> <span class="Type">int</span> signum)
{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_cont_handler] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(in_psrp_handler == TRUE)
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;psrp_env);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Register client side abort callback </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _PUBLIC _BOOLEAN (*on_abort_callback_f)(<span class="Type">void</span>);
_PRIVATE   <span class="Type">char</span>             on_abort_callback_f_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

_PUBLIC <span class="Type">int</span> psrp_register_on_abort_callback_f(<span class="Type">const</span> <span class="Type">char</span> *on_abort_f_name, <span class="Type">const</span> <span class="Type">void</span> *on_abort_f)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[register_psrp_on_abort] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(on_abort_f_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   ||
       on_abort_f      == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>    )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    on_abort_callback_f = on_abort_f;
    (<span class="Type">void</span>)strlcpy(on_abort_callback_f_name,on_abort_f_name,SSIZE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Deregister client side abort callback </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_deregister_on_abort_callback_f(<span class="Type">void</span>)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[register_psrp_on_abort] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

     on_abort_callback_f = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
     (<span class="Type">void</span>)strlcpy(on_abort_callback_f_name,<span class="Constant">&quot;&quot;</span>,SSIZE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display client side abort callback function details </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_show_on_abort_callback_f(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(on_abort_callback_f != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Client side abort callback function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> installed at </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                  on_abort_callback_f_name,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)on_abort_callback_f);
       (<span class="Type">void</span>)fflush(stream);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for client abort </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> abrt_handler(<span class="Type">int</span> signum)

{   <span class="Type">int</span> i,
        f_index,
        client_pid;

    _BOOLEAN omp_abort          = FALSE,
             close_psrp_channel = FALSE;


<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB </span><span class="Special">%d</span><span class="Constant"> SIGABRT</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set interrupt flag (if enabled) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_abrtflag_enable == TRUE)
       psrp_abrtflag = TRUE;


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Callback for abort </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((<span class="Type">void</span> *)on_abort_callback_f != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Abort callback function    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> returns TRUE if aborted    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> code is parallelised using </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> OpenMP                     </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

       omp_abort = on_abort_callback_f();
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get pid of client which requested abort </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_in == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Note homeostasis for the PSRP channel is </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> pups_maintained by the psrp_homeostat    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

       psrp_in  = pups_fopen(channel_name_in, <span class="Constant">&quot;r+&quot;</span>,DEAD);
       psrp_out = pups_fopen(channel_name_out,<span class="Constant">&quot;r+&quot;</span>,DEAD);
       close_psrp_channel = TRUE;
    }

    (<span class="Type">void</span>)efscanf(psrp_in,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;client_pid);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Execute registered PUPS abort functions </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_abort_funcs_alloc; ++i)
    {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_abort_f[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          (*pups_abort_f[i])(pups_abort_arg[i]);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell psrp client we have finished </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> handling abort operation          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    psrp_endop(<span class="Constant">&quot;abrt&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have an overforked child -- terminate it </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(overforking == TRUE)
    {  (<span class="Type">void</span>)kill(overforked_child_pid,<span class="Constant">SIGTERM</span>);
       overforking          = FALSE;
       overforked_child_pid = (-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB %d <span class="Constant">SIGABRT</span> stage <span class="Constant">2</span>\n<span class="Constant">&quot;,appl_pid);</span>
<span class="Constant">    (void)fflush(stderr);</span>
<span class="Constant">    #endif /* PSRPLIB_DEBUG */</span>


<span class="Constant">    /*-----------------------------------------------------------*/</span>
<span class="Constant">    /* If we are talking to a slaved client forward signal to it */</span>
<span class="Constant">    /* and destroy channel                                       */</span>
<span class="Constant">    /*-----------------------------------------------------------*/</span>

<span class="Constant">    if(psrp_current_sic != (psrp_channel_type *)NULL)</span>
<span class="Constant">    {  </span>

<span class="Constant">       #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">       (void)fprintf(stderr,&quot;&quot;PSRPLIB </span><span class="Special">%d</span><span class="Constant"> SIGABRT stage 3 (propagate to SIC: </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,psrp_current_sic-&gt;scp);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)kill(psrp_current_sic-&gt;scp,<span class="Constant">SIGINT</span>);

<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB %d <span class="Constant">SIGABRT</span> stage <span class="Constant">4</span>: SIC closed\n<span class="Constant">&quot;,appl_pid);</span>
<span class="Constant">       (void)fflush(stderr);</span>
<span class="Constant">       #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">    }</span>

<span class="Constant">    #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">    (void)fprintf(stderr,&quot;&quot;PSRPLIB </span><span class="Special">%d</span><span class="Constant"> SIGABRT stage 5: abrt sent</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(close_psrp_channel == TRUE)
    {  psrp_in  = pups_fclose(psrp_in);
       psrp_out = pups_fclose(psrp_out);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP interrupt received (from PSRP client </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_client],client_pid,appl_host);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we were talking to a socket close it down now  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> so resources on remote end of socket are released </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((f_index = pups_get_ftab_index_by_id(c_client)) != (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): datalink [</span><span class="Special">%s</span><span class="Constant">] closed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,ftab[f_index].fname);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       <span class="Statement">if</span>(ftab[f_index].stream != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)pups_fclose(ftab[f_index].stream);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)pups_close(ftab[f_index].fdes);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Client exit handler is provided so any application specific </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> files etc can be cleaned up when PSRP channel is closed     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((<span class="Type">void</span> *)psrp_client_exitf[c_client] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)(*psrp_client_exitf[c_client])(c_client);
       psrp_client_exitf[c_client] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP client connection exit handler </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> executed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_efname[c_client]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)strlcpy(psrp_client_efname[c_client],<span class="Constant">&quot;&quot;</span>,SSIZE);
    }

    <span class="Statement">if</span>(req_r_cnt[c_client] &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) last request repeated </span><span class="Special">%d</span><span class="Constant"> times</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                     date,
                                                                                                appl_name,
                                                                                                 appl_pid,
                                                                                                appl_host,
                                                                                               appl_owner,
                                                                                    PSRP_PROTOCOL_VERSION,
                                                                                  req_r_cnt[c_client] + <span class="Constant">1</span>);
       req_r_cnt[c_client] = <span class="Constant">0</span>;
       (<span class="Type">void</span>)strlcpy(old_request_str[c_client],<span class="Constant">&quot;&quot;</span>,SSIZE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> The PUPS/P3 function abort is serial    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> OMP parallel codes have to handle the   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> client side of the abort themselves due </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to limitations of OpemMP abort handling </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(omp_abort == FALSE)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We don't need to do anything unless we are in the PSRP handler code </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> or the chan handler code                                            </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(in_psrp_handler == TRUE)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Need to adjust count here to stop mismatch exit</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

          ++pupsighold_cnt[<span class="Constant">SIGALRM</span>];
          (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;psrp_env);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(in_chan_handler == TRUE)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Need to adjust count here to stop mismatch exit</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

          ++pupsighold_cnt[<span class="Constant">SIGALRM</span>];
          (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;chan_env);
       }
    }

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for SIGCHAN -- supplies information about server to connected </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PSRP client function                                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> chan_handler(<span class="Type">int</span> signum)

{   sigset_t set;

    <span class="Type">char</span>  psrp_channel_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
          recreated[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
          psrp_channel_op[SSIZE]   = <span class="Constant">&quot;&quot;</span>;

    _IMMORTAL _BOOLEAN entered = FALSE;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sometimes, because of latency, we can get a SIGCHAN </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> raised in psrp_new_segment - this is spurious and   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> must not be processed                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_psrp_new_segment == TRUE)
       <span class="Statement">return</span>(<span class="Constant">0</span>);

    in_chan_handler = TRUE;
    <span class="Statement">if</span>(sigsetjmp(chan_env,<span class="Constant">0</span>) &gt; <span class="Constant">0</span>)
    {  psrp_in  = pups_fclose(psrp_in);
       psrp_out = pups_fclose(psrp_out);

       in_chan_handler     = FALSE;

       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB CHAN open (%d)\n<span class="Constant">&quot;,signum);</span>
<span class="Constant">    (void)fflush(stderr);</span>
<span class="Constant">    #endif /* PSRPLIB_DEBUG */</span>


<span class="Constant">    /*-----------------------------------------*/</span>
<span class="Constant">    /* Open an input client -&gt; process channel */</span>
<span class="Constant">    /*-----------------------------------------*/</span>

<span class="Constant">    (void)snprintf(psrp_channel_name,SSIZE,&quot;</span>%s/psrp#%s#fifo#in#%d#%d<span class="Constant">&quot;,appl_fifo_dir,appl_ch_name,appl_pid,getuid());</span>


<span class="Constant">    /*----------------------------------------------------------*/</span>
<span class="Constant">    /* Homeostatsis for the psrp channels is pups_maintained by */</span>
<span class="Constant">    /* the psrp_homeostat                                       */</span>
<span class="Constant">    /*----------------------------------------------------------*/</span>

<span class="Constant">    if((psrp_in = pups_fopen(psrp_channel_name,&quot;</span>r+<span class="Constant">&quot;,DEAD)) == (FILE *)NULL)</span>
<span class="Constant">    {  if(appl_verbose == TRUE)</span>
<span class="Constant">       {  (void)fprintf(stderr,</span>
<span class="Constant">                  &quot;</span>error(%d@%s): failed to open input stream (%s) <span class="Statement">for</span> status request\n<span class="Constant">&quot;,appl_ch_name,appl_pid,appl_host);</span>
<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">       }</span>

<span class="Constant">       in_chan_handler     = FALSE;</span>
<span class="Constant">       return(0);</span>
<span class="Constant">    }</span>


<span class="Constant">    /*-------------------------------------------*/</span>
<span class="Constant">    /* Open an output process -&gt; client channel  */</span>
<span class="Constant">    /*-------------------------------------------*/</span>

<span class="Constant">    (void)snprintf(psrp_channel_name,SSIZE,&quot;</span>%s/psrp#%s#fifo#out#%d#%d<span class="Constant">&quot;,appl_fifo_dir,appl_ch_name,appl_pid,getuid());</span>


<span class="Constant">    /*----------------------------------------------------------*/</span>
<span class="Constant">    /* Homeostatsis for the psrp channels is pups_maintained by */</span>
<span class="Constant">    /* the psrp_homeostat                                       */</span>
<span class="Constant">    /*----------------------------------------------------------*/</span>

<span class="Constant">    if((psrp_out = pups_fopen(psrp_channel_name,&quot;</span>r+<span class="Constant">&quot;,DEAD)) == (FILE *)NULL)</span>
<span class="Constant">    {  if(appl_verbose == TRUE)</span>
<span class="Constant">       {  (void)fprintf(stderr,</span>
<span class="Constant">                  &quot;</span>error(%d@%s): failed to open output stream (%s) <span class="Statement">for</span> status request\n<span class="Constant">&quot;,appl_ch_name,appl_pid,appl_host);</span>
<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">       }</span>

<span class="Constant">       psrp_in = pups_fclose(psrp_in);</span>
<span class="Constant">       return(0);</span>
<span class="Constant">    }</span>

<span class="Constant">    ftab[pups_get_ftab_index(fileno(psrp_in))].psrp  = TRUE;</span>
<span class="Constant">    ftab[pups_get_ftab_index(fileno(psrp_out))].psrp = TRUE;</span>

<span class="Constant">    if(psrp_bind_status &amp; PSRP_HOMEOSTATIC_STREAMS)</span>
<span class="Constant">    {  ftab[pups_get_ftab_index(fileno(psrp_in)) ].homeostatic = 1;</span>
<span class="Constant">       ftab[pups_get_ftab_index(fileno(psrp_out))].homeostatic = 1;</span>
<span class="Constant">    }</span>


<span class="Constant">    /*--------------------------------------------------------*/</span>
<span class="Constant">    /* A client wants to connect to us -- service the request */</span>
<span class="Constant">    /*--------------------------------------------------------*/</span>

<span class="Constant">    if(signum == SIGINIT)</span>
<span class="Constant">    {  int  psrp_op_pid;</span>
<span class="Constant">       char tmp_str[SSIZE] = &quot;&quot;;</span>


<span class="Constant">       /*----------------------------*/</span>
<span class="Constant">       /* Get PSRP channel operation */ </span>
<span class="Constant">       /*----------------------------*/</span>

<span class="Constant">       (void)efgets(tmp_str,SSIZE,psrp_in);</span>
<span class="Constant">       (void)sscanf(tmp_str,&quot;</span>%s %d %s<span class="Constant">&quot;,psrp_channel_op,&amp;psrp_op_pid,psrp_password);</span>

<span class="Constant">       #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">       (void)fprintf(stderr,&quot;&quot;PSRPLIB CLIENT OP: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tmp_str);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Newly segmented servers pick up any existing authentication token </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(psrp_seg_cnt &gt; <span class="Constant">0</span> &amp;&amp; entered == FALSE &amp;&amp; strcmp(psrp_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
       {  entered     = TRUE;
          appl_secure = TRUE;
          (<span class="Type">void</span>)strlcpy(appl_password,psrp_password,SSIZE);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): segmented server secure</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }

<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB SIGINIT (op = %s): password is %s:%s\n<span class="Constant">&quot;,psrp_channel_op,psrp_password,appl_password);</span>
<span class="Constant">       (void)fflush(stderr);</span>
<span class="Constant">       #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">       if(strncmp(psrp_channel_op,&quot;</span>CLOSE<span class="Constant">&quot;,5) == 0)</span>
<span class="Constant">       {  psrp_channel_open = FALSE;</span>

<span class="Constant">          #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">          (void)fprintf(stderr,&quot;&quot;PSRPLIB SIGINIT (disconnect)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have a channel exit function installed it must </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> be executed now                                      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>((<span class="Type">void</span> *)psrp_client_exitf[c_client] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  (<span class="Type">void</span>)(*psrp_client_exitf[c_client])(c_client);
             psrp_client_exitf[c_client] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
             (<span class="Type">void</span>)strlcpy(psrp_client_efname[c_client],<span class="Constant">&quot;&quot;</span>,SSIZE);
          }

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             (<span class="Type">void</span>)strdate(date);
             <span class="Statement">if</span>(psrp_transactions[c_client] == <span class="Constant">1</span>)
                (<span class="Type">void</span>)strlcpy(tmpstr,<span class="Constant">&quot;transaction&quot;</span>,SSIZE);
             <span class="Statement">else</span>
                (<span class="Type">void</span>)strlcpy(tmpstr,<span class="Constant">&quot;transactions&quot;</span>,SSIZE);

             <span class="Statement">if</span>(strcmp(psrp_remote_hostpath[c_client],<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): client </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has disconnected (</span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                 date,
                                                                                            appl_name,
                                                                                             appl_pid,
                                                                                            appl_host,
                                                                                           appl_owner,
                                                                           psrp_client_name[c_client],
                                                                            psrp_client_pid[c_client],
                                                                           psrp_client_host[c_client],
                                                                          psrp_transactions[c_client],
                                                                                               tmpstr);
             <span class="Statement">else</span>
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): client </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has disconnected [from </span><span class="Special">%s</span><span class="Constant">] (</span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                           date,
                                                                                                      appl_name,
                                                                                                       appl_pid,
                                                                                                      appl_host,
                                                                                                     appl_owner,
                                                                                     psrp_client_name[c_client],
                                                                                      psrp_client_pid[c_client],
                                                                                     psrp_client_host[c_client],
                                                                                 psrp_remote_hostpath[c_client],
                                                                                    psrp_transactions[c_client],
                                                                                                        tmpstr);

             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Clear this client from the table of connected clients </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

          c_client = psrp_clear_client_slot(c_client);


          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Tell client we have finished servicing SIGINT (CLOSE) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

          psrp_endop(<span class="Constant">&quot;close&quot;</span>);

          psrp_in  = pups_fclose(psrp_in);
          psrp_out = pups_fclose(psrp_out);

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB CHAN CLOSE close\n<span class="Constant">&quot;);</span>
<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">          #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">          in_chan_handler     = FALSE;</span>

<span class="Constant">          return(0);</span>
<span class="Constant">       }</span>
<span class="Constant">       else if(strncmp(psrp_channel_op,&quot;</span>OPEN<span class="Constant">&quot;,4) == 0                                        ||</span>
<span class="Constant">                      (strncmp(psrp_channel_op,&quot;</span>GRAB<span class="Constant">&quot;,4) == 0 &amp;&amp; in_psrp_new_segment == FALSE))</span>
<span class="Constant">       {  int  trys = 0,</span>
<span class="Constant">               fdes = (-1);</span>

<span class="Constant">          char client_info[SSIZE] = &quot;&quot;;</span>

<span class="Constant">          if(strncmp(psrp_channel_op,&quot;</span>OPEN<span class="Constant">&quot;,4) == 0)</span>
<span class="Constant">          {  </span>

<span class="Constant">             /*-------------------------------------------------------*/</span>
<span class="Constant">             /* Flag the fact we have connected at least once in this */</span>
<span class="Constant">             /* segment                                               */</span>
<span class="Constant">             /*-------------------------------------------------------*/</span>

<span class="Constant">             connected_once = TRUE;</span>
<span class="Constant">          }</span>


<span class="Constant">          /*---------------------------------------*/</span>
<span class="Constant">          /* Find a free slot for the next client  */</span>
<span class="Constant">          /* or return its slot if we have already */</span>
<span class="Constant">          /* connected to it                       */</span>
<span class="Constant">          /*---------------------------------------*/</span>

<span class="Constant">          c_client = psrp_get_client_slot(psrp_op_pid);</span>


<span class="Constant">          /*-----------------------------------------------------*/</span>
<span class="Constant">          /* If we have no free virtual channels tell the client */</span>
<span class="Constant">          /*-----------------------------------------------------*/</span>

<span class="Constant">          if(c_client == ENOCH)</span>
<span class="Constant">          {  (void)fprintf(psrp_out,&quot;</span>%s: PSRP connect error (no PSRP channels free)\n<span class="Constant">&quot;,appl_name);</span>
<span class="Constant">             (void)fflush(psrp_out);</span>

<span class="Constant">             if(appl_verbose == TRUE)</span>
<span class="Constant">             {  (void)strdate(date);</span>
<span class="Constant">                (void)fprintf(stderr,&quot;</span>%s %s (%d@%s:%s): PSRP connect error (no PSRP channels free)\n<span class="Constant">&quot;,</span>
<span class="Constant">                                                         date,appl_name,appl_pid,appl_host,appl_owner);</span>
<span class="Constant">                (void)fflush(stderr);</span>
<span class="Constant">             }</span>

<span class="Constant">             psrp_in  = pups_fclose(psrp_in);</span>
<span class="Constant">             psrp_out = pups_fclose(psrp_out);</span>

<span class="Constant">             in_chan_handler     = FALSE;</span>
<span class="Constant">             connected_once      = FALSE;</span>

<span class="Constant">             return(0);</span>
<span class="Constant">          }</span>
<span class="Constant">          else</span>
<span class="Constant">          {  (void)fprintf(psrp_out,&quot;</span>%d\n<span class="Constant">&quot;,psrp_seg_cnt);</span>
<span class="Constant">             (void)fflush(psrp_out);</span>
<span class="Constant">          }</span>

<span class="Constant">          #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">          if(strncmp(psrp_channel_op,&quot;</span>OPEN<span class="Constant">&quot;,4) == 0)</span>
<span class="Constant">             (void)fprintf(stderr,&quot;&quot;PSRPLIB SIGINIT (connect)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB SIGINIT (grab)\n<span class="Constant">&quot;);</span>

<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">          #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">          (void)efgets(client_info,SSIZE,psrp_in);</span>

<span class="Constant">          #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">          (void)fprintf(stderr,&quot;&quot;PSRPLIB CLIENT INFO </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,client_info);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

          <span class="Statement">if</span>(sscanf(client_info,<span class="Constant">&quot;</span><span class="Special">%s%d%s%s</span><span class="Constant">&quot;</span>,psrp_client_name[c_client],
                                           &amp;psrp_client_pid[c_client],
                                           psrp_client_host[c_client],
                                           psrp_remote_hostpath[c_client]) != <span class="Constant">4</span>)
             (<span class="Type">void</span>)strlcpy(psrp_remote_hostpath[c_client],<span class="Constant">&quot;notset&quot;</span>,SSIZE);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We can only flag channel open once we have a valid client pid </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> otherwise the homeostat will try to kill(0,SIGALIVE) with     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> disasterous results                                           </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

          psrp_channel_open           = TRUE;

          <span class="Statement">if</span>(strncmp(psrp_channel_op,<span class="Constant">&quot;OPEN&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  strdate(date);

                <span class="Statement">if</span>(strcmp(psrp_remote_hostpath[c_client],<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): client </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has connected</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                         appl_name,
                                                                                          appl_pid,
                                                                                         appl_host,
                                                                                        appl_owner,
                                                                        psrp_client_name[c_client],
                                                                         psrp_client_pid[c_client],
                                                                        psrp_client_host[c_client]);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): client </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) has connected [from </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                                   appl_name,
                                                                                                    appl_pid,
                                                                                                   appl_host,
                                                                                                  appl_owner,
                                                                                  psrp_client_name[c_client],
                                                                                   psrp_client_pid[c_client],
                                                                                  psrp_client_host[c_client],
                                                                              psrp_remote_hostpath[c_client]);

                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
             psrp_transactions[c_client] = <span class="Constant">0</span>;
          }


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Tell client we have finished servicing SIGINIT (grab or open) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

          psrp_endop(<span class="Constant">&quot;grope&quot;</span>);

          psrp_in  = pups_fclose(psrp_in);
          psrp_out = pups_fclose(psrp_out);

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB CHAN GROPE close\n<span class="Constant">&quot;);</span>
<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">          #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">          in_chan_handler     = FALSE;</span>

<span class="Constant">          return(0);</span>
<span class="Constant">       }</span>
<span class="Constant">    }</span>

<span class="Constant">    #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">    (void)fprintf(stderr,&quot;&quot;PSRPLIB SIGCHAN (</span><span class="Special">%016lx</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)psrp_out);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell client we have finished servicing SIGCHAN </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    psrp_endop(<span class="Constant">&quot;chan&quot;</span>);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB SIGCHAN DONE\n<span class="Constant">&quot;);</span>
<span class="Constant">    (void)fflush(stderr);</span>
<span class="Constant">    #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">    in_chan_handler     = FALSE;</span>
<span class="Constant">    return(0);</span>
<span class="Constant">}</span>




<span class="Constant">/*-------------------------------------------*/</span>
<span class="Constant">/* Check PSRP communication FIFOS are intact */</span>
<span class="Constant">/*-------------------------------------------*/</span>

<span class="Constant">_PRIVATE void psrp_homeostat(void *t_info, char *args)</span>

<span class="Constant">{    int idum  = 0,</span>
<span class="Constant">         trys  = 0;</span>

<span class="Constant">     if(psrp_channel_open == TRUE)</span>
<span class="Constant">     {  int i,</span>
<span class="Constant">            ret;</span>

<span class="Constant">        char tcode[SSIZE] = &quot;&quot;;</span>


<span class="Constant">        /*------------------------------------------------------*/</span>
<span class="Constant">        /* Check (non active) connected clients are still alive */</span>
<span class="Constant">        /*------------------------------------------------------*/</span>


<span class="Constant">        for(i=0; i&lt;MAX_CLIENTS; ++i)</span>
<span class="Constant">        { </span>
<span class="Constant">            /*------------------------------*/</span>
<span class="Constant">            /* Do not process active client */</span>
<span class="Constant">            /*------------------------------*/</span>
<span class="Constant"> </span>
<span class="Constant">            if(i != c_client &amp;&amp; psrp_client_pid[i] != (-1)) </span>
<span class="Constant">            {  do {    ret = pups_statkill(psrp_client_pid[i],SIGALIVE); </span>
<span class="Constant">                       ++trys;</span>
<span class="Constant">                  } while(trys &lt; max_trys &amp;&amp; ret &lt; 0);</span>

<span class="Constant">               if(ret &lt; 0)</span>
<span class="Constant">                  psrp_chbrk_handler(i,PSRP_CLIENT_TERMINATED);</span>
<span class="Constant">            }</span>
<span class="Constant">        }</span>


<span class="Constant">        /*--------------------------------------------------*/</span>
<span class="Constant">        /* Check that (active) current client is still alive */</span>
<span class="Constant">        /*---------------------------------------------------*/</span>

<span class="Constant">        do {    ret = pups_statkill(psrp_client_pid[c_client],SIGALIVE);</span>
<span class="Constant">                   ++trys;</span>
<span class="Constant">           } while(trys &lt; max_trys &amp;&amp; ret &lt; 0);</span>

<span class="Constant">        if(ret &lt; 0)</span>
<span class="Constant">           psrp_chbrk_handler(c_client,PSRP_CLIENT_TERMINATED);</span>
<span class="Constant">     }</span>

<span class="Constant">     if(access(channel_name_in,F_OK | R_OK | W_OK)  == (-1))</span>
<span class="Constant">     {  (void)mkfifo(channel_name_in,0600);</span>
<span class="Constant">        psrp_chbrk_handler(idum,PSRP_IPC_LOST);</span>
<span class="Constant">     } </span>

<span class="Constant">     if(access(channel_name_out,F_OK | R_OK | W_OK) == (-1))</span>
<span class="Constant">     {  (void)mkfifo(channel_name_out,0600);</span>
<span class="Constant">        psrp_chbrk_handler(idum,PSRP_OPC_LOST);</span>
<span class="Constant">     } </span>

<span class="Constant">     (void)pups_sigvector(SIGALRM,(sigjmp_buf *)NULL);</span>
<span class="Constant">}</span>




<span class="Constant">/*------------*/</span>
<span class="Constant">/* Empty FIFO */</span>
<span class="Constant">/*------------*/</span>

<span class="Constant">_PUBLIC void empty_fifo(const int fdes)</span>

<span class="Constant">{   long int bytes_out;</span>
<span class="Constant">    _BYTE    ch_buf[512] = &quot;&quot;;</span>


<span class="Constant">return;</span>

<span class="Constant">    /*----------------------------------*/</span>
<span class="Constant">    /* Only the root thread can process */</span>
<span class="Constant">    /* PSRP requests                    */</span>
<span class="Constant">    /*----------------------------------*/</span>

<span class="Constant">    if(pupsthread_is_root_thread() == FALSE)</span>
<span class="Constant">       pups_error(&quot;</span>[empty_fifo] attempt by non root thread to perform PUPS/P3 PSRP operation<span class="Constant">&quot;);</span>

<span class="Constant">    if(fcntl(fdes,F_SETFL, fcntl(fdes,F_GETFL,0) | O_NONBLOCK) == (-1))</span>
<span class="Constant">    {  pups_set_errno(errno);</span>
<span class="Constant">       return;</span>
<span class="Constant">    }</span>

<span class="Constant">    do {    bytes_out  = (int)read(fdes,ch_buf,512);</span>

<span class="Constant">            #ifdef _PSRPLIB_DEBUG</span>
<span class="Constant">            (void)fprintf(stderr,&quot;</span>PSRPLIB fdes %d flushed (%d bytes out)\n<span class="Constant">&quot;,fdes,bytes_out);</span>
<span class="Constant">            (void)fflush(stderr);</span>
<span class="Constant">            #endif /* PSRPLIB_DEBUG */ </span>
<span class="Constant"> </span>
<span class="Constant">       } while(bytes_out &gt; 0);</span>

<span class="Constant">    (void)fcntl(fdes,F_SETFL, fcntl(fdes,F_GETFL,0) &amp; ~O_NONBLOCK);</span>
<span class="Constant">}</span>




<span class="Constant">/*----------------------------------------------*/</span>
<span class="Constant">/* Handler for unexpected PSRP channel timeouts */</span>
<span class="Constant">/*----------------------------------------------*/</span>

<span class="Constant">_PUBLIC int psrp_chbrk_handler(const unsigned int c_index, const int event)</span>

<span class="Constant">{   int  bytes_out,</span>
<span class="Constant">         fdes_out = (-1); </span>

<span class="Constant">    char channel_name[SSIZE] = &quot;&quot;;</span>

<span class="Constant">    (void)snprintf(channel_name,SSIZE,&quot;</span>%s#%s/psrp#%s#%d#%d<span class="Constant">&quot;,appl_name,appl_fifo_dir,appl_ch_name,appl_pid,getuid()); </span>
<span class="Constant">    if(appl_verbose == TRUE)</span>
<span class="Constant">    {  strdate(date);</span>

<span class="Constant">       switch(event)</span>
<span class="Constant">       {    case PSRP_CLIENT_TERMINATED:    if(strcmp(psrp_remote_hostpath[c_index],&quot;</span>notset<span class="Constant">&quot;) == 0)</span>
<span class="Constant">                                            {  if(psrp_transactions[c_index] == 0)</span>
<span class="Constant">                                                  (void)fprintf(stderr,</span>
<span class="Constant">                                                                &quot;</span>%s %s (%d@%s:%s): connection to client (%s) broken on channel \<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (0 client transactons)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                              date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_index],channel_name);
                                               <span class="Statement">else</span> <span class="Statement">if</span>(psrp_transactions[c_index] == <span class="Constant">1</span>)
                                                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                                                        <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): connection to client (</span><span class="Special">%s</span><span class="Constant">) broken on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (1 client transaction)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                      date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_index],channel_name);
                                               <span class="Statement">else</span>
                                                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                                                               <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): connection to client (</span><span class="Special">%s</span><span class="Constant">) broken on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant"> client transactions)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                               date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_index],channel_name,psrp_transactions[c_index]);
                                            }
                                            <span class="Statement">else</span>
                                            {  <span class="Statement">if</span>(psrp_transactions[c_index] == <span class="Constant">0</span>)
                                                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                                                                <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): connection to client (</span><span class="Special">%s</span><span class="Constant"> [via </span><span class="Special">%s</span><span class="Constant">]) on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> broken (0 client transactons)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_index],psrp_remote_hostpath[c_index],channel_name);
                                               <span class="Statement">else</span> <span class="Statement">if</span>(psrp_transactions[c_index] == <span class="Constant">1</span>)
                                                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                                                                 <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): connection to client (</span><span class="Special">%s</span><span class="Constant"> [via </span><span class="Special">%s</span><span class="Constant">]) on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> broken (1 client transaction)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                 date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_index],psrp_remote_hostpath[c_index],channel_name);
                                               <span class="Statement">else</span>
                                                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                                                                <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): connection to client (</span><span class="Special">%s</span><span class="Constant"> [via </span><span class="Special">%s</span><span class="Constant">]) on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> broken (</span><span class="Special">%d</span><span class="Constant"> client transactions)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_name[c_index],psrp_remote_hostpath[c_index],channel_name,psrp_transactions[c_index]);
                                            }

                                            <span class="Statement">if</span>(c_index == c_client)
                                            {

                                               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment"> If we have a channel exit function installed it must </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment"> be executed now                                      </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

                                               <span class="Statement">if</span>((<span class="Type">void</span> *)psrp_client_exitf[c_client] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                                               {  (<span class="Type">void</span>)(*psrp_client_exitf[c_client])(c_client);
                                                  psrp_client_exitf[c_client] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
                                                  (<span class="Type">void</span>)strlcpy(psrp_client_efname[c_client],<span class="Constant">&quot;&quot;</span>,SSIZE);
                                               }


                                               <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment"> Dispose of input FIFO contents </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

                                               <span class="Statement">if</span>(psrp_in != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
                                               {  (<span class="Type">void</span>)fflush(psrp_in);
                                                  empty_fifo(fileno(psrp_in));
                                                  psrp_in  = pups_fclose(psrp_in);
                                               }


                                               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment"> Dispose of output FIFO contents </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

                                               <span class="Statement">if</span>(psrp_out != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
                                               {  (<span class="Type">void</span>)fflush(psrp_out);
                                                  (<span class="Type">void</span>)empty_fifo(fileno(psrp_out));
                                                  psrp_out = pups_fclose(psrp_out);
                                               }

                                               <span class="Statement">if</span>(appl_verbose == TRUE)
                                               {  strdate(date);
                                                  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                                                  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): channel lock released (accepting new PSRP connections on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                       date,appl_name,appl_pid,appl_host,appl_owner,channel_name);
                                               }
                                            }
                                            <span class="Statement">break</span>;


            <span class="Statement">case</span> PSRP_IPC_LOST:             strdate(date);
                                            (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP input stream on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lost -- re-establishing</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                         date,appl_name,appl_pid,appl_host,appl_owner,channel_name);
                                            <span class="Statement">break</span>;


            <span class="Statement">case</span> PSRP_OPC_LOST:             strdate(date);
                                            (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP output stream on channel </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lost -- re-establishing</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                          date,appl_name,appl_pid,appl_host,appl_owner,channel_name);
                                            <span class="Statement">break</span>;

            <span class="Statement">default</span>:                        <span class="Statement">break</span>;
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Must remember to clear the clients slot </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(event == PSRP_CLIENT_TERMINATED)
    {  (<span class="Type">void</span>)psrp_clear_client_slot(c_index);

       <span class="Statement">if</span>(n_clients == <span class="Constant">0</span>)
          psrp_channel_open = FALSE;
    }

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB PSRP close DONE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only vector if broken client is active </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(c_client == c_index &amp;&amp;  in_psrp_handler == TRUE)
       (<span class="Type">void</span>)pups_sigvector(<span class="Constant">SIGALRM</span>, &amp;psrp_env);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Search object table for requested action and return its address </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> *psrp_find_action_object(<span class="Type">char</span> *fname)

{   <span class="Type">int</span>  i;
    <span class="Type">void</span> *ret = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_find_action_object] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(fname == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
       <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_isearch_tag_list(fname,i) &gt;= <span class="Constant">0</span>)
       {   <span class="Type">int</span> init,
               (*func)(<span class="Type">int</span>, <span class="Type">char</span> **);


           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Dispatch the requested action - note the actual form of the action is </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> determined by the actual type of object that we have.                 </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">switch</span>(psrp_object_list[i].object_type)
           {

               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Object is an excutable function </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">case</span> PSRP_STATIC_FUNCTION:
               <span class="Statement">case</span> PSRP_DYNAMIC_FUNCTION:  ret  = psrp_object_list[i].object_handle;
                                            <span class="Statement">break</span>;

               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Object is a PSRP data area (databag) </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">case</span> PSRP_STATIC_DATABAG:
               <span class="Statement">case</span> PSRP_DYNAMIC_DATABAG:   (<span class="Type">void</span>)fprintf(psrp_out, <span class="Constant">&quot;    object </span><span class="Special">%s</span><span class="Constant"> is a databag (and cannot be executed!)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                               psrp_object_list[i].object_tag);
                                            <span class="Statement">break</span>;


               <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Object is a persistent heap </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

               <span class="Statement">case</span> PSRP_PERSISTENT_HEAP:   (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    object </span><span class="Special">%s</span><span class="Constant"> is a persistent heap (and cannot be executed!)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                     psrp_object_list[i].object_tag);
                                            <span class="Statement">break</span>;

               <span class="Statement">default</span>:                     <span class="Statement">break</span>;
           }
       }

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Search object table for requested action </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN psrp_exec_action_object(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">int</span> *status, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i;

    _BOOLEAN ret = FALSE;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
       <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_isearch_tag_list(argv[<span class="Constant">0</span>],i) &gt;= <span class="Constant">0</span>)
       {   <span class="Type">int</span> init,
               (*func)(<span class="Type">int</span>, <span class="Type">char</span> **) = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Dispatch the requested action - note the actual form of the action is </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> determined by the actual type of object that we have.                 </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">switch</span>(psrp_object_list[i].object_type)
           {

               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Object is an excutable function </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">case</span> PSRP_STATIC_FUNCTION:
               <span class="Statement">case</span> PSRP_DYNAMIC_FUNCTION:  func    = psrp_object_list[i].object_handle;
                                            *status = (*func)(argc,(<span class="Type">char</span> **)argv);
                                            ret     = TRUE;
                                            <span class="Statement">break</span>;


               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Object is a PSRP data area (databag) </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">case</span> PSRP_STATIC_DATABAG:
               <span class="Statement">case</span> PSRP_DYNAMIC_DATABAG:   (<span class="Type">void</span>)fprintf(psrp_out,
                                            <span class="Constant">&quot;    object </span><span class="Special">%s</span><span class="Constant"> is a databag (and cannot be executed!)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                      psrp_object_list[i].object_tag);
                                            <span class="Statement">break</span>;


               <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Object is a persistent heap </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

               <span class="Statement">case</span> PSRP_PERSISTENT_HEAP:   (<span class="Type">void</span>)fprintf(psrp_out,
                                            <span class="Constant">&quot;    object </span><span class="Special">%s</span><span class="Constant"> is a persistent heap (and cannot be executed!)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                              psrp_object_list[i].object_tag);
                                            <span class="Statement">break</span>;

               <span class="Statement">default</span>:                     <span class="Statement">break</span>;
           }
       }

    <span class="Statement">return</span>(ret);
}




<span class="PreProc">#ifdef MAIL_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set type for part(s) of MIME message to be saved </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_mime_type(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   _BOOLEAN default_mime_type = FALSE;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;mtype&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {   <span class="Statement">if</span>(strcmp(appl_mime_type,<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)
           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">all parts of MIME messages currently saved [default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">parts of type </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> of MIME messages currently saved</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_mime_type);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage mtype [help | usage] [&lt;MIME part type&gt; | default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)strlcpy(appl_mime_type,<span class="Constant">&quot;all&quot;</span>,SSIZE);
       default_mime_type = TRUE;
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;all&quot;</span>)         == <span class="Constant">0</span>    ||
          strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;text&quot;</span>)        == <span class="Constant">0</span>    ||
          strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;multipart&quot;</span>)   == <span class="Constant">0</span>    ||
          strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;application&quot;</span>) == <span class="Constant">0</span>    ||
          strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;image&quot;</span>)       == <span class="Constant">0</span>    ||
          strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;audio&quot;</span>)       == <span class="Constant">0</span>    ||
          strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;video&quot;</span>)       == <span class="Constant">0</span>     )
          (<span class="Type">void</span>)strlcpy(appl_mime_type,argv[<span class="Constant">1</span>],SSIZE);
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">incorrect mime type </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> specified</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
    }

    <span class="Statement">if</span>(default_mime_type == TRUE)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">set mime type (save) to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_mime_type);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">set mime type (save) to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_mime_type);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(default_mime_type == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): set mime type (save) to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                       date,appl_name,appl_pid,appl_host,appl_owner,appl_mime_type);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): set mime type (save) to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                       date,appl_name,appl_pid,appl_host,appl_owner,appl_mime_type);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send PSRP requests (originated from the MIME mail interface) to the </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PSRP request parser                                                 </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_parse_requests(<span class="Type">char</span> *requests)

{   <span class="Type">char</span> next_request[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">while</span>(strext(<span class="Constant">' '</span>,next_request,requests) != END_STRING)
         psrp_parse_request(next_request,MAIL_FACE);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to duplicate a PSRP process - this give the user their own private </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> copy of the PSRP process which they can subsequently modify                </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_new_instance(<span class="Type">const</span> _BOOLEAN t_c_instance, <span class="Type">const</span> <span class="Type">char</span> *instance_name, <span class="Type">const</span> <span class="Type">char</span> *host_name)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_new_instance] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(instance_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): rcCreating a new instance of PSRP server</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                               date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create new instance of this process. The existing PSRP process   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is forked, so the new instance initially has the same context as </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> as its parent                                                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Statement">if</span>(psrp_new_segment(instance_name,host_name,ssh_remote_port,(<span class="Type">char</span> *)<span class="Constant">NULL</span>) == (-<span class="Constant">1</span>))
<span class="PreProc">    #else</span>
    <span class="Statement">if</span>(psrp_new_segment(instance_name,host_name,(<span class="Type">char</span> *)<span class="Constant">NULL</span>) == (-<span class="Constant">1</span>))
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to create new instance </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                              date,appl_name,appl_pid,appl_host,appl_owner,instance_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       <span class="Statement">return</span>(PSRP_ERROR);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): new instance </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> created</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner,instance_name);

        <span class="Statement">if</span>(t_c_instance == TRUE)
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): initial instance terminated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                      date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    psrp_child_instance = TRUE;
    ++psrp_instances;

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Parse PSRP request (taking account of the interface which has generated </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> the request)                                                            </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Argument vector decode workspace pointer array </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">char</span> *r_argv[SSIZE] = { [<span class="Constant">0</span> ... <span class="Constant">255</span>] = (<span class="Type">char</span> *)<span class="Constant">NULL</span> };

_PRIVATE <span class="Type">int</span> psrp_parse_request(<span class="Type">char</span> *request, <span class="Type">int</span> interface)

{   <span class="Type">int</span> r_argc,
        status;

    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Transform request to a vector of arguments. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    psrp_argvec(&amp;r_argc,request);

    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> The only builtins are detach which removes dynamic entries from the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP handler dispatch table and show which shows the functions      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> currently loaded in the PSRP handler dispatch table.                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PSRP_AUTHENTICATE</span>
    <span class="Comment">/*</span><span class="Comment"> Change (secure) server authentication token </span><span class="Comment">*/</span>
    <span class="Statement">if</span>(psrp_builtin_set_secure(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set quantum for PSRP handler. The smaller the quantum, the better </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the response time, but the greater the system loading.            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_vitimer_quantum(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show host information </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_hinfo(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


<span class="PreProc">    #ifdef BUBBLE_MEMORY_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set/show memory bubble utilisation threshold </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_mbubble_utilisation_threshold(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show malloc statistics </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_malloc_stats(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef CRIU_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enable/disable (Criu) state saving </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_ssave(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set PSRP server stdio detach on background state </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_nodetach(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set PSRP servers system context migration status </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_rooted(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset PSRP servers system context migration status </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_unrooted(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set PSRP servers (effective) parent </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_parent(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set PSRP servers (effective) parent exit status </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_pexit(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set PSRP servers current working directory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_cwd(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set number of times an operation will be retried (before aborting it) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_trys(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Protect a file or files </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_file_live(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unprotect a file or files </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_file_dead(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show resource usage for this server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_rusage(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set resource usage for this server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_set_rlimit(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Toggle server transaction logging on/off </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_appl_verbose(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Toggle server side error handling on/off </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_error_handling(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Builtin to toggle PSRP status logging </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_transactions(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-=---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Add a scheduling slot to this servers crontab </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-=---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_crontab_schedule(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove a schedulign slot from this servers crontab </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_crontab_unschedule(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show crontab </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_crontab(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;

    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Delete action function bound to PSRP handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_detach_object(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set automatic dispatch table save status </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_autosave_dispatch_table(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Load a new dispatch table. If the new dispatch table contains </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP objects with the same name(s) as existing objects, the   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> new objects will overwrite the old                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_load_dispatch_table(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save current dispatch table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_save_dispatch_table(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show client current PSRP action bindings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_psrp_state(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset dispatch table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_reset_dispatch_table(r_argc,(<span class="Type">char</span> **)r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell client process the type of PSRP object bindings permitted </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_psrp_bind_type(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display the builtin commands for this handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_help(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show concurrently held link file locks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_link_file_locks(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show (flock) locks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_flock_locks(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show non default signal handlers installed for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_sigstatus(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show signal mask/ signals pending for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_sigmaskstatus(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show streams/file descriptors opened by this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_open_fdescriptors(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show (active) children of this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_children(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show mapped (fast) caches </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_caches(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


<span class="PreProc">    #ifdef DLL_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show orifices which are bound to this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_attached_orifices(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef PTHREAD_SUPPORT </span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show all threads running in this PSRP server instance </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_threads(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Launch a new thread of execution (bound to named function) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_launch_thread(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Terminate a thread of execution </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_kill_thread(r_argc,r_argv) == PSRP_OK)
      <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Pause thread of execution </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_pause_thread(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restart thread of execution </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_restart_thread(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show slaved interation client channels open </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_open_sics(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show entrance functions for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_pups_show_entrance_f(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show exit functions for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_pups_show_exit_f(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show abort functions for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_pups_show_abort_f(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show status entry in /proc filesystem for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_procstatus(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show clients connected to this server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_clients(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show status of virtual interval timers associated with this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_pups_show_vitimers(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Alias an attached function of the handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_alias(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unalias an attached function of the handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_unalias(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show the aliases of an attached function of the handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_showaliases(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend child table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_extend_chtab(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend virtual timer table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_extend_vitab(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend file table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_extend_ftab(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend persistent heap table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_PERSISTENT_HEAP &amp;&amp; psrp_builtin_extend_htab(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef DLL_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extend (DLL) orifice table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_FUNCTION &amp;&amp;  psrp_builtin_extend_ortab(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Produce new instance of current process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_new_instance(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Overlay the current process with new command </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_overlay_server_process(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Overfork the current process with new command </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_overfork_server_process(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


<span class="PreProc">    #ifdef DLL_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Attach a dynamic function to PSRP dispatch handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_attach_dynamic_function(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Attach a dynamic databag to PSRP dispatch handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_attach_dbag(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Attach a persistent heap to PSRP dispatch handler </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_attach_persistent_heap(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show persistent heaps mapped into process address space </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_persistent_heaps(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show tracked heap objects on local heap </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_show_htobjects(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Client termination of server process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_terminate_process(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set ssh compression mode </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_ssh_compress(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set remote ssh port </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_builtin_ssh_port(r_argc,r_argv) == PSRP_OK)
       <span class="Statement">goto</span> object_dispatched;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Search list of user defined action functions bound to current process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Statement">re_dispatch</span>:


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Process next PSRP command </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_exec_action_object(r_argc,&amp;status,r_argv) == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Command error                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Non zero return code indicates error </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(status &lt; <span class="Constant">0</span>  &amp;&amp; psrp_error_handling == TRUE)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Command returned error (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,r_argv[<span class="Constant">0</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;err&quot;</span>,SSIZE);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  strdate(date);

            (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> error (dispatch failure)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                date,
                                                                                                           appl_name,
                                                                                                            appl_pid,
                                                                                                           appl_host,
                                                                                                          appl_owner,
                                                                                               PSRP_PROTOCOL_VERSION,
                                                                                                             request);
            (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          <span class="Statement">goto</span> object_dispatched;
       }


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> PSRP command ok </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
          <span class="Statement">goto</span> object_dispatched;
    }


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Command not found </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Illegal command [</span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,r_argv[<span class="Constant">0</span>]);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;illcerr&quot;</span>,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> not recognised (dispatch failure)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                    date,
                                                                                                               appl_name,
                                                                                                                appl_pid,
                                                                                                               appl_host,
                                                                                                              appl_owner,
                                                                                                   PSRP_PROTOCOL_VERSION,
                                                                                                                 request);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> dispatch failure (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                    PSRP_PROTOCOL_VERSION,request,appl_pid,appl_host);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

<span class="Statement">object_dispatched</span>:

    <span class="Statement">if</span>(interface == PSRP_FACE)
    {

       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell client that the request has been processed and reset the handler </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> for future PSRP requests.                                             </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If PSRP service function has not returned its own error code </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> simply return &quot;ok&quot;                                           </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strncmp(psrp_c_code,<span class="Constant">&quot;none&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)strlcpy(psrp_c_code,<span class="Constant">&quot;ok&quot;</span>,SSIZE);


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell client this request is now processed and return </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> its exit code                                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;EOT </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_c_code);
       (<span class="Type">void</span>)fflush(psrp_out);


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell client that we have finished processing SIGPSRP </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       psrp_endop(<span class="Constant">&quot;psrp&quot;</span>);
    }
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PSRP hander routine - handles process status request protocol </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> [PSRP] interrupts                                             </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_handler(<span class="Type">int</span> signum)

{   <span class="Type">int</span> i,
        idum,
        r_argc,
        status;

    <span class="Type">char</span> request[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         get_object_command[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         psrp_channel_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         request_str[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         psrp_ckpt_status[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

    sigset_t set;


<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB IN PSRP HANDLER</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sometimes, because of latency, we can get a SIGPSRP </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> raised in psrp_new_segment - this is spurious and   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> must not be processed                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_psrp_new_segment == TRUE)
       <span class="Statement">return</span>(<span class="Constant">0</span>);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB SIGPSRP</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Environment restore if SIGABRT recieved by process. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    ++psrp_transactions[c_client];

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB CCLIENT:</span><span class="Special">%d</span><span class="Constant">, CNT:</span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,c_client,psrp_transactions[c_client]);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(sigsetjmp(psrp_env,<span class="Constant">1</span>) &gt; <span class="Constant">0</span>)
    {

<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB SIGPSRP3 (ABORT)\n<span class="Constant">&quot;);</span>
<span class="Constant">       (void)fflush(stderr);</span>
<span class="Constant">       #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">       if(psrp_current_sic != (psrp_channel_type *)NULL)</span>
<span class="Constant">       {  psrp_destroy_slaved_interaction_client(psrp_current_sic,TRUE);</span>
<span class="Constant">          psrp_unset_current_sic();</span>
<span class="Constant">       }</span>


<span class="Constant">       /*-----------------------*/</span>
<span class="Constant">       /* Close PSRP connection */</span>
<span class="Constant">       /*-----------------------*/</span>

<span class="Constant">       if(psrp_in != (FILE *)NULL)</span>
<span class="Constant">       {  empty_fifo(fileno(psrp_in));</span>
<span class="Constant">          psrp_in  = pups_fclose(psrp_in);</span>
<span class="Constant">       }</span>

<span class="Constant">       if(psrp_out != (FILE *)NULL)</span>
<span class="Constant">       {  empty_fifo(fileno(psrp_out));</span>
<span class="Constant">          psrp_out = pups_fclose(psrp_out);</span>
<span class="Constant">       }</span>

<span class="Constant">       in_psrp_handler     = FALSE;</span>


<span class="Constant">       /*--------------------------------------------------*/</span>
<span class="Constant">       /* Make sure that virtual timer system is restarted */</span>
<span class="Constant">       /* after PSRP request is aborted                    */</span>
<span class="Constant">       /*(void)pupsigrelse(SIGALRM);                       */</span>
<span class="Constant">       /*--------------------------------------------------*/</span>

<span class="Constant">       (void)pups_malarm(1);</span>

<span class="Constant">       #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">       (void)fprintf(stderr,&quot;</span>ABORT EXIT\n<span class="Constant">&quot;);</span>
<span class="Constant">       (void)fflush(stderr);</span>
<span class="Constant">       #endif /* PSRPLIB_DEBUG */</span>
<span class="Constant">  </span>
<span class="Constant">       return(0);</span>
<span class="Constant">    }</span>

<span class="Constant">    in_psrp_handler = TRUE;</span>
<span class="Constant">    (void)strlcpy(psrp_c_code,&quot;</span>none<span class="Constant">&quot;,SSIZE);</span>
<span class="Constant">    (void)sigemptyset(&amp;set);</span>
<span class="Constant">    (void)sigaddset(&amp;set,SIGABRT);</span>
<span class="Constant">    (void)pups_sigprocmask(SIG_UNBLOCK,&amp;set,(sigset_t *)NULL);</span>


<span class="Constant">    /*------------------------------------------------------------------------*/</span>
<span class="Constant">    /* Tell PSRP client that this process supports the PSRP protocol and will */</span>
<span class="Constant">    /* provide status information to the PSRP client.                         */</span>
<span class="Constant">    /*------------------------------------------------------------------------*/</span>

<span class="Constant">    #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">    (void)fprintf(stderr,&quot;&quot;PSRPLIB SIGPSRP2</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    (<span class="Type">void</span>)snprintf(psrp_channel_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_name,appl_pid,getuid());
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;(</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_channel_name);
    (<span class="Type">void</span>)fflush(psrp_out);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read request string from client - this is used by the client to tell  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the handler which PSRP action function it wishes to be dispatched on  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> its behalf.                                                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)efgets(request,SSIZE,psrp_in);
    (<span class="Type">void</span>)strlcpy(request_str,request,SSIZE);
    request_str[pups_strlen(request_str) - <span class="Constant">2</span>] = <span class="Special">'\0'</span>;


<span class="PreProc">    #ifdef PSRP_AUTHENTICATE</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Authenticate from psrp_passwd here if secure </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_secure == TRUE &amp;&amp; pups_check_appl_password(psrp_password) == FALSE)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Secure server authentication failure (PSRP connection closed)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          <span class="Statement">if</span>(strcmp(psrp_remote_hostpath[c_client],<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): secure server authentication failure [client </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@localhost)]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                   date,
                                                                                                              appl_name,
                                                                                                               appl_pid,
                                                                                                              appl_host,
                                                                                                             appl_owner,
                                                                                             psrp_client_name[c_client],
                                                                                              psrp_client_pid[c_client]);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): secure server authentication failure [client </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                            date,
                                                                                                       appl_name,
                                                                                                        appl_pid,
                                                                                                       appl_host,
                                                                                                      appl_owner,
                                                                                      psrp_client_name[c_client],
                                                                                       psrp_client_pid[c_client],
                                                                                  psrp_remote_hostpath[c_client]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell client this request is now processed and return </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> its exit code                                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;EOT safail</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell client that we have finished processing SIGPSRP </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       psrp_endop(<span class="Constant">&quot;psrp&quot;</span>);

       psrp_in  = pups_fclose(psrp_in);
       psrp_out = pups_fclose(psrp_out);

       in_psrp_handler = FALSE;
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>


    <span class="Statement">if</span>(psrp_log[c_client] == TRUE &amp;&amp; strncmp(request_str,<span class="Constant">&quot;secure&quot;</span>,<span class="Constant">6</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(strcmp(psrp_remote_hostpath[c_client],<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,
                         <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> received by </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">) from </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                          PSRP_PROTOCOL_VERSION,
                                                                                          request_str,appl_name,
                                                                                  appl_pid,appl_host,appl_owner,
                                                                                     psrp_client_name[c_client],
                                                                                      psrp_client_pid[c_client],
                                                                                     psrp_client_host[c_client]);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)fprintf(psrp_out,
                          <span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> received by </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">) from </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [from </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                                     PSRP_PROTOCOL_VERSION,
                                                                                                     request_str,appl_name,
                                                                                             appl_pid,appl_host,appl_owner,
                                                                                                psrp_client_name[c_client],
                                                                                                 psrp_client_pid[c_client],
                                                                                                psrp_client_host[c_client],
                                                                                            psrp_remote_hostpath[c_client]);
        (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; strncmp(request_str,<span class="Constant">&quot;secure&quot;</span>,<span class="Constant">6</span>) != <span class="Constant">0</span>)
    {  strdate(date);

       <span class="Statement">if</span>(strcmp(request_str,old_request_str[c_client]) != <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(req_r_cnt[c_client] &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) last request repeated </span><span class="Special">%d</span><span class="Constant"> times</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                        date,
                                                                                                   appl_name,
                                                                                                    appl_pid,
                                                                                                   appl_host,
                                                                                                  appl_owner,
                                                                                       PSRP_PROTOCOL_VERSION,
                                                                                     req_r_cnt[c_client] + <span class="Constant">1</span>);

          <span class="Statement">if</span>(strcmp(psrp_remote_hostpath[c_client],<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> received from </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                 date,
                                                                                                            appl_name,
                                                                                                             appl_pid,
                                                                                                            appl_host,
                                                                                                           appl_owner,
                                                                                                PSRP_PROTOCOL_VERSION,
                                                                                                          request_str,
                                                                                           psrp_client_name[c_client],
                                                                                            psrp_client_pid[c_client],
                                                                                           psrp_client_host[c_client]);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) request </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> received from </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) [from </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                           date,
                                                                                                                      appl_name,
                                                                                                                       appl_pid,
                                                                                                                      appl_host,
                                                                                                                     appl_owner,
                                                                                                          PSRP_PROTOCOL_VERSION,
                                                                                                                    request_str,
                                                                                                     psrp_client_name[c_client],
                                                                                                      psrp_client_pid[c_client],
                                                                                                     psrp_client_host[c_client],
                                                                                                 psrp_remote_hostpath[c_client]);
          req_r_cnt[c_client] = <span class="Constant">0</span>;
       }
       <span class="Statement">else</span>
          ++req_r_cnt[c_client];

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       (<span class="Type">void</span>)strlcpy(old_request_str[c_client],request_str,SSIZE);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parse PSRP request (noting request has been originated by a client talking </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP protocols).                                                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

    psrp_parse_request(request_str,PSRP_FACE);

    psrp_in  = pups_fclose(psrp_in);
    psrp_out = pups_fclose(psrp_out);

    in_psrp_handler = FALSE;

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Save dispatch table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_save_dispatch_table(<span class="Type">const</span> <span class="Type">char</span> *autoload_file_name)

{   <span class="Type">int</span> i,
        j,
        objects = <span class="Constant">0</span>;

    <span class="Type">FILE</span> *autoload_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_save_dispatch_table] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(autoload_file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Statement">if</span>(autoload_file_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(access(autoload_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_creat(autoload_file_name,<span class="PreProc">0</span><span class="Constant">644</span>);
       <span class="Statement">if</span>((autoload_stream = fopen(autoload_file_name,<span class="Constant">&quot;w&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">EIO</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((autoload_stream = fopen(autoload_file_name,<span class="Constant">&quot;w+&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">EPERM</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We need to lock the dispatch table file as multiple processes </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> could be accessing the same file                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_get_link_file_lock(WAIT_FOREVER,autoload_file_name);

    <span class="Statement">if</span>(psrp_object_list_size == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fclose(autoload_stream);
       (<span class="Type">void</span>)unlink(autoload_file_name);
       (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);

       pups_set_errno(OK);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get the number of valid objects (e.g. dispatch </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> table slots which are both allocated and used) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_object_list[i].aliases &gt; <span class="Constant">0</span>)
          ++objects;
    }

    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;#-------------------------------------------------------------------</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;#    PSRP dispatch table resource file version 1.0                  </span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;#    (C) M.A. O'Neill, Tumbling Dice, Gosforth, 2022                </span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;#-------------------------------------------------------------------</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;# Number of dispatch table objects saved</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,objects);
    (<span class="Type">void</span>)fflush(autoload_stream);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save objects in PSRP dispatch table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {   <span class="Statement">if</span>(psrp_object_list[i].aliases &gt; <span class="Constant">0</span>)
        {  (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">#-------------------------------------------------------------------</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;#    PSRP (root tag) object: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_object_list[i].object_tag[<span class="Constant">0</span>]);
           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;#-------------------------------------------------------------------</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;# object type</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fflush(autoload_stream);

           <span class="Statement">if</span>(psrp_object_list[i].object_type == PSRP_DYNAMIC_FUNCTION)
              (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;dynamic_function</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

           <span class="Statement">if</span>(psrp_object_list[i].object_type == PSRP_STATIC_FUNCTION)
              (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;static_function</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

           <span class="Statement">if</span>(psrp_object_list[i].object_type == PSRP_DYNAMIC_DATABAG)
              (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;dynamic_databag</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

           <span class="Statement">if</span>(psrp_object_list[i].object_type == PSRP_STATIC_DATABAG)
           {  <span class="Type">int</span> slot_index;

              slot_index = pups_fname2index(psrp_object_list[i].object_f_name);
              <span class="Statement">if</span>(ftab[slot_index].homeostatic == <span class="Constant">1</span>)
                 (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;static_databag LIVE</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
              <span class="Statement">else</span>
                 (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;static_databag DEAD</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
           }

<span class="PreProc">           #ifdef HAVE_DLL_SUPPORT </span>
           <span class="Statement">if</span>(psrp_object_list[i].object_type == PSRP_PERSISTENT_HEAP)
           {  <span class="Type">int</span> f_index;


              <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Get index into PUPS file table </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

              f_index = pups_fname2index(psrp_object_list[i].object_f_name);

              <span class="Statement">if</span>(ftab[f_index].homeostatic == <span class="Constant">1</span>)
                 (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;dynamic function LIVEn</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
              <span class="Statement">else</span>
                 (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;dynamic function</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
           }
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> HAVE_DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">           #ifdef PERSISTENT_HEAP_SUPPORT</span>
           <span class="Statement">if</span>(psrp_object_list[i].object_type == PSRP_PERSISTENT_HEAP)
           {  <span class="Type">int</span> hdes,
		  f_index;


              <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
	      <span class="Comment">/*</span><span class="Comment"> Get index into PUPS file table </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

              f_index = pups_fname2index(psrp_object_list[i].object_f_name);


              <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
	      <span class="Comment">/*</span><span class="Comment"> Get mapping mode for this persistent heap </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(ftab[f_index].homeostatic == <span class="Constant">1</span>)
                 (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;persistent_heap LIVE</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
              <span class="Statement">else</span>
                 (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;persistent_heap DEAD</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
           }
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;# File where object is located</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

           <span class="Statement">if</span>(psrp_object_list[i].object_f_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
           {  (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_object_list[i].object_f_name);
              (<span class="Type">void</span>)fflush(autoload_stream);
           }
           <span class="Statement">else</span>
           {  (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;none</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
              (<span class="Type">void</span>)fflush(autoload_stream);
           }

           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;# Object alias(es)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fflush(autoload_stream);
           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,psrp_object_list[i].aliases);

           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;# Object root tag&quot;</span>);
           <span class="Statement">if</span>(psrp_object_list[i].aliases &gt; <span class="Constant">1</span>)
              (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot; and alias list</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
           <span class="Statement">else</span>
              (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> &quot;</span>,psrp_object_list[i].object_tag[<span class="Constant">0</span>]);
           (<span class="Type">void</span>)fflush(autoload_stream);

           <span class="Statement">if</span>(psrp_object_list[i].aliases &gt; <span class="Constant">1</span>)
           {  <span class="Statement">for</span>(j=<span class="Constant">1</span>; j&lt;psrp_object_list[i].aliases_allocated; ++j)
                 <span class="Statement">if</span>(psrp_object_list[i].object_tag[j] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                    (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> &quot;</span>,psrp_object_list[i].object_tag[j]);
           }

           (<span class="Type">void</span>)fprintf(autoload_stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fflush(autoload_stream);
        }
    }

    (<span class="Type">void</span>)fclose(autoload_stream);
    (<span class="Type">void</span>)pups_release_link_file_lock(autoload_file_name);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): dispatch table saved (to PSRP resource file </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                  date,appl_name,appl_pid,appl_host,appl_owner,autoload_file_name);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove communication channel when process exits </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_exit(<span class="Type">void</span>)

{   <span class="Type">int</span> i,
        j;

    <span class="Type">char</span> autoload_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_exit] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(appl_psrp_save == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Save the names of those objects which are to be automatically </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> loaded at the next invocation of this server                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(getuid() != <span class="Constant">0</span>)
          (<span class="Type">void</span>)snprintf(autoload_file_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.</span><span class="Special">%s</span><span class="Constant">.psrp&quot;</span>,appl_home,appl_name);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(autoload_file_name,SSIZE,<span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">.psrp&quot;</span>,appl_name);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): saving PSRP dispatch table (to [default] PSRP resource file </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner,autoload_file_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       psrp_save_dispatch_table(autoload_file_name);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Delete communication channel </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)unlink(channel_name_in);
    (<span class="Type">void</span>)unlink(channel_name_out);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Release memory allocated to PSRP server process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
       psrp_destroy_object(i);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get PSRP dispatch table entry by name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> lookup_psrp_object_by_name(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[lookup_psrp_object_by_name] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_isearch_tag_list(name,i) &gt;= <span class="Constant">0</span>)
       {  pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get PSRP dispatch table entry by handle </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> lookup_psrp_object_by_handle(<span class="Type">const</span> <span class="Type">void</span> *object_handle)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[lookup_psrp_object_by_handle] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(object_handle == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
       <span class="Statement">if</span>(psrp_object_list[i].object_handle == object_handle)
       {  pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get PSRP object handle from name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *psrp_get_handle_from_name(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> d_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_handle_from_name] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((d_index = lookup_psrp_object_by_name(name)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(psrp_object_list[d_index].object_handle);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">Get PSRP object name from handle </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_get_name_from_handle(<span class="Type">const</span> <span class="Type">void</span> *handle, <span class="Type">char</span> *name)

{   <span class="Type">int</span> d_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_name_from_handle] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(handle == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span> || name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((d_index = lookup_psrp_object_by_handle(handle)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    (<span class="Type">void</span>)strlcpy(name,psrp_object_list[d_index].object_handle,SSIZE);
    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get PSRP object type from name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_get_type_from_name(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> d_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_type_from_name] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((d_index = lookup_psrp_object_by_name(name)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(psrp_object_list[d_index].object_type);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get PSRP object type from handle </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_get_type_from_handle(<span class="Type">const</span> <span class="Type">void</span> *handle)

{   <span class="Type">int</span> d_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_type_from_handle] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(handle == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((d_index = lookup_psrp_object_by_handle(handle)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(psrp_object_list[d_index].object_type);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Parse PSRP dispatch request into UNIX command line format so that it can be further </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> processed by the comamnd line decoding utilities                                    </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_argvec(<span class="Type">int</span> *r_argc, <span class="Type">char</span> *request)

{   <span class="Type">int</span>  i,
         ret;

    <span class="Type">char</span> next_arg[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _IMMORTAL _BOOLEAN entered = FALSE;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">256</span>; ++i)
    {  <span class="Statement">if</span>(entered == FALSE)
          r_argv[i] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(r_argv[i],<span class="Constant">&quot;&quot;</span>,SSIZE);
    }
    entered = TRUE;

    *r_argc = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset internal pointers in strext function </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strext(<span class="Constant">' '</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    <span class="Statement">do</span> {    ret = strext(<span class="Constant">' '</span>,next_arg,request);

            (<span class="Type">void</span>)strlcpy(r_argv[(*r_argc)],next_arg,SSIZE);
            ++(*r_argc);

            <span class="Statement">if</span>(*r_argc &gt; <span class="Constant">256</span>)
               pups_error(<span class="Constant">&quot;[psrp_argvec] too man arguments (max 256)&quot;</span>);

       } <span class="Statement">while</span>(ret == TRUE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Standard initialisation function for builtins </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_std_init(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        init,
        ptr;

    <span class="Type">char</span>                item[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    psrp_object_type *psrp_object;



    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_std_init] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(argv == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset argument decode status vector </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    t_args = argc;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> By the time we have got here we have implicitly decoded </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the first argument                                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    argd[<span class="Constant">0</span>] = TRUE;
    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;<span class="Constant">255</span>; ++i)
       argd[i] = FALSE;

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PSRP argument decode checking function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_t_arg_errs(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> _BOOLEAN argd[], <span class="Type">const</span> <span class="Type">char</span> *args[])

{   <span class="Type">int</span>      i;
    _BOOLEAN parse_failed = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_t_arg_errs] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(argd == (_BOOLEAN *)<span class="Constant">NULL</span> || args == (<span class="Type">char</span> **)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;t_args; ++i)
    {   <span class="Statement">if</span>(argd[i] == FALSE)
        {  <span class="Statement">if</span>(parse_failed == FALSE)
           {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
              parse_failed = TRUE;
           }

           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;psrp_t_arg_errs: failed to parse: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,args[i]);
           (<span class="Type">void</span>)fflush(psrp_out);
        }
    }

    pups_set_errno(OK);
    <span class="Statement">if</span>(parse_failed == TRUE)
       <span class="Statement">return</span>(FALSE);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Switch error logging on or off from PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_appl_verbose(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;appl_verbose&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: appl_verbose [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server transaction/error logging enabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       appl_verbose = TRUE;
       <span class="Statement">return</span>(PSRP_OK);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server transaction/error logging disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          appl_verbose = FALSE;
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: appl_verbose [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
       }

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Switch error handling on or off from PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_error_handling(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;error_handling&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: error_handling [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server error handling enabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       psrp_error_handling = TRUE;
       <span class="Statement">return</span>(PSRP_OK);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">error handling disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          psrp_error_handling = FALSE;
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: error_handling [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
       }

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}



<span class="PreProc">#ifdef SSH_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set ssh compression mode for PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_ssh_compress(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;compress&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: compress [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server ssh compression enabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       ssh_compression = TRUE;
       <span class="Statement">return</span>(PSRP_OK);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server ssh compression disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ssh_compression = FALSE;
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: compress  [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
       }

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set ssh remote host port for PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_ssh_port(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> port_id[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;port&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: port &lt;port number | default&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">0</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;port_id) != <span class="Constant">1</span> || port_id &lt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(strcmp(port_id,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)


          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> ssh is using default port </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(ssh_remote_port,<span class="Constant">&quot;&quot;</span>,SSIZE);
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> ssh is using user defined port. This is useful </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> when the remote psrp server is running is a    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> container                                      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;remote ssh port must be an (&gt;= 0)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(ssh_remote_port,port_id,SSIZE);

    <span class="Statement">if</span>(strcmp(port_id,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;using default port (22) for ssh</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;using (remote) port (</span><span class="Special">%s</span><span class="Constant">) for ssh</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ssh_remote_port);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Switch error logging on or off from PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_transactions(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;log&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: transactions [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server transaction logging enabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       psrp_log[c_client] = TRUE;
       <span class="Statement">return</span>(PSRP_OK);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">server transaction logging disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          psrp_log[c_client] = FALSE;
          <span class="Statement">return</span>(PSRP_OK);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: transactions [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
    }

    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}





<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Load new dispatch table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_autosave_dispatch_table(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  init,
         ptr,
         ret_code;

    <span class="Type">char</span> item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;autosave&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
        <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: autosave [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc &gt; <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
          appl_psrp_save = TRUE;
       <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
          appl_psrp_save = FALSE;
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;   </span><span class="Special">\n</span><span class="Constant">usage: autosave [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
    }

    <span class="Statement">if</span>(appl_psrp_save == TRUE)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">   Dispatch table automatically saved when application exits (to ~/.</span><span class="Special">%s</span><span class="Constant">.psrp)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                                         appl_name);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">   Dispatch table is not automatically saved when application exits</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);

}




<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Load new dispatch table  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_load_dispatch_table(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  init,
         ptr,
         ret_code;

    <span class="Type">char</span> item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;load&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: load &lt;PSRP resource file name&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)psrp_load_dispatch_table(TRUE,argv[<span class="Constant">1</span>]);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP resource file </span><span class="Special">%s</span><span class="Constant"> loaded (commands appended to existing dispatch table)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);

}



<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Save dispatch table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_save_dispatch_table(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  init,
         ptr,
         ret_code;

    <span class="Type">char</span> item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;save&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: save &lt;PSRP resource file name&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)psrp_save_dispatch_table(argv[<span class="Constant">1</span>]);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP resource file </span><span class="Special">%s</span><span class="Constant"> saved (contains all current dispatch table objects)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);

}




<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Reset dispatch table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_reset_dispatch_table(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  init,
         ptr,
         ret_code;

    <span class="Type">char</span> item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;reset&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    (<span class="Type">void</span>)psrp_reset_dispatch_table();

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">dispatch table reset to default state (static aliases deleted and dynamic objects detached)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function detach </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_detach_object(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  i,
         ret_code;

    <span class="Type">char</span> item[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;detach&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span>)
    {  psrp_error(<span class="Constant">&quot;Usage: detach &lt;object-list&gt;&quot;</span>);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
    {

        <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> If object is &quot;all&quot; then detach all dynamic objects and re-set </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> alias list of all static objects                              </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;all&quot;</span>) == <span class="Constant">0</span>)
        {  psrp_reset_dispatch_table();

           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">all objects detached</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fflush(psrp_out);

           <span class="Statement">return</span>(PSRP_OK);
        }

        ret_code = psrp_detach_object_by_name(argv[i]);

        <span class="Statement">switch</span>(ret_code)
        {   <span class="Statement">case</span> PSRP_DISPATCH_ERROR:    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">dynamic object not in PSRP handler dispatch_list (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
                                         <span class="Statement">break</span>;

            <span class="Statement">case</span> PSRP_DYNAMIC_FUNCTION:  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">dynamic function detached (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
                                         <span class="Statement">break</span>;

            <span class="Statement">case</span> PSRP_DYNAMIC_DATABAG:   (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">dynamic databag detached (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
                                         <span class="Statement">break</span>;

            <span class="Statement">case</span> PSRP_PERSISTENT_HEAP:   (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">persistent heap detached (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
                                         <span class="Statement">break</span>;

            <span class="Statement">default</span>:                     (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">dynamic object detached (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
                                         <span class="Statement">break</span>;
        }
        (<span class="Type">void</span>)fflush(psrp_out);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to display current PSRP bindings </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_hinfo(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> machtype[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         ostype[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         hosttype[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;hinfo&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up command tail decoder for this object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_std_init(argc,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that there is no junk left on the command line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_t_arg_errs(argc,argd,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show client current PSRP action bindings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(getenv(<span class="Constant">&quot;MACHTYPE&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; getenv(<span class="Constant">&quot;OSTYPE&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; getenv(<span class="Constant">&quot;HOSTTYPE&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)strlcpy(machtype,getenv(<span class="Constant">&quot;MACHTYPE&quot;</span>),SSIZE);
       (<span class="Type">void</span>)strlcpy(ostype,  getenv(<span class="Constant">&quot;OSTYPE&quot;</span>),SSIZE);
       (<span class="Type">void</span>)strlcpy(hosttype,getenv(<span class="Constant">&quot;HOSTTYPE&quot;</span>),SSIZE);

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> running on </span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,machtype,ostype,hosttype);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;using named pipes (FIFO) for PSRP channels</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Host information is not available</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to display current PSRP bindings </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_psrp_state(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;show&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up command tail decoder for this object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_std_init(argc,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that there is no junk left on the command line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_t_arg_errs(argc,argd,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show client current PSRP action bindings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    psrp_show_object_list();

    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to display current object binding types permitted on process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_psrp_bind_type(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;bindtype&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up command tail decoder for this object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_std_init(argc,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that there is no junk left on the command line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_t_arg_errs(argc,argd,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell client process the type of PSRP object bindings permitted </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    PSRP server interface (protocol </span><span class="Special">%5.2F</span><span class="Constant">) bind status</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,PSRP_PROTOCOL_VERSION);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_STATUS_ONLY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    PSRP interface supports status reporting only</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_STATIC_DATABAG)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Databags:  static binding enabled (cannot import databags)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_DATABAG)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Databags:  dynamic binding enabled (can import databags)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_STATIC_FUNCTION)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Functions: static binding enabled (cannot import DLL functions)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

       <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_PERSISTENT_HEAP)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Heaps: dynamic binding enabled (can import persistent heaps) [</span><span class="Special">%d</span><span class="Constant"> heap slots allocated]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_max_pheaps);

<span class="PreProc">       #ifdef DLL_SUPPORT</span>
       <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_FUNCTION)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Functions: dynamic binding enabled (can import DLL functions) [</span><span class="Special">%d</span><span class="Constant"> orifices allocated]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_max_orifices);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

    }

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_HOMEOSTATIC_STREAMS)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Streams: PSRP channels are hoemostatic</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)fflush(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to terminate PSRP server process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_terminate_process(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;terminate&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span> &amp;&amp; strcmp(<span class="Constant">&quot;kill&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up command tail decoder for this object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_std_init(argc,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that there is no junk left on the command line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_t_arg_errs(argc,argd,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Client termination of server process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">) terminated by PSRP client</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;CST</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Commit suicide explicitly to invoke handler - just in case we are a session leader </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)raise(<span class="Constant">SIGTERM</span>);

    pups_exit(<span class="Constant">255</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to add an alias the tag list of a PSRP object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_alias(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;alias&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">3</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>)
    {  psrp_error(<span class="Constant">&quot;usage: alias &lt;PSRP object name&gt; &lt;alias to PSRP object name&gt;&quot;</span>);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(psrp_alias(argv[<span class="Constant">1</span>],argv[<span class="Constant">2</span>]) == PSRP_DISPATCH_ERROR)
    {  <span class="Statement">if</span>(psrp_alias(argv[<span class="Constant">2</span>],argv[<span class="Constant">1</span>]) == PSRP_DISPATCH_ERROR)
       {  psrp_error(<span class="Constant">&quot;psrp_builtin_alias: problem with alias (builtin or not unique or not found)&quot;</span>);
          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now an alias of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>],argv[<span class="Constant">2</span>]);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now an alias of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">2</span>],argv[<span class="Constant">1</span>]);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to show clients attached to this server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_clients(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;clients&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">1</span> || strcmp(r_argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: clients [usage]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc != <span class="Constant">1</span>)
    {  psrp_error(<span class="Constant">&quot;usage: clients&quot;</span>);
       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)psrp_show_clients();
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to add an alias the tag list of a PSRP object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_unalias(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  ret;
    <span class="Type">char</span> basename[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unalias&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span> || strcmp(r_argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  psrp_error(<span class="Constant">&quot;usage: unalias &lt;PSRP object name alias&gt;&quot;</span>);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>((ret = psrp_unalias(argv[<span class="Constant">1</span>],basename)) == PSRP_TAG_ERROR)
       psrp_error(<span class="Constant">&quot;psrp_builtin_alias: alias cannot be removed (or object would become untagged)&quot;</span>);
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(ret == PSRP_DISPATCH_ERROR)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;psrp_builtin_alias: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not a tag name of any attached PSRP object</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is no longer an alias of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>],basename);
          (<span class="Type">void</span>)fflush(psrp_out);



       }
    }

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin function to show aliases of tag name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_showaliases(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;showaliases&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  psrp_error(<span class="Constant">&quot;usage: showaliases &lt;of PSRP object tagname&gt;&quot;</span>);
       <span class="Statement">return</span>(PSRP_OK);
    }

    psrp_show_aliases(argv[<span class="Constant">1</span>]);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Create a new instance of the current process - the old process is </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> terminated and a new instance of it is created - this permits the </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> user to modify the PSRP dispatch tables associated with a process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> without effecting the parent                                      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_new_instance(<span class="Type">const</span> <span class="Type">int</span> r_argc, <span class="Type">const</span> <span class="Type">char</span> *r_argv[])

{

    <span class="Type">int</span> ret;

    <span class="Type">char</span> n_i_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         n_i_host[SSIZE] = <span class="Constant">&quot;notset&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;new&quot;</span>,r_argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(r_argc &lt; <span class="Constant">2</span> || r_argc &gt; <span class="Constant">4</span> || strcmp(r_argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: new [keep | segment (current instance)] [&lt;new instance name&gt;] [&lt;exec host&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(r_argc == <span class="Constant">4</span> &amp;&amp; strcmp(r_argv[<span class="Constant">1</span>],<span class="Constant">&quot;segment&quot;</span>) == <span class="Constant">0</span> &amp;&amp; appl_rooted == TRUE)
    {  <span class="Type">char</span> rooted[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
            lyosome_command[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is rooted (system context cannot migrate to new host)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

       (<span class="Type">void</span>)snprintf(rooted,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%d</span><span class="Constant">.rooted&quot;</span>,appl_fifo_dir,appl_pid);
       (<span class="Type">void</span>)pups_creat(rooted,<span class="PreProc">0</span><span class="Constant">600</span>);

       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Start lyosome process which destroys trail file after delay </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> of 15 seconds - this should be long enough for clients to   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> attach to new instance                                      </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(lyosome_command,SSIZE,<span class="Constant">&quot;lyosome -lifetime 15 </span><span class="Special">%s</span><span class="Constant">&amp;&quot;</span>,rooted);
       (<span class="Type">void</span>)system(lyosome_command);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is the current instance to be kept? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(r_argv[<span class="Constant">1</span>],<span class="Constant">&quot;segment&quot;</span>) == <span class="Constant">0</span>)
       terminate_current_instance = TRUE;
    <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(r_argv[<span class="Constant">1</span>],<span class="Constant">&quot;fork&quot;</span>) == <span class="Constant">0</span>)
       terminate_current_instance = FALSE;
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: new [fork | segment (current instance)] [&lt;new instance name&gt; | default] [&lt;exec host&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get default name of the new instance </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(n_i_name,appl_name,SSIZE);
    (<span class="Type">void</span>)strlcpy(n_i_host,<span class="Constant">&quot;notset&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> New instance remote - if name is set to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> default it keeps the same name as the   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> current instance                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(r_argc == <span class="Constant">4</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get name of new instance </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> (if not defaulted)       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(r_argv[<span class="Constant">2</span>],<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)strlcpy(n_i_name,appl_name,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(n_i_name,r_argv[<span class="Constant">2</span>],SSIZE);


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We cannot have a duplicate instance with the same name </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> as our current server                                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(terminate_current_instance  == FALSE    &amp;&amp;
          strcmp(r_argv[<span class="Constant">2</span>],appl_name)   == <span class="Constant">0</span>      &amp;&amp;
          strcmp(r_argv[<span class="Constant">3</span>],<span class="Constant">&quot;localhost&quot;</span>) == <span class="Constant">0</span>       )
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot have duplicate local instance with same name (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Get name of remote host (if any) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(n_i_host,r_argv[<span class="Constant">3</span>],SSIZE);
       }

       <span class="Statement">if</span>(terminate_current_instance == TRUE)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">creating new [segmented] instance of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (on host </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                               appl_name,n_i_name,n_i_host);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">creating new instance of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (on host </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                   appl_name,n_i_name,n_i_host);

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;... waiting for </span><span class="Special">%d</span><span class="Constant"> seconds for remote instance to start</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,segmentation_delay);
       (<span class="Type">void</span>)fflush(psrp_out);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> New instance local with new name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(r_argc == <span class="Constant">3</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We cannot have a duplicate instance with the same name </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> as our current server                                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(terminate_current_instance  == FALSE    &amp;&amp;
          strcmp(r_argv[<span class="Constant">2</span>],appl_name) ==<span class="Constant">0</span>          )
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cannot have duplicate local instance with same name (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(n_i_name,r_argv[<span class="Constant">2</span>],SSIZE);

       <span class="Statement">if</span>(terminate_current_instance == TRUE)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">creating new [segmented] instance of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_name,n_i_name);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">creating new instance of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> as </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,appl_name,n_i_name);
       (<span class="Type">void</span>)fflush(psrp_out);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> New local instance with default name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {   <span class="Statement">if</span>(terminate_current_instance == TRUE)
           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">creating new [segmented] instance of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,appl_name);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">creating new instance of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,appl_name);
        (<span class="Type">void</span>)fflush(psrp_out);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start new instance </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(n_i_host,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
       ret = psrp_new_instance(terminate_current_instance,n_i_name,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    <span class="Statement">else</span>
       ret = psrp_new_instance(terminate_current_instance,n_i_name,n_i_host);


    <span class="Statement">if</span>(ret &lt; <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;failed to created new instance</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell client this request is now processed and return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> its exit code                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;EOT </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_c_code);
    (<span class="Type">void</span>)fflush(psrp_out);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell client that we have finished processing SIGPSRP </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    psrp_endop(<span class="Constant">&quot;psrp&quot;</span>);
    pups_sleep(<span class="Constant">1</span>);

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get state of the current object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_ostate(<span class="Type">const</span> <span class="Type">char</span> *object_tag)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
      pups_error(<span class="Constant">&quot;[psrp_ostate] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
       <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; psrp_isearch_tag_list(object_tag,i) &gt;= <span class="Constant">0</span>)
       {  pups_set_errno(OK);
          <span class="Statement">return</span>(psrp_object_list[i].object_state);
       }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Builtin help function (displays server builtin functions) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_help(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;shelp&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up command tail decoder for this object </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_std_init(argc,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that there is no junk left on the command line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_t_arg_errs(argc,argd,argv) == FALSE)
       <span class="Statement">return</span>(PSRP_OK);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display on line help for builtin commands </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    PSRP request handler version 2.16 (protocol </span><span class="Special">%5.2F</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,PSRP_PROTOCOL_VERSION);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    (C) M.A. O'Neill, Tumbling Dice, 1995-2022</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    Builtin commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    General P3 server control/status commands</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =========================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    log            [on | off]        :   switch server transaction logging on or off</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    verbose        [on | off]        :   switch server error logging on or off</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    errorhandling  [on | off]        :   toggle error handling on or off</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    hinfo                            :   display host information</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    show                             :   display PSRP handler status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    clients                          :   display clients connected to this server</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    bindtype                         :   display current object binding (static or dynamic)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    help                             :   display on line help information</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    strys                            :   set number of time PSRP server retrys operation (before aborting)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    nodetach       [on | off]        :   toggle stdio (when in background) on or off</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    cwd            &lt;path&gt;            :   set PSRP servers current working directory</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    rusage                           :   show current resource usage status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    rset                             :   set resource usage limits</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    pstat                            :   display /proc filesystem status entry</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    terminate | kill                 :   terminate (this) PSRP server process</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server virtual timer control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    quantum        [&lt;time&gt; | default]:   set PSRP (vitimer) quantum</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    vitstat                          :   display status of PUPS virtual interval timers</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    vitab          [&lt;n&gt; | shrink]    :   display [or set to &lt;n&gt; or Procrustes shrink] number of virtal timer table slots</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server child control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =========================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    cstat                            :   display active children`</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    htab          [&lt;n&gt; | shrink]    :   display [or set to &lt;n&gt; or Procrustes shrink] number of child table slots</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server command alias control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    showaliases    &lt;n&gt;               :   show aliases of PSRP object &lt;n&gt;                  </span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    alias          &lt;n&gt; &lt;a&gt;           :   alias &lt;n&gt; to &lt;a&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    unalias        &lt;a&gt;               :   remove alias &lt;a&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server entry/exit routine control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =====================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    atentrance                       :   display list of (PUPS) application entrance functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    atexit                           :   display list of (PUPS) application exit functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    atabort                          :   display list of (PUPS) application abort functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server ssh control functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ===============================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    compress                         :   toggle ssh compression mode</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    port           &lt;port number&gt;     :   set remote ssh port</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef MAIL_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server mail control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =======================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    mtype          &lt;mime part type&gt;  :   set part type (for parts of MIME messages to be saved)</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef PSRP_AUTHENTICATE</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server security control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ===========================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    secure         &lt;token&gt;           :   set (secure) server authentication token</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef CRIU_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server (Criu) state save control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ====================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ssave                           |  :   Report state saving status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;                   [-t &lt;poll time&gt;]    :   Save state every &lt;poll time&gt; seconds (default 60 seconds)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;                   [-enable       ] |  :   Enable state saving</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;                   [-disable      ] |  :   Disable state saving</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;                   [-cd &lt;criu dir&gt;] |  :   Set Criu directory (default /tmp)</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef BUBBLE_MEMORY_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server bubble memory control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    mstat                              :   show memory allocation statistics</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    mset           &lt;threshold&gt;         :   set memory bubble utilisation threshold </span><span class="Special">%%</span><span class="Constant"> (-usage for more detailed help)</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server (attached) file control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ==================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    lflstat                            :   show concurrently held link file locks</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    flstat                             :   show currently held flockfile locks</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    fstat                              :   display open file descriptors</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ftab           [&lt;n&gt; | shrink]      :   display [or set to &lt;n&gt; or Procrustes shrink] number of file table slots</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server (attached) signal control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ====================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    sigstat                            :   display non default signal handlers</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    sigstat        &lt;sig list&gt;          :   display detailed data for selected signal handlers</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    maskstat                           :   display signal mask and pending signals</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server (attached) fast cache status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ======================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    cachestat                          :   display (fast) caches mapped into process address space</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server process cron scheduler control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =========================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    schedule       &lt;f&gt; &lt;t&gt; [&lt;func&gt;]    :   schedule function &lt;func&gt; between times &lt;f&gt; and &lt;t&gt; using cron homeostat</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;                                    :   if &lt;func&gt; is omitted sleep between times &lt;f&gt; and &lt;t&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    unschedule    &lt;index&gt;              :   unschedule a previously scheduled crontab slot</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    crontstat                          :   display crontab</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server process general hoeostatis control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =============================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    sicstat                            :   display open slaved interaction client channels</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    rooted                             :   set process to rooted mode (system context cannot migrate)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    unrooted                           :   set process to unrooted mode (system context can migrate)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    parent         &lt;name | PID&gt;        :   set name/PID of effective parent process</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    pexit                              :   process  exits if effective parent terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    unpexit                            :   process does not exit if effective parent terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    live           &lt;f1&gt; &lt;f2&gt; ...       :   protects list of (open) files against damage or deletion</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    dead           &lt;f1&gt; &lt;f2&gt; ...       :   unprotects list of (open) files</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    new            &lt;f|&gt;s&gt; &lt;n&gt; &lt;h&gt;      :   create new instance &lt;n&gt; of server, n=instance, f=fork, s=segment, h=hostname</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    overlay        &lt;command&gt;           :   Overlay server process with &lt;command&gt; (server resumes when command exits)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    overfork       &lt;command&gt;           :   Overfork server process with &lt;command&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    autosave       [on | off]          :   switch automatic saving of dipatch table (at exit) on or off</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    autosave                           :   display status of automatic dispatch table saving (at exit)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    save           &lt;n&gt;                 :   save dispatch table (to PSRP ressource file &lt;n&gt;)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    load           &lt;n&gt;                 :   load PSRP resource file &lt;n&gt; (appending objects to current dispatch table)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    reset                              :   reset dispatch table (returning it to its default state)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_DATABAG)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    bag         &lt;n&gt; &lt;f&gt;   [LIVE|DEAD]  :   bind dynamic databag in &lt;f&gt; to PSRP handler &lt;n&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);


<span class="PreProc">    #ifdef DLL_SUPPORT </span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server process DLL (dynamically linked object) control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ==========================================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_FUNCTION)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    dll         &lt;name&gt; &lt;object DLL&gt;    :   bind dynamic function in &lt;object DLL&gt; to PSRP handler with &lt;name&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ostat                              :   display orifices which are bound to application</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ortab       [&lt;n&gt;]                  :   display [or set to &lt;n&gt;] number of orifice [DLL] table slots</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    }

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_FUNCTION || psrp_bind_status &amp; PSRP_DYNAMIC_DATABAG || psrp_bind_status &amp; PSRP_PERSISTENT_HEAP)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    detach      &lt;item-list&gt;            :   detach PSRP objects function in &lt;item-list&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;                                       :   if item list contains </span><span class="Special">\&quot;</span><span class="Constant">all</span><span class="Special">\&quot;</span><span class="Constant"> reset dispatch table</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    dllstat     &lt;name&gt;                 :   show orifices exported by DLL &lt;name&gt;</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server process thread control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    =================================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    tstat          [&lt;nid&gt;]             :   show running threads, or optionally info for thread &lt;nid&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    tstart         [&lt;n&gt; [ &lt;a&gt;]         :   run (static or dynamic payload function) [name &lt;a&gt;] on thread &lt;n&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    tpause         [&lt;n&gt; | &lt;all&gt;]       :   pause thread &lt;n&gt; or all threads if &lt;all&gt; specifed</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    tcont          [&lt;n&gt; | &lt;all&gt;]       :   restart thread &lt;n&gt; or all threads if &lt;all&gt; specifed</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    tkill          [&lt;n&gt; | &lt;all&gt;]       :   kill thread &lt;n&gt; or all threads if &lt;all&gt; specifed</span><span class="Special">\n\n\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    P3 server process heap control/status functions</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    ===============================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);


<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_PERSISTENT_HEAP)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    heap     &lt;n&gt; &lt;f&gt;  [LIVE|DEAD       :   map persistent heap in &lt;f&gt; to PSRP handler &lt;n&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    hstat    [&lt;h | id&gt; [&lt;o | id&gt;]      :   display pesistent heap details</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    htab     [&lt;n&gt; | shrink]            :   display [or set to &lt;n&gt;] or Procrustes shrink number of persistent heap table slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    hostat      &lt;o1&gt; &lt;o2&gt; ... &lt;on&gt;i    :   Show statistics for tracked heap object &lt;tracked object&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    hostat                             :   Show statistics for all tracked heap objects</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}



<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show orifices which are bound to this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_attached_orifices(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;ostat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: ostat</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)pups_show_orifices(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>




<span class="PreProc">#ifdef PTHREAD_SUPPORT </span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show threads of execution running in this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_threads(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;tstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span> || (argc == <span class="Constant">1</span> &amp;&amp; strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>))
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: tstat [&lt;nid&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(argc == <span class="Constant">2</span>)
    {  <span class="Type">int</span> nid;


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check that we have a valid nid </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;nid) != <span class="Constant">1</span> || nid &lt; <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;expecting integer value (&gt;= 0) for (thread) nid</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Show ttab entry for specified thread </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pupsthread_show_threadinfo(psrp_out,nid) &lt; <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;specfied thread (nid </span><span class="Special">%d</span><span class="Constant">) does not exist</span><span class="Special">\n</span><span class="Constant">&quot;</span>,nid);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }


    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)pupsthread_show_ttab(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Start a new thread of execution (using dispatch table object) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_launch_thread(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        d_index;

    <span class="Type">char</span> tname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">void</span> *tfunc = (<span class="Type">void</span> *)<span class="Constant">NULL</span>,
         *targs = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    pthread_t tid;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;tstart&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || argc == <span class="Constant">2</span> &amp;&amp; (strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>))
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: tstart [-usage] | [&lt;thread name&gt; &lt;payload name&gt; [&lt;argument string&gt;]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that payload is in dispatch table and that it is executable </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((d_index = lookup_psrp_object_by_name(argv[<span class="Constant">2</span>])) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Payload function </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not in disptach table</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">2</span>]);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check object type - if its not PSRP_STATIC_FUNCTION or </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP_DYNAMIC_FUNCTION we can't execute it!             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_object_list[d_index].object_type != PSRP_STATIC_FUNCTION    &amp;&amp;
       psrp_object_list[d_index].object_type != PSRP_DYNAMIC_FUNCTION    )
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Payload function </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not a static or dynamic executable</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build argument list for thread launcher </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and get name of thread                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    tfunc = (<span class="Type">void</span> *)psrp_object_list[d_index].object_handle;
    (<span class="Type">void</span>)strlcpy(tname,argv[<span class="Constant">1</span>],SSIZE);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have some arguments - typically these </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> will be passed as a string which will be </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> parsed by the thread payload function    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(argc == <span class="Constant">4</span>)
       targs = argv[<span class="Constant">3</span>];
                                                             <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Statement">if</span>((tid = pupsthread_create(tname,                       <span class="Comment">/*</span><span class="Comment"> Name of payload function to be run by thread </span><span class="Comment">*/</span>
                                tfunc,                       <span class="Comment">/*</span><span class="Comment"> Payload function to be run by thread         </span><span class="Comment">*/</span>
                                targs)) != (pthread_t)<span class="Constant">NULL</span>)  <span class="Comment">/*</span><span class="Comment"> Payload arguments                            </span><span class="Comment">*/</span>
                                                             <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    {  <span class="Type">int</span> tpid,
           t_index;

       t_index = pupsthread_tid2nid(tid);
       tpid    = pupsthread_nid2tpid(t_index);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread </span><span class="Special">%d</span><span class="Constant"> (LWP: </span><span class="Special">%d</span><span class="Constant">, payload function: </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant">) launched (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                      t_index,tpid,tname,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Failed to start thread</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Pause thread executing in this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_pause_thread(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   pthread_t tid;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;tpause&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || argc == <span class="Constant">2</span> &amp;&amp; strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: tpause [-usage] | [&lt;thread name&gt; | [all]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Pause specified thread </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;all&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>((tid = pupsthread_tfuncname2tid(argv[<span class="Constant">1</span>])) == (pthread_t)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not associated with a running thread</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       <span class="Statement">if</span>(pupsthread_pause(tid) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) failed to stop</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) paused</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,argv[<span class="Constant">1</span>]);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Pause all threads </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">int</span> i,
           t_cnt = <span class="Constant">0</span>;

       <span class="Type">char</span> tmpname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ttab_mutex);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Pause all active threads (other than root thread) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_THREADS; ++i)
       {  <span class="Statement">if</span>(ttab[i].tid != (pthread_t *)<span class="Constant">NULL</span>)
          {  tid = ttab[i].tid;
             (<span class="Type">void</span>)strlcpy(tmpname,ttab[i].tfuncname,SSIZE);
             <span class="Statement">if</span>(pupsthread_pause(tid) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) failed to stop</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tmpname);
                (<span class="Type">void</span>)fflush(psrp_out);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tmpname);
                (<span class="Type">void</span>)fflush(psrp_out);

                ++t_cnt;
             }
          }
       }

       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ttab_mutex);


       <span class="Statement">if</span>(t_cnt == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">no threads stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> threads stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,t_cnt);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Restart thread executing in this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_restart_thread(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   pthread_t tid;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;tcont&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || argc == <span class="Constant">2</span> &amp;&amp; strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: tcont [-usage] | [&lt;thread name&gt; | [all]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restart specified thread </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;all&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>((tid = pupsthread_tfuncname2tid(argv[<span class="Constant">1</span>])) == (pthread_t)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not associated with a running thread</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       <span class="Statement">if</span>(pupsthread_cont(tid) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) failed to restart</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) restarted</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,argv[<span class="Constant">1</span>]);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restart all threads </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">int</span> i,
           t_cnt = <span class="Constant">0</span>;

       <span class="Type">char</span> tmpname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ttab_mutex);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Restart all active threads (other than root thread) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_THREADS; ++i)
       {  <span class="Statement">if</span>(ttab[i].tid != (pthread_t *)<span class="Constant">NULL</span>)
          {  tid = ttab[i].tid;
             (<span class="Type">void</span>)strlcpy(tmpname,ttab[i].tfuncname,SSIZE);
             <span class="Statement">if</span>(pupsthread_cont(tid) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) failed to restart</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tmpname);
                (<span class="Type">void</span>)fflush(psrp_out);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) restarted</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tmpname);
                (<span class="Type">void</span>)fflush(psrp_out);

                ++t_cnt;
             }
          }
       }

       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ttab_mutex);


       <span class="Statement">if</span>(t_cnt == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">no threads restarted</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> threads restarted</span><span class="Special">\n</span><span class="Constant">&quot;</span>,t_cnt);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Kill thread executing in this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_kill_thread(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   pthread_t tid;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;tkill&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || argc == <span class="Constant">2</span> &amp;&amp; strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: tkill [-usage] | [&lt;thread name&gt; | [all]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Kill specified thread </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;all&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>((tid = pupsthread_tfuncname2tid(argv[<span class="Constant">1</span>])) == (pthread_t)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not associated with a running thread</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       <span class="Statement">if</span>(pupsthread_cancel(tid) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) failed to terminate</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,argv[<span class="Constant">1</span>]);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,argv[<span class="Constant">1</span>]);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Kill all threads </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">int</span> i,
           t_cnt = <span class="Constant">0</span>;

       <span class="Type">char</span> tmpname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ttab_mutex);


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Kill all active threads (other than root thread) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_THREADS; ++i)
       {  <span class="Statement">if</span>(ttab[i].tid != (pthread_t *)<span class="Constant">NULL</span>)
          {  tid = ttab[i].tid;
             (<span class="Type">void</span>)strlcpy(tmpname,ttab[i].tfuncname,SSIZE);
             <span class="Statement">if</span>(pupsthread_cancel(tid) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) failed to terminate</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tmpname);
                (<span class="Type">void</span>)fflush(psrp_out);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Thread (</span><span class="Special">%lx</span><span class="Constant">, name </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tmpname);
                (<span class="Type">void</span>)fflush(psrp_out);

                ++t_cnt;
             }
          }
       }

       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ttab_mutex);


       <span class="Statement">if</span>(t_cnt == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">no threads terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> threads terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,t_cnt);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show /proc filesystem entries for this process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_procstatus(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> appl_procstatus[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         line[SSIZE]            = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *proc_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;pstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: procstatus</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)snprintf(appl_procstatus,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/status&quot;</span>,appl_pid);

    proc_stream = pups_fopen(appl_procstatus,<span class="Constant">&quot;r&quot;</span>,DEAD);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">do</span> {   (<span class="Type">void</span>)pups_fgets(line,SSIZE,proc_stream);

           <span class="Statement">if</span>(feof(proc_stream) == <span class="Constant">0</span>)
           {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,line);
              (<span class="Type">void</span>)fflush(psrp_out);
           }
       } <span class="Statement">while</span>(feof(proc_stream) == <span class="Constant">0</span>);

    (<span class="Type">void</span>)pups_fclose(proc_stream);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show link file locks held by this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_link_file_locks(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;lflstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    (<span class="Type">void</span>)pups_show_link_file_locks(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Show flock locks held by this application ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_flock_locks(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;flstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    (<span class="Type">void</span>)pups_show_flock_locks(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show non-default signal handlers installed for this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_sigstatus(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;sigstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show signal status for individual signal </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(argc &gt; <span class="Constant">1</span>)
    {  <span class="Type">int</span> i;

       <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
       {  <span class="Statement">if</span>(pups_show_siglstatus(pups_signametosigno(argv[i]),psrp_out) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Not a valid signal (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
             (<span class="Type">void</span>)fflush(psrp_out);
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Show (abridged) status of all signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       pups_show_sigstatus(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show signal mask and signals pending for this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_sigmaskstatus(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;maskstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_sigmaskstatus(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------*.</span>
<span class="Error">/</span><span class="Comment">* Show file descriptors opened by this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_open_fdescriptors(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;fstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_open_fdescriptors(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show (active) children of current process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_children(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;cstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_children(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show (fast) caches curently mapped into the address space of this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_caches(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;cachestat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: cashestat &lt;cache&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">2</span>)
    {  <span class="Type">int</span> c_index;

       c_index = cache_name2index(argv[<span class="Constant">1</span>]);
       <span class="Statement">if</span>(cache_display_statistics(FALSE,psrp_out,c_index) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">cache </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not mapped into addrees space of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>],appl_name);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)cache_display(FALSE,psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show persistent heaps attached to this application - if request is of the </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> form hstat &lt;heap&gt; show the object map of that heap                        </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_persistent_heaps(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;hstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parse command line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(argc &gt; <span class="Constant">3</span> || (argc == <span class="Constant">2</span> &amp;&amp; strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;-usage&quot;</span>) == <span class="Constant">0</span>))
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: hstat [&lt;hid&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display details of specific persistent heap </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(argc &gt;= <span class="Constant">2</span>)
    {  <span class="Type">int</span>  h_index;
       <span class="Type">char</span> heapname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;h_index) != <span class="Constant">1</span> || h_index &lt; <span class="Constant">0</span>)
       {
          <span class="Statement">if</span>((h_index = msm_name2index(argv[<span class="Constant">1</span>])) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;invalid heap specification (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Display objects on persistent heap </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(argc == <span class="Constant">2</span>)
       {  <span class="Statement">if</span>(msm_show_mapped_objects(h_index,psrp_out) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;invalid heap specification (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">1</span>]);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Display details of specific object </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> on peristent heap                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  <span class="Type">int</span> o_index;

          <span class="Statement">if</span>(sscanf(argv[<span class="Constant">2</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;o_index) != <span class="Constant">1</span> ||  o_index &lt; <span class="Constant">0</span>)
          {  <span class="Statement">if</span>((o_index = msm_map_objectname2index(h_index,argv[<span class="Constant">2</span>])) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Invalid object specification (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">2</span>]);
                (<span class="Type">void</span>)fflush(psrp_out);

                <span class="Statement">return</span>(PSRP_OK);
              }
          }

          <span class="Statement">if</span>(msm_show_mapped_object(h_index,o_index,psrp_out) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Invalid object specification (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[<span class="Constant">2</span>]);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display details of all attached persistent heaps </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       psrp_show_persistent_heaps(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show slaved interation client channels opened by this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_open_sics(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;sicstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    psrp_show_open_sics(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show (PUPS) entrance functions bound to application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_entrance_f(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;atentrance&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_entrance_f(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show (PUPS) exit functions bound to application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_exit_f(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;atexit&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_exit_f(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show (PUPS) exit functions bound to application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_abort_f(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;atabort&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_abort_f(psrp_out);
    psrp_show_on_abort_callback_f(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show (PUPS) virtual interval timers associated with application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_pups_show_vitimers(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;vitstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    pups_show_vitimers(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show tracked heap memory objects </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_htobjects(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> objects;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;hostat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Usage: hostat &lt;Largest N objects | list of named objects&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;objects) == <span class="Constant">1</span>)
       pups_tshowobjects(psrp_out,objects);
    <span class="Statement">else</span>
    {  <span class="Type">int</span> i;

       <span class="Statement">if</span>(argc &gt;= <span class="Constant">2</span>)
       {  <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
          {  <span class="Type">int</span> cnt          = <span class="Constant">0</span>;
             _BOOLEAN is_name = FALSE;
             <span class="Type">void</span>     *ptr    = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;


             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Search matab by (partial) name </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)pups_tpartnametoptr(<span class="Constant">&quot;RESET&quot;</span>);
             <span class="Statement">while</span>((ptr = pups_tpartnametoptr(argv[i])) != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             {    is_name = TRUE;

                  pups_tshowobject(psrp_out,ptr);
                  ++cnt;
             }


             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Not a name - search matab by type </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(is_name == FALSE)
             {  (<span class="Type">void</span>)pups_ttypetoptr(<span class="Constant">&quot;RESET&quot;</span>);
                <span class="Statement">while</span>((ptr = pups_ttypetoptr(argv[i])) != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                {    pups_tshowobject(psrp_out,ptr);
                     ++cnt;
                }
             }

             <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> is not a tracked heap object</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,argv[i]);
                (<span class="Type">void</span>)fflush(psrp_out);
             }
          }
       }
    }

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Destroy psrp object (releasing its memory) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_destroy_object(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> slot_index)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_destroy_object] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    (<span class="Type">void</span>)psrp_ifree_tag_list(slot_index);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send error message string to client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_error(<span class="Type">const</span> <span class="Type">char</span> *error_string)

{
    <span class="Statement">if</span>(error_string == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;[psrp ERROR] </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,error_string);
    (<span class="Type">void</span>)fflush(psrp_out);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Do a name to pid conversion if user has given the name of the PSRP server process to be </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> contacted                                                                               </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_pname_to_pid(<span class="Type">const</span> <span class="Type">char</span> *process_name)

{   <span class="Type">int</span>  pid,
         cnt        = <span class="Constant">0</span>,
         target_pid = PSRP_TERMINATED;

    <span class="Type">char</span> cmd_line[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         procpidpath[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span>          *stream    = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    <span class="Type">DIR</span>           *dirp      = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(process_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((dirp = opendir(<span class="Constant">&quot;/proc&quot;</span>)) == (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ENOTDIR</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       error(<span class="Constant">&quot;[psrp_pname_to_pid] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search for (named) process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {    <span class="Statement">if</span>(sscanf(next_item-&gt;d_name,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;pid) == <span class="Constant">1</span>)
         {  (<span class="Type">void</span>)snprintf(procpidpath,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/cmdline&quot;</span>,pid);
            <span class="Statement">if</span> ((stream = fopen(procpidpath,<span class="Constant">&quot;r&quot;</span>)) != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
            {
               (<span class="Type">void</span>)strlcpy(cmd_line,<span class="Constant">&quot;&quot;</span>,SSIZE);
               (<span class="Type">void</span>)fgets(cmd_line,SSIZE,stream);
               (<span class="Type">void</span>)fclose(stream);

               <span class="Statement">if</span>(strncmp(cmd_line,process_name,strlen(process_name)) == <span class="Constant">0</span>)
               {  ++cnt;

                  <span class="Statement">if</span>(cnt &gt; <span class="Constant">1</span>)
                  {  (<span class="Type">void</span>)closedir(dirp);
                      pups_set_errno(<span class="Constant">ESRCH</span>);

                      <span class="Statement">return</span>(PSRP_DUPLICATE_PROCESS_NAME);
                  }

                  target_pid = pid;
               }
            }
         }
    }

    (<span class="Type">void</span>)closedir(dirp);

    pups_set_errno(OK);
    <span class="Statement">return</span>(target_pid);
}






<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Do a pid to name conversion if user has given the pid of the PSRP server process to be </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> contacted                                                                              </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_pid_to_pname(<span class="Type">const</span> <span class="Type">int</span> pid, <span class="Type">char</span> *process_name)

{   <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> cmd_line[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         procpidpath[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(process_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       error(<span class="Constant">&quot;[psrp_pid_to_pname] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Does the process exist? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(procpidpath,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/cmdline&quot;</span>,pid);
    <span class="Statement">if</span>((stream = fopen(procpidpath,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ESRCH</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Ok -- process exists -- lets get its name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fgets(cmd_line,SSIZE,stream);
    (<span class="Type">void</span>)fclose(stream);

    <span class="Statement">if</span>(sscanf(cmd_line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,process_name) != <span class="Constant">1</span>)
       (<span class="Type">void</span>)strlcpy(process_name,<span class="Constant">&quot;&lt;unknown&gt;&quot;</span>,SSIZE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get pid from psrp channel name (given process name running on given host) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_channelname_to_pid(<span class="Type">const</span> <span class="Type">char</span> *patchboard_path,  <span class="Comment">// Patchboard containing channel information</span>
                                    <span class="Type">char</span>       *process_name,     <span class="Comment">// Name of process for which corresponding pid required</span>
                                    <span class="Type">char</span>       *process_host)     <span class="Comment">// Name of host running process</span>

{   <span class="Type">int</span>  i,
         entry_cnt,
         d_cnt           = <span class="Constant">0</span>,
         old_target_pid  = PSRP_TERMINATED,
         target_pid      = PSRP_TERMINATED,
         target_uid      = (-<span class="Constant">1</span>);

    <span class="Type">char</span> strdum[SSIZE]               = <span class="Constant">&quot;&quot;</span>,
         tmpstr[SSIZE]               = <span class="Constant">&quot;&quot;</span>,
         channel_process_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         **entries                   = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_channelname_to_pid] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Statement">if</span>(patchboard_path == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       process_name    == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       process_host    == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)strlcpy(tmpstr,process_name,SSIZE);
    (<span class="Type">void</span>)strlcat(tmpstr,<span class="Constant">&quot;#&quot;</span>,SSIZE);
    <span class="Statement">if</span>((entries = pups_get_directory_entries(patchboard_path,
                                             tmpstr,
                                             &amp;d_cnt,
                                             &amp;entry_cnt)) == (<span class="Type">char</span> **)<span class="Constant">NULL</span>)
    {   pups_set_errno(<span class="Constant">ESRCH</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we don't have duplicate processes with the same name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;d_cnt; ++i)
    {  (<span class="Type">void</span>)mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;#&quot;</span>,entries[i]);

       <span class="Statement">if</span>(strin(entries[i],<span class="Constant">&quot;psrp&quot;</span>) == TRUE &amp;&amp; strin(entries[i],<span class="Constant">&quot;in&quot;</span>) == TRUE)
       {  <span class="Type">int</span> tmp_pid;

          (<span class="Type">void</span>)sscanf(entries[i],<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d%d</span><span class="Constant">&quot;</span>,strdum,channel_process_name,process_host,strdum,strdum,&amp;tmp_pid,&amp;target_uid);

          <span class="Statement">if</span>(target_uid == getuid())
          {  <span class="Statement">if</span>(i &gt; <span class="Constant">0</span>                                          &amp;&amp;
                old_target_pid &gt; <span class="Constant">0</span>                             &amp;&amp;
                strcmp(process_name,channel_process_name) == <span class="Constant">0</span> &amp;&amp;
                tmp_pid != old_target_pid                       )
             {

                <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Clear memory allocated by directory search routine </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;d_cnt; ++i)
                   (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries[i]);
                (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries);

                pups_set_errno(<span class="Constant">EEXIST</span>);
                <span class="Statement">return</span>(PSRP_DUPLICATE_PROCESS_NAME);
             }
             <span class="Statement">else</span>
             {  target_pid     = tmp_pid;
                old_target_pid = target_pid;
             }
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear memory allocated by directory search routine </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;d_cnt; ++i)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries[i]);
    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is the channel actually associated with a live processs? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(target_pid &gt; <span class="Constant">0</span> &amp;&amp; kill(target_pid,SIGALIVE) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(PSRP_TERMINATED);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(target_pid);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get psrp channel name from psrp channel name (given pid) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_pid_to_channelname(<span class="Type">const</span> <span class="Type">char</span> *patchboard_path,  <span class="Comment">// Patchboard containing channel information</span>
                                         <span class="Type">const</span> <span class="Type">int</span>               pid,  <span class="Comment">// Pid for which corresponding channelname is required</span>
                                         <span class="Type">char</span>          *process_name,  <span class="Comment">// Name of process corresponding to pid</span>
                                         <span class="Type">char</span>          *process_host)  <span class="Comment">// Name of host running process corresponding to pid</span>

{  <span class="Type">int</span>  i,
        uid,
        entry_cnt,
        d_cnt = <span class="Constant">0</span>;

   <span class="Type">char</span> strdum[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
        pid_str[SSIZE] = <span class="Constant">&quot;&quot;</span>,
        **entries      = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_pid_to_channelname] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(patchboard_path == (<span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       pid             &lt;  <span class="Constant">0</span>               ||
       process_name    == (<span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       process_host    == (<span class="Type">char</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if process actually exists </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(kill(pid,SIGALIVE) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open stream and run ps command to get pid list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(pid_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,pid);
    <span class="Statement">if</span>((entries = pups_get_directory_entries(patchboard_path,
                                             pid_str,
                                             &amp;d_cnt,
                                             &amp;entry_cnt)) == (<span class="Type">char</span> **)<span class="Constant">NULL</span>)
    {   pups_set_errno(<span class="Constant">ESRCH</span>);
        <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> values &lt;= 0 imply that their is no channel for specified pid </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(d_cnt &gt; <span class="Constant">0</span>)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;d_cnt; ++i)
       {  <span class="Statement">if</span>(strin(entries[i],<span class="Constant">&quot;psrp&quot;</span>) == TRUE)
          {  <span class="Type">int</span> tmp_pid;

             (<span class="Type">void</span>)mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;#&quot;</span>,entries[i]);
             (<span class="Type">void</span>)sscanf(entries[i],<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d%d</span><span class="Constant">&quot;</span>,strdum,process_name,process_host,strdum,strdum,&amp;tmp_pid,&amp;uid);


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check to see if we actually own this process </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(uid != getuid())
             {  pups_set_errno(<span class="Constant">EACCES</span>);
                <span class="Statement">return</span>(FALSE);
             }

             <span class="Statement">if</span>(pid == tmp_pid)
             {

                <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Clear memory allocated by directory search routine </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;d_cnt; ++i)
                   (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries[i]);
                (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries);

                pups_set_errno(OK);
                <span class="Statement">return</span>(TRUE);
             }
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear memory allocated by directory search routine </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;d_cnt; ++i)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries[i]);
    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)entries);

    (<span class="Type">void</span>)strlcpy(process_name,<span class="Constant">&quot;nochan&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(process_host,<span class="Constant">&quot;nohost&quot;</span>,SSIZE);

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Initialise slaved interation client channel table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_initsic(<span class="Type">void</span>)

{   <span class="Type">int</span>  i;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PSRP_MAX_SIC_CHANNELS; ++i)
    {  channel[i].in_name    = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       channel[i].out_name   = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       channel[i].host_name  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       channel[i].ssh_port   = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       channel[i].pen        = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       channel[i].index      = FREE;
       channel[i].in_stream  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
       channel[i].out_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP slaved interaction clients (</span><span class="Special">%d</span><span class="Constant"> channels available)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_host,appl_owner,PSRP_MAX_SIC_CHANNELS);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
}




<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show persistent heaps attached to this PSRP server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_show_persistent_heaps(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        heaps = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_show_persistemt_heaps] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see that we have initialised </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> persistent heaps                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(msm_init == FALSE)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Persistent heaps not initialised</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Persistent heaps attached</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display abridged details of each attached persistent heap </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_pheaps; ++i)
    {

<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;HTABLE: </span><span class="Special">%d</span><span class="Constant"> name: (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,htable[i].name);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(htable[i].name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
       {

          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant">  mapped at </span><span class="Special">%016lx</span><span class="Constant"> virtual (size </span><span class="Special">%016lx</span><span class="Constant"> bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                                        htable[i].name,
                                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[i].addr,
                                                                     htable[i].edata - htable[i].sdata);
          (<span class="Type">void</span>)fflush(stream);

          ++heaps;
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display number of attached persistent heaps </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(heaps == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    no persistent heaps mapped (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_max_pheaps,appl_max_pheaps);
       (<span class="Type">void</span>)fflush(stream);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(heaps == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> persistent heap mapped into process address space (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,appl_max_pheaps,appl_max_pheaps - <span class="Constant">1</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(heaps &gt; <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> persistent heaps mapped into process address space (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,heaps,appl_max_pheaps,appl_max_pheaps - heaps);

    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;htab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show PSRP slaved client channels open on this server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_show_open_sics(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        sics = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_show_open_sics] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">     Slaved interation client channels (SICs) free</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;     =============================================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PSRP_MAX_SIC_CHANNELS; ++i)
    {  <span class="Statement">if</span>(channel[i].index != FREE)
       {  <span class="Type">char</span> type[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(channel[i].type == SIC_FIFO)
             (<span class="Type">void</span>)strlcpy(type,<span class="Constant">&quot;[duplex FIFO]&quot;</span>,SSIZE);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(type,<span class="Constant">&quot;[ssh tunnel]&quot;</span>,SSIZE);

<span class="PreProc">          #ifdef SSH_SUPPORT</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">%-32s</span><span class="Constant"> (on host </span><span class="Special">%-48s</span><span class="Constant"> via </span><span class="Special">%-48s</span><span class="Constant">) </span><span class="Special">%-16s</span><span class="Constant"> (ssh port: </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                                     channel[i].pen,
                                                                                channel[i].out_name,
                                                                               channel[i].host_name,
                                                                                               type,
                                                                                channel[i].ssh_port);
<span class="PreProc">          #else</span>
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">%-32s</span><span class="Constant"> (on host </span><span class="Special">%-48s</span><span class="Constant"> via </span><span class="Special">%-48s</span><span class="Constant">) </span><span class="Special">%-16s</span><span class="Constant"> (ssh port: </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                                     channel[i].pen,
                                                                                channel[i].out_name,
                                                                               channel[i].host_name,
                                                                                               type);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPPORT </span><span class="Comment">*/</span>

          (<span class="Type">void</span>)fflush(stream);
          ++sics;
       }
    }

    <span class="Statement">if</span>(sics == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">     no sics in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,PSRP_MAX_SIC_CHANNELS);
    <span class="Statement">else</span> <span class="Statement">if</span>(sics == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">     </span><span class="Special">%04d</span><span class="Constant"> sic in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>, <span class="Constant">1</span>,PSRP_MAX_SIC_CHANNELS - <span class="Constant">1</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant"> sics in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,sics,PSRP_MAX_SIC_CHANNELS - sics);

    (<span class="Type">void</span>)fflush(stream);

    pups_set_errno(OK);
}






<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send a single command to PSRP server process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SSH_SUPPORT</span>
_PUBLIC psrp_channel_type *psrp_create_slaved_interaction_client(<span class="Type">const</span> <span class="Type">char</span>  *host_name,  <span class="Comment">// Host to create client on </span>
                                                                 <span class="Type">const</span> <span class="Type">char</span>  *ssh_port,   <span class="Comment">// Port on client</span>
                                                                 <span class="Type">const</span> <span class="Type">char</span>  *psrp_pen)   <span class="Comment">// PEN of client</span>
<span class="PreProc">#else</span>
_PUBLIC psrp_channel_type *psrp_create_slaved_interaction_client(<span class="Type">const</span> <span class="Type">char</span>  *psrp_pen)   <span class="Comment">// PEN of client</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
{   <span class="Type">int</span>  i,
         ssh_portNo                   = (-<span class="Constant">1</span>),
         sic_index,
         scp,
         ft_index,
         get_items;

    <span class="Type">char</span> eff_psrp_pen[SSIZE]          = <span class="Constant">&quot;psrp&quot;</span>,
         sic_channel_in_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         sic_channel_out_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         psrp_command[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
         psrp_pathname[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         pwd_file_name[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         slaved_psrp_client_ok[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN local_client             = TRUE,
             channel_in_use           = FALSE,
             channel_allocated        = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_create_slaved_interaction_client] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get name of slaved psrp instance </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_pen != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(eff_psrp_pen,psrp_pen,SSIZE);


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check port specification </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ssh_port                  != (<span class="Type">char</span> *)<span class="Constant">NULL</span>  &amp;&amp;
       strcmp(ssh_port,<span class="Constant">&quot;&quot;</span>)       != <span class="Constant">0</span>             &amp;&amp;
       strcmp(ssh_port,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>              )
    {  <span class="Statement">if</span>(sscanf(ssh_port,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;ssh_portNo) != <span class="Constant">1</span> || ssh_portNo &lt;= <span class="Constant">0</span>)
       {  pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have not yet created this channel so find a free slot in the channel table and </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> allocate it.                                                                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PSRP_MAX_SIC_CHANNELS; ++i)
    {  <span class="Statement">if</span>(channel[i].index == FREE)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> SIC channel can be allocated </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

          sic_index         = i;
          channel_allocated = TRUE;
          <span class="Statement">break</span>;
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> SIC channel names for input and output channels </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(sic_channel_in_name,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">#sic#</span><span class="Special">%d</span><span class="Constant">&quot;</span> ,appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid,sic_index);
    (<span class="Type">void</span>)snprintf(sic_channel_out_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">#sic#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid,sic_index);


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> All SIC channels in use </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(channel_allocated == FALSE)
    {  pups_set_errno(<span class="Constant">ENFILE</span>);
       <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create FIFO channels for local slaved interaction client </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);

       <span class="Statement">if</span>(host_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): creating remote SIC channel [to host </span><span class="Special">%s</span><span class="Constant">] (via slaved client </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                 date,appl_name,appl_pid,appl_host,appl_owner,host_name,eff_psrp_pen);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): creating local SIC channel (via slaved client </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                             date,appl_name,appl_pid,appl_host,appl_owner,eff_psrp_pen);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Fill in (common) fields of SIC channel descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    channel[sic_index].index   = sic_index;

    <span class="Statement">if</span>(channel[sic_index].in_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel[sic_index].in_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    (<span class="Type">void</span>)strlcpy(channel[sic_index].in_name, sic_channel_in_name,SSIZE);

    <span class="Statement">if</span>(channel[sic_index].out_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel[sic_index].out_name  = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    (<span class="Type">void</span>)strlcpy(channel[sic_index].out_name,sic_channel_out_name,SSIZE);

    <span class="Statement">if</span>(channel[sic_index].host_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel[sic_index].host_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(host_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)strlcpy(channel[sic_index].host_name,appl_host,SSIZE);
        channel[sic_index].remote = FALSE;
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)strlcpy(channel[sic_index].host_name,host_name,SSIZE);
        channel[sic_index].remote = TRUE;
    }



    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Non default ssh port </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (e.g. for container) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ssh_portNo &gt;  <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(channel[sic_index].ssh_port == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          channel[sic_index].ssh_port = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(channel[sic_index].ssh_port,ssh_port,SSIZE);
    }

    <span class="Statement">if</span>(channel[sic_index].pen  == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel[sic_index].pen  = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    (<span class="Type">void</span>)strlcpy(channel[sic_index].pen,eff_psrp_pen,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create physical channel (as named FIFO pair) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)mkfifo(sic_channel_in_name,<span class="PreProc">0</span><span class="Constant">600</span>);
    channel[sic_index].in_stream  = pups_fopen(sic_channel_in_name, <span class="Constant">&quot;w&quot;</span>,LIVE);
    (<span class="Type">void</span>)empty_fifo(fileno(channel[sic_index].in_stream));

    (<span class="Type">void</span>)mkfifo(sic_channel_out_name,<span class="PreProc">0</span><span class="Constant">600</span>);
    channel[sic_index].out_stream = pups_fopen(sic_channel_out_name,<span class="Constant">&quot;r&quot;</span>,LIVE);
    (<span class="Type">void</span>)empty_fifo(fileno(channel[sic_index].out_stream));


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Give the slave channel FIFO's the same level of protection as   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> a PSRP channel -- e.g. homeostatic protection cannot be removed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

    ft_index = pups_get_ftab_index(fileno(channel[sic_index].in_stream));
    ftab[ft_index].psrp = TRUE;

    ft_index = pups_get_ftab_index(fileno(channel[sic_index].out_stream));
    ftab[ft_index].psrp = TRUE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start remote slaved interaction client </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strccpy(psrp_pathname,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,<span class="Constant">&quot;psrp&quot;</span>)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);


          <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Cannot find psrp command </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(host_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to create remote (ssh tunnel) SIC channel [to host </span><span class="Special">%s</span><span class="Constant">] (cannot find psrp client in path)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                 date,appl_name,appl_pid,appl_host,appl_owner,host_name);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to create local SIC channel (cannot find psrp client in path)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       psrp_clear_channel_slot(&amp;channel[sic_index]);

       pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build slaved client command (noting whether it is local or remote) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Slaved PSRP client is running remotely </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(host_name                     != (<span class="Type">char</span> *)<span class="Constant">NULL</span>  &amp;&amp;
       strcmp(host_name,<span class="Constant">&quot;localhost&quot;</span>) != <span class="Constant">0</span>             &amp;&amp;
       strcmp(host_name,<span class="Constant">&quot;notset&quot;</span>)    != <span class="Constant">0</span>             &amp;&amp;
       strcmp(host_name,<span class="Constant">&quot;&quot;</span>)          != <span class="Constant">0</span>              )
    {  (<span class="Type">void</span>)snprintf(psrp_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -slaved -on </span><span class="Special">%s</span><span class="Constant"> -from </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> -pen </span><span class="Special">%s</span><span class="Constant"> -noprompt&quot;</span>,
                                                                         psrp_pathname,
                                                                             host_name,
                                                                             appl_host,
                                                                             appl_name,
                                                                              appl_pid,
                                                                          eff_psrp_pen);
       local_client = FALSE;
    }

    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Slaved PSRP client is running locally </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(psrp_command,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -slaved -pen </span><span class="Special">%s</span><span class="Constant"> -noprompt&quot;</span>,
                                                   psrp_pathname,
                                                    eff_psrp_pen);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start (local) slaved instane of psrp client </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(local_client == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child side of fork                                 </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Associate stdio (for slaved ssh) with PSRP channel </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((scp = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Connect slaved client to SIC channel </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
          <span class="Constant">stdin</span> = fopen(sic_channel_in_name,  <span class="Constant">&quot;r&quot;</span>);

          (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
          <span class="Constant">stdout</span> = fopen(sic_channel_out_name,<span class="Constant">&quot;w&quot;</span>);

          (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
          <span class="Constant">stderr</span> = fopen(sic_channel_out_name,<span class="Constant">&quot;w&quot;</span>);


          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Start local slaved psrp instance </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)execlp(<span class="Constant">&quot;sh&quot;</span>,<span class="Constant">&quot;sh&quot;</span>,<span class="Constant">&quot;-c&quot;</span>,psrp_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an error has occured </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          _exit(<span class="Constant">255</span>);
       }


       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(scp == (-<span class="Constant">1</span>))
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Failed to create slaved psrp instance </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)psrp_destroy_slaved_interaction_client(&amp;channel[sic_index],TRUE);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to create local (duplex FIFO) SIC channel (exec failed)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                          date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          psrp_clear_channel_slot(&amp;channel[sic_index]);

          pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
       }


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Fill in remaining fields of SIC channel descriptor </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       channel[sic_index].type     = SIC_FIFO;
       channel[sic_index].remote   = FALSE;
       channel[sic_index].scp      = scp;
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start remote slaved instance of psrp client </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Statement">else</span>
    {  <span class="Type">int</span> nb,
           ret,
           trys                        = <span class="Constant">0</span>;

       <span class="Type">char</span> absolute_pathname[SSIZE]     = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> ssh needs an absolute pathname if we have a relative </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> pathname -- make it absolute                         </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(psrp_pathname[<span class="Constant">0</span>] != <span class="Constant">'/'</span>)
       {  <span class="Type">char</span> cwd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)getcwd(cwd,SSIZE);


          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Pathname is of the form ./relpath </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(psrp_pathname[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
             (<span class="Type">void</span>)snprintf(absolute_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,cwd,&amp;psrp_command[<span class="Constant">2</span>]);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(absolute_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,cwd,psrp_command);

          (<span class="Type">void</span>)strlcpy(psrp_command,absolute_pathname,SSIZE);
       }

       ssh_sic_index = index;

<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REMOTE PSRP COMMAND: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,psrp_command);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child side of fork                                 </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Associate stdio (for slaved ssh) with PSRP channel </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((scp = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
       {  <span class="Type">char</span> sshPortOpt[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(ssh_portNo &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)snprintf(sshPortOpt,SSIZE,<span class="Constant">&quot;-p </span><span class="Special">%d</span><span class="Constant">&quot;</span>,ssh_portNo);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(sshPortOpt,SSIZE,<span class="Constant">&quot;-p 22&quot;</span>);

          (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
          <span class="Constant">stdin</span> = fopen(sic_channel_in_name,  <span class="Constant">&quot;r&quot;</span>);

          (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
          <span class="Constant">stdout</span> = fopen(sic_channel_out_name,<span class="Constant">&quot;w&quot;</span>);

          (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
          <span class="Constant">stderr</span> = fopen(sic_channel_out_name,<span class="Constant">&quot;w&quot;</span>);


          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We are not using passwords. You will </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> need to generate a public/private    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> keyset for this to work              </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Start remote slaved psrp instance </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ssh_compression == TRUE)
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-oPasswordAuthentication=no&quot;</span>,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,    ssh_remote_uname,host_name,psrp_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-oPasswordAuthentication=no&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,         ssh_remote_uname,host_name,psrp_command,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an error has occured </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          _exit(<span class="Constant">255</span>);
       }


       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>(scp == (-<span class="Constant">1</span>))
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to create remote (ssh tunnel) SIC channel [to host </span><span class="Special">%s</span><span class="Constant">] (could not exec ssh)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                    date,appl_name,appl_pid,appl_host,appl_owner,host_name);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          psrp_clear_channel_slot(&amp;channel[sic_index]);

          pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
       }


       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP servers (slaved) ssh using (ssh tunnel) SIC channel (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                  date,appl_name,appl_pid,appl_host,appl_owner,sic_channel_in_name);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): now talking to PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">'s slaved ssh client</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                      date,appl_name,appl_pid,appl_host,appl_owner,appl_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }


       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): finished talking to PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">'s slaved ssh client (authentication successful)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                     date,appl_name,appl_pid,appl_host,appl_owner,appl_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Fill in remaining fields of SIC channel descriptor </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       channel[sic_index].type   = SIC_SSH_TUNNEL;
       channel[sic_index].remote = TRUE;
       channel[sic_index].scp    = scp;


       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear SIC channel </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)empty_fifo(fileno(channel[sic_index].in_stream));
       (<span class="Type">void</span>)empty_fifo(fileno(channel[sic_index].out_stream));

       scp           = (-<span class="Constant">1</span>);
       ssh_sic_index = (-<span class="Constant">1</span>);
    }
<span class="PreProc">    #else</span>
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): remote SIC channels not supported (no ssh support)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                           date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       psrp_clear_channel_slot(&amp;channel[index]);

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(host_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): local (duplex FIFO) SIC channel created (via slaved client </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                          date,appl_name,appl_pid,appl_host,appl_owner,eff_psrp_pen);
<span class="PreProc">       #ifdef SSH_SUPPORT</span>
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): remote (ssh tunnel) SIC channel [to host </span><span class="Special">%s</span><span class="Constant">] created (via slaved client </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                             date,appl_name,appl_pid,appl_host,appl_owner,host_name,eff_psrp_pen);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we have out PSRP server up and running </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fgets(slaved_psrp_client_ok,SSIZE,channel[sic_index].out_stream);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;GOT </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,slaved_psrp_client_ok);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strncmp(slaved_psrp_client_ok,<span class="Constant">&quot;PSRP&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): slaved PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> has started</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                 date,appl_name,appl_pid,appl_host,appl_owner,eff_psrp_pen);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }


<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       <span class="Type">int</span> cnt = <span class="Constant">0</span>;
       <span class="Statement">while</span>(<span class="Constant">1</span>)
       {   (<span class="Type">void</span>)fputs(<span class="Constant">&quot;test</span><span class="Special">\n</span><span class="Constant">&quot;</span>,channel[sic_index].in_stream);
           (<span class="Type">void</span>)fflush(channel[index].in_stream);

           (<span class="Type">void</span>)psrp_read_sic(&amp;channel[sic_index],slaved_psrp_client_ok);
           (<span class="Type">void</span>)pups_sleep(<span class="Constant">1</span>);

           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;GOT: </span><span class="Special">%s</span><span class="Constant"> (cnt: </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">**********</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,slaved_psrp_client_ok,cnt++);
           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(&amp;channel[sic_index]);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Problem with slaved psrp server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): slaved PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> has failed to start</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                      date,appl_name,appl_pid,appl_host,appl_owner,eff_psrp_pen);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    psrp_clear_channel_slot(&amp;channel[sic_index]);

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send a request to slaved psrp client and wait for reply </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *psrp_slaved_client_transaction(<span class="Type">const</span> _BOOLEAN          do_reply, <span class="Comment">// Log reply</span>
                                             <span class="Type">const</span> psrp_channel_type     *sic, <span class="Comment">// SIC channel</span>
                                             <span class="Type">const</span> <span class="Type">char</span>              *request) <span class="Comment">// Request to send</span>

{   <span class="Type">int</span> ret,
        size = <span class="Constant">0</span>;

    _BOOLEAN looper;

    <span class="Type">char</span> tmp_str[<span class="Constant">512</span>]   = <span class="Constant">&quot;&quot;</span>,
         *reply         = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_slaved_client_transaction] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(sic == (<span class="Type">const</span> psrp_channel_type *)<span class="Constant">NULL</span> || request == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Send request </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ret = psrp_write_sic(sic,request)) &lt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(ret == (-<span class="Constant">2</span>) &amp;&amp; appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): attempted SIC transaction with self</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read reply </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {    (<span class="Type">void</span>)psrp_set_current_sic(sic);
            <span class="Statement">if</span>((looper = psrp_read_sic(sic,tmp_str)) == PSRP_MORE)
            {
               <span class="Statement">if</span>(do_reply == TRUE)
               {  size += strlen(tmp_str);
                  reply = (<span class="Type">char</span> *)realloc((<span class="Type">void</span> *)reply,size);
                  (<span class="Type">void</span>)strlcat(reply,tmp_str,SSIZE);
               }
            }

<span class="PreProc">            #ifdef PSRPLIB_DEBUG</span>
            (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB TRANSACTION GOT: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,tmp_str);
            (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

            (<span class="Type">void</span>)psrp_unset_current_sic();
       } <span class="Statement">while</span>(looper == PSRP_MORE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(reply);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to clear a SIC channel descriptor slot </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_clear_channel_slot(psrp_channel_type *channel)

{   channel-&gt;in_stream   = channel-&gt;out_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(channel-&gt;in_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
      channel-&gt;in_name = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)channel-&gt;in_name);

    <span class="Statement">if</span>(channel-&gt;out_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel-&gt;out_name = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)channel-&gt;out_name);

    <span class="Statement">if</span>(channel-&gt;host_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel-&gt;host_name   = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)channel-&gt;host_name);

    <span class="Statement">if</span>(channel-&gt;ssh_port  != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel-&gt;ssh_port = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)channel-&gt;ssh_port);

    <span class="Statement">if</span>(channel-&gt;pen != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       channel-&gt;pen = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)channel-&gt;pen);

    channel-&gt;index       = FREE;
    channel-&gt;scp         = <span class="Constant">0</span>;
    channel-&gt;type        = <span class="Constant">0</span>;
    channel-&gt;remote      = FALSE;
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to close a link to slaved PSRP interaction client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC psrp_channel_type *psrp_destroy_slaved_interaction_client(<span class="Type">const</span> psrp_channel_type        *channel,   <span class="Comment">// SIC to destroy</span>
                                                                  <span class="Type">const</span> _BOOLEAN           channel_client)   <span class="Comment">// Force slaved client termination</span>

{   <span class="Type">int</span>  i;
    <span class="Type">char</span> reply[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_destroy_slaved_interaction_client] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(channel == (<span class="Type">const</span> psrp_channel_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);

<span class="PreProc">       #ifdef SSH_SUPPORT</span>
       <span class="Statement">if</span>(channel-&gt;remote == TRUE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): remote (ssh tunnel) SIC [to PSRP client </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">] destroyed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                 date,appl_name,appl_pid,appl_host,appl_owner,channel-&gt;pen,channel-&gt;host_name);
       }
       <span class="Statement">else</span>
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): local (duplex FIFO) SIC [to PSRP client </span><span class="Special">%s</span><span class="Constant">] destroyed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                 date,appl_name,appl_pid,appl_host,appl_owner,channel-&gt;pen);

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Destroy the interaction client </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(channel_client == TRUE)
       (<span class="Type">void</span>)psrp_write_sic(channel,<span class="Constant">&quot;quit</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)pups_fclose(channel-&gt;in_stream);
    (<span class="Type">void</span>)pups_fclose(channel-&gt;out_stream);
    (<span class="Type">void</span>)unlink(channel-&gt;in_name);
    (<span class="Type">void</span>)unlink(channel-&gt;out_name);


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Clear channel descriptor slot </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    psrp_clear_channel_slot(channel);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have run a suid root SIC we might need to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> re-create /dev/tty                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(<span class="Constant">&quot;/dev/tty&quot;</span>,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): /dev/tty lost - recreating (mktty)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)pups_system(<span class="Constant">&quot;mktty&quot;</span>,shell,PUPS_ERROR_EXIT,(<span class="Type">int</span> *)<span class="Constant">NULL</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>((psrp_channel_type *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Support routine for stream I/O required by PSRP task functions </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_assign_stdio(<span class="Type">const</span> <span class="Type">FILE</span>  *psrp_out,   <span class="Comment">// PSRP output channel</span>
                              <span class="Type">const</span> <span class="Type">int</span>       *argc,   <span class="Comment">// Number of arguments</span>
                              <span class="Type">const</span> <span class="Type">char</span>    *argv[],   <span class="Comment">// Argument vector</span>
                              <span class="Type">int</span>           *in_des,   <span class="Comment">// Input descriptor</span>
                              <span class="Type">int</span>          *out_des,   <span class="Comment">// Output descriptor</span>
                              <span class="Type">int</span>          *err_des)   <span class="Comment">// Error/status logging descriptor</span>

{    <span class="Type">char</span> in_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
          out_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
          err_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_assign_stdio] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(psrp_out == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>     ||
       argc     == (<span class="Type">const</span> <span class="Type">int</span> *) <span class="Constant">NULL</span>     ||
       argv     == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>    ||
       in_des   == (<span class="Type">const</span> <span class="Type">int</span> *)  <span class="Constant">NULL</span>    ||
       out_des  == (<span class="Type">const</span> <span class="Type">int</span> *)  <span class="Constant">NULL</span>    ||
       err_des  == (<span class="Type">const</span> <span class="Type">int</span> *)  <span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_STDIO_ERROR);
    }

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;in&quot;</span>,argc,argv,<span class="Constant">0</span>)) != NOT_FOUND    ||
       (ptr = pups_locate(&amp;init,<span class="Constant">&quot;i&quot;</span>, argc,argv,<span class="Constant">0</span>)) != NOT_FOUND     )
    {  <span class="Statement">if</span>(strccpy(in_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;assign_psrp_stdio: expecting input file name&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(PSRP_STDIO_ERROR);
       }

       <span class="Statement">if</span>((*in_des = open(in_name,<span class="Constant">2</span>)) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;assign_psrp_stdio: (input) stream </span><span class="Special">%s</span><span class="Constant"> could not be opened</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(PSRP_STDIO_ERROR);
       }
    }
    <span class="Statement">else</span>
       *in_des = open(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">2</span>);

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;out&quot;</span>,argc,argv,<span class="Constant">0</span>)) != NOT_FOUND    ||
       (ptr = pups_locate(&amp;init,<span class="Constant">&quot;o&quot;</span>  ,argc,argv,<span class="Constant">0</span>)) != NOT_FOUND     )
    {  <span class="Statement">if</span>(strccpy(out_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;assign_psrp_stdio: expecting output file name&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(PSRP_STDIO_ERROR);
       }

       <span class="Statement">if</span>((*out_des = open(out_name,<span class="Constant">2</span>)) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;assign_psrp_stdio: (output) stream </span><span class="Special">%s</span><span class="Constant"> could not be opened</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(PSRP_STDIO_ERROR);
       }
    }
    <span class="Statement">else</span>
       *out_des = open(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">2</span>);

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;err&quot;</span>,argc,argv,<span class="Constant">0</span>)) != NOT_FOUND    ||
       (ptr = pups_locate(&amp;init,<span class="Constant">&quot;e&quot;</span>  ,argc,argv,<span class="Constant">0</span>))  != NOT_FOUND    )
    {  <span class="Statement">if</span>(strccpy(err_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;assign_psrp_stdio: expecting error (log) file name&quot;</span>);
           (<span class="Type">void</span>)fflush(psrp_out);

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(PSRP_STDIO_ERROR);
       }

       <span class="Statement">if</span>((*err_des = open(err_name,<span class="Constant">2</span>)) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;assign_psrp_stdio: (error) stream </span><span class="Special">%s</span><span class="Constant"> could not be opened</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(PSRP_STDIO_ERROR);
       }
    }
    <span class="Statement">else</span>
       *err_des = open(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">2</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_STDIO_ASSIGNED);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Assign a set of input, output and error (log) streams </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_assign_fstdio(<span class="Type">const</span> <span class="Type">FILE</span>    *psrp_out, <span class="Comment">// PSRP output channel</span>
                               <span class="Type">const</span> <span class="Type">int</span>         *argc, <span class="Comment">// Number of arguments</span>
                               <span class="Type">const</span> <span class="Type">char</span>      *argv[], <span class="Comment">// Argument vector</span>
                               <span class="Type">FILE</span>         *in_stream, <span class="Comment">// Input stream</span>
                               <span class="Type">FILE</span>        *out_stream, <span class="Comment">// Output stream</span>
                               <span class="Type">FILE</span>        *err_stream) <span class="Comment">// Error/logging stream</span>

{   <span class="Type">int</span> in,
        out,
        err,
        ret;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_assign_fstdio] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(psrp_out    == (<span class="Type">const</span> <span class="Type">FILE</span> *) <span class="Constant">NULL</span>    ||
       argc        == (<span class="Type">const</span> <span class="Type">int</span> *)  <span class="Constant">NULL</span>    ||
       argv        == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>    ||
       in_stream   == (<span class="Type">const</span> <span class="Type">FILE</span> *) <span class="Constant">NULL</span>    ||
       out_stream  == (<span class="Type">const</span> <span class="Type">FILE</span> *) <span class="Constant">NULL</span>    ||
       err_stream  == (<span class="Type">const</span> <span class="Type">FILE</span> *) <span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_STDIO_ERROR);
    }

    ret = psrp_assign_stdio(psrp_out,argc,argv,&amp;in,&amp;out,&amp;err);

    <span class="Statement">if</span>(ret != PSRP_STDIO_ERROR)
    {  in_stream  = fdopen(in,<span class="Constant">&quot;r&quot;</span>),
       out_stream = fdopen(out,<span class="Constant">&quot;w&quot;</span>),
       err_stream = fdopen(err,<span class="Constant">&quot;w&quot;</span>);
    }

    <span class="Statement">return</span>(ret);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Wait for data on nominated descriptor </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_wait_for_data(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   fd_set readfds,
           excepfds;

    <span class="Type">struct</span> timeval timeout;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_wait_for_data] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(fdes &lt; <span class="Constant">0</span> || fdes &gt;= appl_max_files)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    timeout.tv_sec  = <span class="Constant">0</span>;
    timeout.tv_usec = <span class="Constant">100</span>;

    FD_ZERO(&amp;readfds);
    FD_ZERO(&amp;excepfds);
    FD_SET(fdes,&amp;readfds);
    FD_SET(fdes,&amp;excepfds);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for data to become available on nominated descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {   <span class="Statement">while</span>(select(<span class="Constant">1</span>,&amp;readfds,(fd_set *)<span class="Constant">NULL</span>,(fd_set *)<span class="Constant">NULL</span>,&amp;timeout) &lt; <span class="Constant">0</span>);


           <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Invalid file descriptor </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(errno == <span class="Constant">EBADF</span>)
              <span class="Statement">return</span>(-<span class="Constant">1</span>);

           timeout.tv_sec  = <span class="Constant">0</span>;
           timeout.tv_usec = <span class="Constant">100</span>;

           <span class="Statement">if</span>(FD_ISSET(<span class="Constant">0</span>,&amp;readfds))
           {  pups_set_errno(OK);
              <span class="Statement">return</span>(<span class="Constant">0</span>);
           }

           FD_SET(<span class="Constant">0</span>,&amp;readfds);
           FD_SET(<span class="Constant">1</span>,&amp;readfds);
        } <span class="Statement">while</span>(TRUE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Search tag list for the first free slot </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_get_tag_index(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> tag_index)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_tag_index] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(tag_index &gt; psrp_object_list_used)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Statement">if</span>(psrp_object_list[tag_index].aliases == psrp_object_list[tag_index].aliases_allocated)
    {  psrp_object_list[tag_index].aliases_allocated += PSRP_ALLOCATION_QUANTUM;
       psrp_object_list[tag_index].object_tag         = (<span class="Type">char</span> **)pups_realloc((<span class="Type">void</span> *)psrp_object_list[tag_index].object_tag,
                                                                              psrp_object_list[tag_index].aliases_allocated*<span class="Statement">sizeof</span>(<span class="Type">char</span> **));

       ++psrp_object_list[tag_index].aliases;
       <span class="Statement">for</span>(i=psrp_object_list[tag_index].aliases; i&lt;psrp_object_list[tag_index].aliases_allocated; ++i)
          psrp_object_list[tag_index].object_tag[i] = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

       pups_set_errno(OK);
       <span class="Statement">return</span>(psrp_object_list[tag_index].aliases - <span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list[tag_index].aliases_allocated; ++i)
       <span class="Statement">if</span>(psrp_object_list[tag_index].object_tag[i] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  ++psrp_object_list[tag_index].aliases;

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Free resources allocated to tag index </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_ifree_tag_list(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> tag_index)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_ifree_tag_list] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(tag_index &gt; psrp_object_list_used)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Statement">if</span>(psrp_object_list[tag_index].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span>    &amp;&amp;
       psrp_object_list[tag_index].object_tag    != (<span class="Type">void</span> *)<span class="Constant">NULL</span>     )
    {   <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list[i].aliases_allocated; ++i)
        {   <span class="Statement">if</span>(psrp_object_list[tag_index].object_tag[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
               (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)psrp_object_list[tag_index].object_tag[i]);
        }

        psrp_object_list[tag_index].object_tag = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

        pups_set_errno(OK);
        <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Search tag list by index </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_isearch_tag_list(<span class="Type">const</span> <span class="Type">char</span> *object_tag, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> tag_index)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_isearch_tag_list] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(object_tag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || tag_index &gt; psrp_object_list_used)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list[tag_index].aliases_allocated; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[tag_index].object_tag[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>       &amp;&amp;
          strcmp(psrp_object_list[tag_index].object_tag[i],object_tag) == <span class="Constant">0</span>)
       {  pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Create an alias for a PSRP object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_alias(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> *alias)

{   <span class="Type">int</span> i,
        j,
        alias_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_alias] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || alias == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search dispatch table for object to alias </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != <span class="Constant">NULL</span>)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Search for PSRP object tagged with target name (to be aliased) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(psrp_isearch_tag_list(name,i) &gt;= <span class="Constant">0</span>)
          {

             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check that this alias is unique </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(psrp_isearch_tag_list(alias,i) &gt;= <span class="Constant">0</span>)
             {  pups_set_errno(<span class="Constant">ESRCH</span>);
                <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
             }
             <span class="Statement">else</span>
             {  alias_index = psrp_get_tag_index(i);

                <span class="Statement">if</span>(psrp_object_list[i].object_tag[alias_index] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                   psrp_object_list[i].object_tag[alias_index] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
                (<span class="Type">void</span>)strlcpy(psrp_object_list[i].object_tag[alias_index],alias,SSIZE);

                <span class="Statement">if</span>(appl_verbose == TRUE)
                {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> aliased to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                          date,
                                                                     appl_name,
                                                                      appl_pid,
                                                                     appl_host,
                                                                    appl_owner,
                                             psrp_object_list[i].object_tag[<span class="Constant">0</span>],
                                                                         alias);
                   (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                }

                pups_set_errno(OK);
                <span class="Statement">return</span>(PSRP_OK);
             }
          }
        }
     }

     pups_set_errno(<span class="Constant">ESRCH</span>);
     <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove alias associated with a PSRP object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_unalias(<span class="Type">const</span> <span class="Type">char</span> *alias, <span class="Type">const</span> <span class="Type">char</span> *base_tag_name)

{   <span class="Type">int</span> i,
        j,
        alias_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_unalias] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(base_tag_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || alias == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search dispatch table for object to unalias </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {   <span class="Statement">if</span>(psrp_object_list[i].object_handle != <span class="Constant">NULL</span>)
        {  <span class="Statement">if</span>((alias_index = psrp_isearch_tag_list(alias,i)) &gt;= <span class="Constant">0</span>)
           {

              <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Check that this is not the root alias (the real name) of </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> this object. We cannot remove this as it is used to map  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> and unmap the object if it a DLL object                  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(alias_index == <span class="Constant">0</span>)
              {  pups_set_errno(<span class="Constant">EPERM</span>);
                 <span class="Statement">return</span>(PSRP_TAG_ERROR);
              }

              <span class="Statement">if</span>(appl_verbose == TRUE)
              {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> unliased from </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                           date,
                                                                      appl_name,
                                                                       appl_pid,
                                                                      appl_host,
                                                                     appl_owner,
                                                                          alias,
                                              psrp_object_list[i].object_tag[<span class="Constant">0</span>]);

                 (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
              }

              (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)psrp_object_list[i].object_tag[alias_index]);
              psrp_object_list[i].object_tag[alias_index] = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

              (<span class="Type">void</span>)strlcpy(base_tag_name,psrp_object_list[i].object_tag[<span class="Constant">0</span>],SSIZE);
              --psrp_object_list[i].aliases;

              pups_set_errno(OK);
              <span class="Statement">return</span>(PSRP_OK);
           }
        }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to display tag names associated with a given PSRP object </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_show_aliases(<span class="Type">const</span> <span class="Type">char</span> *basename)

{   <span class="Type">int</span> i,
        j,
        alias_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_show_aliases] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(basename == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;psrp_object_list_used; ++i)
    {  <span class="Statement">if</span>(psrp_object_list[i].object_handle != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       {  alias_index = psrp_isearch_tag_list(basename,i);

         <span class="Statement">if</span>(alias_index &gt;= <span class="Constant">0</span>)
         {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Aliases list containing object tag </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,basename);
            <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;psrp_object_list[i].aliases_allocated; ++j)
               <span class="Statement">if</span>(psrp_object_list[i].object_tag[j] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
               {  <span class="Statement">if</span>(j == <span class="Constant">0</span>)
                     (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant">:    </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (root tag of PSRP object at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,j,
                                                                               psrp_object_list[i].object_tag[j],
                                                            (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)psrp_object_list[i].object_handle);
                  <span class="Statement">else</span>
                     (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">%04d</span><span class="Constant">:    </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,j,psrp_object_list[i].object_tag[j]);
               }

            (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
            (<span class="Type">void</span>)fflush(psrp_out);

            pups_set_errno(OK);
            <span class="Statement">return</span>(PSRP_OK);
         }
       }
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;psrp_show_aliases: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not a tag name of any loaded PSRP object</span><span class="Special">\n</span><span class="Constant">&quot;</span>,basename);
    (<span class="Type">void</span>)fflush(psrp_out);

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to check if a channel has a client locked on it </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_channel_locked(<span class="Type">const</span> <span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">char</span> *channel_name)

{   <span class="Type">struct</span> stat buf;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_channel_locked] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(channel_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(stat(channel_name,&amp;buf) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">ENFILE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);

    <span class="Statement">if</span>(buf.st_nlink &gt; <span class="Constant">1</span>)
       <span class="Statement">return</span>(TRUE);

    <span class="Statement">return</span>(FALSE);
}





<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Attach a dynamic databag to the dispatch list of the current process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_attach_dbag(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> databag_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         bag_tag[SSIZE]           = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> h_mode;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;bag&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(!(psrp_bind_status &amp; PSRP_DYNAMIC_DATABAG))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): permission denied (attach dynamic databag)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Permision denied (attach dynamic databag)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span> || argc &gt; <span class="Constant">4</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: bag &lt;PSRP dispatch name&gt; [&lt;databag file name&gt;] [LIVE | DEAD]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">2</span>)
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;DEAD&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: bag &lt;PSRP dispatch name&gt; [&lt;databag file name&gt;] [LIVE | DEAD]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)strlcpy(bag_tag,argv[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(databag_file_name,argv[<span class="Constant">1</span>],SSIZE);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(argc == <span class="Constant">3</span>)
    {  (<span class="Type">void</span>)strlcpy(bag_tag,argv[<span class="Constant">1</span>],SSIZE);

       <span class="Statement">if</span>(strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span>)
       {  h_mode = LIVE;
          (<span class="Type">void</span>)strlcpy(databag_file_name,argv[<span class="Constant">1</span>],SSIZE);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;DEAD&quot;</span>) == <span class="Constant">0</span>)
       {  h_mode = DEAD;
          (<span class="Type">void</span>)strlcpy(databag_file_name,argv[<span class="Constant">1</span>],SSIZE);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(databag_file_name,argv[<span class="Constant">1</span>],SSIZE);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(argc == <span class="Constant">4</span>)
    {  (<span class="Type">void</span>)strlcpy(bag_tag,argv[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(databag_file_name,argv[<span class="Constant">2</span>],SSIZE);
       <span class="Statement">if</span>(strcmp(argv[<span class="Constant">3</span>],<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span>)
          h_mode = LIVE;
       <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[<span class="Constant">3</span>],<span class="Constant">&quot;DEAD&quot;</span>) == <span class="Constant">0</span>)
          h_mode = DEAD;
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: bag &lt;PSRP dispatch name&gt; [&lt;databag file name&gt;] [LIVE | DEAD]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
           <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)strlcpy(databag_file_name,argv[<span class="Constant">2</span>],SSIZE);
    }

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_DYNAMIC_DATABAG)
    {  <span class="Statement">if</span>(psrp_attach_dynamic_databag(TRUE,
                                      bag_tag,
                                      databag_file_name,
                                                 h_mode) == PSRP_DISPATCH_ERROR)
       {

           <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> If we could not find an action matching the clients tag report the </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> error back to the client.                                          </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to attach dynamic databag </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (from </span><span class="Special">%s</span><span class="Constant">) to PSRP handler action list</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                               argv[<span class="Constant">1</span>],databag_file_name);
           (<span class="Type">void</span>)fflush(psrp_out);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">dynamic databag </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> bound to PSRP handler action list</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          (<span class="Type">void</span>)strdate(date);
          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): dynamic databag </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> attached to PSRP handler (imported from file </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                         date,appl_name,appl_pid,appl_host,appl_owner,argv[<span class="Constant">1</span>],databag_file_name);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Attach a dynamic function to the dispatch list of the current process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> psrp_builtin_attach_persistent_heap(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> heap_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         heap_tag[SSIZE]       = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> h_mode   = DEAD;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;heap&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(!(psrp_bind_status &amp; PSRP_PERSISTENT_HEAP))
    {  <span class="Type">int</span>  h_mode;

       (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Permision denied (attach persistent heap)</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span> || argc &gt; <span class="Constant">4</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: heap &lt;PSRP dispatch name&gt; !&lt;persistent heap file name&gt;! [LIVE | DEAD]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">2</span>)
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;DEAD&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: heap &lt;PSRP dispatch name&gt; !map mode! [&lt;persistent heap file name&gt;] [LIVE | DEAD]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)strlcpy(heap_tag,argv[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(heap_file_name,argv[<span class="Constant">1</span>],SSIZE);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(argc == <span class="Constant">3</span>)
    {  (<span class="Type">void</span>)strlcpy(heap_tag,argv[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(heap_file_name,argv[<span class="Constant">2</span>],SSIZE);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(argc == <span class="Constant">4</span>)
    {  (<span class="Type">void</span>)strlcpy(heap_tag,argv[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(heap_file_name,argv[<span class="Constant">3</span>],SSIZE);

       <span class="Statement">if</span>(strcmp(argv[<span class="Constant">4</span>],<span class="Constant">&quot;LIVE&quot;</span>) == <span class="Constant">0</span>)
          h_mode = LIVE;
       <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[<span class="Constant">4</span>],<span class="Constant">&quot;DEAD&quot;</span>) == <span class="Constant">0</span>)
          h_mode = DEAD;
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: heap &lt;PSRP dispatch name&gt; !map mode! [&lt;persistent heap file name&gt;] [LIVE | DEAD]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
          <span class="Statement">return</span>(PSRP_OK);
       }
    }

    (<span class="Type">void</span>)psrp_attach_persistent_heap(TRUE,
                                      heap_tag,
                                      heap_file_name,
				      h_mode);

    <span class="Statement">return</span>(PSRP_OK);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Attach a dynamic function to the dispatch list of the current process </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_attach_dynamic_function(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> object_tag[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         object_tag_DLL[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;dll&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(!(psrp_bind_status &amp; PSRP_DYNAMIC_FUNCTION))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  <span class="Type">char</span> date[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): permission denied (attach dynamic function)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                            date,appl_name,appl_pid,appl_host);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Permission denied (attach dynamic function)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span> || argc &gt; <span class="Constant">3</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: dll &lt;PSRP dispatch name&gt; [&lt;object DLL&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">3</span>)
    {  (<span class="Type">void</span>)strlcpy(object_tag,argv[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(object_tag_DLL,argv[<span class="Constant">2</span>],SSIZE);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(object_tag_DLL,argv[<span class="Constant">1</span>],SSIZE);

    <span class="Statement">if</span>(access(object_tag_DLL,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;cannot find DLL </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,object_tag,object_tag_DLL);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(psrp_attach_dynamic_function(TRUE,
                                         object_tag,
                                         object_tag_DLL) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;error attaching </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (from DLL </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,object_tag,object_tag_DLL);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;dynamic function </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> attached (from DLL </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                            object_tag,object_tag_DLL);
    <span class="Statement">return</span>(PSRP_OK);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Start the next segment of a multisegment server - If host is non null then </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> start the new segment on that host and call it name. If we have a          </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> checkpoint file restart using the checkpoint stored in that file           </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SSH_SUPPORT</span>
_PUBLIC <span class="Type">int</span> psrp_new_segment(<span class="Type">const</span> <span class="Type">char</span> *name,             <span class="Comment">// Name of process</span>
                             <span class="Type">const</span> <span class="Type">char</span> *host_name,        <span class="Comment">// Name of new host</span>
                             <span class="Type">const</span> <span class="Type">char</span> *ssh_port,         <span class="Comment">// Ssh port number to use </span>
                             <span class="Type">const</span> <span class="Type">char</span> *ckpt_file_name)   <span class="Comment">// CRIU checkpoint associated with process</span>
<span class="PreProc">#else</span>
_PUBLIC <span class="Type">int</span> psrp_new_segment(<span class="Type">const</span> <span class="Type">char</span> *name,             <span class="Comment">// Name of process</span>
                             <span class="Type">const</span> <span class="Type">char</span> *host_name,        <span class="Comment">// Name of new host</span>
                             <span class="Type">const</span> <span class="Type">char</span> *ckpt_file_name)   <span class="Comment">// CRIU checkpoint associated with process</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
{   <span class="Type">int</span> i,
        ssh_pid;

    sigset_t set;

    <span class="Type">char</span> line[SSIZE]               = <span class="Constant">&quot;&quot;</span>,
         command_line[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         cmd_tail[SSIZE]           = <span class="Constant">&quot;&quot;</span>,
         p_name[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         autoload_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         exec_pathname[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         ckpt_restart[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         errstr[SSIZE]             = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_new_segment] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure that we ignore any yields from (multiple) clients until we have  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> finished segmentation.                                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

    in_psrp_new_segment = TRUE;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save dispatch table so any aliases defined by this segment are passed to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the next.                                                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_psrp_save == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Save the names of those objects which are to be automatically  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> loaded at the next invocation of this server                   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(getuid() != <span class="Constant">0</span>)
          (<span class="Type">void</span>)snprintf(autoload_file_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.</span><span class="Special">%s</span><span class="Constant">.psrp&quot;</span>,appl_home,name);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(autoload_file_name,SSIZE,<span class="Constant">&quot;/</span><span class="Special">%s</span><span class="Constant">.psrp&quot;</span>,name);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): saving PSRP dispatch table (to [default] PSRP resource file </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner,autoload_file_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       psrp_save_dispatch_table(autoload_file_name);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure that we don't catch any signals until the new segment of the PSRP </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> server is up and running.                                                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't raise SIGALRM during the segmentation process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_malarm(<span class="Constant">0</span>);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGALRM</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);

    <span class="Statement">if</span>(host_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pups_sighandle(SIGINIT,  (<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)pups_sighandle(SIGCHAN,  (<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)pups_sighandle(SIGPSRP,  (<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)pups_sighandle(SIGALIVE, (<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGCHLD</span>,  (<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>,   (<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
       (<span class="Type">void</span>)pups_sighandle(SIGCLIENT,(<span class="Type">char</span> *)<span class="Constant">NULL</span>, <span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Make sure all PUPS signals are serviced (while ignored)  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> this stops spurious signals when the next segment starts </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)sigemptyset(&amp;set);
       (<span class="Type">void</span>)sigaddset(&amp;set,SIGINIT);
       (<span class="Type">void</span>)sigaddset(&amp;set,SIGCHAN);
       (<span class="Type">void</span>)sigaddset(&amp;set,SIGPSRP);
       (<span class="Type">void</span>)sigaddset(&amp;set,SIGALIVE);
       (<span class="Type">void</span>)sigaddset(&amp;set,<span class="Constant">SIGALRM</span>);
       (<span class="Type">void</span>)sigaddset(&amp;set,<span class="Constant">SIGINT</span>);
       (<span class="Type">void</span>)sigaddset(&amp;set,<span class="Constant">SIGCHLD</span>);
       (<span class="Type">void</span>)sigaddset(&amp;set,SIGCLIENT);

       (<span class="Type">void</span>)pups_sigprocmask(SIG_UNBLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build command and overlay current process using execls </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    pups_argtline(cmd_tail);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the user has specified a name for the new segment </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> make sure that it answers to it!                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(p_name,name,SSIZE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(p_name,appl_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Expand command pathname </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_bin_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(appl_bin_name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Type">char</span> stripped_bin_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Need to strip path leading to binname </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((<span class="Type">char</span> *)rindex(appl_bin_name,<span class="Constant">'/'</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)strlcpy(tmpstr,(<span class="Type">char</span> *)rindex(appl_bin_name,<span class="Constant">'/'</span>),SSIZE);
          (<span class="Type">void</span>)strlcpy(stripped_bin_name,&amp;tmpstr[<span class="Constant">1</span>],SSIZE);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(stripped_bin_name,appl_bin_name,SSIZE);

       <span class="Statement">if</span>(strccpy(exec_pathname,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,stripped_bin_name)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ENOENT</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strccpy(exec_pathname,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,appl_name)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ENOENT</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB APPL BIN NAME: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_bin_name);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> &quot;PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We must have absolute command paths </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(exec_pathname[<span class="Constant">0</span>] == <span class="Constant">'.'</span> &amp;&amp; exec_pathname[<span class="Constant">1</span>] == <span class="Constant">'/'</span>)
    {  <span class="Type">char</span> cwd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)getcwd(cwd,SSIZE);
       (<span class="Type">void</span>)strlcat(cwd,&amp;exec_pathname[<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(exec_pathname,cwd,SSIZE);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(exec_pathname[<span class="Constant">0</span>] == <span class="Constant">'.'</span> &amp;&amp; exec_pathname[<span class="Constant">1</span>] == <span class="Constant">'.'</span>)
    {  <span class="Type">char</span> uwd[SSIZE] = <span class="Constant">&quot;&quot;</span>,
            cwd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)getcwd(cwd,SSIZE);
       (<span class="Type">void</span>)chdir(<span class="Constant">&quot;..&quot;</span>);
       (<span class="Type">void</span>)getcwd(uwd,SSIZE);
       (<span class="Type">void</span>)strlcat(uwd,&amp;exec_pathname[<span class="Constant">2</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(exec_pathname,uwd,SSIZE);
       (<span class="Type">void</span>)chdir(cwd);
    }


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is the new instance on a remote node? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(host_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(host_name,<span class="Constant">&quot;localhost&quot;</span>) != <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Build command to start new instance </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(command_line,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -pen </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> -psrp_segment </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> &gt;&amp; /dev/null&quot;</span>,exec_pathname,
                                                                                          p_name,
                                                                                    ckpt_restart,
                                                                                  ++psrp_seg_cnt,
                                                                                        cmd_tail);



       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((ssh_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
       {  <span class="Type">char</span> sshPortOpt[SSIZE] = <span class="Constant">&quot;&quot;</span>;


          <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Close files </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_closeall();

          (<span class="Type">void</span>)close(<span class="Constant">0</span>);
          (<span class="Type">void</span>)close(<span class="Constant">1</span>);
          (<span class="Type">void</span>)close(<span class="Constant">2</span>);


          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Are we using non-standard port? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ssh_port != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(ssh_port,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)snprintf(sshPortOpt,SSIZE,<span class="Constant">&quot;-p </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssh_port);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)snprintf(sshPortOpt,SSIZE,<span class="Constant">&quot;-p </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssh_remote_port);


          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We are not using passwords. You will </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> need to generate a public/private    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> keyset for this to work              </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ssh_compression == TRUE)
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-C&quot;</span>,<span class="Constant">&quot;-l&quot;</span>,ssh_remote_uname,host_name,command_line,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)execlp(<span class="Constant">&quot;ssh&quot;</span>,<span class="Constant">&quot;ssh&quot;</span>,sshPortOpt,<span class="Constant">&quot;-l&quot;</span>,     ssh_remote_uname,host_name,command_line,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an error has occured </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          _exit(<span class="Constant">255</span>);
       }

       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
       {  <span class="Type">int</span> status = <span class="Constant">0</span>;


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If the remote end of the ssh connection is still    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> running after 5 seconds  we can assume that command </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> is successfully running on remote server            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_sleep(<span class="Constant">1</span>);

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB SSH EXEC WAITPID: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,waitpid(ssh_pid,&amp;status, WNOHANG));
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


          <span class="Statement">if</span>(waitpid(ssh_pid,&amp;status, WNOHANG) == (-<span class="Constant">1</span>))
          {

<span class="PreProc">             #ifdef PSRPLIB_DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB SSH EXEC FAILED</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

             <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to create remote (ssh tunnel) channel [to host </span><span class="Special">%s</span><span class="Constant">] (could not exec ssh)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                   date,appl_name,appl_pid,appl_host,appl_owner,host_name);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }

             (<span class="Type">void</span>)pups_malarm(<span class="Constant">1</span>);
             in_psrp_new_segment = FALSE;
             pups_set_errno(<span class="Constant">ENOEXEC</span>);

             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }
          <span class="Statement">else</span>
          {
<span class="PreProc">             #ifdef PSRPLIB_DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB SSH EXEC GOOD</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Delay is a kludge - we have      </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> to make sure command has started </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> at remote end before we stop ssh </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)pups_sleep(segmentation_delay);


             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Kill hanging instance of ssh     </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> on local host                    </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)kill(ssh_pid,<span class="Constant">SIGTERM</span>);
          }

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Tell clients that a server change is pending </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)psrp_reactivate_clients();
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we are segmenting parent effectively must delete   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> PSRP channels and then create a regular file (whose   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> name is the same as the input channel) which contains </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> a &quot;trail&quot; to the new location of the server           </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>


<span class="PreProc">       #ifdef PSRPLIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB TERMINATE CURRENT INSTANCE: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,terminate_current_instance);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(terminate_current_instance == TRUE)
       {  <span class="Type">char</span> trailfile_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


<span class="PreProc">           #ifdef PSRPLIB_DEBUG</span>
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB CREATING TRAILFILE</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Make sure that remote invocation can read PSRP initialisation </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> file (assuming it can see the same filesystem as exec host)   </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(appl_name,p_name,SSIZE);
          (<span class="Type">void</span>)snprintf(trailfile_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.trail&quot;</span>,channel_name_out);
          (<span class="Type">void</span>)psrp_create_trailfile(trailfile_name,p_name,host_name,ssh_remote_port);


           <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Parent exits leaving trail to its migrated child </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

           pups_exit(<span class="Constant">0</span>);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Build command to start new instance </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(n_clients &gt; <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have attached client(s) -- we must arrange for them to be re-awakened  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> once our child segment is ready to deal with them                            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)snprintf(command_line,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -pen </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> -psrp_segment </span><span class="Special">%d</span><span class="Constant"> -psrp_reactivate_client </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,
                                                                                      exec_pathname,
                                                                                             p_name,
                                                                                       ckpt_restart,
                                                                                     ++psrp_seg_cnt,
                                                                                          chlockdes,
                                                                                           cmd_tail);
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> No attached clients </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)snprintf(command_line,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> -pen </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> -psrp_segment </span><span class="Special">%d</span><span class="Constant">&quot;</span>,
	                                                exec_pathname,
					                       p_name,
					                 ckpt_restart,
						       ++psrp_seg_cnt);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Local segmentation (parent is overlaid by child) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(terminate_current_instance == TRUE)
       {

          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Make sure PSRP FIFOS are clean for new instance </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(psrp_in != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)empty_fifo(fileno(psrp_in));

          <span class="Statement">if</span>(psrp_out != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)empty_fifo(fileno(psrp_out));


          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Overlay new segment on local process</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_closeall();


          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> PSRP server is changing its name </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strcmp(appl_name,p_name) != <span class="Constant">0</span> &amp;&amp; appl_default_chname == TRUE)
          {

             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If we are changing name we need to rename old PSRP </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> channels and lockposts and tell clients that a     </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> server change is pending                           </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(psrp_rename_channel(p_name) == (-<span class="Constant">1</span>))
                <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> PSRP server is keeping its name </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {

            <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Tell clients that a server change is pending </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

            (<span class="Type">void</span>)psrp_reactivate_clients();
          }

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB EXECLS: %s\n<span class="Constant">&quot;,command_line);</span>
<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">          #endif /* PSRPLIB_DEBUG */</span>


<span class="Constant">          /*-------------------------------------*/</span>
<span class="Constant">          /* We should not return from this call */</span>
<span class="Constant">          /*-------------------------------------*/</span>

<span class="Constant">          (void)pups_execls(command_line);</span>
<span class="Constant"> </span>
<span class="Constant">          (void)snprintf(errstr,SSIZE,&quot;</span>[psrp_new_segment] exec failure (%s)\n<span class="Constant">&quot;,command_line);</span>
<span class="Constant">          pups_error(errstr);</span>
<span class="Constant">       }</span>
<span class="Constant">       else</span>
<span class="Constant">       {  int child_pid = (-1);</span>


<span class="Constant">          /*-------------------------------------*/</span>
<span class="Constant">          /* Build command to start new instance */</span>
<span class="Constant">          /*-------------------------------------*/</span>

<span class="Constant">          (void)snprintf(command_line,SSIZE,&quot;</span>%s -pen %s %s -psrp_segment %d<span class="Constant">&quot;,</span>
<span class="Constant">                                                        exec_pathname,</span>
<span class="Constant">                                                               p_name,</span>
<span class="Constant">                                                         ckpt_restart,</span>
<span class="Constant">                                                       ++psrp_seg_cnt);</span>

<span class="Constant">          #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">          (void)fprintf(stderr,&quot;</span>PSRPLIB NEW INSTANCE COMAMND LINE is: %s\n<span class="Constant">&quot;,command_line);</span>
<span class="Constant">          (void)fflush(stderr);</span>
<span class="Constant">          #endif /* PSRPLIB_DEBUG */</span>


<span class="Constant">          /*---------------------------------------*/</span>
<span class="Constant">          /* Local fork (parent is not terminated) */ </span>
<span class="Constant">          /*---------------------------------------*/</span>

<span class="Constant">          if((child_pid = pups_fork(FALSE,FALSE)) == 0)</span>
<span class="Constant">          {</span>

<span class="Constant">             /*---------------------------------------*/</span>
<span class="Constant">             /* Overlay new segment on local process. */</span>
<span class="Constant">             /* and run in new session                */</span>
<span class="Constant">             /*---------------------------------------*/</span>

<span class="Constant">             (void)fclose(stdin);</span>
<span class="Constant">             stdin = fopen(&quot;</span>/dev/tty<span class="Constant">&quot;,&quot;</span>r<span class="Constant">&quot;);</span>

<span class="Constant">             (void)fclose(stdout);</span>
<span class="Constant">             stdout = fopen(&quot;</span>/dev/tty<span class="Constant">&quot;,&quot;</span>w<span class="Constant">&quot;);</span>

<span class="Constant">             (void)fclose(stderr);</span>
<span class="Constant">             stderr = fopen(&quot;</span>/dev/tty<span class="Constant">&quot;,&quot;</span>w<span class="Constant">&quot;);</span>

<span class="Constant">             (void)pups_closeall();</span>
<span class="Constant">             (void)setsid();</span>


<span class="Constant">             /*-------------------------------------*/</span>
<span class="Constant">             /* We should not return from this call */</span>
<span class="Constant">             /*-------------------------------------*/</span>

<span class="Constant">             (void)pups_execls(command_line);</span>

<span class="Constant">             (void)snprintf(errstr,SSIZE,&quot;</span>[psrp_new_segment] exec failure (%s)\n<span class="Constant">&quot;,command_line);</span>
<span class="Constant">             pups_error(errstr);</span>
<span class="Constant">          }</span>

<span class="Constant">          if(appl_verbose == TRUE)</span>
<span class="Constant">          {  (void)strdate(date);</span>
<span class="Constant">             (void)fprintf(stderr,&quot;</span>%s %s (%d@%s:%s): new instance \<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">) created</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                           date,appl_name,appl_pid,appl_host,appl_owner,name,child_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          (<span class="Type">void</span>)pups_malarm(<span class="Constant">1</span>);
          in_psrp_new_segment = FALSE;

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    (<span class="Type">void</span>)pups_malarm(<span class="Constant">1</span>);
    in_psrp_new_segment = FALSE;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No error if current instance is still running </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(terminate_current_instance == FALSE)
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    <span class="Statement">else</span>
       pups_set_errno(<span class="Constant">ENOEXEC</span>);

    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send end of operation (return code) to client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> this is the psrp service return code          </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_endop(<span class="Type">char</span> *op_tag)

{

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB ENDOP BEGIN </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,op_tag);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(op_tag == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;EOP</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;EOP </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,op_tag);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;&quot;</span>PSRPLIB ENDOP FLUSH %s\n<span class="Constant">&quot;,op_tag);</span>
<span class="Constant">    (void)fflush(stderr);</span>
<span class="Constant">    #endif /* PSRPLIB_DEBUG */</span>

<span class="Constant">    (void)fflush(psrp_out);</span>

<span class="Constant">    #ifdef PSRPLIB_DEBUG</span>
<span class="Constant">    (void)fprintf(stderr,&quot;&quot;PSRPLIB ENDOP: </span><span class="Special">%s</span><span class="Constant"> written</span><span class="Special">\n</span><span class="Constant">&quot;</span>,op_tag);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>

}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Return number of clients connected to server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_connected_clients(<span class="Type">void</span>)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search for client in table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_clients &gt; <span class="Constant">0</span>)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CLIENTS; ++i)
          <span class="Statement">if</span>(psrp_client_pid[i] != (-<span class="Constant">1</span>))
             ++cnt;
    }

    <span class="Statement">return</span>(cnt);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get current client index - if the current client pid is in the channel    </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> table, return the corresponding index, if it isn't, and the channel table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> is not full return a new index, otherwise return error (ENOCH)            </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_get_client_slot(<span class="Type">int</span> pid)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search for client in table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_clients &gt; <span class="Constant">0</span>)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CLIENTS; ++i)
          <span class="Statement">if</span>(psrp_client_pid[i] == pid)
             <span class="Statement">return</span>(i);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find unused slot in table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CLIENTS; ++i)
    {  <span class="Statement">if</span>(psrp_client_pid[i] == (-<span class="Constant">1</span>))
       {  ++n_clients;
          <span class="Statement">return</span>(i);
       }
    }

    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Table full - return error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">return</span>(ENOCH);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Clear current client entry in client table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_clear_client_slot(<span class="Type">int</span> slot_index)

{  <span class="Statement">if</span>(slot_index &lt; <span class="Constant">0</span> || slot_index &gt; MAX_CLIENTS)
      <span class="Statement">return</span>(-<span class="Constant">1</span>);

   psrp_client_exitf[slot_index] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
   psrp_client_pid[slot_index]   = (-<span class="Constant">1</span>);
   req_r_cnt[slot_index]         = <span class="Constant">0</span>;

   (<span class="Type">void</span>)strlcpy(psrp_client_name[slot_index],    <span class="Constant">&quot;none&quot;</span>,SSIZE);
   (<span class="Type">void</span>)strlcpy(psrp_client_efname[slot_index],  <span class="Constant">&quot;none&quot;</span>,SSIZE);
   (<span class="Type">void</span>)strlcpy(psrp_client_host[slot_index],    <span class="Constant">&quot;none&quot;</span>,SSIZE);
   (<span class="Type">void</span>)strlcpy(old_request_str[slot_index],     <span class="Constant">&quot;&quot;</span>,SSIZE);
   (<span class="Type">void</span>)strlcpy(psrp_remote_hostpath[slot_index],<span class="Constant">&quot;notset&quot;</span>,SSIZE);

   --n_clients;
   <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show clients connected to this server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_show_clients(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Clients attached to </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CLIENTS; ++i)
    {  <span class="Statement">if</span>(psrp_client_pid[i] &gt; <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,i,psrp_client_name[i],psrp_client_pid[i],psrp_client_host[i]);

          <span class="Statement">if</span>(psrp_client_pid[i] == psrp_client_pid[c_client])
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    [*** me, your client]&quot;</span>);

          <span class="Statement">if</span>(strcmp(psrp_remote_hostpath[i],<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    [from </span><span class="Special">%s</span><span class="Constant">]&quot;</span>,psrp_remote_hostpath[i]);

          <span class="Statement">if</span>((<span class="Type">void</span> *)psrp_client_exitf[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;    (exit function </span><span class="Special">\&quot;</span><span class="Special">%032s</span><span class="Special">\&quot;</span><span class="Constant"> installed at </span><span class="Special">%016lx</span><span class="Constant"> virtual)&quot;</span>,
                                                                          psrp_client_efname[i],
                                                        (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)psrp_client_exitf[i]);

          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
        }
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Total of </span><span class="Special">%d</span><span class="Constant"> client(s) currently attached to server</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_clients);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Read reply over slaved interaction clients channel </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_read_sic(<span class="Type">const</span> psrp_channel_type *sic, <span class="Type">char</span> *reply)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;IN READ SIC</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_read_sic] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(reply == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || sic == (<span class="Type">const</span> psrp_channel_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;CAN READ SIC</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Buffer in which reply is accumulated MUST be NULL </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> as we are going to dynamically allocate it. The   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> caller is responsible for freeing up the memory   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> used                                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read data from channel until we get an EOT or </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> other error condition                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fgets(reply,<span class="Constant">255</span>,sic-&gt;out_stream);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;READ SIC (reply is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,reply);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check for error conditions                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> EOG - end of current PSRP transaction group </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strncmp(reply,<span class="Constant">&quot;EOT&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(PSRP_EOT);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> CST - remote peer has terminated (unexpectedly) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strncmp(reply,<span class="Constant">&quot;CST&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(PSRP_TERMINATED);
    }

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;READ SIC: OK</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(PSRP_MORE);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send request over slaved interaction clients channel </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_write_sic(<span class="Type">const</span> psrp_channel_type *sic, <span class="Type">const</span> <span class="Type">char</span> *request)

{   <span class="Type">char</span> toxic_1[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         toxic_2[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         toxic_3[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_write_sic] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(sic == (<span class="Type">const</span> psrp_channel_type *)<span class="Constant">NULL</span> || request == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that channel is open </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(toxic_1,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,                    appl_name);
    (<span class="Type">void</span>)snprintf(toxic_2,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">@localhost&quot;</span>,appl_name,appl_host);
    (<span class="Type">void</span>)snprintf(toxic_2,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">&quot;</span>,       appl_name,appl_host);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Self interaction via SIC is very toxic -- don't do it! </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(request,toxic_1) == TRUE || strin(request,toxic_2) == TRUE)
    {  <span class="Type">int</span>  ret;
       <span class="Type">char</span> reply[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)fputs(<span class="Constant">&quot;end</span><span class="Special">\n</span><span class="Constant">&quot;</span>,sic-&gt;in_stream);
       (<span class="Type">void</span>)fflush(sic-&gt;in_stream);


       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Read reply </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

       <span class="Statement">do</span> {    <span class="Statement">if</span>((ret = psrp_read_sic(sic,reply)) == PSRP_MORE)
               {  (<span class="Type">void</span>)fputs(reply,psrp_out);
                  (<span class="Type">void</span>)fflush(psrp_out);
               }
          } <span class="Statement">while</span>(ret == PSRP_MORE);

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">2</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Send request </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(request,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>) == FALSE)
       (<span class="Type">void</span>)strlcat(request,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>,SSIZE);

    (<span class="Type">void</span>)fputs(request,sic-&gt;in_stream);
    (<span class="Type">void</span>)fflush(sic-&gt;in_stream);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set current PSRP interaction channel </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_set_current_sic(<span class="Type">const</span> psrp_channel_type *sic)

{
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_set_current_sic] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(sic == (<span class="Type">const</span> psrp_channel_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    psrp_current_sic = sic;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Unset current PSRP interaction channel </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_unset_current_sic(<span class="Type">void</span>)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_unset_current_sic] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    psrp_current_sic = (psrp_channel_type *)<span class="Constant">NULL</span>;
}




<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send break to remote server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_int_sic(<span class="Type">const</span> psrp_channel_type *sic)

{   <span class="Type">char</span> pidname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;attempt by non root thread to perform PUPS/P3 PSRP operation (psrp_int_sic)&quot;</span>);

    <span class="Statement">if</span>(sic == (<span class="Type">const</span> psrp_channel_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)snprintf(pidname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,sic-&gt;scp);
    (<span class="Type">void</span>)pups_rkill(sic-&gt;host_name,
                     sic-&gt;ssh_port,
                     appl_owner,
                     pidname,
                     <span class="Constant">SIGINT</span>);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Install an exit function for a PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_set_client_exitf(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> chid, <span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type">int</span> (*func)(<span class="Type">int</span>))

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_set_client_exitf] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(chid &gt; MAX_CLIENTS || fname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || (<span class="Type">void</span> *)func == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)strlcpy(psrp_client_efname[chid],fname,SSIZE);
    psrp_client_exitf[chid] = (<span class="Type">void</span> *)func;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Deinstall an exit function for a PSRP client </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_reset_client_exitf(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> chid)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_reset_client_exitf] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(chid &gt; MAX_CLIENTS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)strlcpy(psrp_client_efname[chid],<span class="Constant">&quot;&quot;</span>,SSIZE);
    psrp_client_exitf[chid] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Overlay the current process with a new comamnd </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_overlay_server_process(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  i;

    <span class="Type">char</span> overlay_command_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         overlay_command_tail[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;overlay&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;usage: overlay &lt;command to overlay&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build command to overlay </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(overlay_command_tail,<span class="Constant">&quot;&quot;</span>,SSIZE);
    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
    {   <span class="Statement">if</span>(i == <span class="Constant">1</span>)
           (<span class="Type">void</span>)strlcpy(overlay_command_name,argv[<span class="Constant">1</span>],SSIZE);
        <span class="Statement">else</span>
        {  (<span class="Type">void</span>)strlcat(overlay_command_tail,argv[i],SSIZE);

           <span class="Statement">if</span>(i &lt; argc - <span class="Constant">1</span>)
              (<span class="Type">void</span>)strlcat(overlay_command_tail,<span class="Constant">&quot; &quot;</span>,SSIZE);
        }
    }

    (<span class="Type">void</span>)psrp_overlay_server_process(FALSE,overlay_command_name,overlay_command_tail);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We should not get here if </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> overlay is successful     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to overlay PSRP server (</span><span class="Special">%s</span><span class="Constant">) [with command </span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,overlay_command_name);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Overlay the current process with a new command </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_overfork_server_process(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  i,
         ret;

    <span class="Type">char</span> overlay_command_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         overlay_command_tail[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;overfork&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &lt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: overfork &lt;command to fork&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build command to overfork </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(overlay_command_tail,<span class="Constant">&quot;&quot;</span>,SSIZE);
    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
    {   <span class="Statement">if</span>(i == <span class="Constant">1</span>)
           (<span class="Type">void</span>)strlcpy(overlay_command_name,argv[<span class="Constant">1</span>],SSIZE);
        <span class="Statement">else</span>
        {  (<span class="Type">void</span>)strlcat(overlay_command_tail,argv[i],SSIZE);

           <span class="Statement">if</span>(i &lt; argc - <span class="Constant">1</span>)
              (<span class="Type">void</span>)strlcat(overlay_command_tail,<span class="Constant">&quot; &quot;</span>,SSIZE);
        }
    }

    <span class="Statement">if</span>(psrp_overlay_server_process(TRUE,overlay_command_name,overlay_command_tail) &lt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">overfork  PSRP server (</span><span class="Special">%s</span><span class="Constant">) [with command </span><span class="Special">%s</span><span class="Constant">] failed - resuming execution</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                 appl_name,overlay_command_name);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">overfork  PSRP server (</span><span class="Special">%s</span><span class="Constant">) [with command </span><span class="Special">%s</span><span class="Constant">] finished - resuming execution</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                   appl_name,overlay_command_name);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Overlay server process with specified command </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_overlay_server_process(<span class="Type">const</span> _BOOLEAN over_fork, <span class="Type">const</span> <span class="Type">char</span> *command_name, <span class="Type">const</span> <span class="Type">char</span> *command_tail)

{   <span class="Type">char</span> command_path[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         command_tail_path[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_overlay_server_process] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Statement">if</span>(command_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || command_tail == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> This command should not return (if it is successful) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strccpy(command_path,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,command_name)) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>(command_tail != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)snprintf(command_tail_path,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,command_path,command_tail);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(command_tail_path,command_path,SSIZE);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Make sure this operation is not interrupted </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> by PUPS signal handlers                     </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_malarm(<span class="Constant">0</span>);
       (<span class="Type">void</span>)pupshold(PSRP_SIGS);

       <span class="Statement">if</span>(over_fork == TRUE)
       {  <span class="Type">int</span> status;

          <span class="Type">char</span> channel_wait_in[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
               channel_wait_out[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          overforking = TRUE;
          <span class="Statement">if</span>((overforked_child_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
          {  (<span class="Type">void</span>)pups_execls(command_tail_path);

             <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to overfork command (</span><span class="Special">%s</span><span class="Constant">) - resuming execution</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                      date,appl_name,appl_pid,appl_host,appl_owner,command_name);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
             exit(<span class="Constant">255</span>);
          }

          (<span class="Type">void</span>)snprintf(channel_wait_in,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.wait&quot;</span>,channel_name_in);
          (<span class="Type">void</span>)rename(channel_name_in,channel_wait_in);
          (<span class="Type">void</span>)snprintf(channel_wait_out,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.wait&quot;</span>,channel_name_out);
          (<span class="Type">void</span>)rename(channel_name_out,channel_wait_out);

          <span class="Statement">while</span>(kill(overforked_child_pid,SIGALIVE) != (-<span class="Constant">1</span>))
          {    (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
               (<span class="Type">void</span>)pupswaitpid(FALSE,overforked_child_pid,&amp;status);
          }

          overforking          = FALSE;
          overforked_child_pid = (-<span class="Constant">1</span>);

          (<span class="Type">void</span>)rename(channel_wait_in, channel_name_in);
          (<span class="Type">void</span>)rename(channel_wait_out,channel_name_out);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overforked command (</span><span class="Special">%s</span><span class="Constant">) has terminated - resuming execution</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                          date,appl_name,appl_pid,appl_host,appl_owner,command_name);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(command_tail_path[<span class="Constant">0</span>] != <span class="Constant">' '</span>)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Reply to client </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;EOT </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,psrp_c_code);
          (<span class="Type">void</span>)fflush(psrp_out);


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Tell client that we have finished processing SIGPSRP </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

          psrp_endop(<span class="Constant">&quot;psrp&quot;</span>);


          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Close channel to existing PSRP command </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

          pups_exit(PUPS_DEFER_EXIT);


          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Overlay new command on current process </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_execls(command_tail_path);


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We should not get here -- if overlay has been successful </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_malarm(<span class="Constant">1</span>);
          pupsrelse(PSRP_SIGS);
          pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)pups_malarm(<span class="Constant">1</span>);
          pupsrelse(PSRP_SIGS);

          pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)pups_malarm(<span class="Constant">1</span>);
       pupsrelse(PSRP_SIGS);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set size of PUPS file table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>


_PRIVATE <span class="Type">int</span> psrp_builtin_extend_ftab(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        n_files;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;ftab&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: files [&lt;maximum number of PUPS file table slots&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS file table slots available for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                        appl_max_files,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) != <span class="Constant">0</span> &amp;&amp; sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_files) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Expecting maximum number of files (in PUPS file table)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_MUTEX </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_files &lt; appl_max_files || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Find the high water mark for the file table </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=appl_max_files-<span class="Constant">1</span>; i&gt;<span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(ftab[i].fdes != (-<span class="Constant">1</span>))
          {  <span class="Type">int</span> j;


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> We have found the high water mark return all memory </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> above it to this processes free pool                </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(j=i; j&lt;appl_max_files; ++j)
                (<span class="Type">void</span>)pups_clear_ftab_slot(TRUE,j);
             appl_max_files = i + <span class="Constant">1</span>;
             ftab = (ftab_type *)pups_realloc((<span class="Type">void</span> *)ftab,appl_max_files*<span class="Statement">sizeof</span>(ftab_type));

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS file table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                  appl_max_files,appl_name);
             (<span class="Type">void</span>)fflush(psrp_out);

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_MUTEX </span><span class="Comment">*/</span>

             <span class="Statement">return</span>(PSRP_OK);
          }
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS file table slots allocated for PSRP server (unchanged)</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                   appl_max_files,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);


<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_MUTEX </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(PSRP_OK);
    }

    ftab           = (ftab_type *)pups_realloc((<span class="Type">void</span> *)ftab,n_files*<span class="Statement">sizeof</span>(ftab_type));
    <span class="Statement">for</span>(i=appl_max_files; i&lt;n_files; ++i)
        (<span class="Type">void</span>)pups_clear_ftab_slot(FALSE,i);
    appl_max_files = n_files;


    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS file table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                         appl_max_files,appl_name);
    (<span class="Type">void</span>)fflush(psrp_out);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_MUTEX </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set size of PUPS virtual timer table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_extend_vitab(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        n_vtimers;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;vitab&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: vitab [&lt;maximum number of PUPS virtual timer table slots&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS virtual timer table slots available for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                               appl_max_vtimers,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) != <span class="Constant">0</span> &amp;&amp; sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_vtimers) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Expecting maximum number of timers (in PUPS virtual timer table)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(n_vtimers &lt; appl_max_vtimers || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Find the high water mark for the virtual timer table </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=appl_max_vtimers-<span class="Constant">1</span>; i&gt;<span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(vttab[i].interval_time != (-<span class="Constant">1</span>))
          {  <span class="Type">int</span> j;


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> We have found the high water mark return all memory </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> above it to this processes free pool                </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(j=i; j&lt;appl_max_vtimers; ++j)
                (<span class="Type">void</span>)pups_clear_vitimer(TRUE,j);
             appl_max_vtimers = i + <span class="Constant">1</span>;
             vttab = (vttab_type *)pups_realloc((<span class="Type">void</span> *)vttab,appl_max_vtimers*<span class="Statement">sizeof</span>(vttab_type));

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS virtual timer table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                         appl_max_vtimers,appl_name);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS virtual timer table slots allocated for PSRP server (unchanged) </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                           appl_max_vtimers,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    vttab = (vttab_type *)pups_realloc((<span class="Type">void</span> *)vttab,n_vtimers*<span class="Statement">sizeof</span>(vttab_type));
    <span class="Statement">for</span>(i=appl_max_vtimers; i&lt;n_vtimers; ++i)
        (<span class="Type">void</span>)pups_clear_vitimer(FALSE,i);
    appl_max_vtimers = n_vtimers;

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS virtual timer table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                appl_max_vtimers,appl_name);
    (<span class="Type">void</span>)fflush(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set size of PUPS child table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_extend_chtab(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        n_children;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;chtab&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: chtab [&lt;maximum number of PUPS child table slots&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS child table slots available for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                         appl_max_child,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) != <span class="Constant">0</span> &amp;&amp; sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_children) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Expecting maximum number of children (in PUPS child table)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_children &lt; appl_max_child || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Find the high water mark for the file table </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=appl_max_child-<span class="Constant">1</span>; i&gt;<span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(chtab[i].pid != (-<span class="Constant">1</span>))
          {  <span class="Type">int</span> j;


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> We have found the high water mark return all memory </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> above it to this processes free pool                </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(j=i; j&lt;appl_max_child; ++j)
                (<span class="Type">void</span>)pups_clear_chtab_slot(TRUE,j);
             appl_max_child = i + <span class="Constant">1</span>;
             chtab = (chtab_type *)pups_realloc((<span class="Type">void</span> *)chtab,appl_max_child*<span class="Statement">sizeof</span>(chtab_type));

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS child table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                   appl_max_child,appl_name);
             (<span class="Type">void</span>)fflush(psrp_out);

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;chtab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             <span class="Statement">return</span>(PSRP_OK);
          }
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS child table slots allocated for PSRP server (unchanged) </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                     appl_max_child,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;chtab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(PSRP_OK);
    }

    chtab = (chtab_type *)pups_realloc((<span class="Type">void</span> *)chtab,n_children*<span class="Statement">sizeof</span>(chtab_type));
    <span class="Statement">for</span>(i=appl_max_files; i&lt;n_children; ++i)
        (<span class="Type">void</span>)pups_clear_chtab_slot(FALSE,i);
    appl_max_child = n_children;

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS child table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                          appl_max_child,appl_name);
    (<span class="Type">void</span>)fflush(psrp_out);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Extend PUPS persistent heap table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_extend_htab(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> n_pheaps;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;htab&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: htab [&lt;maximum number of PUPS persistent heap table slots&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS persistent heap table slots available for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                 appl_max_pheaps,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_pheaps) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Expecting maximum number of heaps (in PUPS persistent heap table)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(n_pheaps &lt; appl_max_pheaps)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Cannot shrink PUPS persistent heap table</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    msm_extend(appl_max_pheaps,n_pheaps);
    appl_max_pheaps = n_pheaps;

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS persistent heap table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                  appl_max_pheaps,appl_name);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>




<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Extend PUPS orifice [DLL] table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_extend_ortab(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        n_orifices;

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">0</span>],<span class="Constant">&quot;ortab&quot;</span>) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: ortab [&lt;maximum number of PUPS orifice [DLL] table slots&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS orifice [DLL] table slots available for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                              appl_max_orifices,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) != <span class="Constant">0</span> &amp;&amp; sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_orifices) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Expecting maximum number of orifices (in PUPS orifice [DLL] table)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(n_orifices &lt; appl_max_orifices || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;shrink&quot;</span>) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Find the high water mark for the file table </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=appl_max_orifices-<span class="Constant">1</span>; i&gt;<span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(ortab[i].orifice_handle == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  <span class="Type">int</span> j;


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> We have found the high water mark return all memory </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> above it to this processes free pool                </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">for</span>(j=i; j&lt;appl_max_orifices; ++j)
                 (<span class="Type">void</span>)clear_ortab_slot(TRUE,j);
             appl_max_orifices = i + <span class="Constant">1</span>;
             ortab = (ortab_type *)pups_realloc((<span class="Type">void</span> *)ortab,appl_max_orifices*<span class="Statement">sizeof</span>(ortab_type));

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS orifice [DLL] table slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                        appl_max_orifices,appl_name);
             (<span class="Type">void</span>)fflush(psrp_out);
             <span class="Statement">return</span>(PSRP_OK);
          }
       }

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS orifice [DLL] table slots allocated for PSRP server (unchanged) </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                                          appl_max_orifices,appl_name);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    ortab           = (ortab_type *)pups_realloc((<span class="Type">void</span> *)ortab,n_orifices*<span class="Statement">sizeof</span>(ortab_type));
    <span class="Statement">for</span>(i=appl_max_orifices; i&lt;n_orifices; ++i)
        clear_ortab_slot(FALSE,i);
    appl_max_orifices = n_orifices;

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%d</span><span class="Constant"> PUPS orifice [DLL] slots now allocated for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,
                                                                         appl_max_orifices,appl_name);
    (<span class="Type">void</span>)fflush(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Check process circadian activity (crontab) schedule </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_crontab_checkschedule(<span class="Type">char</span> *args)

{   <span class="Type">int</span> i,
        local_s;

    <span class="Type">time_t</span> t,
           tdum;

    <span class="Type">struct</span> tm *local_time = (<span class="Type">struct</span> tm *)<span class="Constant">NULL</span>;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CRON_SLOTS; ++i)
    {  <span class="Statement">if</span>(crontab[i].from != (-<span class="Constant">1</span>) &amp;&amp; crontab[i].to != (-<span class="Constant">1</span>))
       {  t = time(&amp;tdum);
          local_time = localtime(&amp;t);


          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Should we be awake? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(crontab[i].overnight == TRUE)
             local_s = local_time-&gt;tm_hour*<span class="Constant">3600</span>  + local_time-&gt;tm_min*<span class="Constant">60</span>    + local_time-&gt;tm_sec;
          <span class="Statement">else</span>
             local_s = local_time-&gt;tm_mday*<span class="Constant">86400</span> + local_time-&gt;tm_hour*<span class="Constant">3600</span> + local_time-&gt;tm_min*<span class="Constant">60</span> + local_time-&gt;tm_sec;

          <span class="Statement">if</span>(crontab[i].from &gt;= local_s &amp;&amp; crontab[i].to &lt; local_s)
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> ($d@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): scheduling crontab event </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,i,crontab[i].fname);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }


             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If the entry in the crontab has no computational payload </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> simply sleep for the requisite period                    </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(crontab[i].func == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             {  <span class="Statement">do</span> {   (<span class="Type">void</span>)pups_usleep(<span class="Constant">1000000</span>);

                       t = time(&amp;tdum);
                       local_time = localtime(&amp;t);


                       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
                       <span class="Comment">/*</span><span class="Comment"> Should we be awake? </span><span class="Comment">*/</span>
                       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

                       <span class="Statement">if</span>(crontab[i].overnight == TRUE)
                          local_s = local_time-&gt;tm_hour*<span class="Constant">3600</span>  + local_time-&gt;tm_min*<span class="Constant">60</span>    + local_time-&gt;tm_sec;
                       <span class="Statement">else</span>
                          local_s = local_time-&gt;tm_mday*<span class="Constant">86400</span> + local_time-&gt;tm_hour*<span class="Constant">3600</span> + local_time-&gt;tm_min*<span class="Constant">60</span> + local_time-&gt;tm_sec;
                   } <span class="Statement">while</span>(crontab[i].from &gt;= local_s &amp;&amp; crontab[i].to &lt; local_s);
             }
             <span class="Statement">else</span>
             {

                <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Launch computational payload  - note we pass the </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> payload function its crontab slot so it can stop </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

                (*crontab[i].func)(i);
             }

             <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> ($d@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): crontab event </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) finished</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,i,crontab[i].fname);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }
       }
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Enter a scheduled activity into crontab table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_crontab_schedule(<span class="Type">const</span> <span class="Type">char</span> *from, <span class="Type">const</span> <span class="Type">char</span> *to, <span class="Type">const</span> <span class="Type">char</span> *fname, <span class="Type">const</span> <span class="Type">void</span> *func)

{   <span class="Type">int</span> i,
        to_h,
        to_m,
        to_d,
        from_h,
        from_m,
        from_d,
        to_s,
        from_s,
        ctab_index;

    _BOOLEAN do_from_now = FALSE;

    <span class="Type">time_t</span> t,
           tdum;

    <span class="Type">struct</span> tm *local_time = (<span class="Type">struct</span> tm *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> sfrom[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         sto[SSIZE]   = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_crontab_schedule] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(from  == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       to    == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       fname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       func  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find a free slot in the crontab data structure </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CRON_SLOTS; ++i)
       <span class="Statement">if</span>(strcmp(crontab[i].fname,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
       {  ctab_index = i;
          <span class="Statement">goto</span> cronslot_found;
       }

    pups_set_errno(<span class="Constant">ENOMEM</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);

<span class="Statement">cronslot_found</span>:


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have a free crontab slot -- add schedule information </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to it.                                                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(from); ++i)
       <span class="Statement">if</span>(from[i] == <span class="Constant">':'</span>)
          sfrom[i] = <span class="Constant">' '</span>;
       <span class="Statement">else</span>
          sfrom[i] = from[i];

    <span class="Statement">if</span>(strcmp(sfrom,<span class="Constant">&quot;now&quot;</span>) == <span class="Constant">0</span>)
    {  t = time(&amp;tdum);
       local_time = localtime(&amp;t);

       from_d = local_time-&gt;tm_mday;
       from_h = local_time-&gt;tm_hour;
       from_m = local_time-&gt;tm_min;

       do_from_now = TRUE;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(sfrom,<span class="Constant">&quot;</span><span class="Special">%d%d%d</span><span class="Constant">&quot;</span>,&amp;from_d,&amp;from_h,&amp;from_m) != <span class="Constant">3</span>)
    {  <span class="Statement">if</span>(sscanf(sfrom,<span class="Constant">&quot;</span><span class="Special">%d%d</span><span class="Constant">&quot;</span>,&amp;from_h,&amp;from_m) != <span class="Constant">2</span>)
       {  pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       from_d = <span class="Constant">0</span>;
    }

    <span class="Statement">if</span>(from_h &lt; <span class="Constant">0</span> || from_h &gt; <span class="Constant">24</span> || from_m &lt; <span class="Constant">0</span> || from_m &gt; <span class="Constant">60</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(to); ++i)
       <span class="Statement">if</span>(to[i] == <span class="Constant">':'</span>)
          sto[i] = <span class="Constant">' '</span>;
       <span class="Statement">else</span>
          sto[i] = to[i];

    <span class="Statement">if</span>(strcmp(to,<span class="Constant">&quot;forever&quot;</span>) == <span class="Constant">0</span>)
       to_s = <span class="Constant">INT_MAX</span>;
    <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(sto,<span class="Constant">&quot;</span><span class="Special">%d%d%d</span><span class="Constant">&quot;</span>,&amp;to_d,&amp;to_h,&amp;to_m) != <span class="Constant">3</span>)
    {  <span class="Statement">if</span>(sscanf(sto,<span class="Constant">&quot;</span><span class="Special">%d%d</span><span class="Constant">&quot;</span>,&amp;to_h,&amp;to_m) != <span class="Constant">2</span>)
       {  pups_set_errno(<span class="Constant">EINVAL</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       <span class="Statement">if</span>(do_from_now == TRUE)
          to_d = local_time-&gt;tm_mday;
       <span class="Statement">else</span>
          to_d = <span class="Constant">0</span>;
    }

    <span class="Statement">if</span>(to_h &lt; <span class="Constant">0</span> || to_h &gt; <span class="Constant">24</span> || to_m &lt; <span class="Constant">0</span> || to_m &gt; <span class="Constant">60</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(from_d == <span class="Constant">0</span> &amp;&amp; to_d != <span class="Constant">0</span> || from_d != <span class="Constant">0</span> &amp;&amp; to_d == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(from_h &gt; to_h)
    {  t = time(&amp;tdum);
       local_time = localtime(&amp;t);
       from_d = local_time-&gt;tm_mday;
       to_d   = from_d + <span class="Constant">1</span>;

       crontab[ctab_index].overnight = TRUE;
    }
    <span class="Statement">else</span>
       crontab[ctab_index].overnight = FALSE;

    from_s = from_d*<span class="Constant">86400</span> + from_h*<span class="Constant">3600</span> + from_m*<span class="Constant">60</span>;
    to_s   = to_d* <span class="Constant">86400</span>  + to_h*<span class="Constant">3600</span>   + to_m*<span class="Constant">60</span>;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We can finally add the time data to the crontab slot </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    crontab[ctab_index].from  = from_s;
    crontab[ctab_index].to    = to_s;
    crontab[ctab_index].func  = func;
    (<span class="Type">void</span>)strlcpy(crontab[ctab_index].fname,fname,SSIZE);
    (<span class="Type">void</span>)strlcpy(crontab[ctab_index].fromdate,from,SSIZE);
    (<span class="Type">void</span>)strlcpy(crontab[ctab_index].todate  ,to,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(crontab[ctab_index].func  == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): [crontab slot </span><span class="Special">%d</span><span class="Constant">] inactivity scheduled between </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                date,appl_name,appl_pid,appl_host,appl_owner,ctab_index,from,to);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): [crontab slot </span><span class="Special">%d</span><span class="Constant">]  </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) scheduled between </span><span class="Special">%s</span><span class="Constant"> and </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                      date,appl_name,appl_pid,appl_host,appl_owner,ctab_index,fname,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)func,from,to);

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Unschedule a crontab slot </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_crontab_unschedule(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> ctab_index)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_crontab_unschedule] mattempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(ctab_index &gt;= MAX_CRON_SLOTS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(crontab[ctab_index].from != (-<span class="Constant">1</span>) &amp;&amp; crontab[ctab_index].to != (-<span class="Constant">1</span>))
    {  crontab[ctab_index].to        = (-<span class="Constant">1</span>);
       crontab[ctab_index].from      = (-<span class="Constant">1</span>);
       crontab[ctab_index].overnight = FALSE;
       crontab[ctab_index].func      = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

       (<span class="Type">void</span>)strlcpy(crontab[ctab_index].fname   ,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(crontab[ctab_index].fromdate,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(crontab[ctab_index].todate  ,<span class="Constant">&quot;notset&quot;</span>,SSIZE);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): crontab slot [</span><span class="Special">%d</span><span class="Constant">] cleared</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                      date,appl_name,appl_pid,appl_host,appl_owner,ctab_index);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Initialise crontab </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_crontab_init(<span class="Type">void</span>)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_crontab_init] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise crontab data structure </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CRON_SLOTS; ++i)
    {  crontab[i].from      = (-<span class="Constant">1</span>);
       crontab[i].to        = (-<span class="Constant">1</span>);
       crontab[i].overnight = FALSE;
       crontab[i].func      = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

       (<span class="Type">void</span>)strlcpy(crontab[i].fname,   <span class="Constant">&quot;notset&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(crontab[i].fromdate,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(crontab[i].todate,  <span class="Constant">&quot;notset&quot;</span>,SSIZE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Add croncheck to the list of virtual interval timer tasks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;cron_homeostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">10</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)psrp_crontab_checkschedule);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS/P3 cron service started</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                           date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display schedule of activities for this function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_show_crontab(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        cront = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_show_crontab] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Crontab schedule</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CRON_SLOTS; ++i)
    {  <span class="Statement">if</span>(crontab[i].from &gt; <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(crontab[i].func != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: (payload </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual) start: </span><span class="Special">%-32s</span><span class="Constant">, stop </span><span class="Special">%-32s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                             i,
                                                                                              crontab[i].fname,
                                                                            (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)crontab[i].func,
                                                                                           crontab[i].fromdate,
                                                                                            crontab[i].todate);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: (inactivity) start: </span><span class="Special">%-32s</span><span class="Constant">, stop </span><span class="Special">%-32s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                    i,
                                                                  crontab[i].fromdate,
                                                                    crontab[i].todate);

          (<span class="Type">void</span>)fflush(stream);

          ++cront;
       }
    }

    <span class="Statement">if</span>(cront == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    No crontab tasks scheduled (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_CRON_SLOTS);
    <span class="Statement">else</span> <span class="Statement">if</span>(cront == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> crontab task scheduled (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,MAX_CRON_SLOTS - <span class="Constant">1</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant"> crontab task scheduled (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,cront,MAX_CRON_SLOTS - cront);

    (<span class="Type">void</span>)fflush(stream);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Add scheduling slot to PSRP crontab </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_crontab_schedule(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;schedule&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &lt; <span class="Constant">3</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: schedule !from! !to! [payload computation]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc &gt; <span class="Constant">3</span>)
    {  <span class="Type">int</span>  slot_index;
       <span class="Type">void</span> *func = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

       slot_index = psrp_find_action_slot_index(argv[<span class="Constant">3</span>]);
       <span class="Statement">if</span>(slot_index != (-<span class="Constant">1</span>)                                                   &amp;&amp;
          psrp_object_list[slot_index].object_type == PSRP_DYNAMIC_FUNCTION    ||
          psrp_object_list[slot_index].object_type == PSRP_STATIC_FUNCTION      )
          psrp_crontab_schedule(argv[<span class="Constant">1</span>],argv[<span class="Constant">2</span>],argv[<span class="Constant">3</span>],psrp_object_list[slot_index].object_handle);
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">object </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not executable</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
       }
    }
    <span class="Statement">else</span>
       psrp_crontab_schedule(argv[<span class="Constant">1</span>],argv[<span class="Constant">2</span>],<span class="Constant">&quot;notset&quot;</span>,(<span class="Type">void</span> *)<span class="Constant">NULL</span>);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Remove scheduling slot from PSRP crontab </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_crontab_unschedule(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> ctab_index;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unschedule&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">2</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: unschedule !crontab slot index!</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;ctab_index) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">crontab index must be an integer (range 0 to </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,MAX_CRON_SLOTS - <span class="Constant">1</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    psrp_crontab_unschedule(ctab_index);
    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display PSRP crontab </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_crontab(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;cronstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: cronstat</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    psrp_show_crontab(psrp_out);
    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set PSRP function condition (error/status) code </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_set_c_code(<span class="Type">const</span> <span class="Type">char</span> *c_code)

{
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_set_c_code] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(c_code == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)strlcpy(psrp_c_code,c_code,SSIZE);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Toggle PSRP server background standard I/O autodetach  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_nodetach(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;nodetach&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(appl_nodetach == TRUE)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">standard I/O (for PSRP server) attached when in background</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">standard I/O (for PSRP server) detached when in background</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  nodetach [help | usage] | [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;on&quot;</span>) == <span class="Constant">0</span>)
    {  appl_nodetach = TRUE;

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">standard I/O will remain attached when PSRP server is in background</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;off&quot;</span>) == <span class="Constant">0</span>)
    {  appl_nodetach = FALSE;

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">standard I/O will be detached when PSRP server is in background</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  nodetach [help | usage] | [on | off]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Display process resources </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_rusage(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">struct</span> rusage buf;
    <span class="Type">struct</span> rlimit rlim;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;rusage&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage: rusage help | usage]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)getrusage(RUSAGE_SELF,&amp;buf);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Current resource usage (for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;User time                    : </span><span class="Special">%9.4F</span><span class="Constant"> minutes</span><span class="Special">\n</span><span class="Constant">&quot;</span>, (FTYPE)(buf.ru_utime.tv_sec)/<span class="Constant">60.0</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;System time                  : </span><span class="Special">%9.4F</span><span class="Constant"> minutes</span><span class="Special">\n</span><span class="Constant">&quot;</span>, ((FTYPE)buf.ru_stime.tv_sec)/<span class="Constant">60.0</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Max resident size            : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,  ((FTYPE)buf.ru_maxrss)/<span class="Constant">1000000.0</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Integral shared memory size  : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,  ((FTYPE)buf.ru_ixrss)/<span class="Constant">1000000.0</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Integral unshared data size  : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,  ((FTYPE)buf.ru_idrss)/<span class="Constant">1000000.0</span>);
    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Integral unshared stack size : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,((FTYPE)buf.ru_isrss)/<span class="Constant">1000000.0</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Current resource limits (for PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name);

    (<span class="Type">void</span>)getrlimit(RLIMIT_CPU,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;CPU time                     : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;CPU time                     : </span><span class="Special">%9.4F</span><span class="Constant"> minutes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">60.0</span>);

    (<span class="Type">void</span>)getrlimit(RLIMIT_CORE,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Core size                    : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Core size                    : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">1000000.0</span>);


    (<span class="Type">void</span>)getrlimit(RLIMIT_DATA,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Data segment size            : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Data segment size            : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">1000000.0</span>);


    (<span class="Type">void</span>)getrlimit(RLIMIT_STACK,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Stack size                   : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Stack size                   : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">1000000.0</span>);

    (<span class="Type">void</span>)getrlimit(RLIMIT_RSS,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Resident set size            : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Resident set size            : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">1000000.0</span>);

    (<span class="Type">void</span>)getrlimit(RLIMIT_AS,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Virtual memory size          : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Virtual memory size          : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">1000000.0</span>);

    (<span class="Type">void</span>)getrlimit(RLIMIT_FSIZE,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Max file size                : unlimited</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Max file size                : </span><span class="Special">%9.4F</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(FTYPE)(rlim.rlim_cur)/<span class="Constant">1000000.0</span>);


    (<span class="Type">void</span>)getrlimit(RLIMIT_NOFILE,&amp;rlim);
    <span class="Statement">if</span>(rlim.rlim_cur == RLIM_INFINITY)
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Max simultaneously open files: </span><span class="Special">%d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,RLIMIT_NOFILE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;Max simultaneously open files: </span><span class="Special">%d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,rlim.rlim_cur);


    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set process resources </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_rlimit(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>    cnt = <span class="Constant">1</span>;
    <span class="Type">struct</span> rlimit buf;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;rset&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || strcmp(<span class="Constant">&quot;help&quot;</span>,argv[<span class="Constant">1</span>]) == <span class="Constant">0</span> || strcmp(<span class="Constant">&quot;usage&quot;</span>,argv[<span class="Constant">1</span>]) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage: rset  [help | usage]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             cpu      [&lt;time minutes&gt;    | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             core     [&lt;size Mbytes&gt;     | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             stack    [&lt;size Mbytes&gt;     | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             data     [&lt;size Mbytes&gt;     | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             rss      [&lt;size Mbytes&gt;     | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             vmsize   [&lt;size Mbytes&gt;     | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             fsize    [&lt;size Mbytes&gt;     | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             nfiles   [&lt;number of files&gt; | unlimited]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             nproc    [&lt;max children&gt;    | unlimited]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum amoput of CPU this process can use </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;cpu&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> cpu_time;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_CORE,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = RLIM_INFINITY;
          (<span class="Type">void</span>)setrlimit(RLIMIT_CPU,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) CPU time is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) CPU time is set to hard limit (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;cpu_time) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting CPU time (in minutes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; cpu_time &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for CPU time is: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) CPU time set to: </span><span class="Special">%d</span><span class="Constant"> minutes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,cpu_time);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">60</span>*cpu_time;
             <span class="Statement">if</span>(setrlimit(RLIMIT_CPU,&amp;buf) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to set maximum CPU time</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(psrp_out);
             }
          }
          ++cnt;
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum size of core dump file for this process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;core&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> core_size;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_CORE,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_CORE,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) core dump size is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) core dump size is set to hard limit (</span><span class="Special">%d</span><span class="Constant"> Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;core_size) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting core dump size (in Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; <span class="Constant">1000000</span>*core_size &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for core dump size is: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) core dump size set to: </span><span class="Special">%d</span><span class="Constant"> Mbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,core_size);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">1000000</span>*core_size;
             <span class="Statement">if</span>(setrlimit(RLIMIT_CORE,&amp;buf) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to set maximum core dump size</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(psrp_out);
             }

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum stack size for this process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;stack&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> stack_size;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_STACK,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_STACK,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) stack size is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) stack size is set to hard limit (</span><span class="Special">%d</span><span class="Constant"> Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;stack_size) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting stack size (in Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; <span class="Constant">1000000</span>*stack_size &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for stack size is: </span><span class="Special">%d</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) stack size set to: </span><span class="Special">%d</span><span class="Constant"> Kbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,stack_size);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">1000000</span>*stack_size;
             <span class="Statement">if</span>(setrlimit(RLIMIT_STACK,&amp;buf) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to set maximum stack size</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(psrp_out);
             }

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum data segment size for this process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;data&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> data_size;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_DATA,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_DATA,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) data segement size set is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) data segement size set to hard limit (</span><span class="Special">%d</span><span class="Constant"> Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;data_size) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting data segment size (in Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(<span class="Constant">1000000</span>*data_size &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for data segment size is </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) data segment size set to </span><span class="Special">%d</span><span class="Constant"> Mbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,data_size);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">1000000</span>*data_size;
             <span class="Statement">if</span>(setrlimit(RLIMIT_DATA,&amp;buf) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to set maximum data segment size</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(psrp_out);
             }

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set mamximum resident set size for this process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;rss&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> rss_size;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_RSS,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_RSS,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) resident set size is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) resident set size is set to hard limit (</span><span class="Special">%d</span><span class="Constant"> Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;rss_size) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting resident set size (in Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; <span class="Constant">1000000</span>*rss_size &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for resident set size is: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) resident set size set to: </span><span class="Special">%d</span><span class="Constant"> Kbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,rss_size);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">1000000</span>*rss_size;
             <span class="Statement">if</span>(setrlimit(RLIMIT_RSS,&amp;buf) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to set maximum resident set size</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(psrp_out);
             }

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum virutal memory (address space) which can be used </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> by this process                                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;vmsize&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> vm_size;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_AS,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_AS,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) virtual memory size is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) virtual memory size is set to hard limit (</span><span class="Special">%04d</span><span class="Constant"> Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;vm_size) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting virtual memory size (in Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; <span class="Constant">1000000</span>*vm_size &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for virtual memory size is: </span><span class="Special">%04d</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) virtual memory size set to: </span><span class="Special">%04d</span><span class="Constant"> Mbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,vm_size);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">1000000</span>*vm_size;
             <span class="Statement">if</span>(setrlimit(RLIMIT_AS,&amp;buf) == (-<span class="Constant">1</span>))
             {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">failed to set maximum virtual memory size</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                (<span class="Type">void</span>)fflush(psrp_out);
             }

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum (write) file size for this process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;fsize&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> file_size;

       ++cnt;
       (<span class="Type">void</span>)getrlimit(RLIMIT_FSIZE,&amp;buf);
       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_FSIZE,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) file size is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) file size is set to hard limit (</span><span class="Special">%d</span><span class="Constant"> Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;file_size) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting file segment size (in Mbytes)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; <span class="Constant">1000000</span>*file_size &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for maximum file size is: </span><span class="Special">%d</span><span class="Constant"> Mbytes</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max/<span class="Constant">1000000</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) data segment size set to: </span><span class="Special">%d</span><span class="Constant"> Mbytes</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,file_size);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = <span class="Constant">10000000</span>*file_size;
             (<span class="Type">void</span>)setrlimit(RLIMIT_FSIZE,&amp;buf);

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum number of files which this process can have open simultaneously </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;nfiles&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> n_files;

       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_NOFILE,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) number of simultaneously open files is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) number of simultaneously open files is set to hard limit (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_files) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting maximum number of simultaneously open files</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; n_files &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for maximum number of files simultaneously open is: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">number of files simultaneously open is set to: </span><span class="Special">%d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_files);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = n_files;
             (<span class="Type">void</span>)setrlimit(RLIMIT_NOFILE,&amp;buf);

             ++cnt;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set maximum number of children this process can create </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(argv[cnt],<span class="Constant">&quot;nproc&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> n_children;

       <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unlimited&quot;</span>,argv[cnt]) == <span class="Constant">0</span>)
       {  buf.rlim_cur = buf.rlim_max;
          (<span class="Type">void</span>)setrlimit(RLIMIT_NPROC,&amp;buf);

          <span class="Statement">if</span>(buf.rlim_max == RLIM_INFINITY)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) number of children is unlimited</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">(maximum) number of children is set to hard limit (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,buf.rlim_max);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(argv[cnt],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;n_children) != <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting maximum number of children</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          ++cnt;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(buf.rlim_max != RLIM_INFINITY &amp;&amp; n_children &gt; buf.rlim_max)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">hard limit for maximum number of files simultaneously open is: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buf.rlim_max);
             (<span class="Type">void</span>)fflush(psrp_out);

             ++cnt;
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">number of files simultaneously open is set to: </span><span class="Special">%d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_children);
             (<span class="Type">void</span>)fflush(psrp_out);

             buf.rlim_cur = n_children;
             (<span class="Type">void</span>)setrlimit(RLIMIT_NPROC,&amp;buf);

             ++cnt;
          }
       }
    }

    <span class="Statement">if</span>(cnt == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">syntax error</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set process exit (if effective parent exits) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_pexit(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;pexit&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  pexit [help | usage]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server will exit if its effective parent is terminated</span><span class="Special">\n</span><span class="Constant">)&quot;</span>,
                                                                  date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server will exit if its effective parent is terminated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    appl_ppid_exit = TRUE;
    (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;default_parent_hoemostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)&amp;pups_default_parent_homeostat);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically unset process exit (if effective parent exits) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_unpexit(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unpexit&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  pexit [help | usage]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server will not exit if its effecive parent is terminated</span><span class="Special">\n</span><span class="Constant">)&quot;</span>,
                                                                     date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server will not exit if its effecive parent is terminated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    appl_ppid_exit = FALSE;
    (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;default_parent_hoemostat&quot;</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set PSRP server migration context </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_rooted(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;rooted&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  rooted [help | usage]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server is rooted (cannot migrate</span><span class="Special">\n</span><span class="Constant">)&quot;</span>,
                                            date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server is rooted (cannot migrate)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    appl_rooted = TRUE;
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically unset PSRP server system migration context </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_unrooted(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;unrooted&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  unrooted [help | usage]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    appl_rooted = FALSE;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server is not rooted (can migrate</span><span class="Special">\n</span><span class="Constant">)&quot;</span>,
                                             date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server is not rooted (can migrate)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set PSRP server (effective) parent </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_parent(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span>  i_tmp;
    <span class="Type">char</span> pname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;parent&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(psrp_pid_to_pname(appl_ppid,pname) == TRUE)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">effective parent is </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_ppid,pname,appl_host);
          (<span class="Type">void</span>)fflush(psrp_out);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">effective parent </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,pname);
          (<span class="Type">void</span>)fflush(psrp_out);
       }

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  parent [help | usage] [&lt;effective parent name | effective parent PID&gt;&gt; [exit]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;i_tmp) != <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)strlcpy(pname,argv[<span class="Constant">1</span>],SSIZE);

       <span class="Statement">if</span>((i_tmp = psrp_pname_to_pid(pname)) &lt; <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(i_tmp == PSRP_DUPLICATE_PROCESS_NAME)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">ambiguous parent process name specified (</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,pname);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">effective parent </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,pname);
          (<span class="Type">void</span>)fflush(psrp_out);
          <span class="Statement">return</span>(PSRP_OK);
       }
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(psrp_pid_to_pname(i_tmp,pname) == FALSE)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">effective parent </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,pname);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }
    }

    appl_ppid = i_tmp;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): effective parent is </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
               date,appl_name,appl_pid,appl_host,appl_owner,appl_ppid,pname,appl_host);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">effective parent is now </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_ppid,pname,appl_host);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">if</span>(argc == <span class="Constant">3</span>)
    {  <span class="Statement">if</span>(strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;exit&quot;</span>) == <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP server will exit if its effective parent is terminated</span><span class="Special">\n</span><span class="Constant">)&quot;</span>,
                                                                        date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
           }

           (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server will exit if its effective parent is terminated</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
           (<span class="Type">void</span>)fflush(psrp_out);

           appl_ppid_exit = TRUE;
           (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;default_parent_hoemostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)&amp;pups_default_parent_homeostat);
        }
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set PSRP server current working directory </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_cwd(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">char</span> cwd[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         cwdpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         relpath[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN default_cwd = FALSE;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;cwd&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">current working directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  cwd [help | usage] [&lt;current working directory:</span><span class="Special">%s</span><span class="Constant">&gt; | default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get the name of the new working directory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cwd,argv[<span class="Constant">1</span>],SSIZE);

    <span class="Statement">if</span>(strcmp(cwd,<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)getcwd(appl_cwd,SSIZE);
       default_cwd = TRUE;
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if path is absolute </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(cwd[<span class="Constant">0</span>] == <span class="Constant">'/'</span>)
       (<span class="Type">void</span>)strlcpy(cwdpath,cwd,SSIZE);
    <span class="Statement">else</span> <span class="Statement">if</span>(cwd[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
    {  <span class="Statement">if</span>(cwd[<span class="Constant">1</span>] == <span class="Constant">'.'</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;std_init: cannot have </span><span class="Special">\&quot;</span><span class="Constant">..</span><span class="Special">\&quot;</span><span class="Constant"> in cwd path&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       (<span class="Type">void</span>)getcwd(relpath,SSIZE);
       (<span class="Type">void</span>)snprintf(cwdpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,relpath,&amp;cwd[<span class="Constant">2</span>]);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)getcwd(relpath,SSIZE);
       (<span class="Type">void</span>)snprintf(cwdpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,relpath,cwd);
    }

    <span class="Statement">if</span>(chdir(cwdpath) != (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)strlcpy(appl_cwd,cwdpath,SSIZE);

       <span class="Statement">if</span>(default_cwd == TRUE)
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">set current working directory to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [default]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">set current working directory to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_cwd);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">current working directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (could not change it to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_cwd,cwdpath);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically set number of times psrp function is (re)-tryed </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_trys(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;strys&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  strys [help | usage] [&lt;trys:</span><span class="Special">%d</span><span class="Constant">&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_TRYS);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server process </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> will currently retry an operation </span><span class="Special">%d</span><span class="Constant"> times (before aborting it)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,max_trys);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(argc == <span class="Constant">2</span>)
    {  <span class="Type">int</span> itmp;

       <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;itmp) != <span class="Constant">1</span> || itmp &lt; <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">number of tries must be a positive integer</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       max_trys = itmp;
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage  strys [help | usage] [&lt;trys:</span><span class="Special">%d</span><span class="Constant">&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_TRYS);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server process </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> will now retry an operation </span><span class="Special">%d</span><span class="Constant"> times (before aborting it)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,max_trys);
    (<span class="Type">void</span>)fflush(psrp_out);

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically protect a file or files) from accidental deletion </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_file_live(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        f_index,
        slot_index;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;live&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage live [help | usage] [&lt;filename | slotindex&gt; ...]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up homeostats for all files in list which are not already </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> homeostatically protected                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Do we have a slot identifier? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(sscanf(argv[i],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;slot_index) == <span class="Constant">1</span>)
       {  <span class="Statement">if</span>(slot_index &lt; <span class="Constant">0</span> || slot_index &gt; appl_max_files)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">index </span><span class="Special">%d</span><span class="Constant"> is not avalid slot id (must lie between 0 and </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                         slot_index,appl_max_files);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We have a file name -- get corresponding file table index </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(access(argv[i],F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
             f_index = (-<span class="Constant">1</span>);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>((f_index = pups_get_ftab_index_by_name(argv[i])) == (-<span class="Constant">1</span>))
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not open</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a non zero ftab index start homeostat </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(f_index != (-<span class="Constant">1</span>))
       {  <span class="Type">char</span> homeostat_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;



          <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Homeostat running </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[f_index].homeostatic &gt; <span class="Constant">1</span>)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is already homeostatically protected</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ftab[f_index].fname);


          <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Homeostat not running </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)pups_fd_alive(ftab[f_index].fdes,homeostat_name,&amp;pups_default_fd_homeostat);

             (<span class="Type">void</span>)fprintf   (psrp_out,<span class="Constant">&quot;file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now hoemostatically protected (default_file_homeostat)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ftab[f_index].fname);
             (<span class="Type">void</span>)fflush    (psrp_out);
          }
       }
    }

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Dynamically unprotect a file or files) from accidental deletion </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_file_dead(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        f_index;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;dead&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc == <span class="Constant">1</span> || strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;help&quot;</span>) == <span class="Constant">0</span> || strcmp(argv[<span class="Constant">2</span>],<span class="Constant">&quot;usage&quot;</span>) == <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Usage dead [help | usage] [&lt;filename | slotindex&gt; ...]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unprotect files in list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;argc; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Do we have a slot identifier? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(sscanf(argv[i],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;f_index) == <span class="Constant">1</span>)
       {  <span class="Statement">if</span>(f_index &lt; <span class="Constant">0</span> || f_index &gt; appl_max_files)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">index </span><span class="Special">%d</span><span class="Constant"> is not a valid slot identifier (must lie between 0 and </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                     f_index,appl_max_files);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We have a file name -- get corresponding file table index </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(access(argv[i],F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
             f_index = (-<span class="Constant">1</span>);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>((f_index = pups_get_ftab_index_by_name(argv[i])) == (-<span class="Constant">1</span>))
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is not currently open</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a non zero ftab index stop homeostat </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(f_index != (-<span class="Constant">1</span>))
       {  <span class="Type">char</span> homeostat_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(ftab[f_index].homeostatic &gt; <span class="Constant">1</span>)
             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is already unprotected</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)snprintf(homeostat_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">:default_file_homeostat&quot;</span>,ftab[f_index].fname,argv[<span class="Constant">1</span>]);
             (<span class="Type">void</span>)pups_fd_dead(ftab[f_index].fdes);

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now unprotected</span><span class="Special">\n</span><span class="Constant">&quot;</span>,argv[i]);
             (<span class="Type">void</span>)fflush(psrp_out);
          }
       }
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Fork a PUPS/PSRP server -- this routine will build -- all open files etc are inherited </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> along with any homeostats which the parent may have been running                       </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_fork(<span class="Type">const</span> <span class="Type">char</span>     *childname,   <span class="Comment">// Name of forked child</span>
                      <span class="Type">const</span> _BOOLEAN obituary)     <span class="Comment">// Produce report (of what went wrong) if TRUE</span>

{   <span class="Type">int</span>  i,
         ret,
         cnt = <span class="Constant">0</span>;

    sigset_t set;

    <span class="Type">char</span> new_channel_name_in[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         new_channel_name_out[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;attempt by non root thread to perform PUPS/P3 PSRP operation (psrp_fork)&quot;</span>);

    <span class="Statement">if</span>(childname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(in_chan_handler == TRUE || in_psrp_handler == TRUE)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Signals are not inherited -- so if we have signals pending simply return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;set);
    (<span class="Type">void</span>)sigpending(&amp;set);

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;MAX_SIGS; ++i)
    {  <span class="Statement">if</span>(sigismember(&amp;set,i))
       {

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB SIGNALS PENDING</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> First fork() to creat a child process.     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Non-zero return code indicates that we are </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the parent process                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ret = pups_fork(FALSE,obituary)) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(ret);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We are the child. We need to restart our homeostats   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (pending signals are not inherited) and build ourself </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> a communications channel for PSRP interactions        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Dissassociate child from parents PSRP channels </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> they are not inherited                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">3</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes != (-<span class="Constant">1</span>) &amp;&amp; strncmp(ftab[i].fname,<span class="Constant">&quot;psrp&quot;</span>,<span class="Constant">4</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fclose(ftab[i].stream);

           <span class="Statement">if</span>(cnt ++ &gt; <span class="Constant">2</span>)
             <span class="Statement">goto</span> done;
       }
    }

<span class="Statement">done</span>:

    (<span class="Type">void</span>)strlcpy(appl_name,childname,SSIZE);

    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get (child) PID and update PUPS process information </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    appl_pid = getpid();


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create standard I/O for this process. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)ftab[<span class="Constant">0</span>].fname);
    ftab[<span class="Constant">0</span>].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
    {  ftab[<span class="Constant">0</span>].named = TRUE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">0</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdin.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid);
       (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[<span class="Constant">0</span>].fname);
    }
    <span class="Statement">else</span>
    {  ftab[<span class="Constant">0</span>].named = FALSE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">0</span>].fname,SSIZE,<span class="Constant">&quot;&lt;redirected.0&gt;&quot;</span>);
    }

    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)ftab[<span class="Constant">1</span>].fname);
    ftab[<span class="Constant">1</span>].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
    {  ftab[<span class="Constant">1</span>].named = TRUE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">1</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdout.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid);
       (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[<span class="Constant">1</span>].fname);
    }
    <span class="Statement">else</span>
    {  ftab[<span class="Constant">1</span>].named = FALSE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">1</span>].fname,SSIZE,<span class="Constant">&quot;&lt;redirected.1&gt;&quot;</span>);
    }

    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)ftab[<span class="Constant">2</span>].fname);
    ftab[<span class="Constant">2</span>].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
    {  ftab[<span class="Constant">2</span>].named = TRUE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">2</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stderr.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid);
       (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[<span class="Constant">2</span>].fname);
    }
    <span class="Statement">else</span>
    {  ftab[<span class="Constant">2</span>].named = FALSE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">2</span>].fname,SSIZE,<span class="Constant">&quot;&lt;redirected.2&gt;&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create communication channels for this process. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(channel_name_out,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);
    (<span class="Type">void</span>)snprintf(channel_name_in,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);
    (<span class="Type">void</span>)mkfifo(channel_name_in, <span class="PreProc">0</span><span class="Constant">600</span>);
    (<span class="Type">void</span>)mkfifo(channel_name_out,<span class="PreProc">0</span><span class="Constant">600</span>);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure that we delete the communications channel when this </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> process exits.                                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
               <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) handler initialised on channel </span><span class="Special">%s</span><span class="Constant">/psrp:</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">:fifo:IO:</span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                              date,
                                                                                                         appl_name,
                                                                                                          appl_pid,
                                                                                                         appl_host,
                                                                                                        appl_owner,
                                                                                             PSRP_PROTOCOL_VERSION,
                                                                                                     appl_fifo_dir,
                                                                                                         appl_name,
                                                                                                         appl_host,
                                                                                                          appl_pid);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">if</span>(psrp_bind_status &amp; PSRP_HOMEOSTATIC_STREAMS)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Streams: PSRP streams are homeostatic</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                              date,appl_name,appl_pid,appl_host,appl_owner);
       }

       (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;psrp_homeostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)psrp_homeostat);
    }

    (<span class="Type">void</span>)pups_vitrestart();

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Create a trailfile and associated delayed destructor processs (lyosome) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_create_trailfile(<span class="Type">char</span> *trail_file_name,
                                    <span class="Type">char</span> *pen,
                                    <span class="Type">char</span> *host,
                                    <span class="Type">char</span> *host_port)

{   <span class="Type">char</span> lyosome_command[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create the trailfile </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(trail_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       (<span class="Type">void</span>)pups_creat(trail_file_name,<span class="PreProc">0</span><span class="Constant">666</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Write migration information to trail file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    stream = fopen(trail_file_name,<span class="Constant">&quot;w&quot;</span>);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#--------------------------------------------------------------------</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#    PSRP migration trail file version 1.02</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#    (C) M.A. O'Neill, Tumbling Dice 2022</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#---------------------------------------------------------------------</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,pen,host,host_port);
    (<span class="Type">void</span>)fclose(stream);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start lyosome process which destroys trail file after delay </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(lyosome_command,SSIZE,<span class="Constant">&quot;lyosome -lifetime 15 </span><span class="Special">%s</span><span class="Constant">&amp;&quot;</span>,trail_file_name);
    (<span class="Type">void</span>)system(lyosome_command);
}




<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Read a trailfile </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_read_trailfile(<span class="Type">const</span> <span class="Type">char</span> *trail_file_name, <span class="Comment">// Name of trailfile</span>
                                     <span class="Type">char</span>       *pen,             <span class="Comment">// Name of process on new host</span>
                                     <span class="Type">char</span>       *host,            <span class="Comment">// Name of new host</span>
                                     <span class="Type">char</span>       *host_port)       <span class="Comment">// Port for (ssh) access to new host</span>

{   <span class="Type">char</span> line[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_read_trailfile] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(trail_file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       pen             == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       host            == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">#ifdef PSRPLIB_DEBUG</span>
    <span class="Statement">while</span>(access(trail_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB TFW: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,trail_file_name);
         (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

         (<span class="Type">void</span>)pups_sleep(<span class="Constant">1</span>);
    }
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read migration information from trail file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(trail_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(FALSE);
    }

    stream = pups_fopen(trail_file_name,<span class="Constant">&quot;r&quot;</span>,LIVE);

    (<span class="Type">void</span>)pups_fgets(line,SSIZE,stream);
    (<span class="Type">void</span>)pups_fgets(line,SSIZE,stream);
    (<span class="Type">void</span>)pups_fgets(line,SSIZE,stream);
    (<span class="Type">void</span>)pups_fgets(line,SSIZE,stream);
    (<span class="Type">void</span>)pups_fgets(line,SSIZE,stream);
    (<span class="Type">void</span>)pups_fgets(line,SSIZE,stream);

    (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s%s%s</span><span class="Constant">&quot;</span>,pen,host,host_port);
    (<span class="Type">void</span>)pups_fclose(stream);

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="PreProc">#ifdef PSRP_AUTHENTICATE</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set authentication token for (secure) PSRP server </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_secure(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;secure&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
        <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

     (<span class="Type">void</span>)strlcpy(appl_password,argv[<span class="Constant">1</span>],SSIZE);

     <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
     {  appl_secure = TRUE;
        (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> has accepted new authentication token</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name);
     }
     <span class="Statement">else</span>
     {  appl_secure = FALSE;
        (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP server </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> authentication revoked (open access)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name);
     }

     (<span class="Type">void</span>)fflush(psrp_out);

     <span class="Statement">if</span>(appl_verbose == TRUE)
     {  (<span class="Type">void</span>)strdate(date);

        <span class="Statement">if</span>(appl_secure == TRUE)
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): server authentication token updated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                             date,appl_name,appl_pid,appl_host,appl_owner);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): server authentication revoked (open access)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner);

        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">return</span>(PSRP_OK);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>




<span class="PreProc">#ifdef BUBBLE_MEMORY_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set mallopt parameters. At present only one option mimimum memory bubble </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (utilisation) threshold is supported                                     </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_mbubble_utilisation_threshold(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> mbubble_utilisation;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;mset&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt;<span class="Constant">2</span> || (ptr = pups_locate(&amp;init,<span class="Constant">&quot;usage&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: mset [-usage] | &lt;minimum bubble utilisation </span><span class="Special">%%</span><span class="Constant">&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Memory bubble utilisation threshold is currently </span><span class="Special">%3d</span><span class="Constant"> </span><span class="Special">%%</span><span class="Special">\n</span><span class="Constant">&quot;</span>,mallopt(MUNMAP_THRESHOLD,(-<span class="Constant">1.0</span>)));
       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;If utilisation falls below this threshold bubble will be unmapped (from process address space)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;mbubble_utilisation) == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Memory bubble utilisation threshold is now </span><span class="Special">%3d</span><span class="Constant"> </span><span class="Special">%%</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,mbubble_utilisation);
       (<span class="Type">void</span>)fflush(psrp_out);

       (<span class="Type">void</span>)mallopt(MUNMAP_THRESHOLD,mbubble_utilisation);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting memory bubble utilisation threshold parameter</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Show malloc statistics </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_show_malloc_stats(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;mstat&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
        <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

     jmalloc_usage(FALSE,psrp_out);
     <span class="Statement">return</span>(PSRP_OK);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPORT </span><span class="Comment">*/</span>



<span class="PreProc">#ifdef CRIU_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Enable/disable (Criu) state saving </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_ssave(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        itmp;

    <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;ssave&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
        <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No arguments - report ssave status </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(appl_ssave == FALSE)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving is disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving is enabled (poll time: </span><span class="Special">%d</span><span class="Constant"> seconds, </span><span class="Special">%d</span><span class="Constant"> state saves, criu directory: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                                                  appl_poll_time,
                                                                                                                     appl_ssaves,
                                                                                                                   appl_criu_dir);
          (<span class="Type">void</span>)fflush(psrp_out);
       }

       <span class="Statement">return</span>(PSRP_OK);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parse command tail </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_clear_cmd_tail();
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;argc; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Display usage </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;usage&quot;</span>,&amp;argc,argv,<span class="Constant">0</span>) != NOT_FOUND)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: ssave [-t &lt;poll_time:</span><span class="Special">%d</span><span class="Constant">&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_poll_time);
          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;             [-enable | -disable | -cd &lt;criu directory:/tmp&gt;]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }


       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Enable state saving </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;enable&quot;</span>,&amp;argc,argv,<span class="Constant">0</span>) != NOT_FOUND)
       {  <span class="Statement">if</span>(appl_ssave == TRUE)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving already enabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
          <span class="Statement">else</span>
             appl_ssave = TRUE;

          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving enabled (poll time: </span><span class="Special">%d</span><span class="Constant"> seconds, criu directory: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                             appl_poll_time,
                                                                                              appl_criu_dir);
          (<span class="Type">void</span>)fflush(psrp_out);
       }


       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Disable state saving </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;disable&quot;</span>,&amp;argc,argv,<span class="Constant">0</span>) != NOT_FOUND)
       {  <span class="Statement">if</span>(appl_ssave == FALSE)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving already disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
          <span class="Statement">else</span>
             appl_ssave = FALSE;

          (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Enable state saving with user defined poll time </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span> <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;t&quot;</span>,&amp;argc,argv,<span class="Constant">0</span>)) != NOT_FOUND)
       {
          <span class="Statement">if</span>((itmp = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting poll time in seconds (integer &gt;= 0)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(itmp &gt; <span class="Constant">0</span>)
          {  appl_ssave     = TRUE;
             appl_poll_time = itmp;

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving enabled (poll time: </span><span class="Special">%d</span><span class="Constant"> seconds, criu directory: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                appl_poll_time,
                                                                                                 appl_criu_dir);
             (<span class="Type">void</span>)fflush(psrp_out);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(itmp &lt;= <span class="Constant">0</span>)
          {  appl_ssave = FALSE;

             (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">state saving disabled</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(psrp_out);
          }
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set Criu directory - used to store checkpoints </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;cd&quot;</span>,&amp;argc,argv,<span class="Constant">0</span>)) != NOT_FOUND)
       {  <span class="Statement">if</span>(strccpy(tmpstr,pups_str_dec(ptr,argc,args)) == (<span class="Type">char</span> *)INVALID_ARG)
          {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting name of criu directory</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fflush(psrp_out);

             <span class="Statement">return</span>(PSRP_OK);
          }

          <span class="Statement">if</span>(access(tmpstr,F_OK) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[psrp_builtin_ssave] criu directory </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> not found&quot;</span>);
             pups_error(errstr);
          }
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(appl_criu_dir,tmpstr,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If any arguments remain unparsed - complain and stop </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    pups_t_arg_errs(argd,argv);

    <span class="Statement">return</span>(PSRP_OK);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set vitimer quantum for PSRP handler subsystem </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_builtin_set_vitimer_quantum(<span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> itmp;

    <span class="Statement">if</span>(strcmp(<span class="Constant">&quot;quantum&quot;</span>,argv[<span class="Constant">0</span>]) != <span class="Constant">0</span>)
       <span class="Statement">return</span>(PSRP_DISPATCH_ERROR);

    <span class="Statement">if</span>(argc &gt;<span class="Constant">2</span> || (ptr = pups_locate(&amp;init,<span class="Constant">&quot;usage&quot;</span>,&amp;argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">usage: qunatum [-usage] | &lt;quantum | default&gt;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(argc == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (vitimer) quantum is </span><span class="Special">%d</span><span class="Constant"> milliseconds</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,vitimer_quantum);
       (<span class="Type">void</span>)fflush(psrp_out);

       <span class="Statement">return</span>(PSRP_OK);
    }

    <span class="Statement">if</span>(sscanf(argv[<span class="Constant">1</span>],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;itmp) == <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(itmp &lt; <span class="Constant">1000</span> || itmp &gt; <span class="Constant">1000000</span>)
       {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (vitimer) quantum must lie between 1000 and 1000000 milliseconds</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(psrp_out);

          <span class="Statement">return</span>(PSRP_OK);
       }

       vitimer_quantum = itmp;
       (<span class="Type">void</span>)pups_malarm(vitimer_quantum);

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (vitimer) quantum is now </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%%</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,vitimer_quantum);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[<span class="Constant">1</span>],<span class="Constant">&quot;default&quot;</span>) == <span class="Constant">0</span>)
    {  vitimer_quantum = VITIMER_QUANTUM;
       (<span class="Type">void</span>)pups_malarm(vitimer_quantum);

       (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">PSRP (vitimer) quantum is now </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%%</span><span class="Constant"> (default)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,vitimer_quantum);
       (<span class="Type">void</span>)fflush(psrp_out);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(psrp_out,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">expecting PSRP (vitimer) quantum parameter</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(psrp_out);
    }

    <span class="Statement">return</span>(PSRP_OK);
}





<span class="PreProc">#ifdef MAIL_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Extract return address from an incoming mail </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> extract_return_address(<span class="Type">char</span> *from_line, <span class="Type">char</span> *from_address)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    _BOOLEAN copy_chars = FALSE;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(from_line); ++i)
    {  <span class="Statement">if</span>(from_line[i] == <span class="Constant">'&lt;'</span>)
          copy_chars = TRUE;
       <span class="Statement">else</span> <span class="Statement">if</span>(copy_chars == TRUE &amp;&amp; from_line[i] != <span class="Constant">'&gt;'</span>)
       {  from_address[cnt] = from_line[i];
          ++cnt;
       }

       <span class="Statement">if</span>(from_line[i] == <span class="Constant">'&gt;'</span>)
       {  from_address[cnt + <span class="Constant">1</span>] = <span class="Special">'\0'</span>;
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Read a message from the PSRP process inbox extracting any date which </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> is MIME encapsulated. This is a wrapper wqhich calls the mhstore     </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> function                                                             </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_mime_storeparts(<span class="Type">const</span> <span class="Type">char</span> *msg_file, <span class="Type">const</span> <span class="Type">char</span> *type)

{   <span class="Type">char</span> inc_command[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         line[SSIZE]             = <span class="Constant">&quot;&quot;</span>,
         typestr[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
         address[SSIZE]          = <span class="Constant">&quot;&quot;</span>,
         mhn_command[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         mhstore_command[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span>   size;
    _BYTE buf[<span class="Constant">512</span>] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">FILE</span> *pstream  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_mime_storeparts] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(msg_file == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || type == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> First read (mime) encapsulated message from maildrop    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and put it into the default inbox for the process which </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is running this application                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(inc_command,SSIZE,<span class="Constant">&quot;inc +</span><span class="Special">%s</span><span class="Constant"> | grep </span><span class="Special">\&quot;</span><span class="Constant">no mail</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,appl_mdir);
    <span class="Statement">if</span>((pstream = popen(inc_command,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[psrp_mime_storeparts] failed to open stream to </span><span class="Special">\&quot;</span><span class="Constant">inc</span><span class="Special">\&quot;</span><span class="Constant"> command&quot;</span>);

    (<span class="Type">void</span>)fscanf(pstream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,line);
    (<span class="Type">void</span>)pclose(pstream);

    size = strlen(line);
    <span class="Statement">if</span>(size &gt; <span class="Constant">2</span>)
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is next message addressed to this process? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mhn_command,SSIZE,<span class="Constant">&quot;bash -c </span><span class="Special">\&quot;</span><span class="Constant">mhn +</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> | grep Subject</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,appl_mdir,msg_file);
    <span class="Statement">if</span>((pstream = popen(mhn_command,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       pups_error(<span class="Constant">&quot;[psrp_mime_storeparts] failed to open stream to </span><span class="Special">\&quot;</span><span class="Constant">mhn</span><span class="Special">\&quot;</span><span class="Constant"> command (address)&quot;</span>);

    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
    (<span class="Type">void</span>)pclose(pstream);

    (<span class="Type">void</span>)snprintf(address,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_name,appl_host);
    <span class="Statement">if</span>(strin(line,address) == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Yes someone has sent us a message! Lets find out who it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> is and read what they have sent to us.                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extract parts of (MIME encapsulated) message into directory    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have specified a particular type add an appropriate flag </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> to the mhstore command.                                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(type != (<span class="Type">char</span> *)<span class="Constant">NULL</span> || strcmp(type,<span class="Constant">&quot;all&quot;</span>) != <span class="Constant">0</span>)
          (<span class="Type">void</span>)snprintf(typestr,SSIZE,<span class="Constant">&quot;-type </span><span class="Special">%s</span><span class="Constant"> &quot;</span>,type);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extract parts of (MIME) message (into specified MIME directory) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(mhstore_command,SSIZE,<span class="Constant">&quot;cd </span><span class="Special">%s</span><span class="Constant">; mhstore +</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> &gt;&amp; /dev/null&quot;</span>,appl_mime_dir,appl_mdir,typestr,msg_file);
       (<span class="Type">void</span>)system(mhstore_command);

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Extract text (first part) from MIME message. This is assumed to be a </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PSRP command -- if it is not return error condition to caller        </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_msg2requestlist(<span class="Type">const</span> <span class="Type">char</span> *msg_file, <span class="Type">const</span> <span class="Type">char</span> *psrp_requestlist)

{   _BOOLEAN looper   = TRUE;

    <span class="Type">int</span> server_pid,
        line_cnt     = <span class="Constant">0</span>,
        command_cnt  = <span class="Constant">0</span>;

    <span class="Type">char</span> msg_textpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         next_request[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         server_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_msg2requestlist] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we cannot access text return to caller (with error condition) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(msg_file == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || psrp_requestlist == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || access(msg_textpath,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build path to text part of [MIME] message </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(msg_textpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">.1.txt&quot;</span>,appl_mdir,msg_file);
    stream = pups_fopen(msg_textpath,<span class="Constant">&quot;r&quot;</span>,LIVE);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> First item is our process name -- if mail is not for us </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> delete it from local mailbox and return                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strip_comment(stream,&amp;line_cnt,server_name) == FALSE)
    {  (<span class="Type">void</span>)pups_fclose(stream);

       pups_set_errno(OK);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build request list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {    <span class="Statement">if</span>(feof(stream) == <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(strip_comment(stream,&amp;line_cnt,next_request) == FALSE)
               {  (<span class="Type">void</span>)pups_fclose(stream);


                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> We must have read at least one command to avoid </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> error condition                                 </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(command_cnt == <span class="Constant">0</span>)
                  {  pups_set_errno(<span class="Constant">EINVAL</span>);
                     <span class="Statement">return</span>(-<span class="Constant">1</span>);
                  }

                  pups_set_errno(OK);
                  <span class="Statement">return</span>(<span class="Constant">0</span>);
               }

               (<span class="Type">void</span>)strlcat(psrp_requestlist,next_request,SSIZE);
               (<span class="Type">void</span>)strlcat(psrp_requestlist,<span class="Constant">&quot; &quot;</span>,SSIZE);

               <span class="Statement">if</span>(command_cnt &gt; <span class="Constant">0</span> &amp;&amp; strcmp(next_request,<span class="Constant">&quot;none&quot;</span>) == <span class="Constant">0</span>)
               {  pups_set_errno(<span class="Constant">EINVAL</span>);
                  <span class="Statement">return</span>(-<span class="Constant">1</span>);
               }

               ++command_cnt;
            }
            <span class="Statement">else</span>
               looper = FALSE;

       } <span class="Statement">while</span>(looper == TRUE);

    (<span class="Type">void</span>)pups_fclose(stream);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Delete MIME message (at end of processing) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_mime_delete(<span class="Type">const</span> <span class="Type">char</span> *msg_file)

{   <span class="Type">int</span>  ret;
    <span class="Type">char</span> msg_pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_mime_delete] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(msg_file == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(msg_pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_mdir,msg_file);
    ret = unlink(msg_pathname);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Sends one file as MIME encapsulated message </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_mime_mail(<span class="Type">const</span> <span class="Type">char</span> *to,        <span class="Comment">// Recipient</span>
                            <span class="Type">const</span> <span class="Type">char</span> *filetype,  <span class="Comment">// Type of (MIME) file</span>
                            <span class="Type">const</span> <span class="Type">char</span> *filepath)  <span class="Comment">// Location of file</span>

{   <span class="Type">char</span>    subject[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    mc_type partlist;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_mime_mail] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(to       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       filetype == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       filepath == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)snprintf(subject,SSIZE,<span class="Constant">&quot;Automatic reply [</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">]&quot;</span>,appl_name,appl_host);
    (<span class="Type">void</span>)strlcpy(partlist.type,filetype,SSIZE);
    (<span class="Type">void</span>)strlcpy(partlist.path,filepath,SSIZE);
    (<span class="Type">void</span>)psrp_mime_encapsulate(to,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,subject,<span class="Constant">1</span>,&amp;partlist);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Send set of files and send as multipart MIME message </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_mime_encapsulate(<span class="Type">const</span> <span class="Type">char</span>    *recipient, <span class="Comment">// Recipient (of MIME message)</span>
                                  <span class="Type">const</span> <span class="Type">char</span>    *cc_list,   <span class="Comment">// CC list recipients</span>
                                  <span class="Type">const</span> <span class="Type">char</span>    *subject,   <span class="Comment">// Subject (of message)</span>
                                  <span class="Type">const</span> <span class="Type">int</span>     n_files,    <span class="Comment">// Number of MIME files</span>
                                  <span class="Type">const</span> mc_type *partlist)  <span class="Comment">// Mime partlist</span>

{   <span class="Type">int</span> i;

    <span class="Type">char</span> mcf_filename[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         mail_script[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_mime_encapsulate] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(recipient == (<span class="Type">const</span> <span class="Type">char</span> *)   <span class="Constant">NULL</span>  ||
       cc_list   == (<span class="Type">const</span> <span class="Type">char</span> *)   <span class="Constant">NULL</span>  ||
       subject   == (<span class="Type">const</span> <span class="Type">char</span> *)   <span class="Constant">NULL</span>  ||
       partlist  == (<span class="Type">const</span> mc_type *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build sendfiles script </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(recipient == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || partlist == (mc_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If there is no subject send standard subject banner </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(subject == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)snprintf(subject,SSIZE,<span class="Constant">&quot;Automatic reply from PSRP server </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,appl_name,appl_pid,appl_host,appl_owner);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build MIME composition draft for filelist </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mcf_filename,SSIZE,<span class="Constant">&quot;/tmp/mcf.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.tmp&quot;</span>,appl_pid,appl_host);
    (<span class="Type">void</span>)pups_creat(mcf_filename,<span class="PreProc">0</span><span class="Constant">600</span>);
    stream = fopen(mcf_filename,<span class="Constant">&quot;w&quot;</span>);

    <span class="Statement">if</span>(cc_list != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;Cc: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,cc_list);

    <span class="Statement">if</span>(subject != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;Subject: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,subject);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;-------</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_files; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check that the next file component actually exists </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(access(partlist[i].path,F_OK | R_OK) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">EEXIST</span>);
          (<span class="Type">void</span>)fclose(stream);
          (<span class="Type">void</span>)unlink(mcf_filename);

          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;#</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,(<span class="Type">char</span> *)partlist[i].type,(<span class="Type">char</span> *)partlist[i].path);
       (<span class="Type">void</span>)fflush(stream);

    }
    (<span class="Type">void</span>)fclose(stream);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We now have the sendfiles_script built so lets mail the MIME </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> message!                                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mail_script,SSIZE,<span class="Constant">&quot;cat </span><span class="Special">%s</span><span class="Constant"> | mhbuild - | sendmail </span><span class="Special">%s</span><span class="Constant">&quot;</span>,mcf_filename,recipient);
    (<span class="Type">void</span>)system(mail_script);

    (<span class="Type">void</span>)unlink(mcf_filename);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get reply address </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_get_replyto(<span class="Type">const</span> <span class="Type">char</span> *msg_file, <span class="Type">char</span> *replymailpath)

{   <span class="Type">char</span> mhn_command[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         line[SSIZE]        = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN looper   = TRUE;
    <span class="Type">FILE</span>     *pstream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(msg_file == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || replymailpath == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_get_replyto] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Does message have a replyto field? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mhn_command,SSIZE,<span class="Constant">&quot;bash -c </span><span class="Special">\&quot;</span><span class="Constant">mhn +</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> | grep </span><span class="Special">\&quot;</span><span class="Constant">Replyto:</span><span class="Special">\&quot;\&quot;</span><span class="Constant">&quot;</span>,appl_mh_folder,msg_file);
    <span class="Statement">if</span>((pstream = popen(mhn_command,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
    (<span class="Type">void</span>)pclose(pstream);

    <span class="Statement">if</span>(strin(line,<span class="Constant">&quot;Replyto&quot;</span>) == TRUE)
    {  (<span class="Type">void</span>)extract_return_address(line,replymailpath);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Use from address as reply address </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mhn_command,SSIZE,<span class="Constant">&quot;bash -c </span><span class="Special">\&quot;</span><span class="Constant">mhn +</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> | grep </span><span class="Special">\&quot;</span><span class="Constant">From:</span><span class="Special">\&quot;\&quot;</span><span class="Constant">&quot;</span>,appl_mh_folder,msg_file);
    <span class="Statement">if</span>((pstream = popen(mhn_command,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
    (<span class="Type">void</span>)pclose(pstream);

    <span class="Statement">if</span>(strin(line,<span class="Constant">&quot;From&quot;</span>) == TRUE)
    {  (<span class="Type">void</span>)extract_return_address(line,replymailpath);

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Save PSRP channels </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">FILE</span> *psrp_saved_in  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
_PRIVATE <span class="Type">FILE</span> *psrp_saved_out = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

_PRIVATE <span class="Type">void</span> psrp_save_channels(<span class="Type">void</span>)

{    psrp_saved_in  = psrp_in;
     psrp_saved_out = psrp_out;
}




<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Restore PSRP channels </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> psrp_restore_channels(<span class="Type">void</span>)

{    psrp_in  = psrp_saved_in;
     psrp_out = psrp_saved_out;
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Mail homeostat (checks PSRP process mailbox for mail). If mail is found </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> any PSRP commands are extracted from it and passed to the PSRP command  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> parser                                                                  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_mail_homeostat(<span class="Type">void</span> *t_info, <span class="Type">const</span> <span class="Type">char</span> *args)

{   <span class="Type">int</span> msg_number;

    <span class="Type">char</span> mailbox_lock[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         reply_cmd[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         strmsg_number[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         psrp_requestlist[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         subject[SSIZE]          = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span>          *reply_stream  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item     = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;

    _IMMORTAL <span class="Type">DIR</span> *dirp          = (<span class="Type">DIR</span> *) <span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_mail_homeostat] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP command can only be processed from one interface </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> at a time                                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_psrp_handler == TRUE)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Block PSRP requests while mail is processed </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)psrp_ignore_requests();
       (<span class="Type">void</span>)psrp_save_channels();
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open PSRP process mailbox </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(dirp == (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>((dirp = opendir(appl_mdir)) == (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
         pups_error(<span class="Constant">&quot;[psrp_mail_homeostat] failed to open process mailbox&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Loop over all files in mailbox </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {

         <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Is this a raw message? </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

         <span class="Statement">if</span>(snprintf(strmsg_number,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,next_item-&gt;d_name) == <span class="Constant">1</span>)
         {

            <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> First lock the mailbox </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

            (<span class="Type">void</span>)snprintf(strmsg_number,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,msg_number);

            <span class="Statement">if</span>(access(strmsg_number,F_OK | R_OK) != (-<span class="Constant">1</span>))
            {  (<span class="Type">void</span>)snprintf(mailbox_lock,SSIZE,<span class="Constant">&quot;lock.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,msg_number);
               <span class="Statement">while</span>(pups_creat(mailbox_lock,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
               {     (<span class="Type">void</span>)psrp_restore_channels();
                     (<span class="Type">void</span>)psrp_accept_requests();

                     <span class="Statement">return</span>(-<span class="Constant">1</span>);
               }


               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> We have the lock but someone else has already processed the mail! </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(access(strmsg_number,F_OK | R_OK) == (-<span class="Constant">1</span>))
               {
                  <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Unlock mailbox </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)unlink(mailbox_lock);
               }


               <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> We will produce some kind of reply -- give it a subject line </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

               (<span class="Type">void</span>)snprintf(subject,SSIZE,<span class="Constant">&quot;Reply from PSRP server </span><span class="Special">%s</span><span class="Constant">[</span><span class="Special">%d</span><span class="Constant">]@</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);


               <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Check for mail (decoding and MIME encapsulated messages we may find) </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

               <span class="Statement">if</span>(psrp_mime_storeparts(strmsg_number,appl_mime_type) == <span class="Constant">0</span>)
               {  <span class="Type">char</span> reply[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Mail for us (extract PUPS/PSRP commandlist from text) </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

                  <span class="Statement">if</span>(psrp_msg2requestlist(strmsg_number,psrp_requestlist) == (-<span class="Constant">1</span>))
                  {

                     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Cannot understand mail -- tell sender about problem </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(psrp_get_replyto(strmsg_number,appl_replyto) == (-<span class="Constant">1</span>))
                     {  <span class="Statement">if</span>(appl_verbose == TRUE)
                        {  (<span class="Type">void</span>)strdate(date);
                           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): problem with mail </span><span class="Special">\&quot;</span><span class="Constant">replyto</span><span class="Special">\&quot;</span><span class="Constant"> address</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                              date,appl_name,appl_pid,appl_host,appl_owner);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                        }
                     }
                     <span class="Statement">else</span>
                     {  (<span class="Type">void</span>)snprintf(reply_cmd,SSIZE,<span class="Constant">&quot;mail -s </span><span class="Special">%s</span><span class="Constant"> s&quot;</span>,appl_replyto,subject);
                        (<span class="Type">void</span>)snprintf(reply,SSIZE,<span class="Constant">&quot;PSRP server </span><span class="Special">%s</span><span class="Constant">[</span><span class="Special">%d</span><span class="Constant">]@</span><span class="Special">%s</span><span class="Constant"> could not understand you!</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);


                        <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Mail sender </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

                        <span class="Statement">if</span>((reply_stream = popen(reply_cmd,<span class="Constant">&quot;w&quot;</span>)) != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
                        {  (<span class="Type">void</span>)fputs(reply,reply_stream);
                           (<span class="Type">void</span>)pclose(reply_stream);
                        }

                        <span class="Statement">if</span>(appl_verbose == TRUE)
                        {  (<span class="Type">void</span>)strdate(date);
                           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): mail request from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> rejected (message not understood)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                      date,appl_name,appl_pid,appl_host,appl_owner,appl_replyto);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                        }
                     }
                  }
                  <span class="Statement">else</span>
                  {  <span class="Type">char</span> tmpfile[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
                          reply_command[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                     <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Secure server must be authenticated </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
                     {  <span class="Statement">if</span>(strncmp(psrp_requestlist,<span class="Constant">&quot;password&quot;</span>,<span class="Constant">8</span>) != <span class="Constant">0</span>)
                        {  <span class="Type">char</span> reply_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                           (<span class="Type">void</span>)snprintf(reply_cmd,SSIZE,<span class="Constant">&quot;mail -s </span><span class="Special">%s</span><span class="Constant"> s&quot;</span>,appl_replyto,subject);
                           (<span class="Type">void</span>)snprintf(reply,SSIZE,<span class="Constant">&quot;PSRP server </span><span class="Special">%s</span><span class="Constant">[</span><span class="Special">%d</span><span class="Constant">]@</span><span class="Special">%s</span><span class="Constant"> is secure (and requires authentication)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);


                           <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment"> Mail sender </span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

                           <span class="Statement">if</span>((reply_stream = popen(reply_cmd,<span class="Constant">&quot;w&quot;</span>)) != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
                           {  (<span class="Type">void</span>)fputs(reply,reply_stream);
                              (<span class="Type">void</span>)pclose(reply_stream);
                           }

                           <span class="Statement">if</span>(appl_verbose == TRUE)
                           {  (<span class="Type">void</span>)strdate(date);
                              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): mail request from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> rejected (not authenticated)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                              date,appl_name,appl_pid,appl_host,appl_owner,appl_replyto);
                              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                           }
                        }
                     }

                     <span class="Statement">if</span>(appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)strdate(date);
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): processing incoming mail from </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                             date,appl_name,appl_pid,appl_host,appl_owner,appl_replyto);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                     }

                     <span class="Statement">if</span>(psrp_get_replyto(strmsg_number,appl_replyto) == (-<span class="Constant">1</span>))
                     {  <span class="Statement">if</span>(appl_verbose == TRUE)
                        {  (<span class="Type">void</span>)strdate(date);
                           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): problem with mail </span><span class="Special">\&quot;</span><span class="Constant">replyto</span><span class="Special">\&quot;</span><span class="Constant"> address</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                              date,appl_name,appl_pid,appl_host,appl_owner);
                           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                        }
                     }

                     <span class="Statement">if</span>(strcmp(psrp_requestlist,<span class="Constant">&quot;none&quot;</span>) != <span class="Constant">0</span>)
                     {

                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Send commandlist to PSRP command parser </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

                        (<span class="Type">void</span>)snprintf(tmpfile,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.reply.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,strmsg_number,appl_pid);
                        psrp_out = pups_fopen(tmpfile,<span class="Constant">&quot;w&quot;</span>,LIVE);
                        (<span class="Type">void</span>)psrp_parse_request(psrp_requestlist,MAIL_FACE);
                        (<span class="Type">void</span>)pups_fclose(psrp_out);


                        <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment"> Send reply to sender </span><span class="Comment">*/</span>
                        <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

                        (<span class="Type">void</span>)snprintf(reply_cmd,SSIZE,<span class="Constant">&quot;cat </span><span class="Special">%s</span><span class="Constant"> | mail -s </span><span class="Special">%s</span><span class="Constant"> s&quot;</span>,tmpfile,appl_replyto,subject);
                        (<span class="Type">void</span>)system(reply_command);
                     }


                     <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> Application specific mail handler which runs when </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment"> mail has been received.                           </span><span class="Comment">*/</span>
                     <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

                     <span class="Statement">if</span>((<span class="Type">void</span> *)appl_mail_handler != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                        (<span class="Type">void</span>)(*appl_mail_handler)(appl_mdir);
                  }


                  <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Remove message (from MH drop) </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)psrp_mime_delete(strmsg_number);


                  <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment"> Unlock mailbox </span><span class="Comment">*/</span>
                  <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

                  (<span class="Type">void</span>)unlink(mailbox_lock);
               }
            }
        }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have finished processing mail </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)closedir(dirp);
    dirp = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;

    (<span class="Type">void</span>)psrp_restore_channels();
    (<span class="Type">void</span>)psrp_accept_requests();
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Rename existing PSRP channels (this function expect all appl builtins to </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> have been modified appropriately before it is called)                    </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_rename_channel(<span class="Type">const</span> <span class="Type">char</span> *psrp_name)

{   <span class="Type">char</span> new_channel_name_in[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         new_channel_name_out[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         new_stdin_pst_name[SSIZE]    = <span class="Constant">&quot;&quot;</span>,
         new_stdout_pst_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         new_stderr_pst_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_rename_channel] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(psrp_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(appl_ch_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">&quot;</span>,psrp_name,appl_host);

    (<span class="Type">void</span>)snprintf(new_channel_name_out,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#out#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);
    (<span class="Type">void</span>)snprintf(new_channel_name_in,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/psrp#</span><span class="Special">%s</span><span class="Constant">#fifo#in#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_ch_name,appl_pid,appl_uid);

    <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
      (<span class="Type">void</span>)snprintf(new_stdin_pst_name,SSIZE,  <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdin.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,psrp_name,appl_host,appl_pid,appl_uid);

    <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
      (<span class="Type">void</span>)snprintf(new_stdout_pst_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdout.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,psrp_name,appl_host,appl_pid,appl_uid);

    <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
      (<span class="Type">void</span>)snprintf(new_stderr_pst_name,SSIZE, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stderr.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,psrp_name,appl_host,appl_pid,appl_uid);


<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB NEW CHIN:       </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,new_channel_name_in);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB NEW CHOUT:      </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,new_channel_name_out);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB NEW PST_STDIN:  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,new_stdin_pst_name);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB NEW PST_STDOUT: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,new_stdout_pst_name);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PSRPLIB NEW PST_STDERR  </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,new_stderr_pst_name);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if (renamed) channel is already in use </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> if it is abort the renaming operation               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(new_channel_name_in,F_OK)  == <span class="Constant">0</span> ||
       access(new_channel_name_out,F_OK) == <span class="Constant">0</span> ||
       access(new_stdin_pst_name,F_OK)   == <span class="Constant">0</span> ||
       access(new_stdout_pst_name,F_OK)  == <span class="Constant">0</span> ||
       access(new_stderr_pst_name,F_OK)  == <span class="Constant">0</span>)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell clients that a server change is pending </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_reactivate_clients();

    <span class="Statement">if</span>(rename(channel_name_in, new_channel_name_in) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)strlcpy(channel_name_in, new_channel_name_in,SSIZE);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(rename(channel_name_out,new_channel_name_out) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)strlcpy(channel_name_out,new_channel_name_in,SSIZE);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(strcmp(new_stdin_pst_name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(rename(ftab[<span class="Constant">0</span>].fname,new_stdin_pst_name) == (-<span class="Constant">1</span>))
          <span class="Statement">return</span>(-<span class="Constant">1</span>);

       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fname,new_stdin_pst_name,SSIZE);
    }

    <span class="Statement">if</span>(strcmp(new_stdout_pst_name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(rename(ftab[<span class="Constant">1</span>].fname,new_stdout_pst_name) == (-<span class="Constant">1</span>))
          <span class="Statement">return</span>(-<span class="Constant">1</span>);

       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fname,new_stdout_pst_name,SSIZE);
    }

    <span class="Statement">if</span>(strcmp(new_stderr_pst_name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(rename(ftab[<span class="Constant">2</span>].fname,new_stderr_pst_name) == (-<span class="Constant">1</span>))
          <span class="Statement">return</span>(-<span class="Constant">1</span>);

       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fname,new_stderr_pst_name,SSIZE);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Reactivate connected clients </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> psrp_reactivate_clients(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CLIENTS; ++i)
    {  <span class="Statement">if</span>(psrp_client_pid[i] != (-<span class="Constant">1</span>))
       {  <span class="Statement">if</span>(kill(psrp_client_pid[i],SIGCLIENT) == (-<span class="Constant">1</span>))
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to reactivate client </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_host,appl_owner,i);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): client </span><span class="Special">%d</span><span class="Constant"> reactivated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                  date,appl_name,appl_pid,appl_host,appl_owner,i);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }
       }
    }

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="PreProc">#ifdef SSH_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Routine to start server on given target host </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_remote_start(<span class="Type">const</span> <span class="Type">char</span> *hostname, <span class="Type">const</span> _BOOLEAN bg, <span class="Type">const</span> <span class="Type">int</span> argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        child_pid       = (-<span class="Constant">1</span>);

    <span class="Type">char</span> cmdline[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         ssh_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN vector_found  = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[psrp_remote_start] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

    <span class="Statement">if</span>(hostname == (<span class="Type">const</span> <span class="Type">char</span> *) <span class="Constant">NULL</span>  ||
       argv     == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build command to be executed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cmdline,appl_bin_name,SSIZE);
    (<span class="Type">void</span>)strlcat(cmdline,<span class="Constant">&quot; &quot;</span>,SSIZE);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;argc+<span class="Constant">1</span>; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We need to ignore to -on &lt;host&gt; </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> command line item               </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-on&quot;</span>) == <span class="Constant">0</span>)
          ++i;
       <span class="Statement">else</span>
       { (<span class="Type">void</span>)strlcat(cmdline,argv[i],SSIZE);
         (<span class="Type">void</span>)strlcat(cmdline,<span class="Constant">&quot; &quot;</span>,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build command to be remotely executed        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> note that we can use password authentication </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> as we are pushing server from command line   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REMOTE CMDLINE: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,cmdline);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(ssh_remote_port,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)snprintf(ssh_cmd,SSIZE,<span class="Constant">&quot;exec ssh -n -p 22 </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_owner,hostname,cmdline);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(ssh_cmd,SSIZE,<span class="Constant">&quot;exec ssh -n -p </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssh_remote_port,appl_owner,hostname,cmdline);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is PSRP server running in background on remote host? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(bg == TRUE)
       (<span class="Type">void</span>)strlcat(ssh_cmd,<span class="Constant">&quot; &gt;&amp; /dev/null &amp;&quot;</span>,SSIZE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);

       <span class="Statement">if</span>(bg == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): starting on host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (in background)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_host,appl_owner,hostname);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): starting on host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (in foreground)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_host,appl_owner,hostname);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parent side of fork              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parent has to run ssh command    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> so that it remains in foreground </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((child_pid = fork()) != <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remote command </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)execlp(<span class="Constant">&quot;bash&quot;</span>,<span class="Constant">&quot;bash&quot;</span>,<span class="Constant">&quot;-c&quot;</span>,ssh_cmd,(<span class="Type">char</span> *)<span class="Constant">0</span>);


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We should not get here </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to start on host </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                              date,appl_name,appl_pid,appl_host,appl_owner,hostname);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Child side of fork  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove PSRP channel </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> on launch-host      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)pups_exit(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>



<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Process a set of (slaved) PSRP requests </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SSH_SUPPORT</span>
_PUBLIC <span class="Type">char</span> **psrp_process_sic_transaction_list(<span class="Type">const</span> <span class="Type">char</span>  *hostname, <span class="Comment">// Host running remote server (and slaved client)</span>
                                                 <span class="Type">const</span> <span class="Type">char</span>  *ssh_port, <span class="Comment">// Port for ssh connection to remote host</span>
                                                 <span class="Type">const</span> <span class="Type">int</span>  n_requests, <span class="Comment">// Number of request to be sent to remote server</span>
                                                 <span class="Type">const</span> <span class="Type">char</span>  *requests) <span class="Comment">// Request list</span>
<span class="PreProc">#else</span>
_PUBLIC <span class="Type">char</span> **psrp_process_sic_transaction_list(<span class="Type">const</span> <span class="Type">char</span> *hostname,  <span class="Comment">// Host running remote server (and slaved client)</span>
						 <span class="Type">const</span> <span class="Type">int</span>  n_requests, <span class="Comment">// Number of request to be sent to remote server</span>
                 				 <span class="Type">const</span>       *requests) <span class="Comment">// Request list</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

{   <span class="Type">int</span>  i,
         ret,
         size,
         eff_n_requests;

    _BOOLEAN looper           = FALSE,
             ignore_replys    = FALSE;

    <span class="Type">char</span> sic_name[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         next_request[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         *reply               = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
         **replys             = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

    psrp_channel_type *sic    = (psrp_channel_type *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
      pups_error(<span class="Constant">&quot;[psrp_process_sic_transaction_list] attempt by non root thread to perform PUPS/P3 PSRP operation&quot;</span>);

<span class="PreProc">    #ifdef PSRPLIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[psrp_process_sic_transaction_list] HOST:         </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,hostname);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[psrp_process_sic_transaction_list] REQUESTS:     </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,    n_requests);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[psrp_process_sic_transaction_list] REQUEST LIST: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,requests);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_requests == <span class="Constant">0</span> || requests == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we going to log replys? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_requests &lt; <span class="Constant">0</span>)
    {  eff_n_requests *= (-<span class="Constant">1</span>);
       ignore_replys   =  TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create SIC channels for slaved interaction </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Identifier for SIC channel </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(sic_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">[sic]&quot;</span>,appl_name);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> SIC is local </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hostname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {

<span class="PreProc">       #ifdef SSH_SUPPORT</span>
       <span class="Statement">if</span>((sic = psrp_create_slaved_interaction_client((<span class="Type">char</span> *)<span class="Constant">NULL</span>,<span class="Constant">&quot;&quot;</span>,<span class="Constant">&quot;pslave&quot;</span>)) == (psrp_channel_type *)<span class="Constant">NULL</span>)
<span class="PreProc">       #else</span>
       <span class="Statement">if</span>((sic = psrp_create_slaved_interaction_client(<span class="Constant">&quot;pslave&quot;</span>)) == (psrp_channel_type *)<span class="Constant">NULL</span>)
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIC creation failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[psrp_process_sic_transaction_list] local SIC_CREATE: failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

          <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
       }
    }


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> SIC is remote </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">char</span> eff_ssh_port[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Is ssh port specified? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ssh_port == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)strlcpy(eff_ssh_port,<span class="Constant">&quot;22&quot;</span>,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(eff_ssh_port,ssh_port,SSIZE);

       <span class="Statement">if</span>((sic = psrp_create_slaved_interaction_client(hostname,eff_ssh_port,<span class="Constant">&quot;pslave&quot;</span>)) == (psrp_channel_type *)<span class="Constant">NULL</span>)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIC creation failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

<span class="PreProc">          #ifdef PSRPLIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[psrp_process_sic_transaction_list] remote SIC_CREATE: failed</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

          <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create buffer for replies </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    replys = (<span class="Type">char</span> **)calloc(eff_n_requests,<span class="Statement">sizeof</span>(<span class="Type">char</span> *));


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Send requests and collect replys </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strext(<span class="Constant">' '</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;eff_n_requests; ++i)
    {   looper = strext(<span class="Constant">';'</span>,next_request,requests);

<span class="PreProc">        #ifdef PSRPLIB_DEBUG</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REQUEST </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,i,next_request);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

        <span class="Statement">if</span>(looper != FALSE)
        {  <span class="Statement">if</span>(ignore_replys == FALSE)
           {  <span class="Statement">if</span>((reply = psrp_slaved_client_transaction(TRUE,sic,next_request)) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                 replys[i] = reply;

<span class="PreProc">              #ifdef PSRPLIB_DEBUG</span>
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;REPLY </span><span class="Special">%d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,i,reply);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRPLIB_DEBUG </span><span class="Comment">*/</span>

           }
           <span class="Statement">else</span>
              (<span class="Type">void</span>)psrp_slaved_client_transaction(FALSE,sic, next_request);
        }
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIC transaction done</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>) psrp_destroy_slaved_interaction_client(sic,TRUE);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIC channel closed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(replys);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set up (exec) search paths. This assumes that </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> exec is invoking a bash (Bourne again) shell  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_exec_env(<span class="Type">const</span> <span class="Type">char</span> *remote_env)

{   <span class="Type">char</span> appl_cwd[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(remote_env == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get current directory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)getcwd(appl_cwd,SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Exec shell is bash </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PSRP_DEBUG</span>
    (<span class="Type">void</span>)snprintf(remote_env,SSIZE,<span class="Constant">&quot;source $HOME/.psrp_bash_profile &gt;&amp; /dev/null; echo $PATH; cd </span><span class="Special">%s</span><span class="Constant"> &gt;&amp; /dev/null&quot;</span>,appl_cwd);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)snprintf(remote_env,SSIZE,<span class="Constant">&quot;source $HOME/.psrp_bash_profile &gt;&amp; /dev/null; cd </span><span class="Special">%s</span><span class="Constant"> &gt;&amp; /dev/null&quot;</span>,appl_cwd);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Enable PSRP abort status flag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_enable_abrtflag(<span class="Type">void</span>)

{   psrp_abrtflag_enable = TRUE;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Disable PSRP abort status flag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_disable_abrtflag(<span class="Type">void</span>)

{   psrp_abrtflag_enable = FALSE;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Clear PSRP abort flag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_clear_abrtflag(<span class="Type">void</span>)
{   psrp_abrtflag = FALSE;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get PSRP abort status </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN psrp_get_abrtflag(<span class="Type">void</span>)

{   pups_set_errno(OK);
    <span class="Statement">return</span>(psrp_abrtflag);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Enable/disable PSRP client interrupt (via SIGABRT) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_critical(<span class="Type">const</span> _BOOLEAN critical)

{

    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enter critcial section </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(critical == TRUE)

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell current client server is non interuptable </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)kill(psrp_client_pid[c_client],SIGCRITICAL);


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Exit critical section </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tell current client server is interuptable </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)kill(psrp_client_pid[c_client],SIGCRITICAL);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Block/unblock client interrupt (via SIGABRT) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> psrp_client_block(<span class="Type">const</span> _BOOLEAN block)

{   sigset_t block_set;

    (<span class="Type">void</span>)sigemptyset(&amp;block_set);
    (<span class="Type">void</span>)sigaddset  (&amp;block_set,<span class="Constant">SIGABRT</span>);

    <span class="Statement">if</span>(block == TRUE)
       (<span class="Type">void</span>)sigprocmask(SIG_BLOCK,  &amp;block_set,(sigset_t *)<span class="Constant">NULL</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)sigprocmask(SIG_UNBLOCK,&amp;block_set,(sigset_t *)<span class="Constant">NULL</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is PEN (porcess execution name) unique? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> psrp_pen_unique(<span class="Type">void</span>)

{
    <span class="Statement">if</span>(psrp_pname_to_pid(appl_name) == PSRP_DUPLICATE_PROCESS_NAME)
    {  (<span class="Type">void</span>)strlcpy(errstr,<span class="Constant">&quot;PEN (</span><span class="Special">%s</span><span class="Constant">) is not unique&quot;</span>,SSIZE);
       pups_error(errstr);
    }
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
