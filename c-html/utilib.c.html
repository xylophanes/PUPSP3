<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<title>/usr/local/src/pupsp3-5.4.9.src.git/pupscore.src/utilib.c.html</title>
<meta name="Generator" content="Vim/7.4">
<meta name="plugin-version" content="vim7.4_v1">
<meta name="syntax" content="c">
<meta name="settings" content="use_css,pre_wrap,no_foldcolumn,prevent_copy=">
<meta name="colorscheme" content="none">
<style type="text/css">
<!--
pre { white-space: pre-wrap; font-family: monospace; color: #000000; background-color: #ffffff; }
body { font-family: monospace; color: #000000; background-color: #ffffff; }
* { font-size: 1em; }
.Error { color: #ffffff; background-color: #ff6060; padding-bottom: 1px; }
.Comment { color: #0000c0; }
.Constant { color: #c00000; }
.Special { color: #c000c0; }
.Statement { color: #af5f00; }
.PreProc { color: #c000c0; }
.Type { color: #008000; }
-->
</style>

<script type='text/javascript'>
<!--

-->
</script>
</head>
<body>
<pre id='vimCodeElement'>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Purpose: General purpose utilities library.</span>

<span class="Comment">    Author:  M.A. O'Neill</span>
<span class="Comment">             Tumbling Dice Ltd</span>
<span class="Comment">             Gosforth</span>
<span class="Comment">             Newcastle upon Tyne</span>
<span class="Comment">             NE3 4RT</span>
<span class="Comment">             United Kingdom</span>

<span class="Comment">    Version: 7.19</span>
<span class="Comment">    Dated:   5th September 2023 </span>
<span class="Comment">    E-Mail:  mao@tumblingdice.co.uk</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="PreProc">#include </span><span class="Constant">&lt;me.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;ctype.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;signal.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/file.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;fcntl.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/types.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;unistd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/time.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/stat.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/wait.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dirent.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;bsd/string.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;errno.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;setjmp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdarg.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pwd.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sched.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdarg.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/timeb.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;xtypes.h&gt;</span>



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> If we have OpenMP support then we also have pthread support </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> (OpenMP is built on pthreads for Linux distributions).      </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#if defined(_OPENMP) &amp;&amp; !defined(PTHREAD_SUPPORT)</span>
<span class="PreProc">#define PTHREAD_SUPPORT</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;tad.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SHADOW_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;shadow.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SHADOW_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef SECURE</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sed_securicor.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SECURE </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;termios.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;netdb.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/ioctl.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;time.h&gt;</span>


<span class="PreProc">#ifdef DLL_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;dll.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;pheap.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#include </span><span class="Constant">&lt;sched.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sys/vfs.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;stdlib.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;psrp.h&gt;</span>
<span class="PreProc">#include </span><span class="Constant">&lt;casino.h&gt;</span>


<span class="PreProc">#ifndef __NOT_LIB_SOURCE__</span>
<span class="PreProc">#define __UTILIB__</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> __NOT_LIB_SOURCE__ </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get signal mapping appropriate to OS and hardware architecture </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define __DEFINE__</span>
<span class="PreProc">#if defined(I386) || defined(X86_64)</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.x86.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> I386) || X86_64 </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV6L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV6L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef ARMV7L</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ARMV7L </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef AARCH64</span>
<span class="PreProc">#include </span><span class="Constant">&lt;sig.linux.arm.h&gt;</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> AARCH64 </span><span class="Comment">*/</span>
<span class="PreProc">#undef __DEFINE__</span>

<span class="PreProc">#undef   __NOT_LIB_SOURCE__</span>
<span class="PreProc">#include </span><span class="Constant">&lt;utils.h&gt;</span>
<span class="PreProc">#define  __NOT_LIB_SOURCE__</span>

<span class="PreProc">#include </span><span class="Constant">&lt;netlib.h&gt;</span>


<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Pipe migration protocol (PMP) verson number </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define FSHP_VERSION </span><span class="Constant">&quot;1.00&quot;</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Embedded window resizing data in buffer </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define WINRESIZE_PENDING    </span><span class="Constant">255</span>


<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> ISOFS_SUPER_MAGIC definition </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define ISOFS_SUPER_MAGIC    </span><span class="Constant">0x9660</span>
<span class="PreProc">#define NFS_SUPER_MAGIC      </span><span class="Constant">0x6969</span>


<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handle a broken va_list </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef VA_BROKEN</span>
<span class="Type">int</span> __builtin_va_alist;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> VA_BROKEN </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef DRAFT_POSIX_SIGACTION</span>
<span class="PreProc">#define SA_RESTART </span><span class="Constant">0x0</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DRAFT_POSIX_SIGACTION </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables imported by this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>


_IMPORT _BOOLEAN psrp_reactivate_client;
_IMPORT _BOOLEAN in_psrp_new_segment;
_IMPORT <span class="Type">int</span>      psrp_seg_cnt;
_IMPORT <span class="Type">int</span>      chlockdes;
_IMPORT <span class="Type">int</span>      c_client;
_IMPORT <span class="Type">int</span>      psrp_client_pid[MAX_CLIENTS];



<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Standard globals required by std_init </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>


_PUBLIC <span class="Type">int</span>  ptr,                                                             <span class="Comment">// Argument pointer</span>
             sargc,                                                           <span class="Comment">// Argument count</span>
             t_args,                                                          <span class="Comment">// Total number of arguments</span>
             vitimer_quantum,                                                 <span class="Comment">// Time interval for (PSRP) timers</span>
             pupshold_cnt                  = <span class="Constant">0</span>,                               <span class="Comment">// Number of PUPS/P3 signals held</span>
	     appl_fsa_mode,                                                   <span class="Comment">// Filesystem access mode</span>
             appl_t_args,                                                     <span class="Comment">// Total application command tail arguments</span>
             appl_alloc_opt,                                                  <span class="Comment">// Allocation options (for pups_malloc etc.)</span>
             appl_max_files,                                                  <span class="Comment">// Maximum number of file table slots</span>
             appl_max_child,                                                  <span class="Comment">// Maximum number of child table slots</span>
             appl_max_pheaps,                                                 <span class="Comment">// Maximum number of persistent heap table slots</span>
             appl_max_vtimers,                                                <span class="Comment">// Maximum number of virtual timers</span>
             appl_max_orifices,                                               <span class="Comment">// Maximum number of orifice table slots</span>
             appl_vtag,                                                       <span class="Comment">// Version ID tag  for application</span>
             appl_last_child,                                                 <span class="Comment">// PID of last child forked by pups_system</span>
             appl_sid,                                                        <span class="Comment">// Session (process group) id</span>
             appl_pid,                                                        <span class="Comment">// Process id</span>
             appl_ppid,                                                       <span class="Comment">// Parent process</span>
             appl_uid,                                                        <span class="Comment">// Process UID</span>
             appl_gid;                                                        <span class="Comment">// Process GID</span>

<span class="PreProc">#ifdef CRIU_SUPPORT</span>
             appl_ssaves                  = <span class="Constant">0</span>,                                <span class="Comment">// Number of times state has been saved</span>
             appl_poll_time               = <span class="Constant">60</span>,                               <span class="Comment">// Poll time for (Criu) state saving</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef _OPENMP</span>
             appl_omp_threads,                                                <span class="Comment">// Number of OMP threads</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _OPENMP </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
             appl_root_tid                = (-<span class="Constant">1</span>);                             <span class="Comment">// LWP of root thread</span>
             appl_root_thread,                                                <span class="Comment">// Root (initial) thread for process </span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             appl_tty                     = (-<span class="Constant">1</span>),                             <span class="Comment">// Applications controlling terminal</span>
             appl_remote_pid,                                                 <span class="Comment">// Remote PID to relay signals to </span>
             appl_timestamp,                                                  <span class="Comment">// Application compilation time stamp</span>
             appl_nice_lvl                = <span class="Constant">10</span>;                               <span class="Comment">// Process niceness</span>

_PUBLIC  <span class="Type">int</span> pupsighold_cnt[MAX_SIGS]     = { [<span class="Constant">0</span> ... MAX_SIGS-<span class="Constant">1</span>] = <span class="Constant">1</span> };       <span class="Comment">// Counter for signal states</span>

_PUBLIC _BOOLEAN

         appl_verbose                     = FALSE,                            <span class="Comment">// Set appl_verbose reporting mode</span>
         appl_resident                    = FALSE;                            <span class="Comment">// TRUE if application is memory resident</span>
         appl_enable_resident             = FALSE;                            <span class="Comment">// TRUE if application can be memory resident</span>
         appl_proprietary                 = FALSE;                            <span class="Comment">// TRUE if application is proprietary</span>
         appl_nodetach                    = FALSE,                            <span class="Comment">// Don't detach stdio in background</span>
         test_mode                        = FALSE,                            <span class="Comment">// Set test mode</span>
         init                             = TRUE,                             <span class="Comment">// Initialise tail decoder system</span>
         pg_leader                        = FALSE,                            <span class="Comment">// Application is process group leader</span>
         appl_wait                        = FALSE,                            <span class="Comment">// TRUE if process stopped</span>
         appl_fgnd                        = TRUE,                             <span class="Comment">// TRUE if in foreground pgrp</span>
         appl_snames_crypted              = FALSE,                            <span class="Comment">// If TRUE encrypt shadow files</span>
         <span class="Comment">//pups_exit_entered                = FALSE,                            // TRUE if in pups_exit()</span>
         argd[<span class="Constant">255</span>];                                                           <span class="Comment">// Argument decode status flags</span>

<span class="PreProc">#ifdef CRIU_SUPPORT</span>
         appl_ssave                       = FALSE;                            <span class="Comment">// TRUE if (Criu) state saving enabled</span>

_PUBLIC <span class="Type">char</span> appl_ssave_dir[SSIZE]        = <span class="Constant">&quot;&quot;</span>;                               <span class="Comment">// Criu checkpoint directory for state saving</span>
_PUBLIC <span class="Type">char</span> appl_criu_dir[SSIZE]         = <span class="Constant">&quot;/tmp&quot;</span>;                           <span class="Comment">// Criu directory (holds migratable files and checkpoint directories)</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef SSH_SUPPORT</span>
_PUBLIC <span class="Type">char</span>     ssh_remote_port[SSIZE]   = <span class="Constant">&quot;22&quot;</span>;                             <span class="Comment">// Port for remote node</span>
_PUBLIC <span class="Type">char</span>     ssh_remote_uname[SSIZE]  = <span class="Constant">&quot;&quot;</span>;                               <span class="Comment">// Username for remote node</span>
_PUBLIC _BOOLEAN ssh_compression          = FALSE;                            <span class="Comment">// Use compressed ssh network tunneling</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef MAIL_SUPPORT</span>
_PUBLIC _BOOLEAN appl_mailable            = FALSE;                            <span class="Comment">// TRUE if process supports mail</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN appl_secure              = FALSE;                            <span class="Comment">// TRUE if application secure</span>
_PUBLIC _BOOLEAN appl_kill_pg             = FALSE;                            <span class="Comment">// If TRUE kill process group on exit</span>
_PUBLIC _BOOLEAN appl_default_chname      = TRUE;                             <span class="Comment">// TRUE if PSRP channel name default</span>
_PUBLIC _BOOLEAN appl_have_pen            = FALSE;                            <span class="Comment">// TRUE if binname != execution name</span>
_PUBLIC _BOOLEAN appl_psrp                = FALSE;                            <span class="Comment">// TRUE if application PSRP enabled</span>
_PUBLIC _BOOLEAN appl_psrp_load           = TRUE;                             <span class="Comment">// If TRUE load PSRP resources at start</span>
_PUBLIC _BOOLEAN appl_psrp_save           = FALSE;                            <span class="Comment">// If TRUE save dispatch table at exit</span>
_PUBLIC _BOOLEAN appl_etrap               = FALSE;                            <span class="Comment">// If TRUE trap-wait in pups_exit()</span>
_PUBLIC _BOOLEAN appl_ppid_exit           = FALSE;                            <span class="Comment">// If TRUE exit if parent terminates</span>
_PUBLIC _BOOLEAN appl_rooted              = FALSE;                            <span class="Comment">// If TRUE system context cannot migrate</span>
_PUBLIC _BOOLEAN pups_process_homeostat   = FALSE;                            <span class="Comment">// TRUE if process homeostat enabled </span>
_PUBLIC _BOOLEAN ignore_pups_signals      = TRUE;                             <span class="Comment">// Ignore PUPS signals if TRUE</span>
_PUBLIC _BOOLEAN pups_abort_restart       = FALSE;                            <span class="Comment">// TRUE if abort handler enabled</span>
_PUBLIC _BOOLEAN in_vt_handler            = FALSE;                            <span class="Comment">// TRUE if in vt_handler()</span>
_PUBLIC  sigjmp_buf pups_restart_buf;                                         <span class="Comment">// Abort restart buffer</span>


_PUBLIC _BOOLEAN    ftab_extend           = TRUE;                             <span class="Comment">// TRUE if extening file table</span>
_PUBLIC  ftab_type  *ftab                 = (ftab_type *)<span class="Constant">NULL</span>;                <span class="Comment">// PUPS file table</span>
_PUBLIC  chtab_type *chtab                = (chtab_type *)<span class="Constant">NULL</span>;               <span class="Comment">// PUPS child (process) table</span>
_PUBLIC  sigtab_type sigtab[MAX_SIGS];                                        <span class="Comment">// Addresses of signal handlers</span>
_PUBLIC  vttab_type *vttab                = (vttab_type *)<span class="Constant">NULL</span>;               <span class="Comment">// Virtual timer table</span>


_PUBLIC <span class="Type">char</span>        date[SSIZE]           = <span class="Constant">&quot;&quot;</span>;                               <span class="Comment">// Date stamp</span>
_PUBLIC <span class="Type">char</span>        errstr[SSIZE]         = <span class="Constant">&quot;&quot;</span>;                               <span class="Comment">// Error string</span>
_PUBLIC <span class="Type">char</span>        appl_machid[SSIZE]    = <span class="Constant">&quot;&quot;</span>;                               <span class="Comment">// Unique machine (host) i.d.</span>

_PUBLIC <span class="Type">char</span> *version                     = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Version of the code</span>
             *appl_owner                  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Owner of this application</span>
             *appl_password               = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Application owners password</span>
             *appl_crypted                = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Application encrypted owners password</span>
             *appl_name                   = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of application</span>
             *appl_remote_host            = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of remote host for signal relay</span>
             *appl_fifo_dir               = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of default FIFO patchboard</span>
             *appl_ch_name                = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of application PSRP channel</span>
             *appl_logfile                = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Error/log file</span>

<span class="PreProc">#ifdef MAIL_SUPPORT</span>
             *appl_mdir                   = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// MH inbox for this process</span>
             *appl_mh_folder              = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// MH folder for this process</span>
             *appl_mime_dir               = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// MIME message parts workspace</span>
             *appl_mime_type              = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// MIME message type</span>
             *appl_replyto                = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// MH reply address</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>

             *appl_tunnel_path            = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Pathname for process tunnel</span>
             *appl_bin_name               = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of process binary</span>
             *appl_ttyname                = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of process controlling terminal</span>
             *appl_pam_name               = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of PSRP authentication module</span>
             *author                      = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Author name</span>
             *revdate                     = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Revision date</span>
             *arg_f_name                  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Name of comamnd tail argument file</span>
             *args[<span class="Constant">256</span>]                   = { [<span class="Constant">0</span> ... <span class="Constant">255</span>] = (<span class="Type">char</span> *)<span class="Constant">NULL</span> },   <span class="Comment">// Secondary argument vector</span>
	     *appl_home                   = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Effective home directory</span>
             *appl_cwd                    = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Current working directory</span>
             *appl_cmd_str                = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Application command string</span>
             *appl_host                   = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Application host processor node</span>
             *appl_state                  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Application state information</span>
             *appl_err                    = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,                     <span class="Comment">// Application error information</span>
             appl_argfifo[SSIZE]          = <span class="Constant">&quot;&quot;</span>;                               <span class="Comment">// Argument FIFO (for memory resident application)</span>

_PUBLIC <span class="Type">int</span>  (*appl_mail_handler)(<span class="Type">char</span> *);                                    <span class="Comment">// Application specific mail handler</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Private variables used by this routine </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Homeostatis status for stdio </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE  <span class="Type">int</span> in_state   = NONE;
_PRIVATE  <span class="Type">int</span> pin_state  = NONE;
_PRIVATE  <span class="Type">int</span> out_state  = NONE;
_PRIVATE  <span class="Type">int</span> pout_state = NONE;
_PRIVATE  <span class="Type">int</span> err_state  = NONE;
_PRIVATE  <span class="Type">int</span> perr_state = NONE;


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Error handler parameters (preset to PUPS default values) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE  <span class="Type">int</span>  err_action   = PRINT_ERROR_STRING | EXIT_ON_ERROR;
_PRIVATE  <span class="Type">int</span>  err_code     = (-<span class="Constant">2</span>);
_PRIVATE  <span class="Type">FILE</span> *err_stream  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
_PRIVATE  <span class="Type">FILE</span> *fgnd_stdin  = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
_PRIVATE  <span class="Type">FILE</span> *fgnd_stdout = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
_PRIVATE  <span class="Type">FILE</span> *fgnd_stderr = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


_PRIVATE _BOOLEAN in_setvitimer     = FALSE;      				<span class="Comment">// TRUE if in setvitimer</span>
_PRIVATE _BOOLEAN no_vt_services    = FALSE;    				<span class="Comment">// TRUE if VT services disabled</span>
_PRIVATE _BOOLEAN do_closeall       = FALSE;      				<span class="Comment">// TRUE if closeall entered</span>
_PRIVATE _BOOLEAN started_detached  = FALSE;      				<span class="Comment">// TRUE if application has been detached</span>
_PRIVATE _BOOLEAN default_argfile   = FALSE;      				<span class="Comment">// TRUE if default argument file</span>
_PRIVATE _BOOLEAN in_close_routine  = FALSE;      				<span class="Comment">// TRUE if in pups_close() or pups_fclose()</span>
_PRIVATE _BOOLEAN jump_vector       = TRUE;       				<span class="Comment">// Context OK for longjmp() if TRUE</span>



<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Private variables used by virtual interval timers </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span>         start_index        = <span class="Constant">0</span>;
_PRIVATE <span class="Type">int</span>         active_v_timers    = <span class="Constant">0</span>;
_PRIVATE _BOOLEAN    vt_no_reset        = FALSE;


<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Private variables used by child table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span>         n_children          = <span class="Constant">0</span>;


<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Checkpoint file name </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">char</span>        ckpt_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;



<span class="PreProc">#ifdef PTHREAD_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Mutexes used by this library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Thread safe pups_fork mutex </span>
_PUBLIC pthread_mutex_t pups_fork_mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread safe file table mutex</span>
_PUBLIC pthread_mutex_t ftab_mutex      = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread safe child table mutex</span>
_PUBLIC pthread_mutex_t chtab_mutex     = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread safe child table mutex</span>
_PRIVATE pthread_mutex_t sigtab_mutex   = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread safe lock table mutex</span>
_PRIVATE pthread_mutex_t lock_mutex     = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread safe vttimer mutex</span>
_PRIVATE pthread_mutex_t malarm_mutex   = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread safe date mutex</span>
_PRIVATE pthread_mutex_t date_mutex     = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// Thread error handler mutex</span>
_PRIVATE pthread_mutex_t errstr_mutex   = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="Comment">// File copy mutex</span>
_PRIVATE pthread_mutex_t copy_mutex     = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot and usage functions - used by slot manager </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Slot function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> utilib_slot(<span class="Type">int</span> level)
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;int lib utilib </span><span class="Special">%s</span><span class="Constant">: [ANSI C]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,UTILIB_VERSION);

    <span class="Statement">if</span>(level &gt; <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;(C) 1985-2022 Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;Author: M.A. O'Neill</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;PUPS/P3 general purpose utilities library (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">__TIME__</span>,<span class="Constant">__DATE__</span>);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
}


<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Usage function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> utilib_usage()
{   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Generic PUPS/P3 options</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;=======================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-mra [-cpu &lt;cpu available:</span><span class="Special">%f</span><span class="Constant">&gt;] [-mem &lt;mem required:</span><span class="Special">%d</span><span class="Constant">&gt; [-timeout &lt;hours:</span><span class="Special">%f</span><span class="Constant">&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                      PUPS_DEFAULT_MIN_CPU,PUPS_DEFAULT_MIN_MEM,PUPS_DEFAULT_RESOURCE_WAIT);

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-etrap:FALSE]   [-version:FALSE] [-vtag] [-usage:FALSE] [-verbose:FALSE [-test:FALSE]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-argf &lt;argfile&gt;] [-slots] [-slotinfo] [-secure:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">#ifdef SSH_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-on &lt;host&gt; [-bg:FALSE]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef MAIL_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-mail_dir &lt;mail directory&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef _OPENMP</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-omp_threads]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> _OPENMP </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_enable_resident == TRUE)
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-resident &lt;command argument FIFO&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-noseed:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-parent &lt;parent pid:</span><span class="Special">%d</span><span class="Constant"> | parent name&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_ppid);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-parent_exit:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-closestdio]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-tunnel]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-log]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-cwd &lt;working directory&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-growth_protection] &lt;retrys&gt; [-nice &lt;lvl: </span><span class="Special">%d</span><span class="Constant">&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_nice_lvl);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-pen &lt;process execution name:application name&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-bin &lt;application exec binary:pen defaulted&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-in | -inalive | -pin | -pinalive &lt;stdin redirection stream&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-out | -outalive | -pout | -poutalive &lt;stdout redirection stream&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-err | -erralive | -perr | -perralive &lt;stderr redirection stream&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-patchboard &lt;local or private PSRP patchboard:/tmp&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-no_vt_services:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-pg_leader] | [-session_leader]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-kill_pg:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-pgrp &lt;process group leader pid&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-channel_name &lt;process PSRP channel name&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">#ifdef SSH_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-ssh_port &lt;port&gt;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-ssh_compress]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">#ifdef CRIU_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-ssave [-t &lt;poll time:</span><span class="Special">%d</span><span class="Constant">&gt;] [-cd &lt;criu directory:/tmp]]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_poll_time);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-stdio_dead]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-pam &lt;PUPS authentication module name&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-shadows_crypted:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">#ifndef SUPPRESS_PSRP_USAGE</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-psrp_autoload:FALSEE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-psrp_autosave:FALSE]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SUPPRESS_PSRP_USAGE </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-vitab &lt;max virtual timers:32&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-ftab &lt;max files:32&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-chtab &lt;max children:32&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);


<span class="PreProc">#ifdef DLL_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-ortab &lt;max DLL orifices:32&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


<span class="PreProc">#ifdef PERSISTENT_HEAP_SUPPORT</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;[-phtab &lt;max persistent heaps:32&gt;]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Application specific options</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;============================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
}


<span class="PreProc">#ifdef SLOT</span>
<span class="PreProc">#include </span><span class="Constant">&lt;slotman.h&gt;</span>
_EXTERN <span class="Type">void</span> (* SLOT )() __attribute__ ((aligned(<span class="Constant">16</span>))) = utilib_slot;
_EXTERN <span class="Type">void</span> (* USE  )() __attribute__ ((aligned(<span class="Constant">16</span>))) = utilib_usage;
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SLOT </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Application build date </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

_EXTERN <span class="Type">char</span> appl_build_time[SSIZE];
_EXTERN <span class="Type">char</span> appl_build_date[SSIZE];




<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Application shell </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *shell = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Variables which are private to this application </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>


                           <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
_PRIVATE <span class="Type">int</span> sbrk_retrys;  <span class="Comment">/*</span><span class="Comment"> Maximum number of retrys for sbrk </span><span class="Comment">*/</span>
                           <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Procedures which are private to the utilities library </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef CRIU_SUPPORT</span>
<span class="Comment">// Perioidically save state (via Criu)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> ssave_homeostat(<span class="Type">void</span> *, <span class="Type">char</span> *);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>

<span class="Comment">/*</span><span class="Comment"> Extract embedded window resizing data from buffer </span><span class="Comment">*/</span>       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
_PROTOTYPE _PRIVATE _BOOLEAN ws_extract(<span class="Type">int</span>    ,              <span class="Comment">/*</span><span class="Comment"> File descriptor for ibuf    </span><span class="Comment">*/</span>
                                        _BYTE *,              <span class="Comment">/*</span><span class="Comment"> Input buffer                </span><span class="Comment">*/</span>
                                        <span class="Type">unsigned</span> <span class="Type">long</span>  <span class="Type">int</span>  , <span class="Comment">/*</span><span class="Comment"> Bytes in input buffer       </span><span class="Comment">*/</span>
                                        _BYTE *,              <span class="Comment">/*</span><span class="Comment"> Pre resize buffer           </span><span class="Comment">*/</span>
                                        <span class="Type">unsigned</span> <span class="Type">long</span>  <span class="Type">int</span> *, <span class="Comment">/*</span><span class="Comment"> Number of pre resize bytes  </span><span class="Comment">*/</span>
                                        _BYTE *,              <span class="Comment">/*</span><span class="Comment"> Post resize buffer          </span><span class="Comment">*/</span>
                                        <span class="Type">unsigned</span> <span class="Type">long</span>  <span class="Type">int</span>*,  <span class="Comment">/*</span><span class="Comment"> Number of post resize bytes </span><span class="Comment">*/</span>
                               <span class="Type">struct</span> winsize *);             <span class="Comment">/*</span><span class="Comment"> Winsize structure           </span><span class="Comment">*/</span>
                                                              <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

<span class="Comment">// Abort restart handler</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> pups_restart_handler(<span class="Type">int</span>);


<span class="PreProc">#ifdef CRIU_SUPPORT</span>
<span class="Comment">// Handler for state saving</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> ssave_handler(<span class="Type">int</span>);
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>

<span class="Comment">// Handler for SIGTTIN/SIGTTOU</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> fgio_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGTTIN/SIGTTOU</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> segbusfpe_handler(<span class="Type">int</span>);

<span class="Comment">// Handler to deal with segmentation violations</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> catch_sigsegv(<span class="Type">void</span>);

<span class="Comment">// Process group leaders handler for SIGTERM</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> pg_leaders_term_handler(<span class="Type">int</span>);

<span class="Comment">// Process group leaders handler for SIGHUP (SIGTSTP)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> pg_leaders_stop_handler(<span class="Type">int</span>);

<span class="Comment">// Process group leaders handler for SIGCONT</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> pg_leaders_cont_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGCONT (for PUPS processes other than process group leader)</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> pups_cont_handler(<span class="Type">int</span>);


<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for SIGQUIT - enables PUPS processes to exec </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PUPS exit functions on reciept of SIGQUIT            </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

_PROTOTYPE _PRIVATE <span class="Type">int</span> pups_exit_handler(<span class="Type">int</span>);

<span class="Comment">// Handler for SIGCHLD</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> chld_handler(<span class="Type">int</span>);

<span class="Comment">// Initialise PUPS virtual interval timers</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> initvitimers(<span class="Type">int</span>);

<span class="Comment">// Initialise PUPS file table</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> initftab(<span class="Type">int</span>, <span class="Type">int</span>);

<span class="Comment">// Initialise signal status</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> initsigstatus(<span class="Type">void</span>);

<span class="Comment">// Hoemeostat which reconnects migrating file system objects</span>
_PROTOTYPE _PRIVATE <span class="Type">int</span> reconnect(<span class="Type">int</span>, _BOOLEAN *);

<span class="Comment">// Initialise PUPS persistent heaps</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> shm_init(<span class="Type">void</span>);

<span class="Comment">// Initialise PUPS heap object tracking system</span>
_PROTOTYPE _PRIVATE <span class="Type">void</span> tinit(<span class="Type">void</span>);




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Make sure correct signal mask is used if we are multithreaded ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_sigprocmask(<span class="Type">int</span> how,  <span class="Type">const</span> sigset_t *<span class="Type">restrict</span> set, sigset_t *<span class="Type">restrict</span> oset)

{   <span class="Type">int</span> ret;

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     ret = pthread_sigmask(how,set,oset);
<span class="PreProc">     #else</span>
     ret = setprocmask(how,set,oset);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Get time accurate to milliseconds - this funtcion has to be double</span>
<span class="Comment">    precision because of the size of the integers in the timeb structure ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">double</span> millitime(<span class="Type">void</span>)

{    <span class="Type">double</span>       ret;
     <span class="Type">struct</span> timeb tspec;

     (<span class="Type">void</span>)ftime(&amp;tspec);
     ret = (<span class="Type">double</span>)tspec.time + (<span class="Type">double</span>)tspec.millitm/<span class="Constant">1000.0</span>;

     <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Get ip_address and node name of Internet device ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ip_info(<span class="Type">const</span> <span class="Type">char</span> *dev_name, <span class="Type">char</span> *ip_addr, <span class="Type">char</span> *node_name)
{
    <span class="Type">int</span> fd;

    <span class="Type">struct</span> ifreq       ifr;
    <span class="Type">struct</span> sockaddr_in sin;

    <span class="Type">char</span> buf[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(dev_name  == (<span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       ip_addr   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       node_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    fd = socket(AF_INET, SOCK_DGRAM, <span class="Constant">0</span>);
    ifr.ifr_addr.sa_family = AF_INET;

    <span class="Statement">if</span>(dev_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)snprintf(ifr.ifr_name, IFNAMSIZ, <span class="Constant">&quot;eth0&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(ifr.ifr_name, IFNAMSIZ, dev_name);

    <span class="Statement">if</span>(ioctl(fd, SIOCGIFADDR, &amp;ifr) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get IPV4 I.P. address (in human readable form) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Need to use inet_ntop for IPV4 and IPV6        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    snprintf(ip_addr,SSIZE, (<span class="Type">char</span> *)inet_ntoa(((<span class="Type">struct</span> sockaddr_in *)&amp;ifr.ifr_addr)-&gt;sin_addr));
    (<span class="Type">void</span>)close(fd);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get network node name (from I.P. address) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)memset(&amp;sin, <span class="Constant">0</span>, <span class="Statement">sizeof</span>(sin));
    sin.sin_family      = AF_INET;
    sin.sin_addr.s_addr = inet_addr(ip_addr);
    sin.sin_port        = <span class="Constant">0</span>;

    (<span class="Type">void</span>)getnameinfo( (<span class="Type">struct</span> sockaddr *)&amp;sin,
                       <span class="Statement">sizeof</span>(sin),
                       buf,
                       <span class="Statement">sizeof</span>(buf), <span class="Constant">NULL</span>, <span class="Constant">0</span>, <span class="Constant">0</span>);

    (<span class="Type">void</span>)strlcpy(node_name,buf,SSIZE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Round a floating point number to N significant figures</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC FTYPE sigfig(<span class="Type">const</span> FTYPE arg, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> digits)

{   FTYPE factor,
          sigfig_arg;

    <span class="Statement">if</span>(arg == <span class="Constant">0.0</span>)
       <span class="Statement">return</span>(<span class="Constant">0.0</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(digits == <span class="Constant">0</span>)
       <span class="Statement">return</span>(arg);

    factor     = POW(<span class="Constant">10.0</span>, digits - CEIL(LOG10(FABS(arg))));
    sigfig_arg = ROUND(arg * factor) / factor;

    <span class="Statement">return</span>(sigfig_arg);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Find the square of a floating point argument ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC FTYPE sqr(<span class="Type">const</span> FTYPE arg)

{   <span class="Statement">return</span>((FTYPE)arg*arg);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Swap a pair of integer arguments ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Type">void</span> iswap(<span class="Type">int</span> *arg_1, <span class="Type">int</span> *arg_2)

{   <span class="Type">int</span> temp;

    temp   = *arg_1;
    *arg_1 = *arg_2;
    *arg_2 = temp;
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Swap a pair of floating point arguments ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Type">void</span> fswap(FTYPE *arg_1, FTYPE *arg_2)

{   FTYPE temp;

    temp   = *arg_1;
    *arg_1 = *arg_2;
    *arg_2 = temp;
}



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Procedure to strip comments of the form {token} comment {token} from an</span>
<span class="Comment">    ASCII text file ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">FILE</span> *pups_strp_commnts(<span class="Type">const</span> <span class="Type">char</span> token, <span class="Type">const</span> <span class="Type">FILE</span> *c_file, <span class="Type">char</span> *tmp_f_name)

{  <span class="Type">int</span> i;

   <span class="Type">char</span> ch,
        *line = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

   _BOOLEAN content = FALSE,
            looper  = TRUE;

   <span class="Type">FILE</span>     *t_file = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

   <span class="Statement">if</span>(c_file == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || tmp_f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
   }

   <span class="Statement">if</span>(access(tmp_f_name,F_OK) == (-<span class="Constant">1</span>) &amp;&amp; pups_creat(tmp_f_name,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
   }

   t_file = fopen(tmp_f_name,<span class="Constant">&quot;w+&quot;</span>);
   line   = pups_malloc(SSIZE);


   <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> If line is prefixed with a '#' character, skip the line </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

   <span class="Statement">do</span>  {   (<span class="Type">void</span>)fgets(line,SSIZE,c_file);

           <span class="Statement">if</span>(feof(c_file) != <span class="Constant">0</span>)
              looper = FALSE;
           <span class="Statement">else</span>
           {  content = FALSE;


              <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> If line only contains carriage return </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> discard it.                           </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(line[<span class="Constant">0</span>] == <span class="Special">'\n'</span>)
                 line[i]   = <span class="Special">'\0'</span>;
              <span class="Statement">else</span>


              <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Check for content. Discard empty line      </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> containing only whitespace and/or comment. </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

              {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(line); ++i)
                 {  <span class="Statement">if</span>(line[i] == <span class="Constant">'#'</span>)
                    {  line[i]   = <span class="Special">'\0'</span>;
                       <span class="Statement">break</span>;
                    }
                    <span class="Statement">else</span> <span class="Statement">if</span>(line[i] != <span class="Constant">&quot;&quot;</span> &amp;&amp; line != <span class="Special">'\t'</span>)
                       content = TRUE;
                 }
              }


              <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Only output lines which contain content </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(content == TRUE)
              {  (<span class="Type">void</span>)fputs(line,t_file);
                 (<span class="Type">void</span>)fflush(t_file);
              }
          }

        } <span class="Statement">while</span>(looper == TRUE);

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Free all resources which are no longer required ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

   pups_set_errno(OK);
   (<span class="Type">void</span>)pups_free(line);
   (<span class="Type">void</span>)fclose(c_file);

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Rewind stripped data file, and return a pointer to it ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

   (<span class="Type">void</span>)rewind(t_file);
   <span class="Statement">return</span>(t_file);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Return first non whitespace character in a string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *strfirst(<span class="Type">char</span> *s1)

{   <span class="Type">int</span> i,
        size;

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s1);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
    {  <span class="Statement">if</span>(s1[i] != <span class="Constant">' '</span> &amp;&amp; s1[i] != <span class="Special">'\n'</span> &amp;&amp; s1[i] != <span class="Special">'\r'</span> &amp;&amp; s1[i] != <span class="Special">'\0'</span>)
         <span class="Statement">return</span>(&amp;s1[i]);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Alternative comment stripping algorithm which strips comments in place ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strip_comment(<span class="Type">const</span> <span class="Type">FILE</span> *stream, <span class="Type">int</span> *line_cnt, <span class="Type">char</span> *line)

{
    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span> || line_cnt == (<span class="Type">int</span> *)<span class="Constant">NULL</span> || line == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wind to next line which is not either a comment </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> or whitespace                                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {

           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Swapped position of fgets() used to be after feof() </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

           (<span class="Type">void</span>)fgets(line,SSIZE,stream);

           <span class="Statement">if</span>(feof(stream) != <span class="Constant">0</span>)
              <span class="Statement">return</span>(FALSE);

           ++(*line_cnt);
       } <span class="Statement">while</span>(strempty(line) == TRUE || strin(strfirst(line),<span class="Constant">&quot;#&quot;</span>) == TRUE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Convert ASCII character to integer ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> actoi(<span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Statement">if</span>((<span class="Type">int</span>)ch &gt;= (<span class="Type">int</span>)<span class="Constant">'0'</span> &amp;&amp; (<span class="Type">int</span>)ch &lt;= (<span class="Type">int</span>)<span class="Constant">'9'</span>)
       <span class="Statement">return</span>((<span class="Type">int</span>)ch - <span class="Constant">0x30</span>);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Procedure to test whether an integer is even ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN ieven(<span class="Type">const</span> <span class="Type">int</span> arg)

{   <span class="Statement">if</span>(arg%<span class="Constant">2</span> &gt; <span class="Constant">0</span>)
       <span class="Statement">return</span>(FALSE);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Routine to test whether an integer is odd ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN iodd(<span class="Type">const</span> <span class="Type">int</span> arg)

{   <span class="Statement">if</span>(arg%<span class="Constant">2</span> &gt; <span class="Constant">0</span>)
       <span class="Statement">return</span>(TRUE);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(FALSE);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to find the absolute value of an integer ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> iabs(<span class="Type">const</span> <span class="Type">int</span> arg)

{   <span class="Statement">if</span>(arg &lt; <span class="Constant">0</span>)
       <span class="Statement">return</span>(-arg);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(arg);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Return the sign of integer argument ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> isign(<span class="Type">const</span> <span class="Type">int</span> arg)

{   <span class="Statement">if</span>(arg &gt; <span class="Constant">0</span>)
       <span class="Statement">return</span>((<span class="Type">int</span>)<span class="Constant">1</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(arg &lt; <span class="Constant">0</span>)
       <span class="Statement">return</span>((<span class="Type">int</span>)(-<span class="Constant">1</span>));

    <span class="Statement">return</span>((<span class="Type">int</span>)<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Find the maximum of a pair of integers ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> imax(<span class="Type">const</span> <span class="Type">int</span> a, <span class="Type">const</span> <span class="Type">int</span> b)

{   <span class="Statement">if</span>(a &gt;= b)
       <span class="Statement">return</span>(a);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(b);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Find the minimum of a pair of integers ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> imin(<span class="Type">const</span> <span class="Type">int</span> a, <span class="Type">const</span> <span class="Type">int</span> b)

{   <span class="Statement">if</span>(a &lt; b)
       <span class="Statement">return</span>(a);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(b);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Return the sign of floating point argument ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC FTYPE fsign(<span class="Type">const</span> FTYPE arg)

{   <span class="Statement">if</span>(arg &gt; <span class="Constant">0.0</span>)
       <span class="Statement">return</span>(<span class="Constant">1.0</span>);

    <span class="Statement">if</span>(arg &lt; <span class="Constant">0.0</span>)
       <span class="Statement">return</span>(-<span class="Constant">1.0</span>);

    <span class="Statement">return</span>(<span class="Constant">0.0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Procedure to round  floating point value to the nearest integer ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> iround(<span class="Type">const</span> FTYPE x)
{   <span class="Statement">return</span>((<span class="Type">int</span>)rint(x));
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to pause program while under development ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> upause(<span class="Type">const</span> <span class="Type">char</span> *prompt)

{   <span class="Type">char</span> ch;

    <span class="Statement">if</span>(prompt == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,prompt);
    (<span class="Type">void</span>)fflush(<span class="Constant">stdin</span>);
    (<span class="Type">void</span>)scanf(<span class="Constant">&quot;</span><span class="Special">%c</span><span class="Constant">&quot;</span>,&amp;ch);

    <span class="Statement">if</span>(pups_get_errno() == OK)
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Test to see if file is on a mounted filesystem. If it is, return</span>
<span class="Comment">    details of the host exporting the filesystem ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_get_fs_mountinfo(<span class="Type">const</span> <span class="Type">char</span> *f_name, <span class="Type">char</span> *mount_host)

{   <span class="Type">int</span>  f_index,
         status;

    <span class="Type">FILE</span> *mtab_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> line[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         cwd[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         import_fs[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         pathname[SSIZE]  = <span class="Constant">&quot;&quot;</span>;


    <span class="Statement">if</span>(f_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || mount_host == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(pups_is_on_nfs(f_name) == FALSE)
       <span class="Statement">return</span>(FALSE);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We must have an absolute path - if not we need to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> build the absolute path                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(f_name[<span class="Constant">0</span>] != <span class="Constant">'/'</span>)
    {  (<span class="Type">void</span>)getcwd(cwd,SSIZE);
       (<span class="Type">void</span>)snprintf(pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,cwd,f_name);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(pathname,f_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> df O/P has a common format in most modern UNIX </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> variants. It may be quicker to use /etc/mtab   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> but unfortunately this is far less standard    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    mtab_stream = pups_fcopen(<span class="Constant">&quot;df&quot;</span>,shell,<span class="Constant">&quot;r&quot;</span>);
    <span class="Statement">do</span> {   (<span class="Type">void</span>)pups_fgets(line,SSIZE,mtab_stream);

           <span class="Statement">if</span>(feof(mtab_stream) == <span class="Constant">0</span>)
           {  <span class="Type">char</span> strdum[SSIZE];

              (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%s</span><span class="Constant">&quot;</span>,mount_host,strdum,strdum,strdum,strdum,import_fs);
              <span class="Statement">if</span>(strin(pathname,import_fs) == TRUE)
              {

                 <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> Get name of host exporting file's filesystem  </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> we only need process mount information if we  </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> detect a ':' character which is indicative of </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment"> a mounted filesystem                          </span><span class="Comment">*/</span>
                 <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

                 <span class="Statement">if</span>((f_index = ch_pos(mount_host,<span class="Constant">':'</span>)) != (-<span class="Constant">1</span>) &amp;&amp; f_index &lt; <span class="Constant">256</span>)
                 {  mount_host[f_index] = <span class="Special">'\0'</span>;

                    (<span class="Type">void</span>)pups_fclose(mtab_stream);

                    pups_set_errno(OK);
                    <span class="Statement">return</span>(TRUE);
                }
              }
           }
       } <span class="Statement">while</span>(feof(mtab_stream) == <span class="Constant">0</span>);

    (<span class="Type">void</span>)strlcpy(mount_host,<span class="Constant">&quot;none&quot;</span>,SSIZE);
    (<span class="Type">void</span>)pups_fclose(mtab_stream);


    pups_set_errno(OK);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Find next free file table index (returns (-1) if file table full) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_find_free_ftab_index(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
       <span class="Statement">if</span>(ftab[i].fdes == (-<span class="Constant">1</span>))
       {  pups_set_errno(OK);


          <span class="Statement">if</span>(ftab[i].fname == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             ftab[i].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          <span class="Statement">if</span>(ftab[i].hname == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             ftab[i].hname = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          <span class="Statement">if</span>(ftab[i].fshadow == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             ftab[i].fshadow = (<span class="Type">char</span> *)pups_malloc(SSIZE);

<span class="PreProc">          #ifdef SSH_SUPPORT</span>
          <span class="Statement">if</span>(ftab[i].rd_host == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
            ftab[i].rd_host = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          <span class="Statement">if</span>(ftab[i].rd_ssh_port == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             ftab[i].rd_ssh_port = (<span class="Type">char</span> *)pups_malloc(SSIZE);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment">SSH_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].fs_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             ftab[i].fs_name  = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          ftab[i].fname[<span class="Constant">0</span>]    = <span class="Special">'\0'</span>;
          ftab[i].hname[<span class="Constant">0</span>]    = <span class="Special">'\0'</span>;
          ftab[i].fshadow[<span class="Constant">0</span>]  = <span class="Special">'\0'</span>;
          ftab[i].rd_host[<span class="Constant">0</span>]  = <span class="Special">'\0'</span>;
          ftab[i].fs_name[<span class="Constant">0</span>]  = <span class="Special">'\0'</span>;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(i);
       }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ENOMEM</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Get the file table entry which corresponds to descriptor (returns (-1)</span>
<span class="Comment">    if there is no entry) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ftab_index(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Set file table entry identification tag ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_set_ftab_id(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">int</span> id)

{   <span class="Type">int</span> i,
        f_index;

    <span class="Statement">if</span>(fdes &lt; <span class="Constant">0</span> || fdes &gt;= appl_max_files || id &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fdes)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].id == id)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

    ftab[f_index].id = id;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Get file table entry (by identification tag) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ftab_index_by_id(<span class="Type">const</span> <span class="Type">int</span> id)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(id &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].id == id)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Get file table entry (by filename) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ftab_index_by_name(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fname != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(ftab[i].fname,name) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}






<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Clear file table slot ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_clear_ftab_slot(<span class="Type">const</span> _BOOLEAN destroy, <span class="Type">const</span> <span class="Type">int</span> f_index)

{   <span class="Statement">if</span>(f_index &lt; <span class="Constant">0</span> || f_index &gt;= appl_max_files)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    ftab[f_index].st_mode           = <span class="Constant">0</span>;
    ftab[f_index].fdes              = (-<span class="Constant">1</span>);
    ftab[f_index].id                = (-<span class="Constant">1</span>);
    ftab[f_index].mode              = (-<span class="Constant">1</span>);
    ftab[f_index].stream            = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    ftab[f_index].psrp              = FALSE;
    ftab[f_index].creator           = FALSE;
    ftab[f_index].homeostatic       = <span class="Constant">0</span>;
    ftab[f_index].handler           = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    ftab[f_index].homeostat         = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    ftab[f_index].fs_blocks         = <span class="Constant">128</span>;
    ftab[f_index].mounted           = FALSE;
    ftab[f_index].rd_pid            = (-<span class="Constant">1</span>);
    ftab[f_index].fifo_pid          = (-<span class="Constant">1</span>);
    ftab[f_index].locked            = FALSE;

<span class="PreProc">    #ifdef ZLIB_SUPPORT</span>
    ftab[f_index].zstream           = (gzFILE *)<span class="Constant">NULL</span>;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> ZLIB_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(destroy == TRUE)
    {  ftab[f_index].fname       = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)ftab[f_index].fname);
       ftab[f_index].hname       = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)ftab[f_index].hname);
       ftab[f_index].fshadow     = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)ftab[f_index].fshadow);

<span class="PreProc">       #ifdef SSH_SUPPORT</span>
       ftab[f_index].rd_host     = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)ftab[f_index].rd_host);
       ftab[f_index].rd_ssh_port = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)ftab[f_index].rd_ssh_port);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

       ftab[f_index].fs_name     = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)ftab[f_index].fs_name);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Initialise the PUPS extended file descriptor table ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> initftab(<span class="Type">int</span> max_files, <span class="Type">int</span> stdio_homeostasis)

{   <span class="Type">int</span>         i;
    <span class="Type">struct</span> stat buf;

    <span class="Statement">if</span>((ftab = (ftab_type *)pups_calloc(max_files,<span class="Statement">sizeof</span>(ftab_type))) == (ftab_type *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[initftab] could not allocate PUPS file table (</span><span class="Special">%d</span><span class="Constant"> entries)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,max_files);
       pups_error(errstr);
    }

    (<span class="Type">void</span>)fstat(<span class="Constant">0</span>,&amp;buf);
    ftab[<span class="Constant">0</span>].st_mode     = (<span class="Type">int</span>)buf.st_mode;
    ftab[<span class="Constant">0</span>].stream      = <span class="Constant">stdin</span>;
    ftab[<span class="Constant">0</span>].mode        = <span class="Constant">0</span>;

    (<span class="Type">void</span>)fstat(<span class="Constant">1</span>,&amp;buf);
    ftab[<span class="Constant">1</span>].st_mode     = (<span class="Type">int</span>)buf.st_mode;
    ftab[<span class="Constant">1</span>].stream      = <span class="Constant">stdout</span>;
    ftab[<span class="Constant">1</span>].mode        = <span class="Constant">1</span>;

    (<span class="Type">void</span>)fstat(<span class="Constant">2</span>,&amp;buf);
    ftab[<span class="Constant">2</span>].st_mode     = (<span class="Type">int</span>)buf.st_mode;
    ftab[<span class="Constant">2</span>].stream      = <span class="Constant">stderr</span>;
    ftab[<span class="Constant">2</span>].mode        = <span class="Constant">2</span>;

    ftab[<span class="Constant">0</span>].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
    {  ftab[<span class="Constant">0</span>].named = TRUE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">0</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdin.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_name,appl_host,getpid(),getuid());
    }
    <span class="Statement">else</span>
    {  ftab[<span class="Constant">0</span>].named = FALSE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">0</span>].fname,SSIZE,<span class="Constant">&quot;&lt;redirected.0&gt;&quot;</span>);
    }

    ftab[<span class="Constant">1</span>].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
    {  ftab[<span class="Constant">1</span>].named = TRUE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">1</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdout.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_name,appl_host,getpid(),getuid());
    }
    <span class="Statement">else</span>
    {  ftab[<span class="Constant">1</span>].named = FALSE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">1</span>].fname,SSIZE,<span class="Constant">&quot;&lt;redirected.1&gt;&quot;</span>);
    }

    ftab[<span class="Constant">2</span>].fname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
    {  ftab[<span class="Constant">2</span>].named = TRUE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">2</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stderr.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_fifo_dir,appl_name,appl_host,getpid(),getuid());
    }
    <span class="Statement">else</span>
    {  ftab[<span class="Constant">2</span>].named = FALSE;
       (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">2</span>].fname,SSIZE,<span class="Constant">&quot;&lt;redirected.2&gt;&quot;</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">3</span>; ++i)
    {  <span class="Type">char</span> stdio_homeostat_name[SSIZE];

<span class="PreProc">       #ifdef ZLIB_SUPPORT</span>
       ftab[i].zstream           = (gzFILE *)<span class="Constant">NULL</span>;
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> ZLIB_SUPPORT </span><span class="Comment">*/</span>

       ftab[i].psrp              = FALSE;
       ftab[i].creator           = TRUE;
       ftab[i].fs_blocks         = <span class="Constant">128</span>;
       ftab[i].fdes              = i;
       ftab[i].id                = (-<span class="Constant">1</span>);
       ftab[i].homeostat         = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       ftab[i].handler           = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       ftab[i].homeostatic       = <span class="Constant">0</span>;
       ftab[i].locked            = FALSE;
       ftab[i].mounted           = FALSE;
       ftab[i].rd_pid            = (-<span class="Constant">1</span>);
       ftab[i].fifo_pid          = (-<span class="Constant">1</span>);

       ftab[i].fs_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[i].fs_name,<span class="Constant">&quot;.&quot;</span>,SSIZE);

       ftab[i].fshadow = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[i].fshadow,<span class="Constant">&quot;none&quot;</span>,SSIZE);


<span class="PreProc">       #ifdef SSH_SUPPORT</span>
       ftab[i].rd_host = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[i].rd_host,<span class="Constant">&quot;none&quot;</span>,SSIZE);

       ftab[i].rd_ssh_port = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[i].rd_ssh_port,ssh_remote_port,SSIZE);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

       ftab[i].hname   = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[i].hname,<span class="Constant">&quot;none&quot;</span>,SSIZE);

       <span class="Statement">if</span>(isatty(i) == <span class="Constant">1</span>)
          (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[i].fname);

       <span class="Statement">if</span>(stdio_homeostasis == STDIO_LIVE &amp;&amp; strncmp(ftab[i].fname,<span class="Constant">&quot;&lt;redirected&quot;</span>,<span class="Constant">11</span>) != <span class="Constant">0</span>)
       {  <span class="Statement">switch</span>(i)
          {     <span class="Statement">case</span> <span class="Constant">0</span>: (<span class="Type">void</span>)snprintf(stdio_homeostat_name,SSIZE,<span class="Constant">&quot;default_fd_homeostat: stdin &quot;</span>);
                        <span class="Statement">break</span>;

                <span class="Statement">case</span> <span class="Constant">1</span>: (<span class="Type">void</span>)snprintf(stdio_homeostat_name,SSIZE,<span class="Constant">&quot;default_fd_homeostat: stdout&quot;</span>);
                        <span class="Statement">break</span>;

                <span class="Statement">case</span> <span class="Constant">2</span>: (<span class="Type">void</span>)snprintf(stdio_homeostat_name,SSIZE,<span class="Constant">&quot;default_fd_homeostat: stderr&quot;</span>);
                        <span class="Statement">break</span>;

                <span class="Statement">default</span>: <span class="Statement">break</span>;
          }

          (<span class="Type">void</span>)pups_fd_alive(i,stdio_homeostat_name,pups_default_fd_homeostat);
       }
    }

    <span class="Statement">for</span>(i=<span class="Constant">3</span>; i&lt;appl_max_files; ++i)
       pups_clear_ftab_slot(FALSE,i);
}





<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Get the number of time a given filesystem resource has been lost ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_lost(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(ftab[i].lost_cnt);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Test if file descriptor is living ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_fd_islive(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;

    pups_set_errno(OK);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> File descriptor living </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ftab[i].fdes == fdes &amp;&amp; ftab[i].homeostatic &gt; <span class="Constant">0</span>)
          <span class="Statement">return</span>(TRUE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is descriptor valid ? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(i == appl_max_files)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Invalid file descriptor </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(FALSE);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Dead file descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Make a file descriptor living ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fd_alive(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">char</span> *handler_name, <span class="Type">const</span> <span class="Type">void</span> *handler)

{   <span class="Type">int</span>  i;
    <span class="Type">char</span> handler_args[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         cntl_chars[]        = {<span class="Special">'\1'</span>, <span class="Special">'\2'</span>, <span class="Special">'\3'</span>, <span class="Special">'\4'</span>, <span class="Special">'\5'</span>, <span class="Special">'\6'</span>};

    <span class="Statement">if</span>(handler_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || handler == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Type">int</span> ret;

       <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {  <span class="Type">int</span> t_index;

          <span class="Statement">if</span>(ftab[i].creator == FALSE)
          {

<span class="PreProc">            #ifdef PTHREAD_SUPPORT</span>
            (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EACCES</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }

          <span class="Statement">if</span>(ftab[i].psrp == TRUE)
          {

<span class="PreProc">            #ifdef PTHREAD_SUPPORT</span>
            (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EACCES</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Check that this file is not already live </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> if it is simply increment the count on   </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> its homeostasis lock  and return         </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].homeostatic &gt; <span class="Constant">0</span>)
          {  <span class="Type">int</span> ret;

             ++ftab[i].homeostatic;
             ret = ftab[i].homeostatic - <span class="Constant">1</span>;

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(OK);
             <span class="Statement">return</span>(ret);
          }


          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> File not live (yet) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  ftab[i].homeostatic = <span class="Constant">1</span>;
             ftab[i].lost_cnt    = <span class="Constant">0</span>;
          }


          <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Shadow file </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(isatty(ftab[i].fdes))
             (<span class="Type">void</span>)snprintf(ftab[i].fshadow,SSIZE,<span class="Constant">&quot;/dev/tty&quot;</span>);


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Directory protection files do not have shadows </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> they are simply recreated when lost            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {  <span class="Type">int</span>  j,
                  cnt,
                  index,
                  c_index;

             <span class="Type">char</span> cntl_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;


             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check to see if we are either in (or a link to)  </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> a patchboard directory                           </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(strin(ftab[i].fname,<span class="Constant">&quot;fifos&quot;</span>) == TRUE)
             {  c_index                    = rch_pos(ftab[i].fname,<span class="Constant">'/'</span>);
                (<span class="Type">void</span>)strlcpy(ftab[i].fshadow,ftab[i].fname,SSIZE);

                ftab[i].fshadow[c_index+<span class="Constant">1</span>] = <span class="Constant">'.'</span>;
                ftab[i].fshadow[c_index+<span class="Constant">2</span>] = <span class="Special">'\0'</span>;
             }
             <span class="Statement">else</span>
                (<span class="Type">void</span>)strlcpy(ftab[i].fshadow,<span class="Constant">&quot;.&quot;</span>,SSIZE);


             <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Crypted shadow </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(appl_snames_crypted == TRUE)
             {  <span class="Type">char</span> fshadow_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;


                <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Make sure that the shadow file is well protected </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> so that rm -rf * does not remove the shadow file </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> before it can be used to re-instate the file it  </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> is supposed to be protecting                     </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">for</span>(j=<span class="Constant">1</span>; j&lt;<span class="Constant">8</span>; ++j)
                {  c_index = (<span class="Type">int</span>)(drand48()*<span class="Constant">6.0</span>);
                   (<span class="Type">void</span>)snprintf(cntl_str,SSIZE,<span class="Constant">&quot;</span><span class="Special">%c</span><span class="Constant">&quot;</span>,cntl_chars[c_index]);
                   (<span class="Type">void</span>)strlcat(fshadow_name,cntl_str,SSIZE);
                }


                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Put shadow in the same directory as its principle </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(strin(ftab[i].fname,<span class="Constant">&quot;/&quot;</span>) == TRUE)
                {  <span class="Type">char</span> fdir[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                   (<span class="Type">void</span>)strlcpy(fdir,ftab[i].fname,SSIZE);
                   c_index = rch_index(fdir,<span class="Constant">'/'</span>);
                   fdir[c_index] = <span class="Special">'\0'</span>;

                   (<span class="Type">void</span>)snprintf(ftab[i].fshadow,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">&quot;</span>,fdir,fshadow_name);
                }
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)snprintf(ftab[i].fshadow,SSIZE,<span class="Constant">&quot;.</span><span class="Special">%s</span><span class="Constant">&quot;</span>,fshadow_name);
             }


             <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Plaintext shadow </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span>
             {

                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Put shadow in the same directory as its principle </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(strin(ftab[i].fname,<span class="Constant">&quot;/&quot;</span>) == TRUE)
                {  <span class="Type">char</span> fdir[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                   (<span class="Type">void</span>)strlcpy(fdir,ftab[i].fname,SSIZE);
                   c_index = rch_index(fdir,<span class="Constant">'/'</span>);
                   fdir[c_index] = <span class="Special">'\0'</span>;

                   (<span class="Type">void</span>)snprintf(ftab[i].fshadow,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.shadow.tmp&quot;</span>,fdir,i,appl_pid);
                }
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)snprintf(ftab[i].fshadow,SSIZE,<span class="Constant">&quot;.</span><span class="Special">%d</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.shadow.tmp&quot;</span>,i,appl_pid);
             }

             (<span class="Type">void</span>)link(ftab[i].fname,ftab[i].fshadow);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Increment homeostat protection level </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

          ++ftab[i].homeostatic;


          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Set up virtual time (and payload) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)snprintf(ftab[i].hname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: (</span><span class="Special">%s</span><span class="Constant">)&quot;</span>,handler_name,ftab[i].fname);
          ftab[i].handler = handler;
          (<span class="Type">void</span>)snprintf(handler_args,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,i);

          t_index = pups_setvitimer(ftab[i].hname,
                                    <span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">10</span>,
                                    handler_args,
                                    (<span class="Type">void</span> *)ftab[i].handler);

          ret = ftab[i].homeostatic - <span class="Constant">1</span>;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">--------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Error </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(t_index == (-<span class="Constant">1</span>))
          {  pups_set_errno(<span class="Constant">EINVAL</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Log </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>

          <span class="Statement">else</span> <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now live (status polling via vtimer </span><span class="Special">%d</span><span class="Constant"> (payload function: </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                date,appl_name,appl_pid,appl_host,appl_owner,ftab[i].fname,t_index,handler_name);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(ret);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Make the current application the creator of the object associated with</span>
<span class="Comment">    file descriptor (which means it will have the responsibility of</span>
<span class="Comment">    destroying it in a multiprocess environment)  ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_creator(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> has acquired creator privileges for </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                           date,appl_name,appl_pid,appl_host,appl_owner,appl_name,ftab[i].fname);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Relieve this application of the onerous burden of being the creator of</span>
<span class="Comment">    the object referenced by fdes ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_not_creator(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(fdes &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {  ftab[i].creator = FALSE;

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): creator privilidges for </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> relinquished</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                         date,appl_name,appl_pid,appl_host,appl_owner,ftab[i].fname);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Test to see if file is live ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_isalive(<span class="Type">const</span> <span class="Type">char</span> *name)

{  <span class="Type">int</span> i;

   pups_set_errno(OK);

   <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fname              != (<span class="Type">char</span> *)<span class="Constant">NULL</span>    &amp;&amp;
          strcmp(ftab[i].fname,name) == <span class="Constant">0</span>               &amp;&amp;
          ftab[i].homeostatic        &gt;  <span class="Constant">0</span>                )
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(TRUE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Protect an unopened file ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_protect(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> *handler_name, <span class="Type">const</span> <span class="Type">void</span> *handler)

{    <span class="Type">int</span> fdes = (-<span class="Constant">1</span>);

     <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || handler_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || handler == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }

     <span class="Statement">if</span>(access(name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
     {  pups_set_errno(<span class="Constant">EEXIST</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }

     fdes = pups_open(name,O_DUMMY,LIVE);

     (<span class="Type">void</span>)pups_creator(fdes);
     (<span class="Type">void</span>)pups_fd_alive(fdes,handler_name,handler);
     (<span class="Type">void</span>)close(fdes);

     pups_set_errno(OK);
     <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Unprotect a file (which is currently homeostatically protected by the</span>
<span class="Comment">    calling application) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_unprotect(<span class="Type">const</span> <span class="Type">char</span> *name)

{  <span class="Type">int</span> i;

   <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(strcmp(ftab[i].fname,name) == <span class="Constant">0</span> &amp;&amp; ftab[i].homeostatic &gt; <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Do not remove protection from PSRP channels </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> (unless application is exiting).            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].psrp == TRUE &amp;&amp; do_closeall == FALSE)
          {  pups_set_errno(<span class="Constant">EACCES</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If the resource is closed then we have to </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> terminate homeostat                       </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(in_close_routine == FALSE &amp;&amp; ftab[i].homeostatic &gt; <span class="Constant">1</span>)
          {  --ftab[i].homeostatic;

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(PSRP_OK);
             <span class="Statement">return</span>(<span class="Constant">0</span>);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Do not remove protection from heap objects </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> (unless application is exiting).           </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].pheap == TRUE &amp;&amp; do_closeall == FALSE)
          {  pups_set_errno(<span class="Constant">EACCES</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Remove homeostat associated with this item </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].psrp == TRUE &amp;&amp; do_closeall == TRUE)
             (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;psrp_homeostat&quot;</span>);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)pups_clearvitimer(ftab[i].hname);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Make sure we don't remove /dev/tty if descriptor is     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> 0,1 or 2 (these are symlinks which are shadowed by      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> dev/tty). If application is suid root and we do not     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> do this test, we could remove /dev/tty with potentially </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> serious consequences                                    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strcmp(ftab[i].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)unlink(ftab[i].fshadow);

          (<span class="Type">void</span>)strlcpy(ftab[i].fshadow,<span class="Constant">&quot;none&quot;</span>,SSIZE);

          ftab[i].homeostatic = <span class="Constant">0</span>;
          ftab[i].handler     = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

          (<span class="Type">void</span>)strlcpy(ftab[i].hname,<span class="Constant">&quot;none&quot;</span>,SSIZE);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
   }

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

   pups_set_errno(<span class="Constant">ESRCH</span>);
   <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Make a living descriptor inanimate (and remove hoemeostatic protection</span>
<span class="Comment">    of underlying inode-object) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fd_dead(<span class="Type">const</span> <span class="Type">int</span> fdes)

{  <span class="Type">int</span>  i;
   <span class="Type">char</span> fname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {

          <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Already dead </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].homeostatic == <span class="Constant">0</span>)
          {
<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(PSRP_OK);
             <span class="Statement">return</span>(<span class="Constant">0</span>);
          }


          <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Decrease homeostatic protection level </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
             --ftab[i].homeostatic;


          <span class="Statement">if</span>(in_close_routine == FALSE &amp;&amp; ftab[i].homeostatic &gt; <span class="Constant">1</span>)
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(PSRP_OK);
             <span class="Statement">return</span>(ftab[i].homeostatic - <span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Remove homeostat associated with this item </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_clearvitimer(ftab[i].hname);


          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Make sure we don't remove /dev/tty if descriptor is     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> 0,1 or 2 (these are symlinks which are shadowed by      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> dev/tty). If application is suid root and we do not     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> do this test, we could remove /dev/tty with potentially </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> serious consequences                                    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strcmp(ftab[i].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) != <span class="Constant">0</span>)
             (<span class="Type">void</span>)unlink(ftab[i].fshadow);

          (<span class="Type">void</span>)strlcpy(ftab[i].fshadow,<span class="Constant">&quot;none&quot;</span>,SSIZE);

          ftab[i].homeostatic = <span class="Constant">0</span>;
          ftab[i].handler     = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

          (<span class="Type">void</span>)strlcpy(ftab[i].hname,<span class="Constant">&quot;none&quot;</span>,SSIZE);
          (<span class="Type">void</span>)strlcpy(fname,ftab[i].fname,SSIZE);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is now dead</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                           date,appl_name,appl_pid,appl_host,appl_owner,fname);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
   }

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

   pups_set_errno(<span class="Constant">ESRCH</span>);
   <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Check the file table closing all open files and releasing their</span>
<span class="Comment">    resources ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_closeall(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    do_closeall = TRUE;
    <span class="Statement">for</span>(i=<span class="Constant">3</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes != (-<span class="Constant">1</span>) &amp;&amp; ftab[i].fname != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): closing </span><span class="Special">%-48s</span><span class="Constant"> [ftab slot </span><span class="Special">%04d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                          date,appl_name,appl_pid,appl_host,appl_owner,
                                                                         ftab[i].fname,
                                                                                     i);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          (<span class="Type">void</span>)pups_fd_dead(ftab[i].fdes);
          (<span class="Type">void</span>)pups_close(ftab[i].fdes);
       }
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Close any non file table files which may be open </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">3</span>; i&lt;appl_max_files; ++i)
       <span class="Statement">if</span>(i != chlockdes)
         (<span class="Type">void</span>)close(i);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Get ftab index (from file descriptor) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ftab_index_from_fd(<span class="Type">unsigned</span> <span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {   <span class="Statement">if</span>(ftab[i].fdes == fdes)
        {

<span class="PreProc">           #ifdef PTHREAD_SUPPORT</span>
           (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

            pups_set_errno(OK);
            <span class="Statement">return</span>(i);
        }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Get ftab index (from stream pointer) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ftab_index_from_stream(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {   <span class="Statement">if</span>(ftab[i].stream == stream)
        {

<span class="PreProc">           #ifdef PTHREAD_SUPPORT</span>
           (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

            pups_set_errno(OK);
            <span class="Statement">return</span>(i);
        }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="PreProc">#ifdef ZLIB_SUPPORT</span>

<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Open file associated with compressed data stream ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>


_PUBLIC gzFILE *pups_gzopen(<span class="Type">const</span> <span class="Type">char</span> *f_name, <span class="Type">const</span> <span class="Type">char</span> *mode, <span class="Type">const</span> <span class="Type">int</span> h_state)

{   <span class="Type">int</span> i_mode,
        z_index,
        zdes  = (-<span class="Constant">1</span>);

    gzFILE *zstream = (gzFILE *)<span class="Constant">NULL</span>;


    <span class="Statement">if</span>(f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       mode   == (<span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up mode switches </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(mode,<span class="Constant">&quot;r&quot;</span>) == <span class="Constant">0</span>)
       i_mode = <span class="Constant">0</span>;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(strcmp(mode,<span class="Constant">&quot;w&quot;</span>) == <span class="Constant">0</span>)
          i_mode = <span class="Constant">1</span>;
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(strcmp(mode,<span class="Constant">&quot;w+&quot;</span>) == <span class="Constant">0</span>   ||
             strcmp(mode,<span class="Constant">&quot;r+&quot;</span>) == <span class="Constant">0</span>)
             i_mode = <span class="Constant">2</span>;
          <span class="Statement">else</span>
          {  pups_set_errno(<span class="Constant">EINVAL</span>);
             <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open underlying file descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((zdes = pups_open(f_name,i_mode,h_state)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Associate zstream with this descriptor </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((zstream = gzdopen(zdes,mode)) == (gzFILE *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);

    z_index               = pups_get_ftab_index(zdes);
    ftab[z_index].zstream = zstream;

    pups_set_errno(OK);
    <span class="Statement">return</span>(zstream);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Get ftab index (from zstream pointer) ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_ftab_index_from_zstream(<span class="Type">const</span> gzFILE *zstream)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(zstream == (<span class="Type">const</span> gzFILE *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].zstream == zstream)
       {

<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Close a file associated with a compressed data stream ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC gzFILE *pups_gzclose(<span class="Type">const</span> gzFILE *zstream)

{   <span class="Type">int</span> z_index;

    <span class="Statement">if</span>(zstream == (gzFILE *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">if</span>((z_index = pups_get_ftab_index_from_zstream(zstream)) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);
    }

    (<span class="Type">void</span>)gzclose(zstream);
    (<span class="Type">void</span>)pups_close(ftab[z_index].fdes);

    pups_set_errno(OK);
    <span class="Statement">return</span>((gzFILE *)<span class="Constant">NULL</span>);
}

<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> ZLIB_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if file is hidden ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN pups_hidden_leaf(<span class="Type">const</span> <span class="Type">char</span> *fname)

{   <span class="Type">char</span> leaf[SSIZE]   = <span class="Constant">&quot;&quot;</span>;

    (<span class="Type">void</span>)strleaf(fname,leaf);
    <span class="Statement">if</span>(leaf[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
       <span class="Statement">return</span>(TRUE);

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span>
<span class="Comment">    Check for the existence of a file - if it exists, open it, otherwise</span>
<span class="Comment">    print error code and abort ...</span>
<span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Forward declaration of ch_index() function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> ch_index(<span class="Type">const</span> <span class="Type">char</span> *, <span class="Type">const</span> <span class="Type">char</span>);


<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Forward declaration of the strinp() function </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strinp(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *, <span class="Type">const</span> <span class="Type">char</span> *, <span class="Type">const</span> <span class="Type">char</span> *);

_PUBLIC <span class="Type">FILE</span> *pups_fopen(<span class="Type">char</span> *f_name, <span class="Type">char</span> *mode, <span class="Type">int</span> h_state)

{   <span class="Type">FILE</span>   *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    <span class="Type">int</span>    pos;
    <span class="Type">struct</span> statfs  buf;


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check function parameters </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || mode == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || (h_state != LIVE &amp;&amp; h_state != DEAD))
    {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hidden files are not allowed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_hidden_leaf(f_name) == TRUE)
    {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }


    (<span class="Type">void</span>)statfs(f_name,&amp;buf);
    <span class="Statement">if</span>(buf.f_type == ISOFS_SUPER_MAGIC)
       h_state = DEAD;


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Try to open a local pipe stream </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strinp((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)&amp;pos,f_name,<span class="Constant">&quot;|&quot;</span>) == TRUE)
    {  <span class="Statement">if</span>((stream = pups_fcopen(&amp;f_name[pos+<span class="Constant">1</span>],shell,mode)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
       }

       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          <span class="Statement">return</span>(stream);
       }
    }
    <span class="Statement">else</span>

    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Process as a regular file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    {  <span class="Type">int</span> i,
           f_index,
           st_mode,
           cnt = <span class="Constant">0</span>;

       <span class="Type">struct</span>   stat buf;
       _BOOLEAN fix_perms = FALSE;


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Fix up permissions if file is live (homeostasis enabled) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(h_state == LIVE || strin(mode,<span class="Constant">&quot;l&quot;</span>) == TRUE || strin(mode,<span class="Constant">&quot;L&quot;</span>) == TRUE)
          fix_perms = TRUE;


       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to see if file exists </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(access(f_name,F_OK) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
       }


       <span class="Statement">if</span>((f_index = pups_find_free_ftab_index()) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)pups_clear_ftab_slot(FALSE,f_index);
          (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(<span class="Constant">ESRCH</span>);
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
       }


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If the file mode is O_DUMMY don't actually open it - simply place the </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> file in the file table so it may be homeostatically protected.        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Stat the file to extract information on permissions and  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> ownership etc from its inode                             </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)stat(f_name,&amp;buf);
       st_mode = buf.st_mode;

       <span class="Statement">if</span>(mode[<span class="Constant">0</span>] != <span class="Constant">'D'</span>)
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> FIFOS are always opened read/write irrespective of mode </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(S_ISFIFO(st_mode))
             stream = fopen(f_name,<span class="Constant">&quot;r+&quot;</span>);
          <span class="Statement">else</span>
             stream = fopen(f_name,mode);

          <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
          {

             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If permissions are to be forced fix up permissions so we </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> can do the desired operation on the file                 </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(fix_perms == LIVE)
             {  <span class="Statement">if</span>(strin(mode,<span class="Constant">&quot;r&quot;</span>) == TRUE)
                   st_mode |= S_IRUSR;

                <span class="Statement">if</span>(strin(mode,<span class="Constant">&quot;w&quot;</span>) == TRUE || strin(mode,<span class="Constant">&quot;r+&quot;</span>) == TRUE)
                   st_mode |= S_IWUSR;

                <span class="Statement">if</span>(chmod(f_name,st_mode) == (-<span class="Constant">1</span>))
                {  (<span class="Type">void</span>)pups_clear_ftab_slot(FALSE,f_index);
                   (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
                   pups_set_errno(<span class="Constant">EACCES</span>);
                   <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
                }


                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> FIFOS are always opened read/write irrespective of mode </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(S_ISFIFO(st_mode))
                    stream = fopen(f_name,<span class="Constant">&quot;r+&quot;</span>);
                 <span class="Statement">else</span>
                    stream = fopen(f_name,mode);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)pups_clear_ftab_slot(FALSE,f_index);
                (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
                pups_set_errno(<span class="Constant">EACCES</span>);
                <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
             }
          }

          (<span class="Type">void</span>)strlcpy(ftab[f_index].fname,f_name,SSIZE);


<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          ftab[f_index].st_mode = st_mode;
          ftab[f_index].named   = TRUE;

          <span class="Statement">if</span>(mode[<span class="Constant">0</span>] == <span class="Constant">'D'</span>)
          {  ftab[f_index].fdes = (-f_index - <span class="Constant">1000</span>);
             ftab[f_index].mode = O_DUMMY;
          }
          <span class="Statement">else</span>
             ftab[f_index].fdes = fileno(stream);

          ftab[f_index].stream = stream;

          <span class="Statement">if</span>(mode[<span class="Constant">0</span>] == <span class="Constant">'r'</span> &amp;&amp; mode[<span class="Constant">1</span>] != <span class="Constant">'+'</span>)
             ftab[f_index].mode = <span class="Constant">0</span>;
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(mode[<span class="Constant">0</span>] == <span class="Constant">'w'</span>)
                ftab[f_index].mode = <span class="Constant">1</span>;
             <span class="Statement">else</span>
                ftab[f_index].mode = <span class="Constant">2</span>;
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If l or L flag is specified make file live </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(strin(mode,<span class="Constant">&quot;l&quot;</span>) == TRUE || strin(mode,<span class="Constant">&quot;L&quot;</span>) == TRUE || h_state == LIVE &amp;&amp; ftab[f_index].psrp == FALSE)
          {  <span class="Type">char</span> default_fd_hname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             ftab[f_index].creator = TRUE;
             (<span class="Type">void</span>)snprintf(default_fd_hname,SSIZE,<span class="Constant">&quot;default_fd_homeostat: </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,f_name,fileno(stream));
             (<span class="Type">void</span>)pups_fd_alive(fileno(stream),default_fd_hname,(<span class="Type">void</span> *)&amp;pups_default_fd_homeostat);
          }


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Get information about mount point (if this is a mounted file system) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

          ftab[f_index].mounted = pups_get_fs_mountinfo(f_name,ftab[f_index].rd_host);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);


    pups_set_errno(OK);
    <span class="Statement">return</span>(stream);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Extended fdopen command -- adds stream information to PUPS filetable if</span>
<span class="Comment">    the passed descriptor is associated with PUPS filetable ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">FILE</span> *pups_fdopen(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">char</span> *mode)

{   <span class="Type">int</span>  f_index;
    <span class="Type">FILE</span> *ret = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(mode == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">if</span>((ret = fdopen(fdes,mode)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fdes)) == (-<span class="Constant">1</span>))
    {  ftab[f_index].stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ENFILE</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If l or L flag is specified make file live </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(mode,<span class="Constant">&quot;l&quot;</span>) == TRUE || strin(mode,<span class="Constant">&quot;L&quot;</span>) == TRUE)
    {  <span class="Type">char</span> default_fd_hname[SSIZE];

       (<span class="Type">void</span>)snprintf(default_fd_hname,SSIZE,<span class="Constant">&quot;default_fd_homeostat: </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">)&quot;</span>,ftab[f_index].fname,ftab[f_index].fdes);
       (<span class="Type">void</span>)pups_fd_alive(fileno(ret),<span class="Constant">&quot;default_fd_hname&quot;</span>,&amp;pups_default_fd_homeostat);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> if d or D flag is specified make file dead </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(strin(mode,<span class="Constant">&quot;d&quot;</span>) == TRUE || strin(mode,<span class="Constant">&quot;D&quot;</span>) == TRUE)
       (<span class="Type">void</span>)pups_fd_dead(fdes);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Check for the existence of a file - if it exists, open it, otherwise</span>
<span class="Comment">    print error code and abort ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_open(<span class="Type">const</span> <span class="Type">char</span> *f_name, <span class="Type">const</span> <span class="Type">int</span> mode, <span class="Type">int</span> h_state)

{   <span class="Type">int</span> pos,
        fdes    = (-<span class="Constant">1</span>);

    <span class="Type">struct</span> statfs  buf;


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check function parameters </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(f_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || mode &lt; <span class="Constant">0</span> || (h_state != LIVE &amp;&amp; h_state != DEAD))
    {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hidden files are not allowed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_hidden_leaf(f_name) == TRUE)
    {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> ISO9660 and similar file systems do not support </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> file homeostasis                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)statfs(f_name,&amp;buf);
    <span class="Statement">if</span>(buf.f_type == ISOFS_SUPER_MAGIC)
       h_state = DEAD;


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Try to open a local pipe stream </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strinp((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)&amp;pos,f_name,<span class="Constant">&quot;|&quot;</span>) == TRUE)
    {  <span class="Statement">if</span>((fdes = pups_copen(&amp;f_name[pos+<span class="Constant">1</span>],shell,mode)) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       pups_set_errno(OK);
       <span class="Statement">return</span>(fdes);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Process as a regular file. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  <span class="Type">int</span> i,
           st_mode,
           f_index;

       <span class="Type">struct</span> stat buf;
       <span class="Type">char</span>   f_lock_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;
       _BOOLEAN fix_perms        = FALSE;


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Fix up permissions if file is live (homeostasis enabled) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(h_state == LIVE || mode &amp; O_LIVE)
          fix_perms = TRUE;


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to see if we can access file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(access(f_name,F_OK) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }


       <span class="Statement">if</span>((f_index = pups_find_free_ftab_index()) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(<span class="Constant">ENFILE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to see if we can access file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(access(f_name,F_OK) == (-<span class="Constant">1</span>))
       {  (<span class="Type">void</span>)pups_clear_ftab_slot(FALSE,f_index);
          (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(<span class="Constant">ESRCH</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       <span class="Statement">if</span>(mode &amp; O_DUMMY)
          fdes = (-f_index - <span class="Constant">1000</span>);
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> FIFOS are always opened read/write irrespective of mode </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(S_ISFIFO(st_mode))
             fdes  = open(f_name,<span class="Constant">2</span>);
          <span class="Statement">else</span>
              fdes = open(f_name,mode);
       }

       <span class="Statement">if</span>(mode &amp; <span class="PreProc">0</span><span class="Constant">01000</span>)
          (<span class="Type">void</span>)chmod(f_name,<span class="PreProc">0</span><span class="Constant">744</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Stat the file to extract information on permissions and  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> ownership etc from its inode                             </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)stat(f_name,&amp;buf);
       st_mode = (<span class="Type">int</span>)buf.st_mode;

       <span class="Statement">if</span>(fdes == (-<span class="Constant">1</span>))
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If permissions are to be forced fix up permissions so we </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> can do the desired operation on the file                 </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(fix_perms == LIVE)
          {  <span class="Statement">if</span>(mode == <span class="Constant">0</span>)
                st_mode |= S_IRUSR;
             <span class="Statement">else</span> <span class="Statement">if</span>(mode == <span class="Constant">1</span>)
                st_mode |= S_IWUSR;
             <span class="Statement">else</span> <span class="Statement">if</span>(mode == <span class="Constant">2</span>)
                st_mode |= (S_IWUSR | S_IRUSR);

             <span class="Statement">if</span>(chmod(f_name,st_mode) == (-<span class="Constant">1</span>))
             {   <span class="Statement">if</span>(appl_verbose == TRUE)
                 {  (<span class="Type">void</span>)fprintf(err_stream,<span class="Constant">&quot;ERROR pusp_open: problem with permissions for file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                         f_name,appl_name,appl_pid);
                    (<span class="Type">void</span>)fflush(err_stream);
                 }

                 (<span class="Type">void</span>)pups_clear_ftab_slot(FALSE,f_index);
                 (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
                 pups_set_errno(<span class="Constant">EACCES</span>);
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
             }
             <span class="Statement">else</span>
             {

                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> FIFOS are always opened read/write irrespective of mode </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(S_ISFIFO(st_mode))
                   fdes = open(f_name,<span class="Constant">2</span>);
                <span class="Statement">else</span>
                   fdes = open(f_name,mode);
             }
          }
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)fprintf(err_stream,errstr,<span class="Constant">&quot;ERROR pups_open: problem with permissions for file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                            f_name,appl_name,appl_pid);
                (<span class="Type">void</span>)fflush(err_stream);
             }

             pups_clear_ftab_slot(FALSE,f_index);
             (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
             pups_set_errno(<span class="Constant">EACCES</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       ftab[f_index].homeostat = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       ftab[f_index].handler   = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
       ftab[f_index].st_mode   = st_mode;
       ftab[f_index].named     = TRUE;
       ftab[f_index].fdes      = fdes;
       ftab[f_index].mode      = mode;
       ftab[f_index].stream    = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

       (<span class="Type">void</span>)strlcpy(ftab[f_index].fname,f_name,SSIZE);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get information about mount point (if this is a mounted file system) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

       ftab[f_index].mounted = pups_get_fs_mountinfo(f_name,ftab[f_index].rd_host);

       <span class="Statement">if</span>(mode &amp; O_LIVE || h_state == LIVE &amp;&amp; ftab[f_index].psrp == FALSE)
       {  <span class="Type">char</span> default_fd_hname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          ftab[f_index].creator = TRUE;
          (<span class="Type">void</span>)snprintf(default_fd_hname,SSIZE,<span class="Constant">&quot;default_fd_homeostat: (</span><span class="Special">%s</span><span class="Constant">) </span><span class="Special">%d</span><span class="Constant">&quot;</span>,f_name,fdes);
          (<span class="Type">void</span>)pups_fd_alive(fdes,default_fd_hname,(<span class="Type">void</span> *)&amp;pups_default_fd_homeostat);
       }
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);

    pups_set_errno(OK);
    <span class="Statement">return</span>(fdes);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Close (extended mode) file descriptor ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_close(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i,
        ret,
        my_errno;


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    in_close_routine = TRUE;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {  <span class="Type">char</span> f_lock_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(ftab[i].homeostatic &gt; <span class="Constant">0</span> &amp;&amp; ftab[i].psrp == FALSE)
             (<span class="Type">void</span>)pups_fd_dead(ftab[i].fdes);


<span class="PreProc">          #ifdef SSH_SUPPORT</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If there is a remote daemon servicing this descriptor </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> kill it now                                           </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].rd_pid &gt; <span class="Constant">0</span>)
          {  <span class="Type">char</span> pidname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             (<span class="Type">void</span>)snprintf(pidname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,-ftab[i].rd_pid);
             (<span class="Type">void</span>)pups_rkill(ftab[i].rd_host,ftab[i].rd_ssh_port,appl_owner,pidname,<span class="Constant">SIGTERM</span>);
          }
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Kill (embedded) pipestream associated with this descriptor </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].fifo_pid &gt; <span class="Constant">0</span> &amp;&amp; kill(ftab[i].fifo_pid,SIGALIVE) != (-<span class="Constant">1</span>))
          {  <span class="Type">int</span> status;

             (<span class="Type">void</span>)pups_noauto_child();


             <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Note that we need to kill the process group of the shell    </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> which started the pipestream in order to be sure of killing </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> the pipestream command itself                               </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)killpg(ftab[i].fifo_pid,<span class="Constant">SIGTERM</span>);

             (<span class="Type">void</span>)pupswait(FALSE,&amp;status);
             (<span class="Type">void</span>)pups_auto_child();
          }

          (<span class="Type">void</span>)pups_release_fd_lock(ftab[i].fdes);
          <span class="Statement">do</span> {   ret = close(fdes);
                 my_errno = errno;

                 (<span class="Type">void</span>)sched_yield();
             } <span class="Statement">while</span>(ret == (-<span class="Constant">1</span>) &amp;&amp; my_errno != <span class="Constant">EBADF</span>);


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have a pipeline attached to this descriptor we must </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> confirm that it has exited before continuing              </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].fifo_pid &lt; <span class="Constant">0</span>)
          {  <span class="Type">int</span> status;

             (<span class="Type">void</span>)pupswaitpid(FALSE,(-ftab[i].fifo_pid),&amp;status);
          }

          (<span class="Type">void</span>)unlink(ftab[i].fshadow);
          pups_clear_ftab_slot(FALSE,i);

          in_close_routine = FALSE;
          (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(OK);

          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

    in_close_routine = FALSE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    pupsrelse(ALL_PUPS_SIGS);

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Close (extended mode) stream) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">FILE</span> *pups_fclose(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span>  i,
         fdes = (-<span class="Constant">1</span>);

    <span class="Type">FILE</span> *ret = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    in_close_routine = TRUE;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fileno(stream))
       {  <span class="Type">char</span> f_lock_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(ftab[i].homeostatic &gt; <span class="Constant">0</span> &amp;&amp; ftab[i].psrp == FALSE)
             (<span class="Type">void</span>)pups_fd_dead(ftab[i].fdes);


<span class="PreProc">          #ifdef SSH_SUPPORT</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If there is a remote daemon servicing this descriptor </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> kill it now                                           </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].rd_pid &gt; <span class="Constant">0</span>)
          {  <span class="Type">char</span> pidname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             (<span class="Type">void</span>)snprintf(pidname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,ftab[i].rd_pid);
             (<span class="Type">void</span>)pups_rkill(ftab[i].rd_host,ftab[i].rd_ssh_port,appl_owner,pidname,<span class="Constant">SIGTERM</span>);
          }
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Kill (embedded) pipestream associated with this descriptor </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].fifo_pid &gt; <span class="Constant">0</span> &amp;&amp; kill(ftab[i].fifo_pid,SIGALIVE) != (-<span class="Constant">1</span>))
          {  <span class="Type">int</span> status;

             (<span class="Type">void</span>)pups_noauto_child();


             <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Note that we need to kill the process group of the shell    </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> which started the pipestream in order to be sure of killing </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> the pipestream command itself                               </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)killpg(ftab[i].fifo_pid,<span class="Constant">SIGTERM</span>);
             (<span class="Type">void</span>)pupswait(FALSE,&amp;status);
             (<span class="Type">void</span>)pups_auto_child();
          }

          (<span class="Type">void</span>)pups_release_fd_lock(ftab[i].fdes);
          <span class="Statement">if</span>(ftab[i].mode != O_DUMMY)
          {  (<span class="Type">void</span>)fclose(stream);


             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If we have a pipeline attached to this descriptor we must </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> confirm that it has exited before continuing              </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(ftab[i].fifo_pid &lt; <span class="Constant">0</span>)
             {  <span class="Type">int</span> status;
                (<span class="Type">void</span>)pupswaitpid(FALSE,(-ftab[i].fifo_pid),&amp;status);
             }
          }

          (<span class="Type">void</span>)unlink(ftab[i].fshadow);
          pups_clear_ftab_slot(FALSE,i);

          in_close_routine = FALSE;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
          pups_set_errno(OK);
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
       }
    }

    in_close_routine = FALSE;
    (<span class="Type">void</span>)fclose(stream);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enable PUPS/P3 signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Display file descriptors which are open on this application ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_open_fdescriptors(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        files        = <span class="Constant">0</span>;

    <span class="Type">char</span> ftype[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         fstate[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         fbuf[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         fdid[SSIZE]   = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_open_fdescriptors] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Open file descriptors</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =====================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes != (-<span class="Constant">1</span>))
       {  <span class="Type">struct</span> stat buf;

          ++files;
          <span class="Statement">if</span>(isatty(ftab[i].fdes) == <span class="Constant">1</span>)
             (<span class="Type">void</span>)strlcpy(ftype,<span class="Constant">&quot;TTY  &quot;</span>,SSIZE);
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fstat(ftab[i].fdes,&amp;buf);
             <span class="Statement">if</span>(S_ISFIFO(buf.st_mode))
                (<span class="Type">void</span>)strlcpy(ftype,<span class="Constant">&quot;FIFO &quot;</span>,SSIZE);
             <span class="Statement">else</span>
             {  <span class="Statement">if</span>(ftab[i].pheap == FALSE)
                   (<span class="Type">void</span>)strlcpy(ftype,<span class="Constant">&quot;REGF &quot;</span>,SSIZE);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)strlcpy(ftype,<span class="Constant">&quot;PHEAP&quot;</span>,SSIZE);
             }
          }

          <span class="Statement">if</span>(ftab[i].homeostatic &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)strlcpy(fstate,<span class="Constant">&quot;live&quot;</span>,SSIZE);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(fstate,<span class="Constant">&quot;dead&quot;</span>,SSIZE);

          <span class="Statement">if</span>((<span class="Type">void</span> *)ftab[i].homeostat != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcat(fstate,<span class="Constant">&quot; dynamic homeostat&quot;</span>,SSIZE);

<span class="PreProc">          #ifdef ZLIB_SUPPORT</span>
          <span class="Statement">if</span>(ftab[i].stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> &amp;&amp; ftab[i].zstream == (gzFILE *)<span class="Constant">NULL</span>)
<span class="PreProc">          #else</span>
          <span class="Statement">if</span>(ftab[i].stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> ZLIB_SUPPORT </span><span class="Comment">*/</span>

             (<span class="Type">void</span>)strlcpy(fbuf,<span class="Constant">&quot;&quot;</span>,SSIZE);
          <span class="Statement">else</span> <span class="Statement">if</span>(ftab[i].stream != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)snprintf(fbuf,SSIZE,<span class="Constant">&quot;(file handle </span><span class="Special">%016lx</span><span class="Constant">)&quot;</span>, (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)ftab[i].stream);

<span class="PreProc">          #ifdef ZLIB_SUPPORT</span>
          <span class="Statement">else</span> <span class="Statement">if</span>(ftab[i].zstream != (gzFILE *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)snprintf(fbuf,SSIZE,<span class="Constant">&quot;(file zhandle </span><span class="Special">%016lx</span><span class="Constant">)&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)ftab[i].zstream);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> ZLIB_SUPPORT </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> PSRP channel </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(ftab[i].psrp == TRUE)
          {  <span class="Type">int</span> idum,
                 schan;

             <span class="Type">char</span> strdum[SSIZE] = <span class="Constant">&quot;&quot;</span>;


             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> PSRP server primary input channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(ftab[i].fname != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strin(ftab[i].fname,<span class="Constant">&quot;in&quot;</span>) == TRUE)
                (<span class="Type">void</span>)strlcpy(fdid,<span class="Constant">&quot;[PSRP channel in ]&quot;</span>,SSIZE);


             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> PSRP server primary input channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(ftab[i].fname != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strin(ftab[i].fname,<span class="Constant">&quot;out&quot;</span>) == TRUE)
                (<span class="Type">void</span>)strlcpy(fdid,<span class="Constant">&quot;[PSRP channel out]&quot;</span>,SSIZE);



             <span class="Comment">/*</span><span class="Comment">---------------- --------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> PSRP server SIC input channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(ftab[i].fname              != (<span class="Type">char</span> *)<span class="Constant">NULL</span>  &amp;&amp;
                     strin(ftab[i].fname,<span class="Constant">&quot;in&quot;</span>)  == TRUE          &amp;&amp;
                     strin(ftab[i].fname,<span class="Constant">&quot;sic&quot;</span>) == TRUE           )
             {  (<span class="Type">void</span>)sscanf (ftab[i].fname,<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d%d%s%d</span><span class="Constant">&quot;</span>,strdum,strdum,strdum,strdum,strdum,&amp;idum,&amp;idum,strdum,&amp;schan);
                (<span class="Type">void</span>)snprintf(fdid,SSIZE,<span class="Constant">&quot;[SIC channel </span><span class="Special">%d</span><span class="Constant"> in ]&quot;</span>,schan);
             }


             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> PSRP server SIC output channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(ftab[i].fname              != (<span class="Type">char</span> *)<span class="Constant">NULL</span>  &amp;&amp;
                     strin(ftab[i].fname,<span class="Constant">&quot;out&quot;</span>) == TRUE          &amp;&amp;
                     strin(ftab[i].fname,<span class="Constant">&quot;sic&quot;</span>) == TRUE           )
             {  (<span class="Type">void</span>)sscanf (ftab[i].fname,<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d%d%s%d</span><span class="Constant">&quot;</span>,strdum,strdum,strdum,strdum,strdum,&amp;idum,&amp;idum,strdum,&amp;schan);
                (<span class="Type">void</span>)snprintf(fdid,SSIZE,<span class="Constant">&quot;[SIC channel </span><span class="Special">%d</span><span class="Constant"> out]&quot;</span>,schan);
             }


             <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Generic PSRP channel </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span>
                (<span class="Type">void</span>)strlcpy(fdid,<span class="Constant">&quot;[PSRP channel]&quot;</span>,SSIZE);
          }
          <span class="Statement">else</span>
          {

<span class="PreProc">             #ifdef PERSISTENT_HEAP_SUPPORT</span>
             <span class="Statement">if</span>(ftab[i].pheap == TRUE)
             {  <span class="Type">int</span> f_index;

                f_index = msm_fdes2hdes(ftab[i].fdes);
                (<span class="Type">void</span>)snprintf(fdid,SSIZE,<span class="Constant">&quot;[peristent heap at </span><span class="Special">%016lx</span><span class="Constant"> virtual]&quot;</span>,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)htable[f_index].addr);
             }
             <span class="Statement">else</span>
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

                (<span class="Type">void</span>)strlcpy(fdid,<span class="Constant">&quot;&quot;</span>,SSIZE);
          }

          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-48s</span><span class="Special">\&quot;\t</span><span class="Constant">fdes </span><span class="Special">%04d</span><span class="Constant">,</span><span class="Special">\t</span><span class="Constant">(</span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Constant">) </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                       ftab[i].fname,
                                                                        ftab[i].fdes,
                                                                               ftype,
                                                                              fstate,
                                                                                fbuf,
                                                                                fdid);
          (<span class="Type">void</span>)fflush(stream);
       }
    }

    <span class="Statement">if</span>(files == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> file slots in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,appl_max_files - files);
    <span class="Statement">if</span>(files  &gt; <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> file slots in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,files,appl_max_files - files);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    No file slots in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_max_files,files);

    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">if</span>(strcmp(appl_ttyname,<span class="Constant">&quot;none&quot;</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Process has no controlling tty</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_fgnd == TRUE)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Controlling tty is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n\n</span><span class="Constant">&quot;</span>,appl_ttyname);
       <span class="Statement">else</span>
       {  started_detached = TRUE;
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Controlling tty is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> [detached]</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_ttyname);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fflush(stream);
    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Decode the sign character, '-' ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> chsign(<span class="Type">const</span> <span class="Type">char</span> ch_arg)

{   pups_set_errno(OK);

    <span class="Statement">if</span>(ch_arg == <span class="Constant">'-'</span>)
       <span class="Statement">return</span>((<span class="Type">int</span>)-<span class="Constant">1</span>);
    <span class="Statement">else</span>
       <span class="Statement">return</span>((<span class="Type">int</span>)<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Standard error handling routines ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Set PUPS error handler parameters (not threadsafe) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_seterror(<span class="Type">const</span> <span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">int</span> action, <span class="Type">const</span> <span class="Type">int</span> code)

{   err_stream = stream;
    err_action = action;
    err_code   = code;
}



<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> PUPS error handler (threadsafe) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_error(<span class="Type">const</span> <span class="Type">char</span> *errstr)

{   <span class="Statement">if</span>(err_action == NONE)
       <span class="Statement">return</span>(<span class="Constant">0</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;errstr_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(err_action &amp; PRINT_ERROR_STRING)
    {  (<span class="Type">void</span>)fprintf(err_stream,<span class="Constant">&quot;    ERROR </span><span class="Special">%s</span><span class="Constant"> [</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">)]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,errstr,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(err_stream);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;errstr_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PHTREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(err_action &amp; EXIT_ON_ERROR)
       pups_exit(err_code);

    <span class="Statement">if</span>(err_action &amp; CHILD_EXIT_ON_ERROR)
       exit(err_code);

    <span class="Statement">return</span>(err_code);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to find any occurence of string s2 in sting s1, the length of</span>
<span class="Comment">    s1 must be greater then s2 ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strncmps(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2)

{   <span class="Type">size_t</span> template,
           sch_length,
           start  = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    sch_length = strlen(s1);
    template   = strlen(s2);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(sch_length &gt; <span class="Constant">0</span> &amp;&amp; template &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Test for s1 &lt;= s2, if so flag error and exit </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(sch_length &lt; template)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       <span class="Statement">do</span> {  <span class="Statement">if</span>(strncmp(&amp;s1[start],s2,template) == <span class="Constant">0</span>)
               <span class="Statement">return</span>(TRUE);
             <span class="Statement">else</span>
                ++start;
          } <span class="Statement">while</span>(start &lt; sch_length);

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to strip an extension from a string ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strrext(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> dm_char)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s1);

    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
       {  <span class="Statement">if</span>(s1[i] == dm_char)
          {  s2[i] = <span class="Special">'\0'</span>;

             <span class="Statement">return</span>(TRUE);
          }
          <span class="Statement">else</span>
             s2[i] = s1[i];
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to reverse strip an extension from a string ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strrextr(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> dm_char)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s1);

    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=strlen(s1); i != <span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(s1[i] == dm_char)
          {  (<span class="Type">void</span>)strlcpy(s2,(<span class="Type">char</span> *)&amp;s1[i+<span class="Constant">1</span>],SSIZE);
             <span class="Statement">return</span>(TRUE);
          }
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to extract substrings which are demarkated by a user defined</span>
<span class="Comment">    character ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
_PUBLIC _BOOLEAN strext(<span class="Type">const</span> <span class="Type">char</span> dm_ch, <span class="Comment">/*</span><span class="Comment"> Demarcation character            </span><span class="Comment">*/</span>
                        <span class="Type">char</span>       *s1,   <span class="Comment">/*</span><span class="Comment"> Extracted sub string             </span><span class="Comment">*/</span>
                        <span class="Type">const</span> <span class="Type">char</span> *s2)   <span class="Comment">/*</span><span class="Comment"> Argument string                  </span><span class="Comment">*/</span>
                                          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">size_t</span> s1_index = <span class="Constant">0</span>;

                                          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">size_t</span> s2_index      = <span class="Constant">0</span>;   <span class="Comment">/*</span><span class="Comment"> Current pointer into arg string </span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">char</span>   s2_was[SSIZE] = <span class="Constant">&quot;&quot;</span>;  <span class="Comment">/*</span><span class="Comment"> Copy of current argument string </span><span class="Comment">*/</span>
                                          <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread perform non thread-safe operations </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[strext] attempt by non root thread to perform PUPS/P3 non thread safe operation&quot;</span>);

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Entry with null parameters forces reset of pointers within strext </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> function.                                                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || strlen(s2) == <span class="Constant">0</span>)
    {  s2_index = <span class="Constant">0</span>;
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save string length for swap test if this is first pass for current </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> extraction string.                                                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2_index == <span class="Constant">0</span>)
       (<span class="Type">void</span>)strlcpy(s2_was,s2,SSIZE);
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If extraction string has changed re-initialise. </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(s2_was,s2) != <span class="Constant">0</span>)
       {  s2_index = <span class="Constant">0</span>;
          (<span class="Type">void</span>)strlcpy(s2_was,s2,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wind to substring to be extracted. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>(s2[s2_index] == dm_ch &amp;&amp; s2[s2_index] != <span class="Special">'\0'</span> &amp;&amp; s2[s2_index] != <span class="Special">'\n'</span>)
          ++s2_index;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------*.</span>
<span class="Comment">    </span><span class="Error">/</span><span class="Comment">* If we have reached the end of the string - reinitialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index] == <span class="Special">'\0'</span> || s2[s2_index] == <span class="Special">'\n'</span>)
    {  s2_index = <span class="Constant">0</span>;
       s1[<span class="Constant">0</span>]    = <span class="Special">'\0'</span>;
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extract substring to next demarcation character. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>(s2[s2_index] != dm_ch &amp;&amp; s2[s2_index] != <span class="Special">'\0'</span> &amp;&amp; s2[s2_index] != <span class="Special">'\n'</span>)
    {     s1[s1_index] = s2[s2_index];
          ++s1_index;
          ++s2_index;
    }
    s1[s1_index] = <span class="Special">'\0'</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the end of the extraction string has been reached, reinitialise.</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index] == <span class="Special">'\0'</span> || s2[s2_index] == <span class="Special">'\n'</span>)
    {  s2_index = <span class="Constant">0</span>;

                              <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Statement">return</span>(END_STRING);    <span class="Comment">/*</span><span class="Comment"> Messy but some applications need to know if  </span><span class="Comment">*/</span>
                              <span class="Comment">/*</span><span class="Comment"> dm_ch was really matched or if we have hit   </span><span class="Comment">*/</span>
                              <span class="Comment">/*</span><span class="Comment"> the end of the string                        </span><span class="Comment">*/</span>
                              <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    }

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to extract substrings which are demarcated by a user defined</span>
<span class="Comment">    character for multiple comparison operations ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                            <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
_PUBLIC _BOOLEAN m_strext(<span class="Type">const</span> <span class="Type">int</span>  i_key, <span class="Comment">/*</span><span class="Comment"> Instance key for operation     </span><span class="Comment">*/</span>
                          <span class="Type">const</span> <span class="Type">char</span> dm_ch, <span class="Comment">/*</span><span class="Comment"> Demarcation character          </span><span class="Comment">*/</span>
                          <span class="Type">char</span>         *s1, <span class="Comment">/*</span><span class="Comment"> Extracted sub string           </span><span class="Comment">*/</span>
                          <span class="Type">const</span> <span class="Type">char</span>   *s2) <span class="Comment">/*</span><span class="Comment"> Argument string                </span><span class="Comment">*/</span>
                                            <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">int</span>    i;
    <span class="Type">size_t</span> s1_index = <span class="Constant">0</span>;

    _IMMORTAL _BOOLEAN entered = FALSE;                         <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">size_t</span>  s2_index[N_STREXT_STRINGS];               <span class="Comment">/*</span><span class="Comment"> Current pointer into arg string </span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">char</span>    s2_was[N_STREXT_STRINGS][SSIZE];  <span class="Comment">/*</span><span class="Comment"> Copy of current argument string </span><span class="Comment">*/</span>
                                                                <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread perform non thread-safe operations </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[m_strext] attempt by non root thread to perform PUPS/P3 non thread safe operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; dm_ch != MSTREXT_RESET_ALL &amp;&amp; dm_ch != MSTREXT_RESET_CUR)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If dm_ch is '*', '@' re-initialise all or the i_key'th channel </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> respectively.                                                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(entered == FALSE)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;N_STREXT_STRINGS; ++i)
       {  s2_index[i] = <span class="Constant">0</span>;
          (<span class="Type">void</span>)strlcpy(s2_was[i],<span class="Constant">&quot;&quot;</span>,SSIZE);
       }

       entered = TRUE;


       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> First call is a reset </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(dm_ch == MSTREXT_RESET_ALL || dm_ch != MSTREXT_RESET_CUR)
          <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset all key strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(dm_ch == MSTREXT_RESET_ALL)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;N_STREXT_STRINGS; ++i)
       {  s2_index[i] = <span class="Constant">0</span>;
          (<span class="Type">void</span>)strlcpy(s2_was[i],<span class="Constant">&quot;&quot;</span>,SSIZE);
       }

       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Reset current key string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(dm_ch == MSTREXT_RESET_CUR)
    {  s2_index[i_key] = <span class="Constant">0</span>;
       (<span class="Type">void</span>)strlcpy(s2_was[i_key],<span class="Constant">&quot;&quot;</span>,SSIZE);

       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check key is valid. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(i_key &gt; N_STREXT_STRINGS)
       <span class="Statement">return</span>(STREXT_ERROR);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save string length for swap test if this is first pass for current </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> extraction string.                                                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2_index[i_key] == <span class="Constant">0</span>)
       (<span class="Type">void</span>)strlcpy(s2_was[i_key],s2,SSIZE);
    <span class="Statement">else</span>
    {

    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If extraction string has changed re-initialise. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(s2_was[i_key],s2) != <span class="Constant">0</span>)
       {  s2_index[i_key] = <span class="Constant">0</span>;
          (<span class="Type">void</span>)strlcpy(s2_was[i_key],s2,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extract substring to next demarcation character. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>(s2[s2_index[i_key]] != dm_ch &amp;&amp;
          s2[s2_index[i_key]] != <span class="Special">'\0'</span>  &amp;&amp;
          s2[s2_index[i_key]] != <span class="Special">'\n'</span>   )
    {
          s1[s1_index] = s2[s2_index[i_key]];
          ++s1_index;
          ++s2_index[i_key];
    }
    s1[s1_index] = <span class="Special">'\0'</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the end of the extraction string has been reached, reinitialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index[i_key]] == <span class="Special">'\0'</span> || s2[s2_index[i_key]] == <span class="Special">'\n'</span> || s2_index[i_key] == strlen(s2))
    {  s2_index[i_key] = <span class="Constant">0</span>;

                              <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Statement">return</span>(END_STRING);    <span class="Comment">/*</span><span class="Comment"> Messy but some applications need to know if </span><span class="Comment">*/</span>
                              <span class="Comment">/*</span><span class="Comment"> dm_ch was really matched or if we have hit  </span><span class="Comment">*/</span>
                              <span class="Comment">/*</span><span class="Comment"> the end of the string                       </span><span class="Comment">*/</span>
                              <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    }

    ++s2_index[i_key];
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to copy a string filtering out characters which have been</span>
<span class="Comment">    marked as excluded ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">size_t</span> strexccpy(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> *ex_ch)

{   <span class="Type">size_t</span> i,
           j,
           k,
           size_1,
           size_2;

    <span class="Statement">if</span>(s1    == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       s2    == (<span class="Type">char</span> *)      <span class="Constant">NULL</span>    ||
       ex_ch == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);
    size_2 = strlen(ex_ch);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {
       j = <span class="Constant">0</span>;
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size_1; ++i)
       {   <span class="Statement">for</span>(k=<span class="Constant">0</span>; k&lt;size_2; ++k)
           {  <span class="Statement">if</span>(s1[i] == ex_ch[k])
                 <span class="Statement">goto</span> exclude;
           }

           s2[j] = s1[i];
           ++j;

<span class="Statement">exclude</span>:   <span class="Statement">continue</span>;

       }

       pups_set_errno(OK);
       <span class="Statement">return</span>(j);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to return the position of a character within a string - if</span>
<span class="Comment">    the character is not in the string (-1) is returned ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> ch_pos(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
       {  <span class="Statement">if</span>(s[i] == ch)
             <span class="Statement">return</span>(i);
       }

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to return the reverse position of a character within a string - if</span>
<span class="Comment">    the character is not in the string (-1) is returned ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> rch_pos(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=strlen(s)-<span class="Constant">1</span>; i != <span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(s[i] == ch)
             <span class="Statement">return</span>(i);
       }

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Test for empty string (contains only whitespace and control chars) ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strempty(<span class="Type">const</span> <span class="Type">char</span> *s)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empnty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s); ++i)
       {  <span class="Statement">if</span>(s[i] != <span class="Constant">' '</span> &amp;&amp; s[i] != <span class="Special">'\n'</span>)
             <span class="Statement">return</span>(FALSE);
       }

       <span class="Statement">return</span>(TRUE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Generate a string filled with random numeric characters ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> strand(<span class="Type">const</span> <span class="Type">size_t</span> size, <span class="Type">char</span> *s)

{   <span class="Type">size_t</span>    i;
    <span class="Type">char</span>      next_char;
    <span class="Type">short</span> <span class="Type">int</span> next_digit;


    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || size == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Populate string with random (numeric) characters </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
    {  next_digit = (<span class="Type">int</span>)FLOOR(drand48()*<span class="Constant">16.0</span>);
       <span class="Statement">switch</span>(next_digit)
       {     <span class="Statement">case</span> <span class="Constant">0</span>:  next_char = <span class="Constant">'0'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">1</span>:  next_char = <span class="Constant">'1'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">2</span>:  next_char = <span class="Constant">'2'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">3</span>:  next_char = <span class="Constant">'3'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">4</span>:  next_char = <span class="Constant">'4'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">5</span>:  next_char = <span class="Constant">'5'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">6</span>:  next_char = <span class="Constant">'6'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">7</span>:  next_char = <span class="Constant">'7'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">8</span>:  next_char = <span class="Constant">'8'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">9</span>:  next_char = <span class="Constant">'9'</span>;
                      <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">10</span>:  next_char = <span class="Constant">'a'</span>;
                       <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">11</span>:  next_char = <span class="Constant">'b'</span>;
                       <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">12</span>:  next_char = <span class="Constant">'c'</span>;
                       <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">13</span>:  next_char = <span class="Constant">'d'</span>;
                       <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">14</span>:  next_char = <span class="Constant">'e'</span>;
                       <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">15</span>:  next_char = <span class="Constant">'f'</span>;
                       <span class="Statement">break</span>;


             <span class="Statement">default</span>: <span class="Statement">break</span>;
       }

       s[i] = next_char;
    }


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Terminate string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    s[i] = '/<span class="Constant">0</span>';

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to extract substrings which are demarcated by user defined</span>
<span class="Comment">    characters ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                                  <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
_PUBLIC _BOOLEAN mdc_strext(<span class="Type">const</span> <span class="Type">char</span>   *dm_ch,  <span class="Comment">/*</span><span class="Comment"> Demarcation characters string  </span><span class="Comment">*/</span>
                            <span class="Type">int</span>          *dm_bit, <span class="Comment">/*</span><span class="Comment"> Bit codes for matched dm chars </span><span class="Comment">*/</span>
                            <span class="Type">char</span>         *s1,     <span class="Comment">/*</span><span class="Comment"> Extracted sub string           </span><span class="Comment">*/</span>
                            <span class="Type">const</span> <span class="Type">char</span>   *s2)     <span class="Comment">/*</span><span class="Comment"> Argument string                </span><span class="Comment">*/</span>
                                                  <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">size_t</span> dm_ch_index,
           s1_index        = <span class="Constant">0</span>;
                                               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">size_t</span> s2_index  = <span class="Constant">0</span>;            <span class="Comment">/*</span><span class="Comment"> Current pointer into arg string </span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">char</span> *s2_was     = (<span class="Type">char</span> *)<span class="Constant">NULL</span>; <span class="Comment">/*</span><span class="Comment"> Copy of current argument string </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread perform non thread-safe operations </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[strext] attempt by non root thread to perform PUPS/P3 non thread safe operation&quot;</span>);

    <span class="Statement">if</span>(s1     == (<span class="Type">char</span> *)<span class="Constant">NULL</span>          ||
       s2     == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       dm_ch  == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       dm_bit == (<span class="Type">int</span> *) <span class="Constant">NULL</span>           )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save string length for swap test if this is first pass for current </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> extraction string.                                                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2_index == <span class="Constant">0</span>)
    {  s2_was = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(s2_was,s2,SSIZE);
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If extraction string has changed re-initialise </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(s2_was,s2) != <span class="Constant">0</span>)
       {  s2_index = <span class="Constant">0</span>;
          (<span class="Type">void</span>)strlcpy(s2_was,s2,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wind to substring to be extracted </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>((dm_ch_index = ch_pos(dm_ch,s2[s2_index])) != (-<span class="Constant">1</span>) &amp;&amp;
          s2[s2_index] != <span class="Special">'\0'</span>                               &amp;&amp;
          s2[s2_index] != <span class="Special">'\n'</span>                                )
    {     *dm_bit |= (<span class="Type">int</span>)pow(<span class="Constant">2.0</span>,(FTYPE)dm_ch_index);
          ++s2_index;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have reached the end of the extraction string - reinitialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index] == <span class="Special">'\0'</span> || s2[s2_index] == <span class="Special">'\n'</span>)
    {  s2_index = <span class="Constant">0</span>;
       (<span class="Type">void</span>)pups_free(s2_was);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extract substring to next demarcation character </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ch_pos(dm_ch,s2[s2_index]) != (-<span class="Constant">1</span>))
       ++s2_index;

    <span class="Statement">while</span>((dm_ch_index = ch_pos(dm_ch,s2[s2_index])) == (-<span class="Constant">1</span>)      &amp;&amp;
          s2[s2_index] != <span class="Special">'\0'</span> &amp;&amp; s2[s2_index] != <span class="Special">'\n'</span>             )
    {
          s1[s1_index] = s2[s2_index];
          ++s1_index;
          ++s2_index;
    }
    s1[s1_index] = <span class="Special">'\0'</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the end of the extraction string has been reached, reinitialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index] == <span class="Special">'\0'</span> || s2[s2_index] == <span class="Special">'\n'</span>)
    {  s2_index = <span class="Constant">0</span>;
       (<span class="Type">void</span>)pups_free(s2_was);
       <span class="Statement">return</span>(FALSE);
    }
    <span class="Statement">else</span>
    {  *dm_bit |= (<span class="Type">int</span>)pow(<span class="Constant">2.0</span>,(FTYPE)dm_ch_index);
       <span class="Statement">return</span>(TRUE);
    }

    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to extract substrings which are demarcated by  user defined</span>
<span class="Comment">    characters ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                                    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
_PUBLIC _BOOLEAN mdc_strext2(<span class="Type">const</span> <span class="Type">char</span>  *dm_ch,    <span class="Comment">/*</span><span class="Comment"> Demarcation characters string        </span><span class="Comment">*/</span>
                             <span class="Type">int</span>         *dm_bit_l, <span class="Comment">/*</span><span class="Comment"> Bit codes for left matched dm chars  </span><span class="Comment">*/</span>
                             <span class="Type">int</span>         *dm_bit_r, <span class="Comment">/*</span><span class="Comment"> Bit codes for right matched dm chars </span><span class="Comment">*/</span>
                             <span class="Type">int</span>         *pos,      <span class="Comment">/*</span><span class="Comment"> Current position in argument string  </span><span class="Comment">*/</span>
                             <span class="Type">char</span>        *s1,       <span class="Comment">/*</span><span class="Comment"> Extracted sub string                 </span><span class="Comment">*/</span>
                             <span class="Type">const</span> <span class="Type">char</span>  *s2)       <span class="Comment">/*</span><span class="Comment"> Argument string                      </span><span class="Comment">*/</span>
                                                    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">size_t</span> dm_ch_index,
           s1_index = <span class="Constant">0</span>;

    _IMMORTAL _BOOLEAN entered = FALSE;
                                               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">size_t</span> s2_index  = <span class="Constant">0</span>;            <span class="Comment">/*</span><span class="Comment"> Current pointer into arg string      </span><span class="Comment">*/</span>
    _IMMORTAL <span class="Type">char</span>   *s2_was = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;;  <span class="Comment">/*</span><span class="Comment"> Copy of current argument string      </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread perform non thread-safe operations </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[strext] attempt by non root thread to perform PUPS/P3 non thread safe operation&quot;</span>);


    <span class="Statement">if</span>(s1       == (<span class="Type">char</span> *)      <span class="Constant">NULL</span>    ||
       s2       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       dm_ch    == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       dm_bit_l == (<span class="Type">int</span> *)       <span class="Constant">NULL</span>    ||
       dm_bit_r == (<span class="Type">int</span> *)       <span class="Constant">NULL</span>    ||
       pos      == (<span class="Type">int</span> *)       <span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>(entered == FALSE)
       entered = TRUE;
    <span class="Statement">else</span>
       --s2_index;

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  s2_index = <span class="Constant">0</span>;
       *pos = s2_index;
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save string length for swap test if this is first pass for current </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> extraction string.                                                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2_index == <span class="Constant">0</span>)
    {  s2_was = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(s2_was,s2,SSIZE);
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If extraction string has changed re-initialise </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(s2_was,s2) != <span class="Constant">0</span>)
       {  s2_index = <span class="Constant">0</span>;
          (<span class="Type">void</span>)strlcpy(s2_was,s2,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wind to substring to be extracted </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>


    <span class="Statement">while</span>((dm_ch_index = ch_pos(dm_ch,s2[s2_index])) != (-<span class="Constant">1</span>) &amp;&amp;
          s2[s2_index] != <span class="Special">'\0'</span>                               &amp;&amp;
          s2[s2_index] != <span class="Special">'\n'</span>                                )
    {    *dm_bit_l |= (<span class="Type">int</span>)pow(<span class="Constant">2.0</span>,(FTYPE)dm_ch_index);
         ++s2_index;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have reached the end of the extraction string - reinitialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index] == <span class="Special">'\0'</span> || s2[s2_index] == <span class="Special">'\n'</span>)
    {  s2_index = <span class="Constant">0</span>;
       *pos = s2_index;
       (<span class="Type">void</span>)pups_free(s2_was);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Extract substring to next demarcation character </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ch_pos(dm_ch,s2[s2_index]) != (-<span class="Constant">1</span>))
       ++s2_index;

    <span class="Statement">while</span>((dm_ch_index = ch_pos(dm_ch,s2[s2_index])) == (-<span class="Constant">1</span>)      &amp;&amp;
          s2[s2_index] != <span class="Special">'\0'</span> &amp;&amp; s2[s2_index] != <span class="Special">'\n'</span>           )
    {     s1[s1_index] = s2[s2_index];
          ++s1_index;
          ++s2_index;
    }
    s1[s1_index] = <span class="Special">'\0'</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the end of the extraction string has been reached, reinitialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s2[s2_index] == <span class="Special">'\0'</span> || s2[s2_index] == <span class="Special">'\n'</span>)
    {  s2_index = <span class="Constant">0</span>;
       *pos = s2_index;
       *dm_bit_r |= (<span class="Type">int</span>)pow(<span class="Constant">2.0</span>,(FTYPE)dm_ch_index);
       (<span class="Type">void</span>)pups_free(s2_was);
       <span class="Statement">return</span>(FALSE);
    }
    <span class="Statement">else</span>
    {  *dm_bit_r |= (<span class="Type">int</span>)pow(<span class="Constant">2.0</span>,(FTYPE)dm_ch_index);
       ++s2_index;
       *pos = s2_index;
       <span class="Statement">return</span>(TRUE);
    }

    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Look for the occurence of string s2 within string s1 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strinp(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *c_index, <span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2)

{   <span class="Type">size_t</span> i,
           size_1,
           size_2,
           chk_limit;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(c_index != (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
       *c_index = <span class="Constant">0</span>;

    size_1    = strlen(s1);
    size_2    = strlen(s2);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process zero size strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(size_2 &gt; size_1)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       pups_set_errno(OK);
       chk_limit = strlen(s1) - strlen(s2) + <span class="Constant">1</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;chk_limit; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s2,size_2) == <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(c_index != (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> *)<span class="Constant">NULL</span>)
                *c_index = i;

             <span class="Statement">return</span>(TRUE);
          }
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Look for the occurence of string s2 within string s1 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strin(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2)

{   <span class="Type">size_t</span> i,
           size_1,
           size_2,
           chk_limit;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);
    size_2 = strlen(s2);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {
       <span class="Statement">if</span>(size_2 &gt; size_1)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(FALSE);
       }

       pups_set_errno(OK);
       chk_limit = strlen(s1) - strlen(s2) + <span class="Constant">1</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;chk_limit; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s2,size_2) == <span class="Constant">0</span>)
             <span class="Statement">return</span>(TRUE);
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Return tail of string s1 which begins at string s2 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *strin2(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2)

{   <span class="Type">size_t</span> i,
           size_1,
           size_2,
           chk_limit;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);
    size_2 = strlen(s2);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(size_2 &gt; size_1)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
       }

       pups_set_errno(OK);
       chk_limit = size_1 - size_2 + <span class="Constant">1</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;chk_limit; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s2,size_2) == <span class="Constant">0</span>)
             <span class="Statement">return</span>((<span class="Type">char</span> *)&amp;s1[i+size_2]);
       }

       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Look for token demarcated occurence of string s2 within string s1 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strintok(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> *dm_chars)

{   <span class="Type">size_t</span> i,
           j,
           k,
           size_1,
           size_2,
           chk_limit;

    <span class="Type">char</span> dm_char_l = <span class="Special">'\0'</span>,
         dm_char_r = <span class="Special">'\0'</span>;

    _BOOLEAN left_tokenised,
             right_tokenised;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || dm_chars == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);
    size_2 = strlen(s2);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(size_2 &gt; size_1)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       pups_set_errno(OK);
       chk_limit = size_1 - size_2 + <span class="Constant">1</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;chk_limit; ++i)
       {  left_tokenised  = FALSE;
          right_tokenised = FALSE;

          <span class="Statement">if</span>(strncmp(&amp;s1[i],s2,size_2) == <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(i + size_2 &lt; size_1)
             {  dm_char_r = s1[i + size_2];

                <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;strlen(dm_chars); ++j)
                    <span class="Statement">if</span>(dm_char_r == dm_chars[j])
                       right_tokenised = TRUE;
             }
             <span class="Statement">else</span>
                right_tokenised = TRUE;

             <span class="Statement">if</span>(i - <span class="Constant">1</span> &gt;= <span class="Constant">0</span>)
             {  dm_char_l = s1[i-<span class="Constant">1</span>];

                <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;strlen(dm_chars); ++j)
                   <span class="Statement">if</span>(dm_char_l == dm_chars[j])
                      left_tokenised = TRUE;
             }
             <span class="Statement">else</span>
                left_tokenised = TRUE;

             <span class="Statement">if</span>(left_tokenised == TRUE &amp;&amp; right_tokenised == TRUE)
                <span class="Statement">return</span>(TRUE);
          }
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Check if string 3 is to right of string 2 within string 1 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN stright(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> *s3)

{   <span class="Type">size_t</span> i,
           size_1,
           size_2,
           chk_limit;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s3 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);
    size_2 = strlen(s2);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(size_2 &gt; size_1)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(FALSE);
       }

       chk_limit = size_1 - size_2 + <span class="Constant">1</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;chk_limit; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s2,size_2) == <span class="Constant">0</span>)
          {  pups_set_errno(OK);

             <span class="Statement">if</span>(strin(&amp;s1[i + size_2],s3) == TRUE)
                <span class="Statement">return</span>(TRUE);
             <span class="Statement">else</span>
                <span class="Statement">return</span>(FALSE);
          }
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Replace sub-string with constant characters ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strepch(<span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> rep_ch)

{   <span class="Type">size_t</span> i,
           j,
           size_1,
           size_2,
           scan_size;

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);
    size_2 = strlen(s2);

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span>)
    {  scan_size = size_1 - size_2;

       pups_set_errno(OK);
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;scan_size; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s2,size_2) == <span class="Constant">0</span>)
          {  <span class="Statement">for</span>(j=i; j&lt;i + size_2; ++j)
                s1[j] = rep_ch;

             <span class="Statement">return</span>(TRUE);
          }
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Replace all occurences of string s3 within string s1 with string s4</span>
<span class="Comment">    returning result in string s2...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> strep(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> *s3, <span class="Type">const</span> <span class="Type">char</span> *s4)

{   <span class="Type">size_t</span> i,
           j,
           out_index,
           size_1,
           size_2,
           cmp_size,
           rep_size;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       s2 == (<span class="Type">char</span>       *)<span class="Constant">NULL</span>    ||
       s3 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       s4 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    size_1   = strlen(s1);
    size_2   = strlen(s1);
    cmp_size = strlen(s3);
    rep_size = strlen(s4);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span> &amp;&amp; cmp_size &gt; <span class="Constant">0</span> &amp;&amp; rep_size &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(size_2 &gt; size_2)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Initialise output string </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

       pups_set_errno(OK);
       (<span class="Type">void</span>)strlcpy(s2,<span class="Constant">&quot;&quot;</span>,SSIZE);

       out_index = <span class="Constant">0</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size_1; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s3,cmp_size) == <span class="Constant">0</span>)
          {  s2[out_index] = <span class="Special">'\0'</span>;

             (<span class="Type">void</span>)strlcat(s2,s4,SSIZE);

             out_index += rep_size;
             i         += cmp_size - <span class="Constant">1</span>;
          }

          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Cannot find valid demarcation character - simply copy string </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
          {   s2[out_index] = s1[i];
              ++out_index;
          }
       }

       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    s2[out_index] = <span class="Special">'\0'</span>;
    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Replace all token demarcated occurences of string s3 within string</span>
<span class="Comment">    s1 with string s4 returning result in string s2 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> streptok(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> *s3, <span class="Type">const</span> <span class="Type">char</span> *s4, <span class="Type">const</span> <span class="Type">char</span> *dm_chars)

{   <span class="Type">size_t</span> i,
           j,
           out_index,
           size_1,
           size_2,
           dm_chars_size,
           cmp_size,
           rep_size;
           <span class="Comment">//chk_limit;</span>

    <span class="Type">char</span> dm_char_l = <span class="Special">'\0'</span>,
         dm_char_r = <span class="Special">'\0'</span>;

    _BOOLEAN left_tokenised,
             right_tokenised;

    <span class="Statement">if</span>(s1       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       s2       == (<span class="Type">char</span>       *)<span class="Constant">NULL</span>    ||
       s3       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       s4       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    ||
       dm_chars == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1        = strlen(s1);
    size_2        = strlen(s1);
    dm_chars_size = strlen(dm_chars);
    cmp_size      = strlen(s3);
    rep_size      = strlen(s4);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span> &amp;&amp; size_2 &gt; <span class="Constant">0</span> &amp;&amp; dm_chars_size &gt; <span class="Constant">0</span> &amp;&amp; cmp_size &gt; <span class="Constant">0</span> &amp;&amp; rep_size &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(size_2 &gt; size_1)
       {  pups_set_errno(<span class="Constant">ERANGE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }


       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Initialise output string </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

       pups_set_errno(OK);
       (<span class="Type">void</span>)strlcpy(s2,<span class="Constant">&quot;&quot;</span>,SSIZE);

       out_index = <span class="Constant">0</span>;

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size_1; ++i)
       {  <span class="Statement">if</span>(strncmp(&amp;s1[i],s3,cmp_size) == <span class="Constant">0</span>)
          {

             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Check that valid demarcation character appended to string s2 </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

             left_tokenised  = FALSE;
             right_tokenised = FALSE;
             <span class="Statement">if</span>(i + cmp_size &lt; size_1)
             {  dm_char_r = s1[i + cmp_size];

                <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;dm_chars_size; ++j)
                    <span class="Statement">if</span>(dm_chars[j] == dm_char_r)
                       right_tokenised = TRUE;
             }
             <span class="Statement">else</span>
                right_tokenised = TRUE;

             <span class="Statement">if</span>(i - <span class="Constant">1</span> &gt;= <span class="Constant">0</span>)
             {  dm_char_l = s1[i - <span class="Constant">1</span>];

                <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;dm_chars_size; ++j)
                    <span class="Statement">if</span>(dm_chars[j] == dm_char_l)
                       left_tokenised = TRUE;
             }
             <span class="Statement">else</span>
                left_tokenised = TRUE;

             <span class="Statement">if</span>(left_tokenised == TRUE &amp;&amp; right_tokenised == TRUE)
             {  s2[out_index] = <span class="Special">'\0'</span>;

                (<span class="Type">void</span>)strlcat(s2,s4,SSIZE);
                out_index += rep_size;
                i         += cmp_size - <span class="Constant">1</span>;
             }


             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Cannot find valid demarcation character - simply copy string </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span>
                 s2[out_index] = s1[i];

              ++out_index;
          }
          <span class="Statement">else</span>
          {  s2[out_index] = s1[i];
             ++out_index;
          }
       }

       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Truncate string at demarcation character starting at tail of string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strtrnc(<span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> trunc_c, <span class="Type">int</span> c_cnt)

{   <span class="Type">size_t</span> f_cnt   = <span class="Constant">0</span>,
           s_index = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    s_index = strlen(s);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not try to process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s_index &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Search for specified demarcation character </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">while</span>(s_index &gt; <span class="Constant">0</span>) <span class="Comment">// Was &gt;= 0</span>
       {  <span class="Statement">if</span>(s[s_index] == trunc_c)
             ++f_cnt;


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We have found specified demarcation character </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> return truncated string                       </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(f_cnt == c_cnt)
          {  s[s_index] = <span class="Special">'\0'</span>;
             <span class="Statement">return</span>(TRUE);
          }

          --s_index;
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Truncate string at demarcation character starting at head of string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strtrnch(<span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> trunc_c, <span class="Type">int</span> c_cnt)

{   <span class="Type">size_t</span> size,
           f_cnt   = <span class="Constant">0</span>,
           s_index = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    s_index = <span class="Constant">0</span>;
    size    = strlen(s);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Search for specified demarcation character </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">while</span>(s_index &lt; size &amp;&amp; f_cnt != c_cnt)
       {   <span class="Statement">if</span>(s[s_index] == trunc_c)
              ++f_cnt;
         ++s_index;
       }


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We have found specified demarcation character </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> return truncated string                       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">if</span>(f_cnt == c_cnt)
       {  s[s_index-<span class="Constant">1</span>] = <span class="Special">'\0'</span>;
          <span class="Statement">return</span>(TRUE);
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Start string from demarcation character returning result in string s2 ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strfrm(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> start_c, <span class="Type">const</span> <span class="Type">int</span> c_cnt, <span class="Type">char</span> *s2)

{   <span class="Type">size_t</span> size_1,
           f_cnt   = <span class="Constant">0</span>,
           s_index = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size_1 = strlen(s1);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size_1 &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">if</span>(c_cnt == <span class="Constant">0</span>)
          (<span class="Type">void</span>)strlcpy(s2,s1,SSIZE);
       <span class="Statement">else</span>
       {  <span class="Statement">while</span>(s_index &lt; size_1 &amp;&amp; f_cnt != c_cnt)
          {   <span class="Statement">if</span>(s1[s_index] == start_c)
                 ++f_cnt;
               ++s_index;
          }

          (<span class="Type">void</span>)strlcpy(s2,&amp;s1[s_index],SSIZE);
       }

       <span class="Statement">if</span>(f_cnt == c_cnt)
         <span class="Statement">return</span>(TRUE);

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Strip trailing characters from string starting analysis at tail of</span>
<span class="Comment">    string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strail(<span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> c)

{   <span class="Type">size_t</span> i,
           size;

    _BOOLEAN has_linefeed = FALSE;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);

    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do not process empty string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt;= <span class="Constant">1</span>)
    {  pups_set_errno(OK);

       --size;

       <span class="Statement">for</span>(i=size; i&gt;=<span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(s[i] != c &amp;&amp; s[i] != <span class="Special">'\n'</span> &amp;&amp; s[i] != <span class="Special">'\0'</span>)
             <span class="Statement">return</span>(TRUE);
          <span class="Statement">else</span> <span class="Statement">if</span>(s[i] == c)
          {  <span class="Statement">if</span>(has_linefeed == TRUE)
             {  s[i] = <span class="Special">'\n'</span>;
                s[i+<span class="Constant">1</span>] = <span class="Special">'\0'</span>;
             }
             <span class="Statement">else</span>
                s[i] = <span class="Special">'\0'</span>;

             <span class="Statement">return</span>(TRUE);
          }

          <span class="Statement">if</span>(s[i] == <span class="Special">'\n'</span>)
             has_linefeed = TRUE;
       }

       <span class="Statement">return</span>(FALSE);
    }

     pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Extract leaf from pathname ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strleaf(<span class="Type">const</span> <span class="Type">char</span> *pathname, <span class="Type">char</span> *leaf)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;
    _BOOLEAN     ret = FALSE;

    <span class="Statement">if</span>(pathname == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || leaf == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=strlen(pathname); i&gt; <span class="Constant">0</span>; --i)
    {  <span class="Statement">if</span>(pathname[i] == <span class="Constant">'/'</span>)
       {  ret = TRUE;
          <span class="Statement">break</span>;
       }
    }


    <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Leaf </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(i &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)strlcpy(leaf,(<span class="Type">char</span> *)&amp;pathname[i+<span class="Constant">1</span>],SSIZE);


    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No leaf </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(leaf,pathname,SSIZE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Extract branch from pathname ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strbranch(<span class="Type">const</span> <span class="Type">char</span> *pathname, <span class="Type">char</span> *branch)

{   <span class="Type">unsigned</span> <span class="Type">int</span> i;
    _BOOLEAN     ret = FALSE;

    <span class="Statement">if</span>(pathname == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || branch == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=strlen(pathname); i&gt; <span class="Constant">0</span>; --i)
    {  <span class="Statement">if</span>(pathname[i] == <span class="Constant">'/'</span>)
       {  ret = TRUE;
          <span class="Statement">break</span>;
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Branch </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(i &gt; <span class="Constant">0</span>)
    {  (<span class="Type">void</span>)strlcpy(branch,pathname,SSIZE);
       branch[i] = <span class="Special">'\0'</span>;
    }


    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No branch </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(branch,pathname,SSIZE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Strip first digit in string (and all characters after it) ...</span>
<span class="Comment">-----------------------:------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strdigit(<span class="Type">char</span> *s)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero size string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
       {  <span class="Statement">if</span>(isdigit(s[i]))
          {  s[i] = <span class="Special">'\0'</span>;
            <span class="Statement">return</span>(TRUE);
          }
       }

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Strip leading characters from string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *strlead(<span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> c)

{   <span class="Type">size_t</span> size,
           i = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }

    size = strlen(s);

    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero size string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">while</span>(s[i] == c)
       {     <span class="Statement">if</span>(i == size)
                <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
             <span class="Statement">else</span>
                ++i;
       }

       <span class="Statement">return</span>((<span class="Type">char</span> *)&amp;s[i]);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Count number of occurences of character in string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> strchcnt(<span class="Type">const</span> <span class="Type">char</span> c, <span class="Type">const</span> <span class="Type">char</span> *s)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Type">int</span>    cnt = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero size string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s); ++i)
       {  <span class="Statement">if</span>(s[i] == c)
             ++cnt;
       }

       <span class="Statement">return</span>(cnt);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Strip numeric characters from string (including '#' and '^' which are</span>
<span class="Comment">    used to demarcate checksums in file names) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strpdigit(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">char</span> *stripped)

{   <span class="Type">size_t</span> i,
           size,
           cnt      = (-<span class="Constant">1</span>);

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || stripped == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
       {  <span class="Statement">if</span>(isdigit(s[i]))
          {  <span class="Statement">if</span>(stripped[cnt] == <span class="Constant">'-'</span>)
                stripped[cnt]   = <span class="Special">'\0'</span>;
             <span class="Statement">else</span>
                stripped[cnt+<span class="Constant">1</span>] = <span class="Special">'\0'</span>;
             <span class="Statement">return</span>(TRUE);
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(s[i] == <span class="Constant">'_'</span> || s[i] == <span class="Constant">'-'</span> ||  s[i] == <span class="Constant">'.'</span> || s[i] == <span class="Constant">'^'</span> || s[i] == <span class="Constant">'#'</span>)
          {  ++cnt;
             stripped[cnt] = <span class="Constant">'-'</span>;
          }
          <span class="Statement">else</span> <span class="Statement">if</span>(isalpha(s[i]))
          {  ++cnt;
             stripped[cnt] = s[i];
          }
       }

       stripped[cnt+<span class="Constant">1</span>] = <span class="Special">'\0'</span>;
       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Strip character from string (starting at tail) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *strpch(<span class="Type">const</span> <span class="Type">char</span> token, <span class="Type">char</span> *s)

{   <span class="Type">size_t</span> start_str,
           size,
           i     = <span class="Constant">0</span>;

    _BOOLEAN c_ret = FALSE;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);


       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remove leading tokens </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

       <span class="Statement">while</span>(s[i] == token)
       {     ++i;

            <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> String just contains token and is </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> effectively empty                 </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(i == <span class="Constant">0</span>)
            {  pups_set_errno(<span class="Constant">ESRCH</span>);
               <span class="Statement">return</span>(-<span class="Constant">1</span>);
            }
       }

       start_str = i;


       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remove trailing tokens </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       i = size;
       <span class="Statement">if</span>(s[i] == <span class="Special">'\n'</span>)
       {  c_ret = TRUE;
          --i;
       }

       <span class="Statement">while</span>(s[i] == token)
            --i;
       ++i;

       <span class="Statement">if</span>(c_ret == TRUE)
          s[i] = <span class="Special">'\n'</span>;
       <span class="Statement">else</span>
          s[i] = <span class="Special">'\0'</span>;

       <span class="Statement">return</span>((<span class="Type">char</span> *)&amp;s[start_str]);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Replace multiple chracters in string with given character ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> mchrep(<span class="Type">const</span> <span class="Type">char</span> rep_ch, <span class="Type">const</span> <span class="Type">char</span> *ch_to_rep, <span class="Type">char</span> *s1)

{   <span class="Type">size_t</span> i,
           j,
           size,
           rep_size;

    <span class="Type">int</span> cnt  = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || ch_to_rep == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size     = strlen(s1);
    rep_size = strlen(ch_to_rep);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero size string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span> &amp;&amp; rep_size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
       {  <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;rep_size; ++j)
          {  <span class="Statement">if</span>(s1[i] == ch_to_rep[j] || (ch_to_rep[j] == <span class="Constant">'D'</span> &amp;&amp; isdigit(s1[i])))
             {  s1[i] = rep_ch;
                ++cnt;
             }
          }
       }

       <span class="Statement">return</span>(cnt);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Copy string checking for NULL or invalid argument string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *strccpy(<span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2)

{   <span class="Type">size_t</span> size_2,
           i  = <span class="Constant">0</span>;

    <span class="Statement">if</span>(s2 == (<span class="Type">char</span> *)INVALID_ARG)
       <span class="Statement">return</span>((<span class="Type">char</span> *)INVALID_ARG);
    <span class="Statement">else</span> <span class="Statement">if</span>(s1 == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }



    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length strings </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    size_2 = strlen(s2);
    <span class="Statement">if</span>(size_2 &gt; <span class="Constant">0</span>)
    {  <span class="Statement">while</span>(s2[i] != <span class="Special">'\0'</span>)
       {  s1[i] = s2[i];
          ++i;
       }
       s1[i] = <span class="Special">'\0'</span>;

       pups_set_errno(OK);
       <span class="Statement">return</span>(s1);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to return the position of the nth occurence of nominated</span>
<span class="Comment">    character within string relative to head ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> ch_index(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;size; ++i)
       {  <span class="Statement">if</span>(s[i] == ch)
             <span class="Statement">return</span>(i);
       }

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to return the position of the nth occurence of nominated</span>
<span class="Comment">    character within string relative to tail ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> rch_index(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">for</span>(i=size; i&gt;= <span class="Constant">0</span>; --i)
       {  <span class="Statement">if</span>(s[i] == ch)
             <span class="Statement">return</span>(i);
       }

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Routine to test if nominated character is the first one in string ...</span>
<span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN ch_is_first(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Type">size_t</span> size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  pups_set_errno(OK);

       <span class="Statement">if</span>(s[<span class="Constant">0</span>] == ch)
          <span class="Statement">return</span>(TRUE);

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Routine to test if nominated character is the last one in string ...</span>
<span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN ch_is_last(<span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">char</span> ch)

{   <span class="Type">size_t</span> size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't process zero length string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(s[size] == ch)
          <span class="Statement">return</span>(TRUE);

       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Locate a given switch in the command tail ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_locate(_BOOLEAN *init, <span class="Type">const</span> <span class="Type">char</span> *swtch, <span class="Type">int</span> *cnt, <span class="Type">const</span> <span class="Type">char</span> *args[], <span class="Type">int</span> nchars)

{     <span class="Type">int</span>  j;
      <span class="Type">char</span> ctail_alias_file_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

      <span class="Statement">if</span>(init  == (_BOOLEAN *)      <span class="Constant">NULL</span>  ||
         swtch == (<span class="Type">const</span> <span class="Type">char</span> *)    <span class="Constant">NULL</span>  ||
         cnt   == (<span class="Type">int</span> *)           <span class="Constant">NULL</span>  ||
         args  == (<span class="Type">const</span> <span class="Type">char</span> **)   <span class="Constant">NULL</span>   )
      {  pups_set_errno(<span class="Constant">EINVAL</span>);
         <span class="Statement">return</span>(-<span class="Constant">1</span>);
      }
      <span class="Statement">else</span>
         pups_set_errno(OK);


      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> If we have a command tail alias argument file </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> see if this switch is aliased                 </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

      (<span class="Type">void</span>)snprintf(ctail_alias_file_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.</span><span class="Special">%s</span><span class="Constant">.ctailrc&quot;</span>,appl_home,appl_name);

      <span class="Statement">if</span>(access(ctail_alias_file_name,F_OK) == <span class="Constant">0</span>)
      {  <span class="Type">FILE</span> *ctail_alias_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

         <span class="Type">int</span>  eof = <span class="Constant">0</span>;

         <span class="Type">char</span> next_alias[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
              alias[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
              substitute[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

         <span class="Statement">if</span>((ctail_alias_stream = fopen(ctail_alias_file_name,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
            pups_error(<span class="Constant">&quot;[pups_locate] cannot open alias file&quot;</span>);

         <span class="Statement">do</span> {   (<span class="Type">void</span>)fgets(next_alias,SSIZE,ctail_alias_stream);


                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> feof() is an alias -- and fail to expand properly </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> if tested in a multi-term if statement.           </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

                eof = feof(ctail_alias_stream);
                <span class="Statement">if</span>(eof == <span class="Constant">0</span> &amp;&amp; next_alias[<span class="Constant">0</span>] != <span class="Special">'\n'</span> &amp;&amp; next_alias[<span class="Constant">0</span>] != <span class="Constant">'#'</span>)
                {  <span class="Statement">if</span>(sscanf(next_alias,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,alias,substitute) != <span class="Constant">2</span>)
                      pups_error(<span class="Constant">&quot;[pups_locate] corrupt alias file&quot;</span>);

                   <span class="Statement">if</span>(nchars &gt; <span class="Constant">0</span>)
                   {  <span class="Statement">if</span>(strncmp(swtch,alias,nchars) == <span class="Constant">0</span>)
                      {  (<span class="Type">void</span>)strlcpy(swtch,substitute,SSIZE);
                         (<span class="Type">void</span>)fclose(ctail_alias_stream);
                         <span class="Statement">goto</span> aliased;
                      }
                   }
                   <span class="Statement">else</span>
                   {  <span class="Statement">if</span>(strcmp(swtch,alias) == <span class="Constant">0</span>)
                      {  (<span class="Type">void</span>)strlcpy(swtch,substitute,SSIZE);
                         (<span class="Type">void</span>)fclose(ctail_alias_stream);
                         <span class="Statement">goto</span> aliased;
                      }
                   }
                }
            } <span class="Statement">while</span>(feof(ctail_alias_stream) == <span class="Constant">0</span>);
      }

<span class="Statement">aliased</span>:

      <span class="Statement">if</span>(*cnt == <span class="Constant">0</span>)
         <span class="Statement">return</span>((<span class="Type">int</span>)NOT_FOUND);

      <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;=t_args; ++j)
      {     <span class="Statement">if</span>(args[j]    != (<span class="Type">char</span> *)<span class="Constant">NULL</span>      &amp;&amp;
               args[j][<span class="Constant">0</span>] == <span class="Constant">'-'</span>               &amp;&amp;
               strcmp(swtch,&amp;args[j][<span class="Constant">1</span>]) == <span class="Constant">0</span>   )
              {  (*cnt)--;
                 argd[j] = TRUE;
                 <span class="Statement">return</span>((<span class="Type">int</span>)j);
              }
      }

      pups_set_errno(<span class="Constant">ERANGE</span>);
      <span class="Statement">return</span>((<span class="Type">int</span>)NOT_FOUND);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Function to decode an integer from a command tail argument ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_i_dec(<span class="Type">int</span> *ptr, <span class="Type">int</span> *argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> ret;

    <span class="Statement">if</span>(ptr  == (<span class="Type">int</span>         *)<span class="Constant">NULL</span>  ||
       argc == (<span class="Type">const</span> <span class="Type">int</span>   *)<span class="Constant">NULL</span>  ||
       argv == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>(*argc &gt; t_args)
       <span class="Statement">return</span>((<span class="Type">int</span>)INVALID_ARG);

    ++(*ptr);
    <span class="Statement">if</span>(argv[(*ptr)] == <span class="Constant">NULL</span> ||
       (argv[(*ptr)][<span class="Constant">0</span>] == <span class="Constant">'-'</span> &amp;&amp; !isdigit(argv[(*ptr)][<span class="Constant">1</span>])))
       <span class="Statement">return</span>((<span class="Type">int</span>)INVALID_ARG);
    <span class="Statement">else</span>
    {  (*argc)--;
       argd[*ptr] = TRUE;
       <span class="Statement">if</span>(sscanf(argv[(*ptr)],<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;ret) != <span class="Constant">1</span>)
          <span class="Statement">return</span>((<span class="Type">int</span>)INVALID_ARG);
       <span class="Statement">else</span>
          <span class="Statement">return</span>(ret);
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Function to decode a real from a command tail argument ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC FTYPE pups_fp_dec(<span class="Type">int</span> *ptr, <span class="Type">int</span> *argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   FTYPE ret;

    <span class="Statement">if</span>(ptr  == (<span class="Type">int</span>         *)<span class="Constant">NULL</span>  ||
       argc == (<span class="Type">const</span> <span class="Type">int</span>   *)<span class="Constant">NULL</span>  ||
       argv == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>(*argc &gt; t_args)
       <span class="Statement">return</span>((FTYPE)INVALID_ARG);

    ++(*ptr);
    <span class="Statement">if</span>(argv[(*ptr)] == (<span class="Type">char</span> *)<span class="Constant">NULL</span> ||
       (argv[(*ptr)][<span class="Constant">0</span>] == <span class="Constant">'-'</span> &amp;&amp; !isdigit(argv[(*ptr)][<span class="Constant">1</span>])))
       <span class="Statement">return</span>((FTYPE)INVALID_ARG);
    <span class="Statement">else</span>
    {  (*argc)--;
       argd[*ptr] = TRUE;
       <span class="Statement">if</span>(sscanf(argv[*ptr],<span class="Constant">&quot;</span><span class="Special">%F</span><span class="Constant">&quot;</span>,&amp;ret) != <span class="Constant">1</span>)
          <span class="Statement">return</span>((FTYPE)INVALID_ARG);
       <span class="Statement">else</span>
          <span class="Statement">return</span>(ret);
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Function to decode a string from the command tail ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *pups_str_dec(<span class="Type">int</span> *ptr, <span class="Type">int</span> *argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   _IMMORTAL <span class="Type">char</span> aggregate_str[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(ptr  == (<span class="Type">int</span>         *)<span class="Constant">NULL</span>  ||
       argc == (<span class="Type">const</span> <span class="Type">int</span>   *)<span class="Constant">NULL</span>  ||
       argv == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">unsigned</span> <span class="Type">char</span> *)INVALID_ARG);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>(*argc &gt; t_args)
       <span class="Statement">return</span>((<span class="Type">char</span> *)INVALID_ARG);

    ++(*ptr);
    <span class="Statement">if</span>(argv[(*ptr)] == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || argv[(*ptr)][<span class="Constant">0</span>] == <span class="Constant">'-'</span> || strlen(argv[(*ptr)]) == <span class="Constant">0</span>)
       <span class="Statement">return</span>((<span class="Type">char</span> *)((<span class="Type">unsigned</span> <span class="Type">char</span> *)INVALID_ARG));
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(argv[(*ptr)][<span class="Constant">0</span>] != <span class="Constant">'&quot;'</span>)
       {  (*argc)--;
          argd[*ptr] = TRUE;
          <span class="Statement">return</span>((<span class="Type">char</span> *)argv[(*ptr)]);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)strlcat(aggregate_str,<span class="Constant">&quot;&quot;</span>,SSIZE);

          <span class="Statement">while</span>(argv[(*ptr)][strlen(argv[(*ptr)])-<span class="Constant">1</span>] != <span class="Constant">'&quot;'</span> &amp;&amp; (*argc) &gt; <span class="Constant">0</span>)
          {  (<span class="Type">void</span>)strlcat(aggregate_str,argv[(*ptr)],SSIZE);
             (<span class="Type">void</span>)strlcat(aggregate_str,<span class="Constant">&quot; &quot;</span>,SSIZE);

             (*argc)--;
             ++(*ptr);
          }

          (<span class="Type">void</span>)strlcat(aggregate_str,argv[(*ptr)],SSIZE);
          aggregate_str[strlen(aggregate_str)-<span class="Constant">1</span>] = <span class="Special">'\0'</span>;

          <span class="Statement">return</span>(&amp;aggregate_str[<span class="Constant">1</span>]);
       }
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Function to decode character from command tail ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> pups_ch_dec(<span class="Type">int</span> *ptr, <span class="Type">int</span> *argc, <span class="Type">const</span> <span class="Type">char</span> *argv[])

{   <span class="Statement">if</span>(ptr  == (<span class="Type">int</span>         *)<span class="Constant">NULL</span>  ||
       argc == (<span class="Type">const</span> <span class="Type">int</span>   *)<span class="Constant">NULL</span>  ||
       argv == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>(*argc &gt; t_args)
       <span class="Statement">return</span>((<span class="Type">char</span>)INVALID_ARG);

    ++(*ptr);
    <span class="Statement">if</span>(argv[(*ptr)] == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || argv[(*ptr)][<span class="Constant">0</span>] == <span class="Constant">'-'</span>)
       <span class="Statement">return</span>((<span class="Type">char</span>)INVALID_ARG);
    <span class="Statement">else</span>
    {  (*argc)--;
       argd[*ptr] = TRUE;
       <span class="Statement">return</span>((<span class="Type">char</span>)argv[(*ptr)][<span class="Constant">0</span>]);
    }
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Decode command argument tail file ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_argfile(<span class="Type">int</span> ptr, <span class="Type">int</span> *argc, <span class="Type">const</span> <span class="Type">char</span> *argv[], _BOOLEAN argd[])

{   <span class="Type">int</span> i,
        n_args,
        c_index;

    _BOOLEAN looper          = TRUE,
             quoted          = FALSE,
             default_argfile = FALSE;

    <span class="Type">char</span> *tmp_f_name = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
         *next_token = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

    <span class="Type">FILE</span> *arg_file = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>,
         *tmp_file = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

     <span class="Statement">if</span>(ptr  == (<span class="Type">int</span>         *)<span class="Constant">NULL</span>  ||
        argc == (<span class="Type">const</span>   <span class="Type">int</span> *)<span class="Constant">NULL</span>  ||
        argv == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>  ||
        argd == (<span class="Type">char</span>       **)<span class="Constant">NULL</span>   )
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }

    arg_f_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    tmp_f_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    next_token = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(ptr &gt;= (*argc) || strccpy(arg_f_name,pups_str_dec(&amp;ptr,argc,argv)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)snprintf(arg_f_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.agf&quot;</span>,appl_name);
       <span class="Statement">if</span>(access(arg_f_name,F_OK | R_OK) == (-<span class="Constant">1</span>))
          <span class="Statement">return</span>;

       default_argfile = TRUE;
       --ptr;
    }
    <span class="Statement">else</span>
       ++ptr;


<span class="PreProc">     #ifdef UTILIB_DEBUG</span>
     (<span class="Type">void</span>)strdate(date);
     <span class="Statement">if</span>(default_argfile == TRUE)
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): argfile: reading command tail from default argfile </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                 date,appl_name,appl_pid,appl_host,appl_owner,arg_f_name);
     <span class="Statement">else</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): argfile: reading command tail from argfile </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                         date,appl_name,appl_pid,appl_host,appl_owner,arg_f_name);
     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Shift all existing arguments left and then add arguments read from</span>
<span class="Comment">   the argument file to the end of the secondary argument vectors ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(default_argfile == FALSE)
    {  ptr -= <span class="Constant">2</span>;
       <span class="Statement">for</span>(i=ptr; i&lt;t_args-<span class="Constant">1</span>; ++i)
           argv[i] = argv[i+<span class="Constant">1</span>];
    }

    <span class="Statement">if</span>((arg_file = (<span class="Type">FILE</span> *)fopen(arg_f_name,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[pups_argfile] cannot find argument file (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,arg_f_name);
       pups_error(errstr);
    }

<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">   Strip all comments from the argument file. Arguments are prefixed by a</span>
<span class="Comment">   '#' character ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(tmp_f_name,SSIZE,<span class="Constant">&quot;/tmp/stripc.dat.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_host,appl_pid);
    tmp_file = (<span class="Type">FILE</span> *)pups_strp_commnts(<span class="Constant">'#'</span>,arg_file,tmp_f_name);

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">   Allocate sufficient space for the replacement argument vector ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

    t_args = ptr;
    <span class="Statement">do</span> {  n_args = fscanf(tmp_file,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,next_token);

          <span class="Statement">if</span>(n_args != <span class="Constant">1</span>)
             <span class="Statement">goto</span> exit;
          <span class="Statement">else</span>
          {  <span class="Statement">if</span>(quoted == FALSE)
             {  argv[t_args] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
                argd[t_args] = FALSE;
             }

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Test to see if string is '&quot;' or contains '&quot;' - if it does catenate</span>
<span class="Comment">    all items read until anoth '&quot;' is found ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>((c_index = ch_index(next_token,<span class="Constant">'&quot;'</span>)) != -<span class="Constant">1</span>)
             {  <span class="Statement">if</span>(quoted == TRUE)
                {  next_token[c_index] = <span class="Special">'\0'</span>;
                   (<span class="Type">void</span>)strlcat(args[t_args],next_token,SSIZE);
                   quoted = FALSE;
                 }
                 <span class="Statement">else</span>
                 {  quoted = TRUE;
                    <span class="Statement">if</span>(strlen(next_token) &gt; <span class="Constant">1</span>)
                    {  (<span class="Type">void</span>)strlcpy(args[t_args],&amp;next_token[<span class="Constant">1</span>],SSIZE);
                       (<span class="Type">void</span>)strlcat(args[t_args],<span class="Constant">&quot; &quot;</span>,SSIZE);
                    }
                    <span class="Statement">else</span>
                       (<span class="Type">void</span>)strlcpy(args[t_args],<span class="Constant">&quot;&quot;</span>,SSIZE);
                 }
              }
              <span class="Statement">else</span>
              {  <span class="Statement">if</span>(quoted == TRUE)
                 {  (<span class="Type">void</span>)strlcat(args[t_args],next_token,SSIZE);
                    (<span class="Type">void</span>)strlcat(args[t_args],<span class="Constant">&quot; &quot;</span>,SSIZE);
                 }
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)strlcpy(args[t_args],next_token,SSIZE);
              }

              ++t_args;
           }
        } <span class="Statement">while</span>(looper == TRUE);

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Adjust the argument count ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Statement">exit</span>:

    init = TRUE;
    *argc = appl_t_args = t_args;


<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;*argc; ++i)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB COPY[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,args[i]);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    (<span class="Type">void</span>)strdate(date);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> additional arguments read</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                  date,appl_name,appl_pid,appl_host,appl_owner,t_args - ptr);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


    (<span class="Type">void</span>)fclose(tmp_file);
    (<span class="Type">void</span>)unlink(tmp_f_name);
    (<span class="Type">void</span>)pups_free((<span class="Type">char</span> *)tmp_f_name);
    (<span class="Type">void</span>)pups_free((<span class="Type">char</span> *)next_token);

    pups_set_errno(OK);
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Generate effective command line from secondary argument vector ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_argtline(<span class="Type">char</span> *cmd_tail)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(cmd_tail == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_t_args; ++i)
    {   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB ARGS[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,args[i]);
        (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(cmd_tail,<span class="Constant">&quot;&quot;</span>,SSIZE);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_t_args; ++i)
    {

<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB IN ARG[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,args[i]);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Note that -psrp_reactivate_client, -psrp_segment, -pen and </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> -bin are generated automatically by psrp_new_segment       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(in_psrp_new_segment == TRUE)
       {  <span class="Statement">if</span>(strcmp(args[i],<span class="Constant">&quot;-psrp_reactivate_client&quot;</span>) == <span class="Constant">0</span>)
             i += <span class="Constant">1</span>;
          <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(args[i],<span class="Constant">&quot;-psrp_segment&quot;</span>) == <span class="Constant">0</span>)
             i += <span class="Constant">1</span>;
          <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(args[i],<span class="Constant">&quot;-pen&quot;</span>) == <span class="Constant">0</span>)
             i += <span class="Constant">1</span>;
          <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(args[i],<span class="Constant">&quot;-bin&quot;</span>) == <span class="Constant">0</span>)
             i += <span class="Constant">1</span>;
          <span class="Statement">else</span>
          {

<span class="PreProc">             #ifdef UTILIB_DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB NEW SEGMENT OUT ARG[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,args[i]);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

             (<span class="Type">void</span>)strlcat(cmd_tail,args[i],SSIZE);
          }
       }
       <span class="Statement">else</span>
       {

<span class="PreProc">          #ifdef UTILIB_DEBUG</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB OUT ARG[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,args[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcat(cmd_tail,args[i],SSIZE);
       }

       <span class="Statement">if</span>(i &lt; appl_t_args - <span class="Constant">1</span>)
          (<span class="Type">void</span>)strlcat(cmd_tail,<span class="Constant">&quot; &quot;</span>,SSIZE);
    }

<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB OUTPUT CMD TAIL: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,cmd_tail);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Signal to catch really bad errors ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> catch_sigsegv(<span class="Type">void</span>)

{   pups_error(<span class="Constant">&quot;[catch_segv] cannot recover from error&quot;</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Do we have resources required for operation? ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_have_resources(<span class="Type">const</span> FTYPE proc_loading, <span class="Type">const</span> <span class="Type">int</span> mem_required)

{   FTYPE current_proc_loading;
    <span class="Type">int</span>   mem_free;

    <span class="Statement">if</span>(pups_get_resource_loading(FALSE,&amp;current_proc_loading,&amp;mem_free) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    <span class="Statement">if</span>(current_proc_loading &gt; proc_loading || mem_free &lt; mem_required)
    {  pups_set_errno(<span class="Constant">EAGAIN</span>);
       <span class="Statement">return</span>(FALSE);
    }

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Copy command tail from system argument vector to process vector ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_copytail(<span class="Type">int</span> *argc, <span class="Type">const</span> <span class="Type">char</span> *args[], <span class="Type">char</span> *argv[])

{   <span class="Type">int</span> i,
        start = <span class="Constant">1</span>,
        cnt   = <span class="Constant">0</span>;

    <span class="Type">char</span> ssh_remote_port[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         ssh_remote_host[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         ssh_remote_user[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         ssh_remote_cmd[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN do_bg            = FALSE,
             do_remote_exec   = FALSE;

    <span class="Statement">if</span>(argc == (<span class="Type">int</span> *)  <span class="Constant">NULL</span>  ||
       args == (<span class="Type">char</span> **)<span class="Constant">NULL</span>  ||
       argv == (<span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is this process going to run remotely? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;(*argc); ++i)
    {  <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-on&quot;</span>) == <span class="Constant">0</span>)
       {  do_remote_exec = TRUE;
          <span class="Statement">break</span>;
       }
    }

    <span class="Statement">if</span>(do_remote_exec == TRUE)
    {  <span class="Statement">if</span>(strccpy(ssh_remote_cmd,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,argv[<span class="Constant">0</span>])) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[set_pen] failed to resolve ben path&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Parse command tail for remote command </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((*argc) &gt; <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)strlcat(ssh_remote_cmd,<span class="Constant">&quot; &quot;</span>,SSIZE);

          <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;(*argc); ++i)
          {

             <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Get name of remote host </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-on&quot;</span>) == <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)strlcpy(ssh_remote_host,argv[i+<span class="Constant">1</span>],SSIZE);
                ++i;
             }


             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Get the username on remote host </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-user&quot;</span>) == <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)snprintf(ssh_remote_user,SSIZE,<span class="Constant">&quot;-l </span><span class="Special">%s</span><span class="Constant">&quot;</span>,argv[i+<span class="Constant">1</span>]);
                ++i;
             }


             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Get the port number to connect to on remote host </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-ssh_port&quot;</span>) == <span class="Constant">0</span>)
             {  (<span class="Type">void</span>)snprintf(ssh_remote_port,SSIZE,<span class="Constant">&quot;-p </span><span class="Special">%s</span><span class="Constant">&quot;</span>,argv[i+<span class="Constant">1</span>]);

                (<span class="Type">void</span>)strlcat(ssh_remote_cmd,argv[i],SSIZE);
                <span class="Statement">if</span>(i &lt; (*argc) - <span class="Constant">1</span>)
                   (<span class="Type">void</span>)strlcat(ssh_remote_cmd,<span class="Constant">&quot; &quot;</span>,SSIZE);
                ++i;

                <span class="Statement">if</span>(i == (*argc))
                   pups_error(<span class="Constant">&quot;expecting remote port specification&quot;</span>);

                (<span class="Type">void</span>)strlcat(ssh_remote_cmd,argv[i],SSIZE);
                <span class="Statement">if</span>(i &lt; (*argc) - <span class="Constant">1</span>)
                   (<span class="Type">void</span>)strlcat(ssh_remote_cmd,<span class="Constant">&quot; &quot;</span>,SSIZE);

<span class="PreProc">                #ifdef UTILIB_DEBUG</span>
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB COPYTAIL SSH_PORT: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ssh_remote_cmd);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

             }


             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> are we going to compress data in the ssh tunnel? </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-ssh_compress&quot;</span>) == <span class="Constant">0</span>)
             {  ssh_compression = TRUE;

                (<span class="Type">void</span>)strlcat(ssh_remote_cmd,argv[i],SSIZE);
                <span class="Statement">if</span>(i &lt; (*argc) -<span class="Constant">1</span>)
                   (<span class="Type">void</span>)strlcat(ssh_remote_cmd,<span class="Constant">&quot; &quot;</span>,SSIZE);

<span class="PreProc">                #ifdef UTILIB_DEBUG</span>
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB COPYTAIL SSH_COMPRESS: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,ssh_remote_cmd);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">                #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>
             }


             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Are we detaching remote command? </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-bg&quot;</span>) == <span class="Constant">0</span>)
                   do_bg = TRUE;
             <span class="Statement">else</span>
             {

                <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Next component of argument vector globbed </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(strin(argv[i],<span class="Constant">&quot; &quot;</span>) == TRUE)
                {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                   (<span class="Type">void</span>)snprintf(tmpstr,SSIZE,<span class="Constant">&quot;</span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,argv[i]);
                   (<span class="Type">void</span>)strlcat(ssh_remote_cmd,  tmpstr,SSIZE);
                }


                <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Next component of argment vector not globbed </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">else</span>
                   (<span class="Type">void</span>)strlcat(ssh_remote_cmd,argv[i],SSIZE);

                <span class="Statement">if</span>(i &lt; (*argc) -<span class="Constant">1</span>)
                   (<span class="Type">void</span>)strlcat(ssh_remote_cmd,<span class="Constant">&quot; &quot;</span>,SSIZE);
             }
          }
       }


       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> is this command running in background? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(do_bg == TRUE)
          (<span class="Type">void</span>)strlcat(ssh_remote_cmd,<span class="Constant">&quot;&gt;&amp; /dev/null &amp;&quot;</span>,SSIZE);


<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB UTILS REMOTE CMD [</span><span class="Special">%d</span><span class="Constant">]: ssh </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,ssh_remote_port,ssh_remote_user,ssh_remote_host,ssh_remote_cmd);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Build argument vector for remote command </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

       args[<span class="Constant">0</span>] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
       (<span class="Type">void</span>)strlcpy(args[cnt],<span class="Constant">&quot;ssh&quot;</span>,SSIZE);
       ++cnt;

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Preseve terminal connection if we have one </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(do_bg == FALSE &amp;&amp; isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
       {   args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
           (<span class="Type">void</span>)strlcpy(args[cnt],<span class="Constant">&quot;-t&quot;</span>,SSIZE);
           ++cnt;
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Compress ssh data if required </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ssh_compression == TRUE)
       {   args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
           (<span class="Type">void</span>)strlcpy(args[cnt],<span class="Constant">&quot;-C&quot;</span>,SSIZE);
           ++cnt;
       }


       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remote port number if specified </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(ssh_remote_port,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
       {   args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
           (<span class="Type">void</span>)strlcpy(args[cnt],ssh_remote_port,SSIZE);
           ++cnt;
       }


       <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remote user </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(ssh_remote_user,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
       {   args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
           (<span class="Type">void</span>)strlcpy(args[cnt],ssh_remote_user,SSIZE);
           ++cnt;
       }


       <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remote host </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

       args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
       (<span class="Type">void</span>)strlcpy(args[cnt],ssh_remote_host,SSIZE);
       ++cnt;


       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remote command </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

       args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>*<span class="Statement">sizeof</span>(_BYTE));
       (<span class="Type">void</span>)strlcpy(args[cnt],ssh_remote_cmd,SSIZE);


<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;cnt; ++i)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB ARG[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,args[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Launch remote command </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_fork(FALSE,FALSE) != <span class="Constant">0</span>)
          (<span class="Type">void</span>)execvp(<span class="Constant">&quot;ssh&quot;</span>,args);
       <span class="Statement">else</span>
          pups_exit(<span class="Constant">0</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is this process going to run under an assumed name - if it is the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> secondary argument vector must include its assumed name           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;(*argc); ++i)
    {  <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-pen&quot;</span>) == <span class="Constant">0</span>)
       {  start = <span class="Constant">0</span>;
          <span class="Statement">break</span>;
       }
    }

    <span class="Statement">for</span>(i=start; i&lt;(*argc); ++i)
    {  args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>);
       <span class="Statement">if</span>(strcmp(argv[i],<span class="Constant">&quot;-pen&quot;</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)strlcpy(args[<span class="Constant">0</span>],  argv[i+<span class="Constant">1</span>],SSIZE);
          appl_have_pen = TRUE;


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Tell the child process it is a pen rather than a ben </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(args[cnt],<span class="Constant">&quot;-bin&quot;</span>,SSIZE);
          argd[cnt] = FALSE;
          ++cnt;

          args[cnt] = (<span class="Type">char</span> *)pups_malloc(<span class="Constant">255</span>);
          (<span class="Type">void</span>)strlcpy(args[cnt],argv[<span class="Constant">0</span>],SSIZE);
          argd[cnt] = FALSE;
          ++cnt;

          ++i;
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)strlcpy(args[cnt],argv[i],SSIZE);
          argd[cnt] = FALSE;
          ++cnt;
       }
    }

    <span class="Statement">if</span>(appl_have_pen == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remove the pen flag and pen name from command tail </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       pups_set_pen(args,argv[<span class="Constant">0</span>],args[<span class="Constant">0</span>]);
    }

    appl_t_args = cnt;
    t_args      = (*argc) - <span class="Constant">1</span>;
}



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to search for standard arguments in the command tail ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                                  <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
_PUBLIC <span class="Type">void</span> pups_std_init(_BOOLEAN open_source,  <span class="Comment">/*</span><span class="Comment"> TRUE if GPL copyrighted open source  </span><span class="Comment">*/</span>
                           <span class="Type">int</span>            *argc,  <span class="Comment">/*</span><span class="Comment"> Argument count                       </span><span class="Comment">*/</span>
                           <span class="Type">char</span>         *v_name,  <span class="Comment">/*</span><span class="Comment"> Version of filter                    </span><span class="Comment">*/</span>
                           <span class="Type">char</span>        *au_name,  <span class="Comment">/*</span><span class="Comment"> Author name                          </span><span class="Comment">*/</span>
                           <span class="Type">char</span>       *app_name,  <span class="Comment">/*</span><span class="Comment"> Application name                     </span><span class="Comment">*/</span>
                           <span class="Type">char</span>         *d_made,  <span class="Comment">/*</span><span class="Comment"> Revision date                        </span><span class="Comment">*/</span>
                           <span class="Type">char</span>         *argv[])  <span class="Comment">/*</span><span class="Comment"> Secondary argument vector            </span><span class="Comment">*/</span>
                                                  <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">int</span>  i;

    sigset_t blocked_set;


                                  <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    _BOOLEAN stdin_bg    = FALSE, <span class="Comment">/*</span><span class="Comment"> TRUE if stdin backgrounded  </span><span class="Comment">*/</span>
             stdout_bg   = FALSE, <span class="Comment">/*</span><span class="Comment"> TRUE if stdout backgrounded </span><span class="Comment">*/</span>
             stderr_bg   = FALSE; <span class="Comment">/*</span><span class="Comment"> TRUE if stderr bacgrounded  </span><span class="Comment">*/</span>
                                  <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Type">struct</span> stat   buf;                             <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;  <span class="Comment">/*</span><span class="Comment"> Passwd entry of owner </span><span class="Comment">*/</span>
                                                   <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>



    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_std_init] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(argc     == (<span class="Type">int</span> *)  <span class="Constant">NULL</span>  ||
       v_name   == (<span class="Type">char</span> *) <span class="Constant">NULL</span>  ||
       au_name  == (<span class="Type">char</span> *) <span class="Constant">NULL</span>  ||
       app_name == (<span class="Type">char</span> *) <span class="Constant">NULL</span>  ||
       d_made   == (<span class="Type">char</span> *) <span class="Constant">NULL</span>  ||
       argv     == (<span class="Type">char</span> **)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Mark application as PSRP enabled but ignoring PSRP protocol signals. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    appl_psrp = TRUE;
    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;-MAX_SIGS; ++i)
       pupsighold_cnt[i] = <span class="Constant">0</span>;
    (<span class="Type">void</span>)pupshold(PSRP_SIGS);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are accessing files via an MFS partition appl_home </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> will be none-NULL                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    appl_home = pups_malloc(SSIZE);
    <span class="Statement">if</span>(getenv(<span class="Constant">&quot;HOME&quot;</span>) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(appl_home,<span class="Constant">&quot;homeless&quot;</span>,SSIZE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(appl_home,getenv(<span class="Constant">&quot;HOME&quot;</span>),SSIZE);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise signal status. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    initsigstatus();


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Delete shadow files if we have a segmentation, bus or floating point </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> error.                                                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGSEGV</span>,<span class="Constant">&quot;segbusfpe_handler&quot;</span>,(<span class="Type">void</span> *)&amp;segbusfpe_handler,(sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(SIGBUS ,<span class="Constant">&quot;segbusfpe_handler&quot;</span>,(<span class="Type">void</span> *)&amp;segbusfpe_handler,(sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGFPE</span> ,<span class="Constant">&quot;segbusfpe_handler&quot;</span>,(<span class="Type">void</span> *)&amp;segbusfpe_handler,(sigset_t *)<span class="Constant">NULL</span>);

    vitimer_quantum = VITIMER_QUANTUM;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we a foreground process - if not arrange for all TERMINAL O/P to be  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> sent to the data sink (/dev/null) ...                                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTTIN</span>,<span class="Constant">&quot;fgio_handler&quot;</span>,(<span class="Type">void</span> *)&amp;fgio_handler,(sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTTOU</span>,<span class="Constant">&quot;fgio_handler&quot;</span>,(<span class="Type">void</span> *)&amp;fgio_handler,(sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get name of controlling tty for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    appl_ttyname = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_tty = open(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">2</span>);

    <span class="Statement">if</span>(appl_tty != (-<span class="Constant">1</span>))
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Try to get precise name of controlling tty </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
          (<span class="Type">void</span>)strlcpy(appl_ttyname,ttyname(<span class="Constant">0</span>),SSIZE);
       <span class="Statement">else</span> <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
          (<span class="Type">void</span>)strlcpy(appl_ttyname,ttyname(<span class="Constant">1</span>),SSIZE);
       <span class="Statement">else</span> <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
          (<span class="Type">void</span>)strlcpy(appl_ttyname,ttyname(<span class="Constant">2</span>),SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(appl_ttyname,<span class="Constant">&quot;/dev/tty&quot;</span>,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Are we a foreground process ? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(tcgetpgrp(appl_tty) == getpgrp())
          appl_fgnd = TRUE;
       <span class="Statement">else</span>
          appl_fgnd = FALSE;
    }
    <span class="Statement">else</span>
       appl_fgnd = FALSE;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get owner of this application (and its parent). </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    appl_uid      = getuid();
    appl_gid      = getgid();
    appl_ppid     = getppid();


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get unique i.d. for host machine running owner application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(<span class="Constant">&quot;/etc/machine-id&quot;</span>,F_OK | R_OK) == (-<span class="Constant">1</span>))
       error(<span class="Constant">&quot;[pups_std_init] cannot get (unique) machine i.d.&quot;</span>);
    <span class="Statement">else</span>
    {  <span class="Type">int</span> fdes = (-<span class="Constant">1</span>);

       fdes = open(<span class="Constant">&quot;/etc/machine-id&quot;</span>,O_RDONLY);
       (<span class="Type">void</span>)read(fdes,appl_machid,<span class="Constant">32</span>);
       (<span class="Type">void</span>)close(fdes);
    }

<span class="PreProc">    #ifdef _OPENMP</span>
    appl_omp_threads = omp_get_max_threads();
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> _OPENMP </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    appl_root_thread = pthread_self();
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pwent         = getpwuid(appl_uid);
    appl_owner    = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(pwent != (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(appl_owner,pwent-&gt;pw_name,SSIZE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(appl_owner,SSIZE,<span class="Constant">&quot;uid</span><span class="Special">%d</span><span class="Constant">&quot;</span>,appl_uid);

    appl_password = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    (<span class="Type">void</span>)strlcpy(appl_password,<span class="Constant">&quot;notset&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get PID and process group. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    appl_pid       = getpid();
    appl_sid       = getpgrp();

    appl_state     = pups_malloc(SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Standard error stream is stderr. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    err_stream = <span class="Constant">stderr</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get the name of the host running this application. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    appl_host = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    (<span class="Type">void</span>)gethostname(appl_host,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get user shell from environment. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    shell = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>(strccpy(shell,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;EXEC_SHELL&quot;</span>)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(shell,<span class="Constant">&quot;/bin/sh&quot;</span>,SSIZE);

    appl_fifo_dir = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(strccpy(appl_fifo_dir,(<span class="Type">char</span> *)getenv(<span class="Constant">&quot;FIFO_PATCHBOARD&quot;</span>)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Type">char</span> tmp_fifos[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a /fifos directory for this host use it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(tmp_fifos,SSIZE,<span class="Constant">&quot;/fifos.</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_host);
       <span class="Statement">if</span>(access(tmp_fifos,F_OK | R_OK | W_OK | X_OK) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)strlcpy(appl_fifo_dir,<span class="Constant">&quot;/fifos&quot;</span>,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(appl_fifo_dir,SSIZE,<span class="Constant">&quot;/tmp&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Iniitialise the slot manager and register all active slots. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    slot_manager_init();


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create storage for global data. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    version         = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    author          = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_name       = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_bin_name   = (<span class="Type">char</span> *)pups_malloc(SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make a copy of the command tail. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    pups_copytail(argc,args,argv);


    appl_err        = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    revdate         = (<span class="Type">char</span> *)pups_malloc(SSIZE);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy application data to global variables. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(version,v_name,SSIZE);
    (<span class="Type">void</span>)strlcpy(author,au_name,SSIZE);

    <span class="Statement">if</span>(strrextr(argv[<span class="Constant">0</span>],appl_name,<span class="Constant">'/'</span>) == FALSE)
    {  (<span class="Type">void</span>)strlcpy(appl_name,    argv[<span class="Constant">0</span>],SSIZE);
       (<span class="Type">void</span>)strlcpy(appl_bin_name,argv[<span class="Constant">0</span>],SSIZE);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(appl_bin_name,appl_name,SSIZE);

    (<span class="Type">void</span>)strlcpy(revdate,d_made,SSIZE);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise heap object tracking. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    tinit();


<span class="PreProc">    #ifdef SECURE</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check license. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_securicor((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SECURE </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read in command line tail if requested. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;argf&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       pups_argfile(ptr,argc,args,argd);
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Read default argfile (if it exists) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

       default_argfile = TRUE;
       pups_argfile((*argc),argc,args,argd);
    }


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Resident process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_enable_resident == TRUE &amp;&amp; (ptr = pups_locate(&amp;init,<span class="Constant">&quot;resident&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>(strccpy(appl_argfifo,pups_str_dec(&amp;ptr,&amp;argc,args)) == (<span class="Type">char</span> *)INVALID_ARG)
          pups_error(<span class="Constant">&quot;[resident process] expecting name of command parameter FIFO&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Create command parameter FIFO </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(mkfifo(appl_argfifo,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
          pups_error(<span class="Constant">&quot;[resident process] cannot create FIFO&quot;</span>);

       appl_resident = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process is memory resident (argument FIFO </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                            date,appl_name,appl_pid,appl_host,appl_owner,appl_argfifo);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If verbose switch is set, log status information to stderr </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;verbose&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_verbose = TRUE;
      (<span class="Type">void</span>)pups_get_fd_lock(<span class="Constant">2</span>,GETLOCK);


      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> If test mode is set provide additional status information to stderr </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;test&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
         test_mode = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't seed random number generator </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;noseed&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    { <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): not seeding random number generator</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Seed random number generator </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)srand48((<span class="Type">long</span> <span class="Type">int</span>)appl_pid);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): seeding random number generator with pid [</span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                             date,appl_name,appl_pid,appl_host,appl_owner,appl_pid);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get (minimal) resource allocation to run application. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;mra&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  FTYPE mincpu;

       <span class="Type">int</span>    ret,
              minmem;

       <span class="Type">time_t</span> tdum,
              timeout,
              start_time;

       <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;cpu&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       {  <span class="Statement">if</span>((mincpu = pups_fp_dec(&amp;ptr,argc,args)) == (FTYPE)INVALID_ARG)
              mincpu = PUPS_DEFAULT_MIN_CPU;
       }
       <span class="Statement">else</span>
          mincpu = PUPS_DEFAULT_MIN_CPU;

       <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;mem&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       {  <span class="Statement">if</span>((minmem = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
             minmem = PUPS_DEFAULT_MIN_MEM;
       }
       <span class="Statement">else</span>
           minmem = PUPS_IGNORE_MIN_MEM;

       <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;timeout&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       {  <span class="Statement">if</span>((timeout = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
             timeout = PUPS_DEFAULT_RESOURCE_WAIT;
       }
       <span class="Statement">else</span>
          timeout = PUPS_DEFAULT_RESOURCE_WAIT;


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Do we have resources to run application - if not hibernate until we do </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((ret = pups_have_resources((FTYPE)mincpu,minmem)) == FALSE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): waiting for minimum resources to run [CPU usage &lt; </span><span class="Special">%f</span><span class="Constant">, at least </span><span class="Special">%d</span><span class="Constant"> KB memory]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                         date,appl_name,appl_pid,appl_host,appl_owner,mincpu,minmem);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          start_time = time(&amp;tdum);
          <span class="Statement">while</span>(pups_have_resources((FTYPE)mincpu,minmem) == FALSE)
          {    <span class="Statement">if</span>(time(&amp;tdum) - start_time &gt; timeout*<span class="Constant">3600</span>)
               {  <span class="Statement">if</span>(appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)strdate(date);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to get minimum resources to run (after </span><span class="Special">%f</span><span class="Constant"> hours) -- aborting</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                        date,appl_name,appl_pid,appl_host,appl_owner,mincpu,minmem);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                  }

                  pups_exit(<span class="Constant">255</span>);
               }
               (<span class="Type">void</span>)pups_usleep(<span class="Constant">10000</span>);
          }

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): resources to run now available [CPU usage &lt; </span><span class="Special">%f</span><span class="Constant">, at least </span><span class="Special">%d</span><span class="Constant"> KB memory]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                   date,appl_name,appl_pid,appl_host,appl_owner,mincpu,minmem);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
       <span class="Statement">else</span>
          pups_error(<span class="Constant">&quot;[pups_std_init] flag </span><span class="Special">\&quot;</span><span class="Constant">-mra</span><span class="Special">\&quot;</span><span class="Constant"> is not supported&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Don't detach stdio when in background. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;nodetach&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
        appl_nodetach = TRUE;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display name and mode of controlling tty (if in appl_verbose mode) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(appl_ttyname == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): application has no controlling tty</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_owner,appl_host);
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(appl_fgnd == TRUE)
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): application controlling tty is </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                date,appl_name,appl_pid,appl_host,appl_owner,appl_ttyname);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): application controlling tty is </span><span class="Special">%s</span><span class="Constant"> [detached]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_host,appl_owner,appl_ttyname);
       }

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Terminal streams associated with a background process     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> are redirected to the datasink to avoid raising SIGTTIN   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and SIGTTOU                                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Note that we need to have the PUPS file table initialised </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> which is why we do the background redirection here        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_fgnd == FALSE &amp;&amp; appl_nodetach == FALSE)
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We need to keep stdin oen here otherwise /dev/tty    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> will go away (and we won't be able to reattach stdio </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> if this process is brought into the foreground       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
       {  stdin_bg = TRUE;
          (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
          <span class="Constant">stdin</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
       }

       <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
       {  stdout_bg = TRUE;
          (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
          <span class="Constant">stdout</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
       }

       <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
       {  stderr_bg = TRUE;
          (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
          <span class="Constant">stderr</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
       }

       started_detached = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we a secure application? If so get authentication token (from stdin). </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;secure&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_secure = TRUE;


       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Get password from standard input </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)fgets(appl_password,SSIZE,<span class="Constant">stdin</span>);
          appl_secure = TRUE;

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): secure application mode </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner,appl_password);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Prompt for password </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

          <span class="Type">int</span>  cnt                  = <span class="Constant">0</span>,
               max_trys             = <span class="Constant">3</span>;

          <span class="Type">char</span> password_banner[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">do</span> {    <span class="Type">int</span> verify_cnt = <span class="Constant">0</span>;

                  <span class="Type">char</span> tmp_pw_1[SSIZE] = <span class="Constant">&quot;&quot;</span>,
                       tmp_pw_2[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                  <span class="Statement">do</span> {   <span class="Statement">if</span>(verify_cnt &gt; <span class="Constant">0</span>)
                         {  (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">not confirmed -- try again</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
                            (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                         }

                         (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) password: &quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                         (<span class="Type">void</span>)strlcpy(tmp_pw_1,getpass(password_banner),SSIZE);
                         (<span class="Type">void</span>)snprintf(password_banner,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> PSRP (protocol </span><span class="Special">%5.2F</span><span class="Constant">) verify password:&quot;</span>,appl_host,PSRP_PROTOCOL_VERSION);
                         (<span class="Type">void</span>)strlcpy(tmp_pw_2,getpass(password_banner),SSIZE);

                         ++verify_cnt;
                      } <span class="Statement">while</span>(strcmp(tmp_pw_1,tmp_pw_2) != <span class="Constant">0</span>);

                  (<span class="Type">void</span>)strlcpy(appl_password,tmp_pw_1,SSIZE);
                  ++cnt;

                  <span class="Statement">if</span>(cnt &gt;= max_trys)
                  {  <span class="Statement">if</span>(appl_verbose == TRUE)
                     {  (<span class="Type">void</span>)strdate(date);
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): too many attempts to set password</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                       date,appl_name,appl_pid,appl_owner,appl_host);
                        (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
                     }

                     pups_exit(<span class="Constant">255</span>);
                  }
               } <span class="Statement">while</span> (strlen(appl_password) == <span class="Constant">0</span>);

          appl_secure = TRUE;

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): authentication token set for secure application services</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                   date,appl_name,appl_pid,appl_owner,appl_host);
             (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
          }
       }
    }


<span class="PreProc">    #ifdef _OPENMP</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set number of OMP threads avaialble to application. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;omp_threads&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_omp_threads = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG || appl_omp_threads &lt; <span class="Constant">1</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting number of OMP threads (integer &gt;= 1)&quot;</span>);
       <span class="Statement">else</span>
       {   omp_set_num_threads(appl_omp_threads);

           <span class="Statement">if</span>(appl_verbose == TRUE)
           {  (<span class="Type">void</span>)strdate(date);
              (<span class="Type">void</span>)fprintf(<span class="Constant">stdout</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> OMP threads</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_owner,appl_host,appl_omp_threads);
              (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
           }
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> _OPENMP </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Nominate an effective parent (in the case of system() and similar command </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> processors it is not the parent which should be notified of the death of  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> a child, it is the grandparent!).                                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;parent&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">int</span>  i_tmp;
       <span class="Type">char</span> pname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       <span class="Statement">if</span>((i_tmp = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
       {  --ptr;
          <span class="Statement">if</span>(strccpy(pname,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[pups_std_init] expecting effective parent PID or process name&quot;</span>);

          <span class="Statement">if</span>((i_tmp = psrp_pname_to_pid(pname)) &lt; <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(i_tmp == PSRP_DUPLICATE_PROCESS_NAME)
                pups_error(<span class="Constant">&quot;[pups_std_init] ambiguous parent process name specified&quot;</span>);
             <span class="Statement">else</span>
                pups_error(<span class="Constant">&quot;[pups_std_init] effective parent does not exist&quot;</span>);
          }
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(psrp_pid_to_pname(i_tmp,pname) == FALSE)
             pups_error(<span class="Constant">&quot;[pups_std_init] effective parent does not exist&quot;</span>);
       }

       appl_ppid = i_tmp;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): effective parent is </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                  date,appl_name,appl_pid,appl_host,appl_owner,appl_ppid,pname,appl_host);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we to exit if our nominated parent exits? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;parent_exit&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_ppid_exit = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process will exit if effective parent terminates</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                date,appl_name,appl_pid,appl_host,appl_owner,appl_pid);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Rooted processes cannot migrate to a new host </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;rooted&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_rooted = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process is rooted (system context cannot migrate to new host)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                             date,appl_name,appl_pid,appl_host,appl_owner,appl_pid);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If process has tunneled to a new host tell its invocation on the old  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> host that tunneling has completed without errors.                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;tunnel&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We need to set path to (tunnel) binary and context </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

       appl_tunnel_path = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       <span class="Statement">if</span>(strccpy(appl_tunnel_path,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)snprintf(appl_tunnel_path,SSIZE,<span class="Constant">&quot;/tmp/tunnel.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,appl_pid);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We must make sure that binary name point to tunnel binary </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strlcpy(appl_bin_name,<span class="Constant">&quot;tunnel&quot;</span>,SSIZE);

<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(stdrr,<span class="Constant">&quot;UTILIB OK </span><span class="Special">%s</span><span class="Constant"> [</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
       (<span class="Type">void</span>)fflush(<span class="Constant">stdout</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process has tunneled to current host (tunnel path is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                    date,appl_name,appl_pid,appl_host,appl_owner,appl_tunnel_path);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we need to close (and reopen) stdio -- lets do it now. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;closestdio&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Reopen stdin, stdout or stderr if asscoiated with a FIFO </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fstat(<span class="Constant">0</span>,&amp;buf);
       <span class="Statement">if</span>(S_ISFIFO(buf.st_mode))
       {  (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
          <span class="Constant">stdin</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
       }

       (<span class="Type">void</span>)fstat(<span class="Constant">1</span>,&amp;buf);
       <span class="Statement">if</span>(S_ISFIFO(buf.st_mode))
       {  (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
          <span class="Constant">stdout</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
       }

       (<span class="Type">void</span>)fstat(<span class="Constant">2</span>,&amp;buf);
       <span class="Statement">if</span>(S_ISFIFO(buf.st_mode))
       {  (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
          <span class="Constant">stderr</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Associate stderr with (named) logfile. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;log&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  appl_logfile = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       <span class="Statement">if</span>(strccpy(appl_logfile,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting name of error/log file&quot;</span>);

       (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
       <span class="Constant">stderr</span> = fopen(appl_logfile,<span class="Constant">&quot;w&quot;</span>);
    }


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set ssh parameters (for remote connection). </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set port </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;ssh_port&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">int</span> idum;

       <span class="Statement">if</span>(strccpy(ssh_remote_port,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)INVALID_ARG)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting (remote ssh) port name&quot;</span>);

       <span class="Statement">if</span>(sscanf(ssh_remote_port,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;idum) != <span class="Constant">1</span> || idum &lt; <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting integer value (&gt;= 0)&quot;</span>);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): secure shell (ssh) remote port is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                 date,appl_name,appl_pid,appl_host,appl_owner,ssh_remote_port);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is ssh connection to be compressed? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;ssh_compress&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  ssh_compression = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): secure shell (ssh) compression enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                               date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Default (for new instance creation) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(ssh_remote_uname,appl_owner,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we going to wait for debugger attachment in the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> event of an error?                                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;etrap&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  appl_etrap = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): errors trapped (for subsequent analysis by gdb)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                        date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get memory allocation options. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;malloc_homeostatic&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_alloc_opt = MALLOC_HOMEOSTATIC;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): memory allocation homeostatic</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                      date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(getenv(<span class="Constant">&quot;MALLOC_HOMEOSTATIC&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  appl_alloc_opt = MALLOC_HOMEOSTATIC;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): memory allocation homeostatic</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                      date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
    <span class="Statement">else</span>
       appl_alloc_opt = MALLOC_DUMB;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we going to encrypt shadow files? This is done if we expect a  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> serious attempt to delete our resources is likely to be made.      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;crypt_shadows&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_snames_crypted = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): encryption for shadow files enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                            date,appl_name,appl_pid,appl_host,appl_owner);

          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set application FIFO directory to user defined directory -- this    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is done if the user wants to create a private patchboard (which may </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> or may not be local).                                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;patchboard&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>(strccpy(appl_fifo_dir,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)strlcpy(appl_fifo_dir,<span class="Constant">&quot;/tmp&quot;</span>,SSIZE);
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(access(appl_fifo_dir,F_OK | R_OK | W_OK | X_OK) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] cannot access (private) patchboard&quot;</span>);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP patchboard is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (default patchboard setting overidden)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                           date,appl_name,appl_pid,appl_host,appl_owner,appl_fifo_dir);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }

<span class="PreProc">    #ifdef MAIL_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set application MIME message storage/worspace directory. This directory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is used as workspace when reading mail messages addressed to            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> this process.                                                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

    appl_mail_handler = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    appl_mdir         = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_mh_folder    = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_mime_dir     = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_mime_type    = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    appl_replyto      = (<span class="Type">char</span> *)pups_malloc(SSIZE);


    (<span class="Type">void</span>)strlcpy(appl_mdir,     <span class="Constant">&quot;notset&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(appl_mh_folder,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(appl_mime_dir,<span class="Constant">&quot;notset&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(appl_mime_type,<span class="Constant">&quot;all&quot;</span>,SSIZE);


    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;mail_dir&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  (<span class="Type">void</span>)snprintf(appl_mdir,SSIZE,     <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/Mail/</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.pinbox&quot;</span>,appl_home,appl_name,appl_pid);
       (<span class="Type">void</span>)snprintf(appl_mh_folder,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.pinbox&quot;</span>,appl_name,appl_pid);

       <span class="Statement">if</span>(access(appl_mdir,F_OK) == (-<span class="Constant">1</span>))
       {  <span class="Statement">if</span>(mkdir(appl_mdir,<span class="PreProc">0</span><span class="Constant">700</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] cannot create mail directory&quot;</span>);
       }

       (<span class="Type">void</span>)snprintf(appl_mime_dir,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.mime&quot;</span>,appl_mdir);
       <span class="Statement">if</span>(access(appl_mime_dir,F_OK) == (-<span class="Constant">1</span>))
       {  <span class="Statement">if</span>(mkdir(appl_mime_dir,<span class="PreProc">0</span><span class="Constant">700</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] cannot create mime directory&quot;</span>);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PSRP mail directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                 appl_name,appl_pid,appl_host,appl_owner,appl_mdir);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
    <span class="Statement">else</span>
       appl_mailable = FALSE;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Authentication module for protected PSRP server operations. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;pam&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_pam_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

       <span class="Statement">if</span>(strccpy(appl_pam_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting PSRP server authentication module name&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise table of children. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;chtab&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_max_child = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): expecting number of [PUPS] child table slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                              date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          exit(<span class="Constant">255</span>);
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(getenv(<span class="Constant">&quot;PUPS_CHILDREN&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  appl_max_child = strtol(<span class="Constant">&quot;PUPS_CHILDREN&quot;</span>, (<span class="Type">char</span> **)<span class="Constant">NULL</span>, <span class="Constant">10</span>);
       <span class="Statement">if</span>(pups_get_errno() == <span class="Constant">ERANGE</span>)
          appl_max_child = MAX_CHILDREN;
    }
    <span class="Statement">else</span>
       appl_max_child = MAX_CHILDREN;

    (<span class="Type">void</span>)pups_init_child_table(appl_max_child);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> slots in PUPS child table</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                 date,appl_name,appl_pid,appl_host,appl_owner,appl_max_child);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise orifaces (to PUPS DLL's). </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef DLL_SUPPORT</span>
    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;ortab&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_max_orifices = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): expecting number of [PUPS] DLL orifice table slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          exit(<span class="Constant">255</span>);
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(getenv(<span class="Constant">&quot;PUPS_ORIFICES&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  appl_max_orifices = strtol(getenv(<span class="Constant">&quot;PUPS_ORIFICES&quot;</span>), (<span class="Type">char</span> **)<span class="Constant">NULL</span>, <span class="Constant">10</span>);
       <span class="Statement">if</span>(pups_get_errno() == <span class="Constant">ERANGE</span>)
          appl_max_orifices = MAX_ORIFICES;
    }
    <span class="Statement">else</span>
       appl_max_orifices = MAX_ORIFICES;

    ortab_init(appl_max_orifices);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> slots in PUPS DLL orifice table</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                 date,appl_name,appl_pid,appl_host,appl_owner,appl_max_orifices);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise vtimers. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;vitab&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_max_vtimers = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): expecting number of [PUPS] virtual timer table slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                             date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          exit(<span class="Constant">255</span>);
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(getenv(<span class="Constant">&quot;PUPS_VTIMERS&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  appl_max_vtimers = strtol(getenv(<span class="Constant">&quot;PUPS_VTIMERS&quot;</span>), (<span class="Type">char</span> **)<span class="Constant">NULL</span>, <span class="Constant">10</span>);
       <span class="Statement">if</span>(pups_get_errno() == <span class="Constant">ERANGE</span>)
          appl_max_vtimers = MAX_VTIMERS;
    }
    <span class="Statement">else</span>
       appl_max_vtimers = MAX_VTIMERS;

    initvitimers(appl_max_vtimers);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> slots in PUPS virtual timer table</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                         date,appl_name,appl_pid,appl_host,appl_owner,appl_max_vtimers);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


<span class="PreProc">    #ifdef CRIU_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Periodically save (process) state via Criu </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;ssave&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {

        <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Get poll time (between state saves) </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;t&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
        {  <span class="Type">int</span> itmp;


            <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Get poll time (between state saves) </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>((itmp = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
                  pups_error(<span class="Constant">&quot;[pups_std_init] expecting (ssave) poll time in seconds (integer &gt;= 0)&quot;</span>);
            <span class="Statement">else</span> <span class="Statement">if</span>(itmp &gt; <span class="Constant">0</span>)
               appl_poll_time = itmp;
            <span class="Statement">else</span>
               pups_error(<span class="Constant">&quot;[pups_std_init] expecting (ssave) poll time in seconds (integer &gt;= 0)&quot;</span>);
        }


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Get name of (Criu) directory (holds migratable files and checkpoints) </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;t&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
        {  <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

            <span class="Statement">if</span>(strccpy(tmpstr,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)INVALID_ARG)
               pups_error(<span class="Constant">&quot;[pups_std_init] expecting Criu directory name&quot;</span>);
            <span class="Statement">else</span>
               (<span class="Type">void</span>)strlcpy(appl_criu_dir,tmpstr,SSIZE);
        }

        (<span class="Type">void</span>)pups_ssave_enable();

        <span class="Statement">if</span>(appl_verbose == TRUE)
        {  (<span class="Type">void</span>)strdate(date);
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Criu state saving enabled (poll time: </span><span class="Special">%d</span><span class="Constant">, Criu directory: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                              date,appl_name,appl_pid,appl_host,appl_owner,appl_poll_time,appl_criu_dir);
           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
        }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Install handler for state saving </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sighandle(SIGCHECK,<span class="Constant">&quot;ssave_handler&quot;</span>,(<span class="Type">void</span> *)ssave_handler,(sigset_t *)<span class="Constant">NULL</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT</span>


<span class="Comment">    </span><span class="Error">/</span><span class="Comment">*------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start (effective) parent homeostat </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_ppid_exit == TRUE)
       (<span class="Type">void</span>)pups_setvitimer(<span class="Constant">&quot;default_parent_homeostat&quot;</span>,<span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">1</span>,<span class="Constant">NULL</span>,(<span class="Type">void</span> *)&amp;pups_default_parent_homeostat);


<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise persistent heaps </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;phtab&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_max_pheaps = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): expecting number of [PUPS] persistent heap table slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                               date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          exit(<span class="Constant">255</span>);
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(getenv(<span class="Constant">&quot;PUPS_PHEAPS&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  appl_max_pheaps = strtol(getenv(<span class="Constant">&quot;PUPS_PHEAPS&quot;</span>), (<span class="Type">char</span> **)<span class="Constant">NULL</span>, <span class="Constant">10</span>);
       <span class="Statement">if</span>(pups_get_errno() == <span class="Constant">ERANGE</span>)
          appl_max_pheaps = MAX_PHEAPS;
    }
    <span class="Statement">else</span>
       appl_max_pheaps = MAX_PHEAPS;

    msm_init(appl_max_pheaps);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> slots in PUPS persistent heap table</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_host,appl_owner,appl_max_pheaps);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise PUPS file table. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;ftab&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_max_files = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): expecting number of (PUPS) file table slots</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                              date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          exit(<span class="Constant">255</span>);
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(getenv(<span class="Constant">&quot;PUPS_FILES&quot;</span>) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  appl_max_files = strtol(getenv(<span class="Constant">&quot;PUPS_FILES&quot;</span>), (<span class="Type">char</span> **)<span class="Constant">NULL</span>, <span class="Constant">10</span>);
       <span class="Statement">if</span>(pups_get_errno() == <span class="Constant">ERANGE</span>)
          appl_max_files = MAX_FILES;
    }
    <span class="Statement">else</span>
       appl_max_files = MAX_FILES;


    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> slots in PUPS file table</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                 date,appl_name,appl_pid,appl_host,appl_owner,appl_max_files);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable VT services (mainly used for debugging) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;no_vt_services&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  no_vt_services = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): VT services disabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                       date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Start cron services for this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_crontab_init();


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We must ALWAYS have ftab slots for stdin, stdout and stderr </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_max_files &lt; <span class="Constant">3</span>)
       appl_max_files = <span class="Constant">3</span>;

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;stdio_dead&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
       initftab(appl_max_files,STDIO_DEAD);
    <span class="Statement">else</span>
       initftab(appl_max_files,STDIO_LIVE);


<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> (Simple) migrate (if requested). </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;on&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  _BOOLEAN do_bg       = FALSE;
        <span class="Type">char</span>    r_host[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       <span class="Statement">if</span>(strccpy(r_host,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting name of host (to migrate to)&quot;</span>);

       <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;bg&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
          do_bg = TRUE;

       <span class="Comment">//if(strcmp(appl_host,r_host) != 0)</span>
       {  <span class="Statement">if</span>(psrp_remote_start(r_host,do_bg,*argc,args) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] remote start failed&quot;</span>);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Terminal streams associated with a background process      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> are redirected to the datasink to avoid raising SIGTTIN    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and SIGTTOU                                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Amend PUPS file table to reflect that we are in background </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_fgnd == FALSE)
    {  <span class="Statement">if</span>(stdin_bg == TRUE)
       {  ftab[<span class="Constant">0</span>].named = TRUE;
          (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fname,  <span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
          (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
       }

       <span class="Statement">if</span>(stdout_bg == TRUE)
       {  ftab[<span class="Constant">1</span>].named = TRUE;
          (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fname,  <span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
          (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
       }

       <span class="Statement">if</span>(stderr_bg == TRUE)
       {  ftab[<span class="Constant">2</span>].named = TRUE;
          (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fname,  <span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
          (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If this process has been relabeled get the execution name of the binary </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> that it is running.                                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;bin&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">char</span> tmp[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       <span class="Statement">if</span>(strccpy(tmp,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting name of application binary&quot;</span>);

<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB APPL BIN NAME IN: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,tmp);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Abstract binary name from its path </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>


       <span class="Statement">if</span>(strrextr(tmp, appl_bin_name, <span class="Constant">'/'</span>) == FALSE)
          (<span class="Type">void</span>)strccpy(appl_bin_name,tmp);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): executing binary </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,appl_bin_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB APPL NAME:     </span><span class="Special">%s</span><span class="Constant">  [</span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid);
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB APPL BIN NAME: </span><span class="Special">%s</span><span class="Constant">  [</span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_bin_name,appl_pid);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If appl_verbose switch is set, report progress to stderr. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;version&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">int</span> i,
           pos;

       <span class="Type">char</span> up_appl_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       <span class="Statement">if</span>(strin(appl_bin_name,<span class="Constant">&quot;/&quot;</span>) == TRUE &amp;&amp; appl_bin_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  pos = strlen(appl_bin_name) + <span class="Constant">1</span>;
          <span class="Statement">do</span> {    --pos;
             } <span class="Statement">while</span>(appl_bin_name[pos] != <span class="Constant">'/'</span>);

          <span class="Statement">if</span>(pos &gt; <span class="Constant">0</span>)
             (<span class="Type">void</span>)strlcpy(up_appl_name,&amp;appl_bin_name[pos+<span class="Constant">1</span>],SSIZE);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(up_appl_name,appl_bin_name,SSIZE);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(up_appl_name,appl_bin_name,SSIZE);

       <span class="Statement">if</span>(appl_bin_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                  <span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> [PEN </span><span class="Special">%s</span><span class="Constant">] version </span><span class="Special">%s</span><span class="Constant"> [build </span><span class="Special">%.5d</span><span class="Constant"> (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)] (C) </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,up_appl_name,
                                                                                      appl_name,
                                                                                        version,
                                                                                      appl_vtag,
                                                                                      appl_build_time,
                                                                                      appl_build_date,
                                                                                               author);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                        <span class="Constant">&quot;    </span><span class="Special">%s</span><span class="Constant"> version </span><span class="Special">%s</span><span class="Constant"> [build </span><span class="Special">%.5d</span><span class="Constant"> (built </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">)] (C) </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,up_appl_name,
                                                                                     version,
                                                                                   appl_vtag,
                                                                                   appl_build_time,
                                                                                   appl_build_date,
                                                                                            author);

<span class="PreProc">       #ifdef SECURE</span>
<span class="PreProc">       #ifdef SINGLE_HOST_LICENSE</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    Single copy single host licence</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">       #else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    Single copy multi host licence</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SINGLE_HOST_LICENSE </span><span class="Comment">*/</span>
<span class="PreProc">       #else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    Multi copy multi host (unrestricted) licence</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> SECURE </span><span class="Comment">*/</span>

<span class="PreProc">       #ifdef FLOAT</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    Floating point representation is single precision (</span><span class="Special">%d</span><span class="Constant"> bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Statement">sizeof</span>(FTYPE));
<span class="PreProc">       #else</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    Floating point representation is double precision (</span><span class="Special">%d</span><span class="Constant"> bytes)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,<span class="Statement">sizeof</span>(FTYPE));
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> FLOAT </span><span class="Comment">*/</span>

<span class="PreProc">       #ifdef _OPENMP</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    </span><span class="Special">%d</span><span class="Constant"> parallel (OMP) threads available</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_omp_threads);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> _OPENMP </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">        #ifdef SHADOW_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with shadow support                  ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> SHADOW_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef NIS_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with NIS support                     ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> NIS_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef SSH_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with ssh support                     ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef IPV6_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with IPV6 support                    ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> IPV6_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef DLL_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with DLL support                     ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> DLL_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef PTHREAD_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with thread support                  ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef PERSISTENT_HEAP_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with persistent heap support         ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef BUBBLE_MEMORY_SUPPORT </span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with dynamic bubble memory support   ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> BUBBLE_MEMORY_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">        #ifdef CRIU_SUPPORT</span>
        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;    [with state saving support            ]</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
<span class="PreProc">        #endif</span> <span class="Comment">/*</span><span class="Comment"> CRUI_SUPPORT </span><span class="Comment">*/</span>


       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(up_appl_name) + <span class="Constant">1</span>; ++i)
           up_appl_name[i] = toupper(up_appl_name[i]);

       <span class="Statement">if</span>(appl_proprietary)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (C) Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>,up_appl_name);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;All rights reserved 2022</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> is free software, covered by the GNU General Public License, and you are</span><span class="Special">\n</span><span class="Constant">&quot;</span>,up_appl_name);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;welcome to change it and/or distribute copies of it under certain conditions.</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;See the GPL and LGPL licences at www.gnu.org for further details</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> comes with ABSOLUTELY NO WARRANTY</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,up_appl_name);
       }
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Just in case .psrprc file has set appl_verbose = TRUE </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

       appl_verbose = FALSE;
       pups_exit(<span class="Constant">255</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display usage for application. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;usage&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">int</span>  i;
       <span class="Type">char</span> up_appl_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                     <span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Special">%s</span><span class="Constant"> version </span><span class="Special">%s</span><span class="Constant"> (C) </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,
                                                        version,
                                                         author,
                                                           date);

       <span class="Statement">if</span>(open_source == TRUE)
       {  <span class="Statement">if</span>(appl_bin_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(appl_bin_name,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
          {  <span class="Type">int</span> pos;

             pos = strlen(appl_bin_name);
             <span class="Statement">do</span> {    --pos;
                } <span class="Statement">while</span>(appl_bin_name[pos] != <span class="Constant">'/'</span> &amp;&amp; pos &gt; (-<span class="Constant">1</span>));

             <span class="Statement">if</span>(pos &gt; <span class="Constant">0</span>)
                (<span class="Type">void</span>)strlcpy(up_appl_name,&amp;appl_bin_name[pos+<span class="Constant">1</span>],SSIZE);
             <span class="Statement">else</span>
                (<span class="Type">void</span>)strlcpy(up_appl_name,appl_name,SSIZE);
          }
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(up_appl_name,appl_bin_name,SSIZE);

          <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(up_appl_name); ++i)
              up_appl_name[i] = toupper(up_appl_name[i]);

          up_appl_name[strlen(appl_name)] = <span class="Special">'\0'</span>;

          <span class="Statement">if</span>(appl_proprietary == TRUE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> (C) Tumbling Dice</span><span class="Special">\n</span><span class="Constant">&quot;</span>,up_appl_name);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;All rights reserved</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> is free software, covered by the GNU General Public License, and you are</span><span class="Special">\n</span><span class="Constant">&quot;</span>,up_appl_name);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;welcome to change it and/or distribute copies of it under certain conditions.</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;See the GPL and LGPL licences at www.gnu.org for further details</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> comes with ABSOLUTELY NO WARRANTY</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,up_appl_name);
          }
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);


       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> usage() never returns </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

       usage();
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Display segments of this application. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Shortform slot information </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;slots&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
              <span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%s</span><span class="Constant"> version </span><span class="Special">%s</span><span class="Constant"> (C) </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,
                                                     version,
                                                      author,
                                                        date);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> slot_usage() never returns </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

       slot_usage(<span class="Constant">0</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Longform slot information </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;slotinfo&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%s</span><span class="Constant"> version </span><span class="Special">%s</span><span class="Constant"> (C) </span><span class="Special">%s</span><span class="Constant">, </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,
                                                                    version,
                                                                     author,
                                                                       date);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> slot_usage() never returns </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

       slot_usage(<span class="Constant">2</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get vtag - this is used by various agents which clean up stale dynamic </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> objects.                                                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;vtag&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">: vtag is </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,appl_vtag);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

       exit(<span class="Constant">0</span>);
    }

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;no_vtag&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_vtag = NO_VERSION_CONTROL;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): version control disabled (vtag: </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_host,appl_owner,appl_vtag);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable loading of default PSRP resource file. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_psrp == TRUE &amp;&amp; pups_locate(&amp;init,<span class="Constant">&quot;psrp_autoload&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_psrp_load = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): loading default PSRP resource file (~.</span><span class="Special">%s</span><span class="Constant">.psrp) enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner,appl_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Disable saving of default PSRP resource file. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_psrp == TRUE &amp;&amp; pups_locate(&amp;init,<span class="Constant">&quot;psrp_autosave&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_psrp_save = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): saving default PSRP resource file (~.</span><span class="Special">%s</span><span class="Constant">.psrp) enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                    date,appl_name,appl_pid,appl_host,appl_owner,appl_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell this process which process group it is to join. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;pgrp&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">int</span> pg_leaders_pid;

       <span class="Statement">if</span>((pg_leaders_pid = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting pid of process group leader&quot;</span>);

       <span class="Statement">if</span>(setpgid(<span class="Constant">0</span>,pg_leaders_pid) &lt; <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] could not join specified process group&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set application name -- makes sure that channel names for PSRP  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> servers remain conistent.                                       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

    appl_ch_name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    <span class="Statement">if</span>(appl_psrp == TRUE)
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;channel_name&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       {  <span class="Type">char</span> tmp_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          <span class="Statement">if</span>(strccpy(tmp_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[pups_std_init] expecting application channel name&quot;</span>);

          (<span class="Type">void</span>)snprintf(appl_ch_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">&quot;</span>,tmp_name,appl_host);
          appl_default_chname = FALSE;
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(appl_ch_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_name,appl_host);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): application channel name (PSRP) is </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                           date,appl_name,appl_pid,appl_host,appl_owner,appl_ch_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): this application is not PSRP enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Tell remote client that it can resume an interrupted PSRP transaction. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;psrp_reactivate_client&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Note we cannot take the absolute value of chlockdes beacause </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> a negative value implies we have no PSRP channel active     </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((chlockdes = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting PSRP channel lock descriptor&quot;</span>);

       psrp_reactivate_client = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Reactivating PSRP clients (segment </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                  date,appl_name,appl_pid,appl_host,appl_owner,psrp_client_pid[c_client],psrp_seg_cnt);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update server segment count </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;psrp_segment&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((psrp_seg_cnt = pups_i_dec(&amp;ptr,argc,args)) == (<span class="Type">int</span>)INVALID_ARG || psrp_seg_cnt &lt; <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting PSRP server segment number&quot;</span>);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): segment is </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,psrp_seg_cnt);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }



    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we going to be a leader of processes? If we are then set up handlers </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to control our subordinates! If we are a foreground process we can never </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> assume this exaulted position as the shell has pre-empted us!            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;blocked_set);
    (<span class="Type">void</span>)sigaddset(&amp;blocked_set,<span class="Constant">SIGTSTP</span>);
    (<span class="Type">void</span>)sigaddset(&amp;blocked_set,<span class="Constant">SIGCONT</span>);
    (<span class="Type">void</span>)sigaddset(&amp;blocked_set,<span class="Constant">SIGTERM</span>);
    (<span class="Type">void</span>)sigaddset(&amp;blocked_set,<span class="Constant">SIGQUIT</span>);
    (<span class="Type">void</span>)sigaddset(&amp;blocked_set,<span class="Constant">SIGINT</span>);

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;kill_pg&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  appl_kill_pg = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process will not terminate process group at exit</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                         date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }

    <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;pg_leader&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  <span class="Statement">if</span>(appl_fgnd == FALSE)
       {  (<span class="Type">void</span>)setsid();

          <span class="Statement">if</span>(setpgid(<span class="Constant">0</span>,getpid()) &lt; <span class="Constant">0</span>)
             pups_error(<span class="Constant">&quot;[pups_std_init] could not set process group leader&quot;</span>);

          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTERM</span>,<span class="Constant">&quot;pg_leaders_term_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_term_handler,&amp;blocked_set);
          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;pg_leaders_stop_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_stop_handler,&amp;blocked_set);
          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGCONT</span>,<span class="Constant">&quot;pg_leaders_cont_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_cont_handler,&amp;blocked_set);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process group leader</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                          date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
          pg_leader = TRUE;
       }
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(pups_locate(&amp;init,<span class="Constant">&quot;session_leader&quot;</span>,argc,args,<span class="Constant">0</span>) != NOT_FOUND)
    {  <span class="Statement">if</span>(appl_fgnd == FALSE)
       {  <span class="Statement">if</span>(setsid() &lt; <span class="Constant">0</span>)
             pups_error(<span class="Constant">&quot;[pups_std_init] could not set session leader&quot;</span>);

          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTERM</span>,<span class="Constant">&quot;pg_leaders_term_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_term_handler,&amp;blocked_set);
          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;pg_leaders_stop_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_stop_handler,&amp;blocked_set);
          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGCONT</span>,<span class="Constant">&quot;pg_leaders_cont_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_cont_handler,&amp;blocked_set);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): session (process group) leader</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                    date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
          pg_leader = TRUE;
       }
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTERM</span>,<span class="Constant">&quot;pups_exit_handler&quot;</span>,(<span class="Type">void</span> *)pups_exit_handler, (sigset_t *)&amp;blocked_set);


    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGINT</span>, <span class="Constant">&quot;pups_exit_handler&quot;</span>,(<span class="Type">void</span> *)pups_exit_handler, (sigset_t *)&amp;blocked_set);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGQUIT</span>,<span class="Constant">&quot;pups_exit_handler&quot;</span>,(<span class="Type">void</span> *)pups_exit_handler, (sigset_t *)&amp;blocked_set);
    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGPIPE</span>,<span class="Constant">&quot;default&quot;</span>,          <span class="Constant">SIG_DFL</span>,                   (sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(SIGALIVE,<span class="Constant">&quot;ignore&quot;</span>,          <span class="Constant">SIG_IGN</span>,                   (sigset_t *)<span class="Constant">NULL</span>);

<span class="PreProc">    #ifdef CRIU_SUPPORT</span>
    (<span class="Type">void</span>)pups_sighandle(SIGCHECK,  <span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_sighandle(SIGRESTART,<span class="Constant">&quot;ignore&quot;</span>,<span class="Constant">SIG_IGN</span>, (sigset_t *)<span class="Constant">NULL</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set working directory. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    appl_cwd = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;cwd&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Type">char</span> cwd[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
            cwdpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
            relpath[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       <span class="Statement">if</span>(strccpy(cwd,pups_str_dec(&amp;ptr,argc,args)) != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Check to see if path is absolute </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(cwd[<span class="Constant">0</span>] == <span class="Constant">'/'</span>)
             (<span class="Type">void</span>)strlcpy(cwdpath,cwd,SSIZE);
          <span class="Statement">else</span> <span class="Statement">if</span>(cwd[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
          {  <span class="Statement">if</span>(cwd[<span class="Constant">1</span>] == <span class="Constant">'.'</span>)
                pups_error(<span class="Constant">&quot;[pups_std_init] cannot have </span><span class="Special">\&quot;</span><span class="Constant">..</span><span class="Special">\&quot;</span><span class="Constant"> in cwd path&quot;</span>);

             (<span class="Type">void</span>)getcwd(relpath,SSIZE);
             (<span class="Type">void</span>)snprintf(cwdpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,relpath,&amp;cwd[<span class="Constant">2</span>]);
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)getcwd(relpath,SSIZE);
             (<span class="Type">void</span>)snprintf(cwdpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,relpath,cwd);
          }

          <span class="Statement">if</span>(chdir(cwdpath) != (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)strlcpy(appl_cwd,cwdpath,SSIZE);

             <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): set current working directory to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_owner,appl_host,appl_cwd);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)getcwd(appl_cwd,SSIZE);
             <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): current working directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (could not change it to </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                               date,appl_name,appl_pid,appl_owner,appl_host,appl_cwd,cwd);
                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }
       }
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)getcwd(appl_cwd,SSIZE);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): current working directory is </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (default)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                       date,appl_name,appl_pid,appl_owner,appl_host,appl_cwd);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Connect stdio to user specified files (or FIFO's). This permits PUPS    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> compliant routines to use redirected FIFO's for I/O (very useful of the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> application is an active process object, or is part of a dynamically    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> reconfigurable pipeline). Note standard UNIX shells sh,csh etc are      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> not clever enough to redirect to FIFO's or sockets.                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stdin (from file) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;in&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       in_state = DEAD;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;inalive&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
          in_state = LIVE;
    }


    <span class="Statement">if</span>(in_state == LIVE || in_state == DEAD)
    {  <span class="Type">int</span>  in_des,
            f_index;

       <span class="Type">char</span>     in_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;
       _BOOLEAN file_creator = FALSE;

       <span class="Statement">if</span>(strccpy(in_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting file name for stdin redirection&quot;</span>);

       <span class="Statement">if</span>(access(in_name,F_OK) == (-<span class="Constant">1</span>))
       {  file_creator = TRUE;
          <span class="Statement">if</span>(pups_creat(in_name,<span class="PreProc">0</span><span class="Constant">644</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] failed to creat file (for stdin redirection)&quot;</span>);
       }

       (<span class="Type">void</span>)pups_close(<span class="Constant">0</span>);
       in_des  = pups_open(in_name,<span class="Constant">2</span>,LIVE);
       f_index = pups_get_ftab_index(in_des);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ftab[f_index].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,in_name);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(file_creator == TRUE)
       {  pups_creator(in_des);

          <span class="Statement">if</span>(in_state == LIVE)
             pups_fd_alive(in_des,<span class="Constant">&quot;default_fd_homeostat: stdin&quot;</span>,&amp;pups_default_fd_homeostat);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stdin (</span><span class="Special">%d</span><span class="Constant">) redirected to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner,in_des,in_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stdin (from FIFO) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;pin&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       pin_state = DEAD;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;pinalive&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
          pin_state = LIVE;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stdin (from FIFO) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pin_state == LIVE || pin_state == DEAD)
    {  <span class="Type">int</span> in_des,
           f_index;

       <span class="Type">char</span>     in_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;
       _BOOLEAN fifo_creator   = FALSE;

       <span class="Statement">if</span>(strccpy(in_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting FIFO name for stdin redirection&quot;</span>);

       <span class="Statement">if</span>(access(in_name,F_OK) == (-<span class="Constant">1</span>))
       {  fifo_creator = TRUE;
          <span class="Statement">if</span>(mkfifo(in_name,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] failed to create FIFO (for stdin redirection)&quot;</span>);
       }

       (<span class="Type">void</span>)pups_close(<span class="Constant">0</span>);
       in_des = pups_open(in_name,<span class="Constant">2</span>,LIVE);

       f_index = pups_get_ftab_index(in_des);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ftab[f_index].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,in_name);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(fifo_creator == TRUE)
       {  pups_creator(in_des);

          <span class="Statement">if</span>(pin_state == LIVE)
             pups_fd_alive(in_des,<span class="Constant">&quot;default_fd_homeostat: stdin&quot;</span>,&amp;pups_default_fd_homeostat);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stdin (</span><span class="Special">%d</span><span class="Constant">) redirected to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner,in_des,in_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stdout (to file) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;out&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       out_state = DEAD;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;outalive&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
          out_state = LIVE;
    }

    <span class="Statement">if</span>(out_state == LIVE || out_state == DEAD)
    {  <span class="Type">int</span>  out_des,
            f_index;

       <span class="Type">char</span> out_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

       _BOOLEAN file_creator = FALSE;

       <span class="Statement">if</span>(strccpy(out_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting file name for stdout redirection&quot;</span>);

       <span class="Statement">if</span>(access(out_name,F_OK | W_OK) == (-<span class="Constant">1</span>))
       {  file_creator = TRUE;
          <span class="Statement">if</span>(pups_creat(out_name,<span class="PreProc">0</span><span class="Constant">644</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] failed to create file (for stdout redirection)&quot;</span>);
       }

       (<span class="Type">void</span>)pups_close(<span class="Constant">1</span>);
       out_des = pups_open(out_name,<span class="Constant">2</span>,LIVE);
       f_index = pups_get_ftab_index(out_des);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ftab[f_index].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,out_name);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(file_creator == TRUE)
       {  pups_creator(out_des);

          <span class="Statement">if</span>(out_state == LIVE)
             pups_fd_alive(out_des,<span class="Constant">&quot;default_fd_homeostat: stdout&quot;</span>,&amp;pups_default_fd_homeostat);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stdout (</span><span class="Special">%d</span><span class="Constant">) redirected to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,out_des,out_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stdout (to FIFO) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;pout&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       pout_state = DEAD;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;poutalive&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
          pout_state = LIVE;
    }

    <span class="Statement">if</span>(pout_state == LIVE || pout_state == DEAD)
    {  <span class="Type">int</span>  out_des,
            f_index;

       <span class="Type">char</span>     out_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;
       _BOOLEAN fifo_creator    = FALSE;

       <span class="Statement">if</span>(strccpy(out_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting FIFO name for stdout redirection&quot;</span>);

       <span class="Statement">if</span>(access(out_name,F_OK | W_OK) == (-<span class="Constant">1</span>))
       {  fifo_creator = TRUE;
          <span class="Statement">if</span>(mkfifo(out_name,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] failed to create FIFO (for stdout redirection)&quot;</span>);
       }

       (<span class="Type">void</span>)pups_close(<span class="Constant">1</span>);
       out_des = pups_open(out_name,<span class="Constant">2</span>,LIVE);

       f_index = pups_get_ftab_index(out_des);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ftab[f_index].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,out_name);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(fifo_creator == TRUE)
       {  pups_creator(out_des);

          <span class="Statement">if</span>(pout_state == LIVE)
             pups_fd_alive(out_des,<span class="Constant">&quot;default_fd_homeostat: stdout&quot;</span>,&amp;pups_default_fd_homeostat);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stdout (</span><span class="Special">%d</span><span class="Constant">) redirected to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,out_des,out_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stderr (to file) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;err&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       err_state = DEAD;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;erralive&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
          err_state = LIVE;
    }

    <span class="Statement">if</span>(err_state == LIVE || err_state == DEAD)
    {  <span class="Type">int</span>  err_des,
            f_index;

       <span class="Type">char</span> err_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

       _BOOLEAN file_creator = FALSE;

       <span class="Statement">if</span>(strccpy(err_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_std_init] expecting file name for stderr redirection&quot;</span>);

       <span class="Statement">if</span>(access(err_name,F_OK) == (-<span class="Constant">1</span>))
       {  file_creator = TRUE;
          <span class="Statement">if</span>(pups_creat(err_name,<span class="PreProc">0</span><span class="Constant">644</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] failed to create file (for stderr redirection)&quot;</span>);
       }

       (<span class="Type">void</span>)pups_close(<span class="Constant">2</span>);
       err_des = pups_open(err_name,<span class="Constant">2</span>,LIVE);
       f_index = pups_get_ftab_index(err_des);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ftab[f_index].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,err_name);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(file_creator == TRUE)
       {  pups_creator(err_des);

          <span class="Statement">if</span>(err_state == LIVE)
             pups_fd_alive(err_des,<span class="Constant">&quot;default_fd_homeostat: stderr&quot;</span>,&amp;pups_default_fd_homeostat);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stderr (</span><span class="Special">%d</span><span class="Constant">) redirected to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                    date,appl_name,appl_pid,appl_host,appl_owner,err_des,err_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Redirect stderr (to FIFO) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;perr&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
       perr_state = DEAD;
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;perralive&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
          perr_state = LIVE;

    }

    <span class="Statement">if</span>(perr_state == LIVE || perr_state == DEAD)
    {  <span class="Type">int</span>  err_des,
            f_index;

       <span class="Type">char</span>     err_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;
       _BOOLEAN fifo_creator    = FALSE;

       <span class="Statement">if</span>(strccpy(err_name,pups_str_dec(&amp;ptr,argc,args)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[std_init] expecting FIFO name for stderr redirection&quot;</span>);

       <span class="Statement">if</span>(access(err_name,F_OK) == (-<span class="Constant">1</span>))
       {  fifo_creator = TRUE;
          <span class="Statement">if</span>(mkfifo(err_name,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
             pups_error(<span class="Constant">&quot;[pups_std_init] failed to created stderr FIFO&quot;</span>);
       }

       (<span class="Type">void</span>)pups_close(<span class="Constant">2</span>);
       err_des = pups_open(err_name,<span class="Constant">2</span>,LIVE);

       f_index = pups_get_ftab_index(err_des);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ftab[f_index].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,err_name);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">if</span>(fifo_creator == TRUE)
       {  pups_creator(err_des);

          <span class="Statement">if</span>(perr_state == LIVE)
             pups_fd_alive(err_des,<span class="Constant">&quot;default_fd_homeostat: stderr&quot;</span>,&amp;pups_default_fd_homeostat);
       }

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stderr (</span><span class="Special">%d</span><span class="Constant">) redirected to </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,err_des,err_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate command string. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    appl_cmd_str = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    (<span class="Type">void</span>)strlcpy(appl_cmd_str,appl_name,SSIZE);
    (<span class="Type">void</span>)strlcat(appl_cmd_str,<span class="Constant">&quot; &quot;</span>,SSIZE);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;(*argc) - <span class="Constant">1</span>; ++i)
    {  (<span class="Type">void</span>)strlcat(appl_cmd_str,args[i],SSIZE);
       (<span class="Type">void</span>)strlcat(appl_cmd_str,<span class="Constant">&quot; &quot;</span>,SSIZE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set the niceness of this process. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((ptr = pups_locate(&amp;init,<span class="Constant">&quot;nice&quot;</span>,argc,args,<span class="Constant">0</span>)) != NOT_FOUND)
    {  <span class="Statement">if</span>((appl_nice_lvl = pups_i_dec(&amp;ptr,argc,args)) == INVALID_ARG)
          pups_error(<span class="Constant">&quot;[std_init] expecting process niceness parameter&quot;</span>);
    }

    (<span class="Type">void</span>)nice(appl_nice_lvl);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Set array allocation options ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_set_alloc_opt(<span class="Type">const</span> <span class="Type">int</span> alloc_opt)

{
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_set_alloc_opt] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);


    appl_alloc_opt = alloc_opt;
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to malloc memory checking for error. If not memory could be</span>
<span class="Comment">    allocated print error message and exit ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_malloc(<span class="Type">const</span> psize_t size)

{   <span class="Type">void</span> *ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(size == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(<span class="Constant">NULL</span>);
    }

    <span class="Statement">if</span>(appl_alloc_opt == MALLOC_HOMEOSTATIC)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Make sure memory is actually allocated </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> before returning to caller             </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">do</span> {    pupshold(ALL_PUPS_SIGS);
               ptr = (<span class="Type">void</span> *)malloc(size);
               pupsrelse(ALL_PUPS_SIGS);

               (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
          } <span class="Statement">while</span>(ptr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
    {  pupshold(ALL_PUPS_SIGS);
       ptr = (<span class="Type">void</span> *)malloc(size);
       pupsrelse(ALL_PUPS_SIGS);

       <span class="Statement">if</span>(ptr == <span class="Constant">NULL</span> &amp;&amp; size != <span class="Constant">0</span>)
          pups_error(<span class="Constant">&quot;[pups_malloc] failed to allocate core&quot;</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>((<span class="Type">void</span> *)ptr);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to realloc memory checking for error. If reallocation fails,</span>
<span class="Comment">    print error message and exit ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_realloc(<span class="Type">void</span> *ptr, <span class="Type">const</span> psize_t size)

{   pups_set_errno(OK);

    <span class="Statement">if</span>(ptr == (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; size != <span class="Constant">0</span>)
    {  ptr = (<span class="Type">void</span> *)pups_malloc((<span class="Type">unsigned</span>)size);
       <span class="Statement">return</span>(ptr);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(ptr != <span class="Constant">NULL</span> &amp;&amp; size == <span class="Constant">0</span>)
       <span class="Statement">return</span>(pups_free((<span class="Type">void</span> *)ptr));
    <span class="Statement">else</span> <span class="Statement">if</span>(ptr != <span class="Constant">NULL</span> &amp;&amp; size &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(appl_alloc_opt == MALLOC_HOMEOSTATIC)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Make sure memory is actually allocated </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> before returning to caller             </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">do</span> {    pupshold(ALL_PUPS_SIGS);
                  ptr = (<span class="Type">void</span> *)realloc(ptr,size);
                  pupsrelse(ALL_PUPS_SIGS);

                  (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
             } <span class="Statement">while</span>(ptr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>);
       }
       <span class="Statement">else</span>
       {  pupshold(ALL_PUPS_SIGS);
          ptr = (<span class="Type">void</span> *)realloc(ptr,size);
          pupsrelse(ALL_PUPS_SIGS);

          <span class="Statement">if</span>(ptr == <span class="Constant">NULL</span>)
             pups_error(<span class="Constant">&quot;[pups_realloc] failed to allocate core&quot;</span>);
       }

       <span class="Statement">return</span>((<span class="Type">void</span> *)ptr);
    }
}



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to calloc memory, checking for error. If reallocation fails,</span>
<span class="Comment">    print error message and exit ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_calloc(<span class="Type">const</span> pindex_t nel, <span class="Type">const</span> psize_t size)

{   <span class="Type">void</span> *ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(nel &lt;= <span class="Constant">0</span> || size &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>(appl_alloc_opt == MALLOC_HOMEOSTATIC)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Make sure memory is actually allocated </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> before returning to caller             </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">do</span> {    pupshold(ALL_PUPS_SIGS);
               ptr = (<span class="Type">void</span> *)calloc(nel,size);
               pupsrelse(ALL_PUPS_SIGS);

               (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
          } <span class="Statement">while</span>(ptr == (<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span>
    {  pupshold(ALL_PUPS_SIGS);
       ptr = (<span class="Type">void</span> *)calloc(nel,size);
       pupsrelse(ALL_PUPS_SIGS);

       <span class="Statement">if</span>(ptr == <span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[pups_calloc] failed to allocate core&quot;</span>);
    }

    <span class="Statement">return</span>((<span class="Type">void</span> *)ptr);
}



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to free a pointer, first checking if it is already free ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_free(<span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Statement">if</span>(ptr != (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pupshold(ALL_PUPS_SIGS);
       (<span class="Type">void</span>)free((<span class="Type">void</span> *)ptr);
       pupsrelse(ALL_PUPS_SIGS);

       ptr = <span class="Constant">NULL</span>;
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>((<span class="Type">void</span> *)ptr);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">   Routine to read n bytes from stream, checking that N bytes are in</span>
<span class="Comment">   fact actually read ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_read(<span class="Type">const</span> des_t f_id, _BYTE *buf, <span class="Type">const</span> psize_t n_bytes)

{
    <span class="Statement">if</span>(buf == (<span class="Type">const</span> _BYTE *)<span class="Constant">NULL</span> || n_bytes &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">if</span>((read(f_id,buf,n_bytes)) != n_bytes)
       pups_error(<span class="Constant">&quot;[xread] failed to read all of data from stream&quot;</span>);

    <span class="Statement">return</span>(n_bytes);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">   Routine to write n bytes to a stream, checking that N bytes are in</span>
<span class="Comment">   fact actually written ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_write(<span class="Type">const</span> des_t fd, <span class="Type">const</span> _BYTE *buf, <span class="Type">const</span> psize_t n_bytes)

{   psize_t written       = <span class="Constant">0L</span>,
            total_written = <span class="Constant">0L</span>;

    _BYTE *bbuf = (_BYTE *)buf;

    <span class="Statement">if</span>(buf == (<span class="Type">const</span> _BYTE *)<span class="Constant">NULL</span> || n_bytes &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Write chunks of data </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>(total_written &lt; n_bytes)
    {    written = write(fd,&amp;bbuf[total_written],(n_bytes - total_written));

         <span class="Statement">if</span>(written == (-<span class="Constant">1</span>) &amp;&amp; pups_get_errno() != <span class="Constant">EINTR</span>)
            <span class="Statement">return</span>(-<span class="Constant">1</span>);
         <span class="Statement">else</span>
            total_written += written;
    }

    <span class="Statement">return</span>(total_written);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Execls - routine to overlay and execute a command string ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_execls(<span class="Type">const</span> <span class="Type">char</span> *command)

{   <span class="Type">int</span> ret,
          j,
          i = <span class="Constant">0</span>;

    <span class="Type">char</span>     *cmd_list[<span class="Constant">256</span>] = { [<span class="Constant">0</span> ... <span class="Constant">255</span>] = (<span class="Type">char</span> *)<span class="Constant">NULL</span> };  <span class="Comment">// List of command arguments </span>
    _BOOLEAN looper;

    <span class="Statement">if</span>(command == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Could expand ^ into xrsh </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(command == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || strin(command,<span class="Constant">&quot;^&quot;</span>) == TRUE)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are part of a command pipeline start a shell to run the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> pipeline.                                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strin(command,<span class="Constant">&quot;|&quot;</span>) == TRUE)
    {  execlp(shell,shell,<span class="Constant">&quot;-c&quot;</span>,command,(<span class="Type">char</span> *)<span class="Constant">0</span>);

       pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Build command vector. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strext(<span class="Constant">' '</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    <span class="Statement">do</span> {   cmd_list[i] = pups_malloc(SSIZE);
           looper = strext(<span class="Constant">' '</span>,cmd_list[i],command);

           <span class="Statement">if</span>(looper != FALSE)
           {

<span class="PreProc">              #ifdef UTILIB_DEBUG</span>
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB EXECA[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">&quot;</span>,i,cmd_list[i]);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

              ++i;
           }
           <span class="Statement">else</span>
              (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)cmd_list[i]);

       } <span class="Statement">while</span>(looper == TRUE);
       cmd_list[i] = (<span class="Type">char</span> *)<span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Execute command: if execv is successful this won't return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    ret = execvp(cmd_list[<span class="Constant">0</span>],cmd_list);

    <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;i; ++j)
        (<span class="Type">void</span>)pups_free(cmd_list[j]);

    pups_set_errno(<span class="Constant">ENOEXEC</span>);;
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span>
<span class="Comment">    Routine to set a discretionary lock. This routine assumes that</span>
<span class="Comment">    the process of making a link to a file is atomic. This means</span>
<span class="Comment">    that only one process can make a link to a file at any</span>
<span class="Comment">    time ...</span>

<span class="Comment">    This routine blocks the caller until lock is acquired. If the</span>
<span class="Comment">    lock cannot be acquired after a reasonable number of attempts</span>
<span class="Comment">    the calling process is exited ...</span>
<span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Lock names,types` and counts </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span>             lock_cnt      [PUPS_MAX_LOCKS]        = { [<span class="Constant">0</span> ... PUPS_MAX_LOCKS-<span class="Constant">1</span>] = <span class="Constant">0</span> };
_PRIVATE <span class="Type">char</span>            lock_name_list[PUPS_MAX_LOCKS][SSIZE] = { [<span class="Constant">0</span> ... PUPS_MAX_LOCKS-<span class="Constant">1</span>] = { <span class="Constant">&quot;notset&quot;</span>}};
_PRIVATE <span class="Type">char</span>            lock_type_list[PUPS_MAX_LOCKS][SSIZE] = { [<span class="Constant">0</span> ... PUPS_MAX_LOCKS-<span class="Constant">1</span>] = { <span class="Constant">&quot;notset&quot;</span>}};
_PRIVATE _BOOLEAN        locks_active                          = FALSE;



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Get next free (link) lock index ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> get_lock_index(<span class="Type">char</span> *name)

{   <span class="Type">int</span> i,
        free_index = <span class="Constant">0</span>;

    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise lock list if this is first </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> call to function                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(locks_active == FALSE)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_LOCKS; ++i)
          (<span class="Type">void</span>)strlcpy(lock_name_list[i],<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       locks_active = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> search for object (to see if it is locked) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_LOCKS; ++i)
    {  <span class="Statement">if</span>(strcmp(lock_name_list[i],name) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(i);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(lock_name_list[i],<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
          ++free_index;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(free_index);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Show (link) locks which are currently in use ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_show_link_file_locks(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        locks = <span class="Constant">0</span>;

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_link_file_locks] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">Link lock table</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;===============</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(locks_active == TRUE)
    {  <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_LOCKS; ++i)
       {  <span class="Statement">if</span>(strcmp(lock_name_list[i],<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
          {

             <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Read lock held </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(strcmp(lock_type_list[i],<span class="Constant">&quot;write&quot;</span>) == <span class="Constant">0</span>)
                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant"> [slot </span><span class="Special">%04d</span><span class="Constant">] read lock held on file </span><span class="Special">\&quot;</span><span class="Special">%-48s</span><span class="Special">\&quot;</span><span class="Constant"> (count is </span><span class="Special">%04d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                         locks,i,lock_name_list[i],lock_cnt[i]);


             <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Write lock held </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

             <span class="Statement">else</span>
                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant"> [slot </span><span class="Special">%04d</span><span class="Constant">] write lock held on file </span><span class="Special">\&quot;</span><span class="Special">%-48s</span><span class="Special">\&quot;</span><span class="Constant"> (count is </span><span class="Special">%04d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                          locks,i,lock_name_list[i],lock_cnt[i]);

             (<span class="Type">void</span>)fflush(stream);

             ++locks;
          }
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(locks == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    No locks held (</span><span class="Special">%04d</span><span class="Constant"> concurrent locks available)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,PUPS_MAX_LOCKS);
    <span class="Statement">else</span> <span class="Statement">if</span>(locks == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> lock held (</span><span class="Special">%04d</span><span class="Constant"> concurrent locks available)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>, locks,PUPS_MAX_LOCKS - <span class="Constant">1</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant"> locks held (</span><span class="Special">%04d</span><span class="Constant"> concurrent locks available)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,locks,PUPS_MAX_LOCKS - locks);


    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Set a read or write link file lock ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_rdwr_link_file_lock(<span class="Type">const</span> <span class="Type">int</span> lock_type, <span class="Type">const</span> <span class="Type">int</span> max_trys, <span class="Type">const</span> <span class="Type">char</span> *file_name)

{   <span class="Type">int</span>  ret,
         owner_pid,
         lock_index,
         trys = <span class="Constant">0</span>;

    <span class="Type">char</span> lock_name[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         rd_lock_name[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         lock_id[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         strdum[SSIZE]         = <span class="Constant">&quot;&quot;</span>,

<span class="PreProc">         #ifdef SSH_SUPPORT</span>
         owner_host[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         owner_ssh_port[SSIZE] = <span class="Constant">&quot;&quot;</span>,
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

         lock_owner[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         lid_name[SSIZE]       = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">struct</span> stat buf;

    <span class="Type">DIR</span>           *dirp      = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(max_trys   == <span class="Constant">0</span>                                                      ||
       (lock_type != EXLOCK &amp;&amp; lock_type != RDLOCK &amp;&amp; lock_type != WRLOCK)  ||
       file_name  == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>                                      )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are on a read only filesystem then we don't need to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> lock files but tell caller that it has attempted to set a </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> write lock on a read only file system via global errno    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_is_on_isofs(file_name) == TRUE)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EROFS</span>);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    <span class="Statement">if</span>(file_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || access(file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(access(file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>) &amp;&amp; appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> does not exist (cannot lock it!))</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                            date,appl_name,appl_pid,appl_host,appl_owner,file_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((lock_index = get_lock_index(file_name)) == (-<span class="Constant">1</span>))
       pups_error(<span class="Constant">&quot;[pups_get_rdwr_link_file_lock] too many locks&quot;</span>);

    ++lock_cnt[lock_index];

    <span class="Statement">if</span>(lock_cnt[lock_index] &gt; <span class="Constant">1</span>)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lock count incremented to </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                              date,appl_name,appl_pid,appl_host,appl_owner,file_name,lock_cnt[lock_index]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Try to acquire lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(lock_name,SSIZE,   <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lock&quot;</span>,  file_name);
    (<span class="Type">void</span>)snprintf(rd_lock_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.rdlock&quot;</span>,file_name);
    (<span class="Type">void</span>)snprintf(lid_name,SSIZE,    <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid&quot;</span>,   file_name);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if the process which owns the lock is still  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> alive and well. Note there are conditions (when owner_pid </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> has been re-used when we may get a deadlock here)         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    dirp = opendir(<span class="Constant">&quot;.&quot;</span>);
    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {

        <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Is this the lid which corresponds to our lock? </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(strncmp(next_item-&gt;d_name,lid_name,strlen(lid_name)) == <span class="Constant">0</span>)
        {

           <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Strip file i.d. information from lock i.d. </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

           <span class="Comment">// MAO (void)strccpy(lock_owner,strin2(next_item-&gt;d_name,&quot;.lid&quot;)); </span>
           (<span class="Type">void</span>)strccpy(lock_owner,next_item-&gt;d_name);
           (<span class="Type">void</span>)mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;.&quot;</span>,lock_owner);


<span class="PreProc">           #ifdef SSH_SUPPORT</span>
                                              <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
                                              <span class="Comment">/*</span><span class="Comment"> name  lid          host       ssh_port        pid </span><span class="Comment">*/</span>
                                              <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(sscanf(lock_owner,<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d</span><span class="Constant">&quot;</span>,strdum,strdum,strdum,owner_host,owner_ssh_port,&amp;owner_pid) == <span class="Constant">6</span>)
<span class="PreProc">           #else</span>
                                              <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
                                              <span class="Comment">/*</span><span class="Comment"> name  lid           pid      </span><span class="Comment">*/</span>
                                              <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">if</span>(sscanf(lock_owner,<span class="Constant">&quot;</span><span class="Special">%s%s%s%s%s%d</span><span class="Constant">&quot;</span>,strdum,strdum,strdum,&amp;owner_pid) == <span class="Constant">4</span>)
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>
           {

              <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Is this lock owned by a local process? </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(strncmp(appl_host,owner_host,strlen(owner_host)) == <span class="Constant">0</span>)
              {  <span class="Statement">if</span>(kill(owner_pid,SIGALIVE) == (-<span class="Constant">1</span>))
                 {

                    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
                    <span class="Comment">/*</span><span class="Comment"> This is a stale I.D. </span><span class="Comment">*/</span>
                    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>


                                                           <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>
                    (<span class="Type">void</span>)pups_unlink(next_item-&gt;d_name);  <span class="Comment">/*</span><span class="Comment"> Lock </span><span class="Comment">*/</span>
                    (<span class="Type">void</span>)pups_unlink(lock_name);          <span class="Comment">/*</span><span class="Comment"> Lid  </span><span class="Comment">*/</span>
                                                           <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>

                    <span class="Statement">if</span>(appl_verbose == TRUE)
                    {  (<span class="Type">void</span>)strdate(date);
                       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stale (local) lock id </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> removed (owner has died)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                         date,appl_name,appl_pid,appl_host,appl_owner,next_item-&gt;d_name);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                    }
                 }
              }


<span class="PreProc">              #ifdef SSH_SUPPORT</span>
              <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remote process </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

              <span class="Statement">else</span>
              {  <span class="Type">char</span> pidname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                 (<span class="Type">void</span>)snprintf(pidname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,owner_pid);
                 <span class="Statement">if</span>(pups_rkill(owner_host,owner_ssh_port,appl_owner,pidname,<span class="Constant">SIGTERM</span>) == (-<span class="Constant">1</span>))
                 {

                    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
                    <span class="Comment">/*</span><span class="Comment"> This is a stale I.D. </span><span class="Comment">*/</span>
                    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>


                                                           <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>
                    (<span class="Type">void</span>)pups_unlink(next_item-&gt;d_name);  <span class="Comment">/*</span><span class="Comment"> Lock </span><span class="Comment">*/</span>
                    (<span class="Type">void</span>)pups_unlink(lock_name);          <span class="Comment">/*</span><span class="Comment"> Lid  </span><span class="Comment">*/</span>
                                                           <span class="Comment">/*</span><span class="Comment">------</span><span class="Comment">*/</span>

                    <span class="Statement">if</span>(appl_verbose == TRUE)
                    {  (<span class="Type">void</span>)strdate(date);
                       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): stale lock id </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> removed (owner has died)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                 date,appl_name,appl_pid,appl_host,appl_owner,next_item-&gt;d_name);
                       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                    }
                 }
              }
<span class="PreProc">              #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

           }
       }
    }
    (<span class="Type">void</span>)closedir(dirp);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> A lock which only has a link count of two is stale and </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> should be removed                                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)stat(lock_name,&amp;buf);
    <span class="Statement">if</span>(access(lock_name,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>) &amp;&amp; buf.st_nlink &lt; <span class="Constant">3</span>)
    {  (<span class="Type">void</span>)unlink(lock_name);
       (<span class="Type">void</span>)unlink(rd_lock_name);
       (<span class="Type">void</span>)unlink(lock_id);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> stale lock removed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                             date,appl_name,appl_pid,appl_host,appl_owner,file_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }

    <span class="Statement">if</span>(max_trys != TRYLOCK)
    {  <span class="Statement">if</span>(lock_type == RDLOCK)
       {  <span class="Statement">while</span>((ret = link(file_name,lock_name)) == (-<span class="Constant">1</span>))
          {    <span class="Statement">if</span>(max_trys != WAIT_FOREVER)
	          ++trys;

               <span class="Statement">if</span>(trys &gt; max_trys &amp;&amp; max_trys != WAIT_FOREVER)
               {  <span class="Statement">if</span>(appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)strdate(date);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> failed to acquire lock (in </span><span class="Special">%d</span><span class="Constant"> attempts)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                    date,appl_name,appl_pid,appl_host,appl_owner,file_name,max_trys);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                  }

<span class="PreProc">                  #ifdef PTHREAD_SUPPORT</span>
                  (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                  --lock_cnt[lock_index];

<span class="PreProc">                  #ifdef PTHREAD_SUPPORT</span>
                  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                  pups_set_errno(<span class="Constant">EBUSY</span>);
                  <span class="Statement">return</span>(-<span class="Constant">1</span>);
               }

               (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
          }
       }
       <span class="Statement">else</span>
       {  <span class="Statement">while</span>(access(rd_lock_name,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>) || link(file_name,lock_name) == (-<span class="Constant">1</span>))
          {    <span class="Statement">if</span>(max_trys != WAIT_FOREVER)
                  ++trys;

               <span class="Statement">if</span>(trys &gt; max_trys &amp;&amp; max_trys != WAIT_FOREVER)
               {  <span class="Statement">if</span>(appl_verbose == TRUE)
                  {  (<span class="Type">void</span>)strdate(date);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> failed to acquire lock (in </span><span class="Special">%d</span><span class="Constant"> attempts)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                    date,appl_name,appl_pid,appl_host,appl_owner,file_name,max_trys);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                  }

<span class="PreProc">                  #ifdef PTHREAD_SUPPORT</span>
                  (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                  --lock_cnt[lock_index];

<span class="PreProc">                  #ifdef PTHREAD_SUPPORT</span>
                  (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">                  #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

                  pups_set_errno(<span class="Constant">EBUSY</span>);
                  <span class="Statement">return</span>(-<span class="Constant">1</span>);
               }

               (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
          }
       }
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Protect the lock </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(lock_type == RDLOCK)
       {  <span class="Statement">if</span>(link(file_name,rd_lock_name) == (-<span class="Constant">1</span>))
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             --lock_cnt[lock_index];

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EBUSY</span>);
	     <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }
       }
       <span class="Statement">else</span>
       {

          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> We need to check if we still have readers before releasing a read lock </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(access(rd_lock_name,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>) || link(file_name,lock_name) == (-<span class="Constant">1</span>))
          {
<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             --lock_cnt[lock_index];

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EBUSY</span>);
	     <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }
       }
    }

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; test_mode == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lock count incremented to </span><span class="Special">%d</span><span class="Constant"> [lock acquired]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,file_name,lock_cnt[lock_index]);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> New object -- put it in the lock name table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(lock_name_list[lock_index],file_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Read lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(lock_type == RDLOCK)
       (<span class="Type">void</span>)strlcpy(lock_type_list[lock_index],<span class="Constant">&quot;read&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Write lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(lock_type_list[lock_index],<span class="Constant">&quot;write&quot;</span>,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    (<span class="Type">void</span>)snprintf(lock_id,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,file_name,appl_name,appl_host,ssh_remote_port,appl_pid);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)snprintf(lock_id,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,file_name,appl_name,appl_pid);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Acquire lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)link(file_name,lock_id);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Set a write (exclusive) link file lock ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_link_file_lock(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> max_trys, <span class="Type">const</span> <span class="Type">char</span> *file_name)

{   <span class="Type">int</span> ret;

    <span class="Statement">if</span>(max_trys == <span class="Constant">0</span> || file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    ret = pups_get_rdwr_link_file_lock(WRLOCK,max_trys,file_name);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Release file lock (set by get_file_lock()) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_release_link_file_lock(<span class="Type">const</span> <span class="Type">char</span> *file_name)

{   <span class="Type">char</span> lock_name[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         lock_id[SSIZE]   = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> lock_index;

    <span class="Statement">if</span>(file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are on a read only filesystem then we don't need to   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> lock files but tell caller that we attempted to set a write </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> lock on a read only file system via global errno            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pups_is_on_isofs(file_name) == TRUE)
    {  pups_set_errno(<span class="Constant">EROFS</span>);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);

<span class="PreProc">    #ifdef SSH_SUPPORT</span>
    (<span class="Type">void</span>)snprintf(lock_id,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,file_name,appl_name,appl_host,ssh_remote_port,appl_pid);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)snprintf(lock_id,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,file_name,appl_name,appl_host,appl_pid);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(lock_id,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): not currently holding lock on </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (so cannot release it!)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                           date,appl_name,appl_pid,appl_host,appl_owner,file_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       pups_set_errno(<span class="Constant">EBADF</span>);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((lock_index = get_lock_index(file_name)) == (-<span class="Constant">1</span>))
       pups_error(<span class="Constant">&quot;[pups_release_link)file_lock] lock count inconsistency&quot;</span>);

    --lock_cnt[lock_index];

    <span class="Statement">if</span>(lock_cnt[lock_index] &gt; <span class="Constant">0</span>)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lock count decremented to </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,file_name,lock_cnt[lock_index]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free lock table entries </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)strlcpy(lock_name_list[lock_index],<span class="Constant">&quot;notset&quot;</span>,SSIZE);
    (<span class="Type">void</span>)strlcpy(lock_type_list[lock_index],<span class="Constant">&quot;notset&quot;</span>,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove write lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(lock_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lock&quot;</span>,file_name);
    (<span class="Type">void</span>)unlink(lock_name);


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove read lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(lock_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.rdlock&quot;</span>,file_name);
    (<span class="Type">void</span>)unlink(lock_name);


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove lock i.d. (LID) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)unlink(lock_id);

    <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; test_mode == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lock count decremented to </span><span class="Special">%d</span><span class="Constant"> [lock released]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,file_name,lock_cnt[lock_index]);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Release all link file locks ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_release_all_link_file_locks(<span class="Type">void</span>)

{   <span class="Type">int</span> i,
        removed = <span class="Constant">0</span>;

    <span class="Type">char</span> next_lock_id[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         next_lock[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove all locks in lock table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_LOCKS; ++i)
    {  <span class="Statement">if</span>(strcmp(lock_name_list[i],<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Remove next lock i.d. (LID) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

<span class="PreProc">          #ifdef SSH_SUPPORT</span>
          (<span class="Type">void</span>)snprintf(next_lock_id,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,lock_name_list[i],appl_name,appl_host,ssh_remote_port,appl_pid);
<span class="PreProc">          #else</span>
          (<span class="Type">void</span>)snprintf(next_lock_id,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lid.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.tmp&quot;</span>,   lock_name_list[i],appl_name,appl_host,appl_pid);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>


          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Error - failed to remove lock i.d. (LID) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(unlink(next_lock_id) == (-<span class="Constant">1</span>))
          {
<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }


          <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Remove next lock </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)snprintf(next_lock,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.lock&quot;</span>,lock_name_list[i]);
          <span class="Statement">if</span>(unlink(next_lock) != (-<span class="Constant">1</span>))
             ++removed;


          <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Error - failed to remove lock </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             <span class="Statement">return</span>(-<span class="Constant">1</span>);


          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Remove lock table entries </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)strlcpy(lock_name_list[i],<span class="Constant">&quot;notset&quot;</span>,SSIZE);
          (<span class="Type">void</span>)strlcpy(lock_type_list[i],<span class="Constant">&quot;notset&quot;</span>,SSIZE);
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> No locks (should) be active at this point </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    locks_active = FALSE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(removed);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Enable obituary for pipestream (child) process ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_pipestream_obituary_enable(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i,
        f_index;

    f_index = pups_get_ftab_index(fdes);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ftab[f_index].fifo_pid == (-<span class="Constant">1</span>) &amp;&amp; ftab[f_index].rd_pid == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_children; ++i)
    {  <span class="Statement">if</span>(chtab[i].pid == ftab[f_index].fifo_pid || chtab[i].pid == ftab[i].rd_pid)
       {  chtab[i].obituary = TRUE;


<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------- </span>
<span class="Comment">    Disable obituary for pipestream (child) process ... </span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_pipestream_obituary_disable(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span> i,
        f_index;

    f_index = pups_get_ftab_index(fdes);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ftab[f_index].fifo_pid == (-<span class="Constant">1</span>) &amp;&amp; ftab[f_index].rd_pid == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_children; ++i)
    {  <span class="Statement">if</span>(chtab[i].pid == ftab[f_index].fifo_pid || chtab[i].pid == ftab[i].rd_pid)
       {  chtab[i].obituary = FALSE;

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Extended fork routine which remembers forked children ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fork(<span class="Type">const</span> _BOOLEAN fork_wait, <span class="Type">const</span> _BOOLEAN obituary)

{   <span class="Type">int</span> i,
        pid;

    <span class="Statement">if</span>((fork_wait != FALSE &amp;&amp; fork_wait != TRUE) ||
       (obituary  != FALSE &amp;&amp; obituary  != TRUE)  )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search for free slot in child table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_child; ++i)
    {  <span class="Statement">if</span>(chtab[i].pid == (-<span class="Constant">1</span>))
       {

          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If fork_wait is TRUE parent will wait until there </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> are sufficient resources to fork its child        </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(fork_wait == TRUE)
          {  <span class="Statement">while</span>((pid = fork()) == (-<span class="Constant">1</span>))
                  (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
          }
          <span class="Statement">else</span>
             pid = fork();


          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pid &gt; <span class="Constant">0</span>)
          {  chtab[i].pid      = pid;
             chtab[i].obituary = obituary;
             ++n_children;

<span class="PreProc">            #ifdef PTHREAD_SUPPORT</span>
            (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             <span class="Statement">return</span>(pid);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
             <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): child table full (max </span><span class="Special">%d</span><span class="Constant"> entries)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                        date,appl_name,appl_pid,appl_host,appl_owner,appl_max_child);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">EAGAIN</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Initialise table of children ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_init_child_table(<span class="Type">const</span> <span class="Type">int</span> max_children)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_init_child_table] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    chtab = (chtab_type *)pups_realloc((<span class="Type">void</span> *)<span class="Constant">NULL</span>,max_children*<span class="Statement">sizeof</span>(chtab_type));
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;max_children; ++i)
    {  chtab[i].pid      = (-<span class="Constant">1</span>);
       chtab[i].obituary = FALSE;
       chtab[i].name     = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
    }

    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGCHLD</span>,<span class="Constant">&quot;child_handler&quot;</span>,(<span class="Type">void</span> *)&amp;chld_handler, (sigset_t *)<span class="Constant">NULL</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Clear a child table slot ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_clear_chtab_slot(<span class="Type">const</span> _BOOLEAN destroy, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> chld_index)

{   <span class="Statement">if</span>(chld_index &gt;= appl_max_child || (destroy != FALSE &amp;&amp; destroy != TRUE))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    chtab[chld_index].pid      = (-<span class="Constant">1</span>);
    chtab[chld_index].obituary = FALSE;

    <span class="Statement">if</span>(destroy == FALSE)
       chtab[chld_index].name = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
    <span class="Statement">else</span>
       chtab[chld_index].name = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)chtab[chld_index].name);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Show child table ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_children(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        children = <span class="Constant">0</span>;

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_children] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Active children</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ===============</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_child; ++i)
    {  <span class="Statement">if</span>(chtab[i].pid != (-<span class="Constant">1</span>))    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       {  <span class="Type">char</span> name[<span class="Constant">4096</span>] = <span class="Constant">&quot;&quot;</span>;    <span class="Comment">/*</span><span class="Comment"> Could be a pipeline so we need to reserve space for this </span><span class="Comment">*/</span>
                                   <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(chtab[i].name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(name,<span class="Constant">&quot;&lt;unnamed&gt;&quot;</span>,SSIZE);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(name,chtab[i].name,SSIZE);

          <span class="Statement">if</span>(chtab[i].obituary == TRUE)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: child pid </span><span class="Special">%09d</span><span class="Constant"> (</span><span class="Special">%-32s</span><span class="Constant">) [obituary]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,chtab[i].pid,name);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: child pid </span><span class="Special">%08d</span><span class="Constant"> (</span><span class="Special">%-32s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,chtab[i].pid,name);

          (<span class="Type">void</span>)fflush(stream);

          ++children;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;chtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(children &gt; <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> active children (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,children,appl_max_child - children);
    <span class="Statement">else</span> <span class="Statement">if</span>(children == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> active child (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,appl_max_child - <span class="Constant">1</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    no active children (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_max_child);
    (<span class="Type">void</span>)fflush(stream);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Set child process name ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_set_child_name(<span class="Type">const</span> <span class="Type">int</span> pid, <span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(pid &lt;= <span class="Constant">0</span> || name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CHILDREN; ++i)
    {  <span class="Statement">if</span>(chtab[i].pid == pid)
       {  <span class="Statement">if</span>(chtab[i].name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             chtab[i].name = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          (<span class="Type">void</span>)strlcpy(chtab[i].name,name,SSIZE);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          <span class="Statement">return</span>(TRUE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to handle SIGCHLD - removes child pid from table of child</span>
<span class="Comment">    processes ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> chld_handler(<span class="Type">int</span> sig)

{   <span class="Type">int</span> i,
        pid,
        status;

    <span class="Statement">while</span>((pid = waitpid((-<span class="Constant">1</span>),&amp;status,WNOHANG)) &gt; <span class="Constant">0</span>)
    {
<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_lock(&amp;pups_fork_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

         <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CHILDREN; ++i)
         {  <span class="Statement">if</span>(chtab[i].pid == pid)
            {  <span class="Statement">if</span>(appl_verbose == TRUE)
               {  <span class="Statement">if</span>(chtab[i].obituary == TRUE)
                  {  (<span class="Type">void</span>)strdate(date);
                     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [chld_handler] child process </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) has exited</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                        date,appl_name,getpid(),appl_host,pid,chtab[i].name);

                     <span class="Statement">if</span>(n_children &gt; <span class="Constant">1</span>)
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [chld_handler] clearing child table slot </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant"> children)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                          date,appl_name,getpid(),appl_host,i,n_children);
                     <span class="Statement">else</span>
                        (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [chld_handler] clearing child table slot </span><span class="Special">%d</span><span class="Constant"> (1 child)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                 date,appl_name,getpid(),appl_host,i);
                     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                  }
               }

               chtab[i].pid = (-<span class="Constant">1</span>);

               <span class="Statement">if</span>(chtab[i].name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                  chtab[i].name = (<span class="Type">char</span> *)pups_free(chtab[i].name);

               --n_children;
               i = MAX_CHILDREN + <span class="Constant">1</span>;
            }
         }

<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
     }

     <span class="Statement">return</span>;
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Install handler for PUPS automatic child management ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_auto_child(<span class="Type">void</span>)

{   pups_sighandle(<span class="Constant">SIGCHLD</span>,<span class="Constant">&quot;child_handler&quot;</span>,(<span class="Type">void</span> *)chld_handler, (sigset_t *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Remove handler for PUPS automatic child managment ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_noauto_child(<span class="Type">void</span>)

{   pups_sighandle(<span class="Constant">SIGCHLD</span>,<span class="Constant">&quot;ignored&quot;</span>,<span class="Constant">SIG_DFL</span>, (sigset_t *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Wait function compatable with PUPS child managment ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pupswait(_BOOLEAN wait_verbose, <span class="Type">int</span> *status)

{   <span class="Type">int</span> i,
        pid;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(status == (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for child to exit </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    pups_noauto_child();
    <span class="Statement">do</span> {   pid = waitpid((-<span class="Constant">1</span>),status,WNOHANG);

           <span class="Statement">if</span>(pid == <span class="Constant">0</span>)
             (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
           <span class="Statement">else</span>
           {  pups_auto_child();
              pups_set_errno(<span class="Constant">ECHILD</span>);
              <span class="Statement">return</span>(-<span class="Constant">1</span>);
           }

        } <span class="Statement">while</span>(pid == <span class="Constant">0</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update child table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CHILDREN; ++i)
    {   <span class="Statement">if</span>(chtab[i].pid == pid)
        {  <span class="Statement">if</span>(wait_verbose == TRUE)
           {  <span class="Statement">if</span>(chtab[i].obituary == TRUE)
              {  (<span class="Type">void</span>)strdate(date);
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [pupswait] child process </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) has exited</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                date,appl_name,appl_pid,appl_host,pid,chtab[i].name);

                 <span class="Statement">if</span>(n_children == <span class="Constant">1</span>)
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [pupswait] clearing child slot </span><span class="Special">%d</span><span class="Constant"> (1 child)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                   date,appl_name,appl_pid,appl_host,i);
                 <span class="Statement">else</span>
                    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [pupswait] clearing child slot </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant"> children)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                            date,appl_name,appl_pid,appl_host,i,n_children);
              }
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
           }

           chtab[i].pid = (-<span class="Constant">1</span>);

           <span class="Statement">if</span>(chtab[i].name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
              chtab[i].name = (<span class="Type">char</span> *)pups_free(chtab[i].name);

           --n_children;

           pups_auto_child();

<span class="PreProc">           #ifdef PTHREAD_SUPPORT</span>
           (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">           #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

           pups_set_errno(OK);
           <span class="Statement">return</span>(pid);
        }
    }

    pups_auto_child();

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">EEXIST</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Waitpid function compatable with PUPS child managment ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pupswaitpid(_BOOLEAN waitpid_verbose, <span class="Type">int</span> wait_pid, <span class="Type">int</span> *status)

{   <span class="Type">int</span> i,
        pid;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(wait_pid &lt;= <span class="Constant">0</span> || status == (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for child to exit </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    pups_noauto_child();
    <span class="Statement">do</span> {   pid = waitpid(wait_pid,status,WNOHANG);

           <span class="Statement">if</span>(pid == <span class="Constant">0</span>)
             (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
           <span class="Statement">else</span>
           {  pups_auto_child();
              pups_set_errno(<span class="Constant">ECHILD</span>);

              <span class="Statement">return</span>(-<span class="Constant">1</span>);
           }

        } <span class="Statement">while</span>(pid == <span class="Constant">0</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update child table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_CHILDREN; ++i)
    {  <span class="Statement">if</span>(chtab[i].pid == pid)
       {  <span class="Statement">if</span>(waitpid_verbose == TRUE)
          {  <span class="Statement">if</span>(chtab[i].obituary == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [pupswaitpid] child process </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) has exited</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                  date,appl_name,getpid(),appl_host,pid,chtab[i].name);

                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">(</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): [pupswaitpid] clearing child slot </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant"> children)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                           date,appl_name,getpid(),appl_host,i,n_children);

                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }
          }

          chtab[i].pid = (-<span class="Constant">1</span>);

          <span class="Statement">if</span>(chtab[i].name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             chtab[i].name = (<span class="Type">char</span> *)pups_free(chtab[i].name);

          --n_children;

          pups_auto_child();

<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(pid);
       }
    }

    pups_auto_child();

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;pups_fork_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    pups_set_errno(<span class="Constant">EEXIST</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}



<span class="PreProc">#ifdef SECURE</span>

<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Send mail to vendor informing of licensing violation ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifdef VENDOR_MAIL_ADDRESS</span>

_PRIVATE <span class="Type">void</span> mail_license_violation(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Type">char</span> mail_cmd[SSIZE]            = <span class="Constant">&quot;&quot;</span>,
         vendor_domain[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         vendor_mail_address[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN remote_domain = FALSE;
    <span class="Type">FILE</span> *pstream          = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    (<span class="Type">void</span>)strlcpy(vendor_mail_address,VENDOR_MAIL_ADDRESS,SSIZE);


    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Can we actually send a mail? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(vendor_mail_address); ++i)
    {  <span class="Statement">if</span>(vendor_mail_address[i] == <span class="Constant">'@'</span>)
       {  remote_domain = TRUE;
          <span class="Statement">break</span>;
       }
    }

<span class="PreProc">    #ifdef PING_REMOTE</span>
    <span class="Statement">if</span>(remote_domain == TRUE)
    {  <span class="Type">char</span> line[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
            ping_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)strlcpy(vendor_domain,&amp;vendor_mail_address[i+<span class="Constant">1</span>],SSIZE);
       (<span class="Type">void</span>)snprintf(ping_cmd,SSIZE,<span class="Constant">&quot;bash -c </span><span class="Special">\&quot;</span><span class="Constant">ping -c 1 </span><span class="Special">%s</span><span class="Constant"> | cat</span><span class="Special">\&quot;</span><span class="Constant">&quot;</span>,vendor_domain);

       <span class="Statement">if</span>((pstream = popen(ping_cmd,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
          <span class="Statement">return</span>;

       (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
       (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
       (<span class="Type">void</span>)pclose(pstream);

       <span class="Statement">if</span>(strin(line,<span class="Constant">&quot;Net Unreach&quot;</span>) == TRUE || strin(line,<span class="Constant">&quot;unknown host&quot;</span>) == TRUE)
          <span class="Statement">return</span>;
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PING_REMOTE </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mail_cmd,SSIZE,<span class="Constant">&quot;cat | mail -s </span><span class="Special">\&quot;</span><span class="Constant">license abuse (securicor)</span><span class="Special">\&quot;</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,vendor_mail_address);

    <span class="Statement">if</span>((pstream = popen(mail_cmd,<span class="Constant">&quot;w&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>;

    (<span class="Type">void</span>)fprintf(pstream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant"> has abused license conditions for application </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;\n</span><span class="Constant">.</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                           appl_owner,appl_host,appl_bin_name);
    (<span class="Type">void</span>)fflush(pstream);
    (<span class="Type">void</span>)pclose(pstream);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> VENDOR_MAIL_ADDRESS </span><span class="Comment">*/</span>



<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Only run application if serial number on disk matches that hard-wired</span>
<span class="Comment">    into code ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_securicor(<span class="Type">char</span> *exec_path)

{   <span class="Type">int</span>  ddes                    = (-<span class="Constant">1</span>);

    <span class="Type">char</span> disk_serial[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         appl_serial[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         hd_device[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         appl_dongle_file[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         appl_dongle[SSIZE]      = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *stream                 = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">struct</span> hd_driveid disk_info;

    <span class="Statement">if</span>(exec-path == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

<span class="PreProc">    #ifndef DISK_SERIAL</span>
    pups_error(<span class="Constant">&quot;[securicor] license has not been installed properly&quot;</span>);
<span class="PreProc">    #else</span> <span class="Comment">/*</span><span class="Comment"> DISK_SERIAL </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(HD_DEVICE,<span class="Constant">&quot;/dev/dummy&quot;</span>) != <span class="Constant">0</span>)
    {


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check hard disk serial number. If this does not match the serial number </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> expected by the application this is illegal so abort run.               </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strlcpy(hd_device,HD_DEVICE,SSIZE);

       <span class="Statement">if</span>((ddes = open(hd_device,<span class="Constant">0</span>)) == (-<span class="Constant">1</span>))
       {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[securicor] cannot open </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> to authorise application&quot;</span>,hd_device);
          pups_error(errstr);
       }

       (<span class="Type">void</span>)ioctl(ddes,HDIO_GET_IDENTITY,(<span class="Type">void</span> *)&amp;disk_info);
       (<span class="Type">void</span>)close(ddes);
       (<span class="Type">void</span>)strlcpy(appl_serial,DISK_SERIAL,SSIZE);
       (<span class="Type">void</span>)ecryptstr(SEQUENCE_SEED,TRUE,disk_info.serial_no,disk_serial);
    }
    <span class="Statement">else</span>
    {  <span class="Type">struct</span> stat stat_buf;

       <span class="Statement">if</span>(getenv(<span class="Constant">&quot;USE_SOFT_DONGLE&quot;</span>) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Default location of soft dongle authentication file </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)snprintf(appl_dongle_file,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/.sdongles/pups.dongle&quot;</span>,appl_home);
          <span class="Statement">if</span>(access(appl_dongle_file,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[securicor] cannot open (soft dongle) to authorise application&quot;</span>);
             pups_error(errstr);
          }

          <span class="Statement">if</span>((ddes = open(appl_dongle_file,<span class="Constant">0</span>)) == (-<span class="Constant">1</span>))
          {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[securicor] cannot open (soft dongle)  </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> to authorise application&quot;</span>,appl_dongle_file);
             pups_error(errstr);
          }
       }
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)strlcpy(appl_dongle_file,getenv(<span class="Constant">&quot;USE_SOFT_DONGLE&quot;</span>),SSIZE);
          <span class="Statement">if</span>((ddes = open(appl_dongle_file,<span class="Constant">0</span>)) == (-<span class="Constant">1</span>))
          {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[securicor] cannot open (soft dongle)  </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> to authorise application&quot;</span>,appl_dongle_file);
             pups_error(errstr);
          }
       }

       (<span class="Type">void</span>)fstat(ddes,&amp;stat_buf);
       (<span class="Type">void</span>)snprintf(disk_serial,SSIZE,<span class="Constant">&quot;</span><span class="Special">%x</span><span class="Constant">&quot;</span>,stat_buf.st_ino);
       (<span class="Type">void</span>)close(ddes);
       (<span class="Type">void</span>)strlcpy(appl_serial,DISK_SERIAL,SSIZE);
    }

    <span class="Statement">if</span>(strcmp(disk_serial,appl_serial) != <span class="Constant">0</span>)
    {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Send mail to vendor noting licence infringement </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)mail_license_violation();

       (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[securicor] this is an unathorised copy of </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> -- aborting&quot;</span>,appl_name);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(exec_path != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check to see if binary is on NFS filesystem. If it is </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> then this is illegal so run must be aborted.          </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_is_on_nfs(exec_path) == TRUE)
       {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Send mail to vendor noting licence infringement </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)mail_license_violation();

          (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[securicor] </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> is running on an unauthorised processor -- aborting&quot;</span>,appl_name);
          pups_error(errstr);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> DISK_SERIAL </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(strcmp(HD_DEVICE,<span class="Constant">&quot;/dev/dummy&quot;</span>) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): using soft dongle (for license authentication)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                       date,appl_name,appl_pid,appl_host,appl_owner);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): using disk serial number (for license authentication)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                              date,appl_name,appl_pid,appl_host,appl_owner);


       <span class="Statement">if</span>(exec_path == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): single host, single user license [securicor]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                     date,appl_name,appl_pid,appl_host,appl_owner);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): single host, multiple user license [securicor]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                       date,appl_name,appl_pid,appl_host,appl_owner);
    }
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SECURE </span><span class="Comment">*/</span>





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to allocate a dynamic array - this is based on T.K.W Chau's</span>
<span class="Comment">    allocation scheme ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> **pups_aalloc(pindex_t rows, pindex_t cols, psize_t size)

{   <span class="Type">int</span>   i;

    <span class="Type">void</span> *array_mem = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    <span class="Type">void</span> **array    = (<span class="Type">void</span> **)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> First allocate memory for the whole array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    array_mem = (<span class="Type">void</span> *)pups_malloc(rows*cols*size);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Now row allocate the pointer array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    array = (<span class="Type">void</span> **)pups_malloc(rows*<span class="Statement">sizeof</span>(<span class="Type">void</span> **));


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Now allocate the columns addressed by the pointer array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;rows; ++i)
    {  array[i]  = (<span class="Type">void</span> *)array_mem;
       array_mem = (<span class="Type">void</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)array_mem + (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)(cols*size));
    }

    <span class="Statement">return</span>(array);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to free memory occupied by a dynamically allocated array ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> **pups_afree(pindex_t rows, <span class="Type">void</span> **array)

{    <span class="Type">int</span> i;

     <span class="Statement">if</span>(array != (<span class="Type">void</span> **)<span class="Constant">NULL</span>)
        (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)array[<span class="Constant">0</span>]);

     <span class="Statement">return</span>(pups_free((<span class="Type">void</span> *)array));
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Routine to sort an array of floating point values using the heapsort</span>
<span class="Comment">    algorithm - this routine is derived from one given in Press et al,</span>
<span class="Comment">    Numerical Recipes in C ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> sort2(<span class="Type">int</span> n, FTYPE ra[], FTYPE rb[])

{   <span class="Type">int</span> l,
        j,
        ir,
         i;

    FTYPE rrb,
          rra;

    l = (n &gt;&gt; <span class="Constant">1</span>) + <span class="Constant">1</span>;

    ir = n;
    <span class="Statement">for</span>(;;)
    {   <span class="Statement">if</span>(l &gt; <span class="Constant">0</span>)
        {  rra = ra[--l];
           rrb = rb[l];
        }
        <span class="Statement">else</span>
        {  rra    = ra[ir];
           rrb    = rb[<span class="Constant">0</span>];
           rb[ir] = rb[<span class="Constant">0</span>];

           <span class="Statement">if</span>(--ir == <span class="Constant">0</span>)
           {  ra[<span class="Constant">0</span>] = rra;
              rb[<span class="Constant">0</span>] = rrb;
              <span class="Statement">return</span>;
           }
        }

        i = <span class="Constant">1</span>;
        j = l &lt;&lt; <span class="Constant">1</span>;

        <span class="Statement">while</span>(j &lt;= ir)
        {   <span class="Statement">if</span>(j &lt; ir &amp;&amp; ra[j] &lt; ra[j+<span class="Constant">1</span>])
               ++j;

            <span class="Statement">if</span>(rra &lt; ra[j])
            {   ra[i] = ra[j];
                rb[i] = rb[j];
                j     += (i + j);
            }
            <span class="Statement">else</span>
               j = ir + <span class="Constant">1</span>;
        }

        ra[i] = rra;
        ra[i] = rrb;
    }
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Check descriptor redirections ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_check_redirection(<span class="Type">const</span> des_t des)

{    <span class="Statement">if</span>(isatty(des) == <span class="Constant">1</span>)
     {  <span class="Statement">switch</span>(des)
        {   <span class="Statement">case</span> <span class="Constant">0</span>:  pups_error(<span class="Constant">&quot;[check_redirection] stdin not redirected&quot;</span>);

            <span class="Statement">case</span> <span class="Constant">1</span>:  pups_error(<span class="Constant">&quot;[check_redirection] stdout not redirected&quot;</span>);

            <span class="Statement">case</span> <span class="Constant">2</span>:  pups_error(<span class="Constant">&quot;[check_redirection] stderr not redirected&quot;</span>);

            <span class="Statement">default</span>: pups_error(<span class="Constant">&quot;[check_redirection] tty device not redirected&quot;</span>);
        }
     }
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">   Set process state ..</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_set_state(<span class="Type">const</span> <span class="Type">char</span> *state)

{   <span class="Statement">if</span>(state == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    (<span class="Type">void</span>)strlcpy(appl_state,state,SSIZE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">   Get process state ,,,</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_get_state(<span class="Type">const</span> <span class="Type">char</span> *state)

{   <span class="Statement">if</span>(state == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    (<span class="Type">void</span>)strlcpy(state,appl_state,SSIZE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to display the state of the current process - this is</span>
<span class="Comment">    normally called in response to a SIGUSR signal. In addition the</span>
<span class="Comment">    originator of the signal must specify an I/O terminal for this</span>
<span class="Comment">    transaction in /tmp/&lt;pid&gt;.info.tmp ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_state(<span class="Type">void</span>)

{   <span class="Type">FILE</span> *info_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>,
         *io_stream   = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> tty_dev_name[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
         tty_info_file[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_state] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get the name of the I/O terminal that is to be used. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    snprintf(tty_info_file,SSIZE,<span class="Constant">&quot;/tmp/info.tmp.</span><span class="Special">%d</span><span class="Constant">&quot;</span>,getpid());
    info_stream = pups_fopen(tty_info_file,<span class="Constant">&quot;r&quot;</span>,LIVE);
    fscanf(info_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,tty_dev_name);
    (<span class="Type">void</span>)pups_fclose(info_stream);

    io_stream = pups_fopen(tty_dev_name,<span class="Constant">&quot;r+&quot;</span>,LIVE);

    (<span class="Type">void</span>)fprintf(io_stream,<span class="Constant">&quot;    Application </span><span class="Special">%s</span><span class="Constant"> [pid </span><span class="Special">%d</span><span class="Constant">]@</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name,
                                                                getpid(),
                                                               appl_host);

    (<span class="Type">void</span>)fprintf(io_stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    Application state: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_state);
    (<span class="Type">void</span>)fflush(io_stream);

    pups_fclose(io_stream);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Register a PUPS entrance function (and its argument string) ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> max_entrance_funcs     = MAX_FUNCS;
_PUBLIC <span class="Type">int</span> n_entrance_funcs       = <span class="Constant">0</span>;
_PUBLIC <span class="Type">int</span> n_entrance_funcs_alloc = <span class="Constant">0</span>;

_PUBLIC <span class="Type">char</span> *pups_entrance_f_name[MAX_FUNCS];
_PUBLIC <span class="Type">char</span> *pups_entrance_arg[MAX_FUNCS];
_PUBLIC <span class="Type">void</span> (*pups_entrance_f[MAX_FUNCS])(<span class="Type">char</span> *);

_PUBLIC <span class="Type">int</span> pups_register_entrance_f(<span class="Type">const</span> <span class="Type">char</span> *f_name,
                                     <span class="Type">const</span> <span class="Type">void</span> *entrance_f,
                                     <span class="Type">const</span> <span class="Type">char</span> *arg_str)

{   <span class="Type">int</span>  i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;pups_register_entrance_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);


    <span class="Statement">if</span>(f_name     == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       entrance_f == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(PUPS_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if the entrance function table is full and that </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> we have a function name                                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_entrance_funcs == max_entrance_funcs)
    {  pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(PUPS_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find a free entrance function slot </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entrance_funcs_alloc; ++i)
    {   <span class="Statement">if</span>((<span class="Type">void</span> *)pups_entrance_f[i] == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
        {  pups_entrance_f[i] = entrance_f;

           (<span class="Type">void</span>)strlcpy(pups_entrance_f_name[i],f_name,SSIZE);
           <span class="Statement">if</span>(arg_str != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(pups_entrance_arg[i],arg_str,SSIZE);

           <span class="Statement">if</span>(appl_verbose == TRUE)
           {  strdate(date);
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                      <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS entrance function </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%016lx</span><span class="Constant">) registered at slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                date,
                                                                                           appl_name,
                                                                                            getpid(),
                                                                                           appl_host,
                                                                                          appl_owner,
                                                                             pups_entrance_f_name[i],
                                                                                  pups_entrance_f[i],
                                                                                                   i);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
           }

           ++n_entrance_funcs;

           pups_set_errno(OK);
           <span class="Statement">return</span>(PUPS_OK);
        }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate next free slot and register entrance function </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    pups_entrance_f_name[n_entrance_funcs_alloc] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    pups_entrance_f[n_entrance_funcs_alloc]      = entrance_f;

    (<span class="Type">void</span>)strlcpy(pups_entrance_f_name[n_entrance_funcs_alloc],f_name,SSIZE);

    <span class="Statement">if</span>(arg_str != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_entrance_arg[n_entrance_funcs_alloc]    = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(pups_entrance_arg[n_entrance_funcs_alloc],arg_str,SSIZE);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS exit function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) registered at slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                    date,
                                                                                                               appl_name,
                                                                                                                getpid(),
                                                                                                               appl_host,
                                                                                                              appl_owner,
                                                                            pups_entrance_f_name[n_entrance_funcs_alloc],
                                                              (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_entrance_f[n_entrance_funcs_alloc],
                                                                                                  n_entrance_funcs_alloc);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    ++n_entrance_funcs;
    ++n_entrance_funcs_alloc;

    pups_set_errno(OK);
    <span class="Statement">return</span>(PUPS_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Deregister a PUPS exit function (and its argument string) ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_deregister_entrance_f(<span class="Type">const</span> <span class="Type">void</span> *func)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_deregister_entrance_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(func   == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entrance_funcs_alloc; ++i)
    {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_entrance_f[i] == func)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS entrance function </span><span class="Special">\&quot;</span><span class="Special">%032s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) at slot </span><span class="Special">%d</span><span class="Constant"> deregistered</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                                 date,
                                                                                                                            appl_name,
                                                                                                                             getpid(),
                                                                                                                            appl_host,
                                                                                                                           appl_owner,
                                                                                                              pups_entrance_f_name[i],
                                                                                                                   pups_entrance_f[i],
                                                                                                                                    i);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          pups_entrance_f[i] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
          (<span class="Type">void</span>)strlcpy(pups_entrance_f_name[i],<span class="Constant">&quot;&quot;</span>,SSIZE);

          <span class="Statement">if</span>(pups_entrance_arg[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
            (<span class="Type">void</span>)strlcpy(pups_entrance_arg[i],<span class="Constant">&quot;&quot;</span>,SSIZE);

          --n_entrance_funcs;

          pups_set_errno(OK);
          <span class="Statement">return</span>(PUPS_OK);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PUPS_ERROR);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Show PUPS entrance functions ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_entrance_f(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_entrance_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    <span class="Statement">if</span>(n_entrance_funcs == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    No entrance functions registered (</span><span class="Special">%d</span><span class="Constant"> slots free0</span><span class="Special">\n</span><span class="Constant">&quot;</span>,n_entrance_funcs_alloc);
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Entrance functions registered</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =============================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);


       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entrance_funcs_alloc; ++i)
       {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_entrance_f[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                        pups_entrance_f_name[i],
                                          (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_entrance_f[i]);
             (<span class="Type">void</span>)fflush(stream);
          }
       }

       <span class="Statement">if</span>(n_entrance_funcs &gt; <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> entrance functions registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_entrance_funcs,n_entrance_funcs_alloc - n_entrance_funcs);
       <span class="Statement">else</span> <span class="Statement">if</span>(n_entrance_funcs == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> entrance function registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,n_entrance_funcs_alloc - <span class="Constant">1</span>);

       (<span class="Type">void</span>)fflush(stream);
    }

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Display any remaining portions of the command line which could not</span>
<span class="Comment">    be parsed ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_t_arg_errs(<span class="Type">const</span> _BOOLEAN argd[], <span class="Type">const</span> <span class="Type">char</span> *args[])

{   <span class="Type">int</span>      i;
    _BOOLEAN parse_failed = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_t_arg_errs] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(argd == (<span class="Type">const</span> _BOOLEAN **)<span class="Constant">NULL</span> || args == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Before we see if all arguments are correctly decoded run all </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> entrance functions                                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_entrance_funcs_alloc; ++i)
    {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_entrance_f[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       {  (<span class="Type">void</span>)strdate(date);
          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): executing entrance function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (slot </span><span class="Special">%d</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                             date,appl_name,appl_pid,appl_host,appl_owner,
                                                                                                  pups_entrance_f_name[i],
                                                                                                                        i,
                                                                                    (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_entrance_f[i]);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          (*pups_entrance_f[i])(pups_entrance_arg[i]);
       }
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;t_args; ++i)
    {   <span class="Statement">if</span>(argd[i] == FALSE &amp;&amp; strcmp(args[i],<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
        {  <span class="Statement">if</span>(parse_failed == FALSE)
           {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
              parse_failed = TRUE;
           }

           (<span class="Type">void</span>)strdate(date);
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): ERROR failed to parse: </span><span class="Special">%s</span><span class="Constant">[</span><span class="Special">%d</span><span class="Constant">]</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                             date,appl_name,appl_pid,appl_host,appl_owner,args[i],i);
           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
        }
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
      (<span class="Type">void</span>)pups_release_fd_lock(<span class="Constant">2</span>);

    <span class="Statement">if</span>(parse_failed == TRUE)
       pups_exit(<span class="Constant">255</span>);

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Register a PUPS exit function (and its argument string) ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> max_exit_funcs     = MAX_FUNCS;
_PUBLIC <span class="Type">int</span> n_exit_funcs       = <span class="Constant">0</span>;
_PUBLIC <span class="Type">int</span> n_exit_funcs_alloc = <span class="Constant">0</span>;

_PUBLIC <span class="Type">char</span> *pups_exit_f_name[MAX_FUNCS];
_PUBLIC <span class="Type">char</span> *pups_exit_arg[MAX_FUNCS];
_PUBLIC <span class="Type">void</span> (*pups_exit_f[MAX_FUNCS])(<span class="Type">char</span> *);

_PUBLIC <span class="Type">int</span> pups_register_exit_f(<span class="Type">const</span> <span class="Type">char</span> *f_name,
                                 <span class="Type">const</span> <span class="Type">void</span> *exit_f,
                                 <span class="Type">const</span> <span class="Type">char</span> *arg_str)

{   <span class="Type">int</span>  i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_register_entrance_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(f_name  == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       exit_f  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if the exit function table is full and that </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> we have a function name                                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_exit_funcs == max_exit_funcs)
       <span class="Statement">return</span>(PUPS_ERROR);


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find a free exit function slot </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_exit_funcs_alloc; ++i)
    {   <span class="Statement">if</span>((<span class="Type">void</span> *)pups_exit_f[i] == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
        {  pups_exit_f[i] = exit_f;

           (<span class="Type">void</span>)strlcpy(pups_exit_f_name[i],f_name,SSIZE);
           <span class="Statement">if</span>(arg_str != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(pups_exit_arg[i],arg_str,SSIZE);

           <span class="Statement">if</span>(appl_verbose == TRUE)
           {  strdate(date);
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
                      <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS exit function </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%016lx</span><span class="Constant">) registered at slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                            date,
                                                                                       appl_name,
                                                                                        getpid(),
                                                                                       appl_host,
                                                                                      appl_owner,
                                                                             pups_exit_f_name[i],
                                                                                  pups_exit_f[i],
                                                                                               i);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
           }

           ++n_exit_funcs;

           pups_set_errno(OK);
           <span class="Statement">return</span>(PUPS_OK);
        }
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate next free slot and register exit function </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

    pups_exit_f_name[n_exit_funcs_alloc] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    pups_exit_f[n_exit_funcs_alloc]      = exit_f;

    (<span class="Type">void</span>)strlcpy(pups_exit_f_name[n_exit_funcs_alloc],f_name,SSIZE);

    <span class="Statement">if</span>(arg_str != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_exit_arg[n_exit_funcs_alloc]    = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(pups_exit_arg[n_exit_funcs_alloc],arg_str,SSIZE);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,
               <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS exit function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) registered at slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                       date,
                                                                                                  appl_name,
                                                                                                   getpid(),
                                                                                                  appl_host,
                                                                                                 appl_owner,
                                                                       pups_exit_f_name[n_exit_funcs_alloc],
                                                         (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_exit_f[n_exit_funcs_alloc],
                                                                                         n_exit_funcs_alloc);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    ++n_exit_funcs;
    ++n_exit_funcs_alloc;

    pups_set_errno(OK);
    <span class="Statement">return</span>(PUPS_OK);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Register a PUPS exit function (and its argument string) ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_deregister_exit_f(<span class="Type">const</span> <span class="Type">void</span> *func)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_deregister_entrance_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(func   == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_exit_funcs_alloc; ++i)
    {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_exit_f[i] == func)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS exit function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) at slot </span><span class="Special">%d</span><span class="Constant"> deregistered</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                            date,
                                                                                                                       appl_name,
                                                                                                                        getpid(),
                                                                                                                       appl_host,
                                                                                                                      appl_owner,
                                                                                                             pups_exit_f_name[i],
                                                                                               (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_exit_f[i],
                                                                                                                               i);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          pups_exit_f[i] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
          (<span class="Type">void</span>)strlcpy(pups_exit_f_name[i],<span class="Constant">&quot;&quot;</span>,SSIZE);

          <span class="Statement">if</span>(pups_exit_arg[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(pups_exit_arg[i],<span class="Constant">&quot;&quot;</span>,SSIZE);

          --n_exit_funcs;

          pups_set_errno(OK);
          <span class="Statement">return</span>(PUPS_OK);
       }
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PUPS_ERROR);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Show PUPS exit functions ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_exit_f(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_exit_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we actually have a valid stream to write to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>;

    <span class="Statement">if</span>(n_exit_funcs == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    No exit functions registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_exit_funcs_alloc);
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Exit functions registered</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);


       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_exit_funcs_alloc; ++i)
       {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_exit_f[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                            pups_exit_f_name[i],
                                              (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_exit_f[i]);
             (<span class="Type">void</span>)fflush(stream);
          }
       }

       <span class="Statement">if</span>(n_exit_funcs &gt; <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> exit functions registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_exit_funcs,n_exit_funcs_alloc - n_exit_funcs);
       <span class="Statement">else</span> <span class="Statement">if</span>(n_exit_funcs == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> exit function registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,n_exit_funcs_alloc - <span class="Constant">1</span>);

       (<span class="Type">void</span>)fflush(stream);
    }

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Register a PUPS abort function (and its argument string) ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> max_abort_funcs     = MAX_FUNCS;
_PUBLIC <span class="Type">int</span> n_abort_funcs       = <span class="Constant">0</span>;
_PUBLIC <span class="Type">int</span> n_abort_funcs_alloc = <span class="Constant">0</span>;

_PUBLIC <span class="Type">void</span> (*pups_abort_f[MAX_FUNCS])(<span class="Type">char</span> *);
_PUBLIC <span class="Type">char</span> *pups_abort_f_name[MAX_FUNCS];
_PUBLIC <span class="Type">char</span> *pups_abort_arg[MAX_FUNCS];


_PUBLIC <span class="Type">int</span> pups_register_abort_f(<span class="Type">const</span> <span class="Type">char</span> *f_name,
                                  <span class="Type">const</span> <span class="Type">void</span>  *abort_f,
                                  <span class="Type">const</span> <span class="Type">char</span> *arg_str)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_register_abort_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(f_name   == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       abort_f  == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if the exit function table is full and that </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> we have a function name                                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(n_abort_funcs == max_abort_funcs || f_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(PUPS_ERROR);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find a free abort function slot </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_abort_funcs_alloc; ++i)
    {   <span class="Statement">if</span>((<span class="Type">void</span> *)pups_abort_f[i] == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
        {  pups_abort_f[i] = abort_f;

           (<span class="Type">void</span>)strlcpy(pups_abort_f_name[i],f_name,SSIZE);
           <span class="Statement">if</span>(arg_str != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(pups_abort_arg[i],arg_str,SSIZE);

           <span class="Statement">if</span>(appl_verbose == TRUE)
           {  (<span class="Type">void</span>)strdate(date);
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS abort function </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%018x</span><span class="Constant">) registered at slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                         date,
                                                                                                    appl_name,
                                                                                                     appl_pid,
                                                                                                    appl_host,
                                                                                                   appl_owner,
                                                                                         pups_abort_f_name[i],
                                                                                              pups_abort_f[i],
                                                                                                            i);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
           }

           ++n_abort_funcs;

           pups_set_errno(OK);
           <span class="Statement">return</span>(PUPS_OK);
        }
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate next free slot and register abort function </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    pups_abort_f_name[n_abort_funcs_alloc] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    pups_abort_f[n_abort_funcs_alloc]      = abort_f;

    (<span class="Type">void</span>)strlcpy(pups_abort_f_name[n_abort_funcs_alloc],f_name,SSIZE);

    <span class="Statement">if</span>(arg_str != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_abort_arg[n_abort_funcs_alloc]    = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(pups_abort_arg[n_abort_funcs_alloc],arg_str,SSIZE);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS abort function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual) registered at slot </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                             date,appl_name,appl_pid,appl_host,appl_owner,
                                                                                   pups_abort_f_name[n_abort_funcs_alloc],
                                                                     (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_abort_f[n_abort_funcs_alloc],
                                                                                                      n_abort_funcs_alloc);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    ++n_abort_funcs;
    ++n_abort_funcs_alloc;

    pups_set_errno(OK);
    <span class="Statement">return</span>(PUPS_OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Deregister a PUPS abort function (and its argument string) ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_deregister_abort_f(<span class="Type">const</span> <span class="Type">void</span> *func)

{   <span class="Type">int</span> i;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_deregister_abort_f] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(func   == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_abort_funcs_alloc; ++i)
    {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_abort_f[i] == func)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS abort function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%018x</span><span class="Constant"> virtual) at slot </span><span class="Special">%d</span><span class="Constant"> deregistered</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                            date,
                                                                                                                       appl_name,
                                                                                                                        appl_pid,
                                                                                                                       appl_host,
                                                                                                                      appl_owner,
                                                                                                            pups_abort_f_name[i],
                                                                                              (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_abort_f[i],
                                                                                                                               i);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          pups_abort_f[i] = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
          (<span class="Type">void</span>)strlcpy(pups_abort_f_name[i],<span class="Constant">&quot;&quot;</span>,SSIZE);

          <span class="Statement">if</span>(pups_abort_arg[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
             (<span class="Type">void</span>)strlcpy(pups_abort_arg[i],<span class="Constant">&quot;&quot;</span>,SSIZE);

          --n_abort_funcs;

          pups_set_errno(OK);
          <span class="Statement">return</span>(PUPS_OK);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(PUPS_ERROR);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Show PUPS abort functions ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_abort_f(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[show_pups_abort_f] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    <span class="Statement">if</span>(n_abort_funcs == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    No abort functions registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_abort_funcs_alloc);
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Abort functions registered</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ==========================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_abort_funcs_alloc; ++i)
       {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_abort_f[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                           pups_abort_f_name[i],
                                             (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_abort_f[i]);
             (<span class="Type">void</span>)fflush(stream);
          }
       }

       <span class="Statement">if</span>(n_abort_funcs &gt; <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> abort functions registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,n_abort_funcs,n_abort_funcs_alloc - n_abort_funcs);
       <span class="Statement">else</span> <span class="Statement">if</span>(n_abort_funcs == <span class="Constant">1</span>)
          (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> abort function registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,n_abort_funcs_alloc - <span class="Constant">1</span>);

       (<span class="Type">void</span>)fflush(stream);
    }

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    Free application information string ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> pups_free_appl_strings(<span class="Type">void</span>)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(version != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">char</span> *)version);

    <span class="Statement">if</span>(appl_owner != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_owner);

    <span class="Statement">if</span>(appl_password != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_password);

    <span class="Statement">if</span>(appl_crypted != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_crypted);

    <span class="Statement">if</span>(appl_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_name);

    <span class="Statement">if</span>(appl_remote_host != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_remote_host);

    <span class="Statement">if</span>(appl_fifo_dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_fifo_dir);

    <span class="Statement">if</span>(appl_ch_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_ch_name);

    <span class="Statement">if</span>(appl_logfile != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_logfile);

<span class="PreProc">    #ifdef MAIL_SUPPORT</span>
    <span class="Statement">if</span>(appl_mdir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_mdir);

    <span class="Statement">if</span>(appl_mh_folder != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_mh_folder);

    <span class="Statement">if</span>(appl_mime_dir != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_mime_dir);

    <span class="Statement">if</span>(appl_replyto != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_replyto);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_tunnel_path != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_tunnel_path);

    <span class="Statement">if</span>(appl_bin_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_bin_name);

    <span class="Statement">if</span>(appl_ttyname != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_ttyname);

    <span class="Statement">if</span>(appl_pam_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_pam_name);

    <span class="Statement">if</span>(author != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)revdate);

    <span class="Statement">if</span>(arg_f_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)arg_f_name);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">255</span>; ++i)
    {  <span class="Statement">if</span>(args[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)args[i]);
    }

    <span class="Statement">if</span>(appl_home != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_home);

    <span class="Statement">if</span>(appl_cwd != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_cwd);

    <span class="Statement">if</span>(appl_host != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_host);

    <span class="Statement">if</span>(appl_state != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_state);

    <span class="Statement">if</span>(appl_err != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)appl_err);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span>
<span class="Comment">    PUPS exit function ...</span>
<span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_exit(<span class="Type">const</span> <span class="Type">int</span> exit_code)

{   <span class="Type">int</span>  i,
         lfl_cnt;

    <span class="Type">char</span> tunnel_f_name   [SSIZE] = <span class="Constant">&quot;&quot;</span>,
         symlink_pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Type">int</span> retval;


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have been called by a thread </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> terminate that thread and not the  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> entire PUPS?P3 server              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  pthread_t tid;
          <span class="Type">char</span>      tfuncname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          tid = pthread_self();
          (<span class="Type">void</span>)pupsthread_tid2tfuncname(tid,tfuncname);
          (<span class="Type">void</span>)strdate(date);

          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): thead </span><span class="Special">%016lx</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) exiting</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                  date,appl_name,appl_pid,appl_host,appl_owner,
                                              (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)tid,tfuncname);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)pupsthread_exit(&amp;retval);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> CLear alarm for virtual timer systems </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and block signals                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_malarm(<span class="Constant">0</span>);
    (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove pen symlink (if any) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(symlink_pathname,SSIZE,<span class="Constant">&quot;/tmp/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_name);
    (<span class="Type">void</span>)unlink(symlink_pathname);


<span class="PreProc">    #ifdef CRIU_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove (Criu) saved state (if state saving enabled) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_ssave == TRUE)
       pups_ssave_disable();
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Execute registered PUPS exit functions </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;n_exit_funcs_alloc; ++i)
    {  <span class="Statement">if</span>((<span class="Type">void</span> *)pups_exit_f[i] != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): executing exit function </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> (slot </span><span class="Special">%d</span><span class="Constant"> at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                 date,
                                                                                                            appl_name,
                                                                                                   appl_pid,appl_host,
                                                                                                           appl_owner,
                                                                                                  pups_exit_f_name[i],
                                                                                                                    i,
                                                                                    (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)pups_exit_f[i]);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          (*pups_exit_f[i])(pups_exit_arg[i]);
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are in PSRP mode clear channels </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(psrp_mode == TRUE)
       psrp_exit();


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Workaround bug in RedHat 6.0/egcs-1.1.2 which cause problems </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> with data transmission down FIFOS's                          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> CLear all active link file locks </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    lfl_cnt = pups_release_all_link_file_locks();

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(lfl_cnt &gt; <span class="Constant">0</span>)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> link file locks released</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner,lfl_cnt);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): no link file locks to release</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): executing standard exit functions</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Detach all fast caches </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    cache_exit();


<span class="PreProc">    #ifdef PERSISTENT_HEAP_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have persistent heaps attached -- detach them now </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    msm_exit(<span class="Constant">0</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PERSISTENT_HEAP_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Close all files </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_closeall();

    vt_no_reset = TRUE;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_vtimers; ++i)
    {  <span class="Statement">if</span>(vttab[i].priority &gt; <span class="Constant">0</span>)
          (<span class="Type">void</span>)pups_clearvitimer(vttab[i].name);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search file table removing all FIFO's  and lockposts created by this application </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Deal with stdio                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Deal with the rest of the file table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Only remove files we have actually created </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(i &lt; <span class="Constant">3</span> || ftab[i].creator == TRUE)
       {  <span class="Type">struct</span> stat buf;


          <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Is this a named file or FIFO? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(i &lt; <span class="Constant">3</span> || ftab[i].named == TRUE)
          {

             <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Is next file a FIFO or a pty? </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)fstat(ftab[i].fdes,&amp;buf);
             <span class="Statement">if</span>(isatty(ftab[i].fdes) == <span class="Constant">1</span> || S_ISFIFO(buf.st_mode) || strcmp(ftab[i].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) == <span class="Constant">0</span>)
             {  <span class="Type">char</span> fname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

                (<span class="Type">void</span>)sscanf(ftab[i].fname,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">&quot;</span>,fname,fname);
                fname[strlen(fname)-<span class="Constant">1</span>] =<span class="Special">'\0'</span>;

                <span class="Statement">if</span>(appl_verbose == TRUE )
                {  (<span class="Type">void</span>)strdate(date);
                   <span class="Statement">if</span>(strcmp(ftab[i].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) == <span class="Constant">0</span>)

                      <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> File is a lockpost symlink </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

                      (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): removing lockpost TTY symlink (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                 date,appl_name,appl_pid,appl_host,appl_owner,fname);
                   <span class="Statement">else</span> <span class="Statement">if</span>(isatty(ftab[i].fdes) == <span class="Constant">1</span>)
                      (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): removing PTY (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                    date,appl_name,appl_pid,appl_host,appl_owner,fname);
                   <span class="Statement">else</span>

                      <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment"> File is a FIFO </span><span class="Comment">*/</span>
                      <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

                      (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): removing FIFO (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                    date,appl_name,appl_pid,appl_host,appl_owner,fname);

                   (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
                }


                <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Make sure that we do not remove /dev/tty        </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> this is possible if application is runnning as  </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> suid root and we do not protect /dev/tty with   </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> a guard link                                    </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

                <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                {  <span class="Statement">if</span>(strcmp(ftab[i].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) == <span class="Constant">0</span>)
                      (<span class="Type">void</span>)link(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;/dev/ttyprot&quot;</span>);
                }


                <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Remove the file </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

                (<span class="Type">void</span>)unlink(ftab[i].fname);


                <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment"> Remove shadow file </span><span class="Comment">*/</span>
                <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

                (<span class="Type">void</span>)unlink(ftab[i].fshadow);

                <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                {  <span class="Statement">if</span>(strcmp(ftab[i].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) == <span class="Constant">0</span>)
                      (<span class="Type">void</span>)rename(<span class="Constant">&quot;/dev/ttyprot&quot;</span>,<span class="Constant">&quot;/dev/tty&quot;</span>);
                }
             }
          }
       }
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%d</span><span class="Constant"> application specific exit function(s) to execute</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                date,appl_name,appl_pid,appl_host,appl_owner,n_exit_funcs);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove file table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    ftab = (ftab_type *)pups_free((<span class="Type">void</span> *)ftab);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove child table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    chtab = (chtab_type *)pups_free((<span class="Type">void</span> *)chtab);


<span class="PreProc">    #ifdef MAIL_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove process mailbox </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_mailable == TRUE)
    {  <span class="Type">char</span> rm_command[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)unlink(appl_mdir);
       (<span class="Type">void</span>)unlink(appl_mime_dir);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process mailbox removed</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> MAIL_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are part of a pipeline and we have a problem terminate </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the pipeline unless connected to a terminal                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_kill_pg == TRUE &amp;&amp; exit_code &lt; <span class="Constant">0</span> &amp;&amp; (isatty(<span class="Constant">0</span>) == <span class="Constant">0</span> || isatty(<span class="Constant">1</span>) == <span class="Constant">0</span>))
    {   <span class="Statement">if</span>(appl_verbose == TRUE)
        {  (<span class="Type">void</span>)strdate(date);
           (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): pipeline </span><span class="Special">%d</span><span class="Constant"> terminated (exit code </span><span class="Special">%d</span><span class="Constant"> for filter </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                               date,appl_name,appl_pid,appl_host,appl_owner,getpgrp(),exit_code,appl_name);
           (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
        }

        (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGTERM</span>);
    }

    <span class="Statement">if</span>(exit_code == PIPESTREAM_DETACH)
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">d </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): overlaying process with xcat filter (to seal pipeline)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)pups_execls(<span class="Constant">&quot;xcat&quot;</span>);

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">d </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): failed to overlay xcat filter (and seal pipeline)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                           date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       _exit(<span class="Constant">255</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If this is a tunnel process remove (stale) tunnel endpoints in /tmp </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove body tunnel endpoint                                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_tunnel_path != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; access(appl_tunnel_path,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
    {  <span class="Type">char</span> tunnel_context_dir[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)unlink(appl_tunnel_path);


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Remove context tunnel endpoint </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(tunnel_context_dir,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.ckpt.dir&quot;</span>,appl_tunnel_path);
       <span class="Statement">if</span>(access(tunnel_context_dir,F_OK | R_OK | W_OK) != (-<span class="Constant">1</span>))
       {  <span class="Type">char</span> rm_command[SSIZE] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)snprintf(rm_command,SSIZE,<span class="Constant">&quot;rm -rf </span><span class="Special">%s</span><span class="Constant">&quot;</span>,tunnel_context_dir);
          (<span class="Type">void</span>)system(rm_command);
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Free information strings for this server </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    pups_free_appl_strings();


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restart process if it is resident </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_resident == TRUE)
       longjmp(appl_resident_restart,<span class="Constant">1</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restore signal handlers if deferred) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(exit_code == PUPS_DEFER_EXIT)
    {  (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);
       (<span class="Type">void</span>)pups_malarm(vitimer_quantum);
    }


    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Really exit </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       _exit(exit_code);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Build a table of entries in the current directory ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> **pups_get_directory_entries(<span class="Type">const</span> <span class="Type">char</span> *dir_name,
                                          <span class="Type">const</span> <span class="Type">char</span> *key,
                                          <span class="Type">int</span>        *key_entries,
                                          <span class="Type">int</span>        *max_entries)

{   <span class="Type">DIR</span>           *dirp      = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> stat   buf;
    <span class="Type">char</span>          ** entries = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(dir_name    == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       key         == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       key_entries == (<span class="Type">int</span> *)       <span class="Constant">NULL</span>  ||
       max_entries == (<span class="Type">int</span> *)       <span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Scan directory for leaves (normal files) stalks (other directories within the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> current directory being scanned are simply ignored).                          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((dirp = opendir(dir_name)) == (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
    }

    (<span class="Type">void</span>)rewinddir(dirp);

    *key_entries = <span class="Constant">0</span>;
    *max_entries = ALLOC_QUANTUM;
    entries      = (<span class="Type">char</span> **)pups_calloc((*max_entries),<span class="Statement">sizeof</span>(<span class="Type">char</span> *));

    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {

         <span class="Statement">if</span>(strin(next_item-&gt;d_name,key) == TRUE)
         {  <span class="Type">char</span> pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

            (<span class="Type">void</span>)snprintf(pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,dir_name,next_item-&gt;d_name);
            (<span class="Type">void</span>)stat(pathname,&amp;buf);

            <span class="Statement">if</span>(buf.st_mode &amp; S_IFREG || buf.st_mode &amp; S_IFIFO || buf.st_mode &amp; S_IFLNK)
            {  <span class="Statement">if</span>((*key_entries)%ALLOC_QUANTUM == <span class="Constant">0</span> &amp;&amp; (*key_entries) &gt; <span class="Constant">0</span>)
               {  (*max_entries) += ALLOC_QUANTUM;
                  entries        =  (<span class="Type">char</span> **)pups_realloc((<span class="Type">void</span> *)entries,(*max_entries)*<span class="Statement">sizeof</span>(<span class="Type">char</span> *));
               }

               entries[(*key_entries)] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
               (<span class="Type">void</span>)strlcpy(entries[(*key_entries)],next_item-&gt;d_name,SSIZE);
               ++(*key_entries);
            }
         }
    }

    (<span class="Type">void</span>)closedir(dirp);

    pups_set_errno(OK);
    <span class="Statement">return</span>(entries);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Build a table of entries in the current driectory ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN multimatch(<span class="Type">char</span> *target, <span class="Type">int</span> keylist, <span class="Type">char</span> **keys)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(target == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || keylist &lt;= <span class="Constant">0</span> || keys == (<span class="Type">char</span> **)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;keylist; ++i)
    {  <span class="Statement">if</span>(strin(target,keys[i]) == FALSE)
          <span class="Statement">return</span>(FALSE);
    }

    <span class="Statement">return</span>(TRUE);
}


_PUBLIC <span class="Type">char</span> **pups_get_multikeyed_directory_entries(<span class="Type">const</span> <span class="Type">char</span> *dir_name,
                                                     <span class="Type">const</span> <span class="Type">int</span>  keys,
                                                     <span class="Type">const</span> <span class="Type">char</span> **keylist,
                                                     <span class="Type">int</span>        *key_entries,
                                                     <span class="Type">int</span>        *max_entries)

{   <span class="Type">DIR</span>           *dirp      = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> stat   buf;
    <span class="Type">char</span>          ** entries = (<span class="Type">char</span> **)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(dir_name    == (<span class="Type">const</span> <span class="Type">char</span> *) <span class="Constant">NULL</span>   ||
       keylist     == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>   ||
       key_entries == (<span class="Type">int</span> *)        <span class="Constant">NULL</span>   ||
       max_entries == (<span class="Type">int</span> *)        <span class="Constant">NULL</span>    )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Scan directory for leaves (normal files) stalks (other directories within the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> current directory being scanned are simply ignored).                          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((dirp = opendir(dir_name)) == (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> **)<span class="Constant">NULL</span>);
    }

    (<span class="Type">void</span>)rewinddir(dirp);

    *key_entries = <span class="Constant">0</span>;
    *max_entries = ALLOC_QUANTUM;
    entries = (<span class="Type">char</span> **)pups_calloc((*max_entries),<span class="Statement">sizeof</span>(<span class="Type">char</span> *));

    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {    <span class="Statement">if</span>(multimatch(next_item-&gt;d_name,keys,keylist) == TRUE)
         {  <span class="Type">char</span> pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

            (<span class="Type">void</span>)snprintf(pathname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,dir_name,next_item-&gt;d_name);
            (<span class="Type">void</span>)stat(pathname,&amp;buf);

            <span class="Statement">if</span>(buf.st_mode &amp; S_IFREG || buf.st_mode &amp; S_IFIFO || buf.st_mode &amp; S_IFLNK)
            {  <span class="Statement">if</span>((*key_entries)%ALLOC_QUANTUM == <span class="Constant">0</span> &amp;&amp; (*key_entries) &gt; <span class="Constant">0</span>)
               {  (*max_entries) += ALLOC_QUANTUM;
                  entries        =  (<span class="Type">char</span> **)pups_realloc((<span class="Type">void</span> *)entries,(*max_entries)*<span class="Statement">sizeof</span>(<span class="Type">char</span> *));
               }

               entries[(*key_entries)] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
               (<span class="Type">void</span>)strlcpy(entries[(*key_entries)],next_item-&gt;d_name,SSIZE);
               ++(*key_entries);
            }
         }
    }

    closedir(dirp);

    pups_set_errno(OK);
    <span class="Statement">return</span>(entries);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Extended read is automatically restarted after interrupted system</span>
<span class="Comment">    call ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pups_sread(<span class="Type">const</span> <span class="Type">int</span> fildes, <span class="Type">char</span> *data, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> ret,
                      eff_size,
                      bytes_read = <span class="Constant">0</span>;

    <span class="Statement">if</span>(data == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    eff_size = size;
    <span class="Statement">do</span> {   ret = read(fildes,(<span class="Type">char</span> *)&amp;data[bytes_read],eff_size);

           <span class="Statement">if</span>(ret &gt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">EINTR</span>)
           {  bytes_read += ret;
              eff_size   -= ret;
           }

       } <span class="Statement">while</span>(errno == <span class="Constant">EINTR</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(bytes_read);
}





<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Extended read is automatically restarted after interrupted system</span>
<span class="Comment">    call ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pups_swrite(<span class="Type">const</span> <span class="Type">int</span> fildes, <span class="Type">const</span> <span class="Type">char</span> *data, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> ret,
                      eff_size,
                      bytes_written = <span class="Constant">0</span>;

    <span class="Statement">if</span>(data == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    eff_size = size;
    <span class="Statement">do</span> {   ret = write(fildes,(<span class="Type">char</span> *)&amp;data[bytes_written],eff_size);

           <span class="Statement">if</span>(ret &gt; <span class="Constant">0</span> &amp;&amp; errno != <span class="Constant">EINTR</span>)
           {  bytes_written += ret;
              eff_size -= bytes_written;
           }

       } <span class="Statement">while</span>(errno == <span class="Constant">EINTR</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(bytes_written);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Broadcast TERM signal to process group ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> pg_leaders_term_handler(<span class="Type">const</span> <span class="Type">int</span> sig)

{   _IMMORTAL _BOOLEAN entered = FALSE;

    <span class="Type">void</span> (*func)(<span class="Type">void</span>);

    <span class="Statement">if</span>(entered == FALSE)
    {  entered = TRUE;

       <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant">'s process group terminated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                            date,appl_name,appl_pid,appl_host,appl_owner,appl_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
    <span class="Statement">else</span>

       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We get here as a result of sending TERM to our process group </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> of which we are (the leading!) member                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

       _exit(-sig);

    (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGTERM</span>);


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Evict process (if resident) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_resident == TRUE)
    {  appl_resident = FALSE;
       (<span class="Type">void</span>)unlink(appl_argfifo);
    }

    pups_exit(-sig);
}



<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Broadcast STOP signal to process group ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> pg_leaders_stop_handler(<span class="Type">int</span> sig)

{   _IMMORTAL _BOOLEAN entered = FALSE;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process group stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                     date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    <span class="Statement">if</span>(entered == FALSE)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;*** </span><span class="Special">%s</span><span class="Constant">'s process group stopped</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_name);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Distribute signal to process group. Note that we have to </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> make sure that we are aware that the next SIGTSTP we get </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> is self generated                                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       entered = TRUE;
       (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGTSTP</span>);
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> This is the SIGTSTP we have propagated. We must signal ourselves </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> at this point                                                    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

       entered = FALSE;
       (<span class="Type">void</span>)kill(appl_pid,<span class="Constant">SIGSTOP</span>);
    }

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Broadcast CONT signal to process group ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> pg_leaders_cont_handler(<span class="Type">int</span> signum)

{   _IMMORTAL _BOOLEAN continuing = FALSE;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure we don't catch our own signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(continuing == TRUE)
    {  continuing = FALSE;
       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGCONT</span>,<span class="Constant">&quot;pg_leaders_cont_handler&quot;</span>,(<span class="Type">void</span> *)pg_leaders_cont_handler, (sigset_t *)<span class="Constant">NULL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): process group restarted</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                             date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    continuing = TRUE;
    appl_wait  = FALSE;

    (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGCONT</span>);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Handler for SIGCONT (for processes other than process group leader) ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> pups_cont_handler(<span class="Type">int</span> signum)

{   appl_wait  = FALSE;
    <span class="Statement">return</span>(psrp_cont_handler(signum));
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------</span>
<span class="Comment">    Process SIGTERM ...</span>
<span class="Comment">-----------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> pups_exit_handler(<span class="Type">int</span> sig)

{   _IMMORTAL _BOOLEAN pups_exit_handler_entered = FALSE;

    <span class="Statement">if</span>(pups_exit_handler_entered == TRUE)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    <span class="Statement">else</span>
       pups_exit_handler_entered = TRUE;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>, <span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): in exit handler</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                      date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Evict process (if resident) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_resident == TRUE)
    {  appl_resident = FALSE;
       (<span class="Type">void</span>)unlink(appl_argfifo);
    }

    pups_exit(-sig);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Mark re-entry point for SIGRESTART ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


_PUBLIC <span class="Type">int</span> pups_restart_enable(<span class="Type">void</span>)

{   <span class="Type">int</span> ret;

    <span class="Statement">if</span>(pups_abort_restart == FALSE)
    {  pups_abort_restart = TRUE;
       (<span class="Type">void</span>)pups_sighandle(SIGRESTART,<span class="Constant">&quot;pups_restart_handler&quot;</span>,(<span class="Type">void</span> *)&amp;pups_restart_handler,(sigset_t *)<span class="Constant">NULL</span>);
    }

    ret = sigsetjmp(pups_restart_buf,<span class="Constant">1</span>);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Disable abort restart ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_restart_disable(<span class="Type">void</span>)

{   pups_set_errno(OK);

    <span class="Statement">if</span>(pups_abort_restart == TRUE)
    {  pups_abort_restart = FALSE;
       (<span class="Type">void</span>)pups_sighandle(SIGRESTART,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>,(sigset_t *)<span class="Constant">NULL</span>);

        <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Process SIGRESTART -- if signal recived siglongjmp to a &quot;known&quot; re-entry</span>
<span class="Comment">    point ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> pups_restart_handler(<span class="Type">int</span> sig)

{   siglongjmp(pups_restart_buf,<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Search path directories for a given command ...</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *pups_search_path(<span class="Type">const</span> <span class="Type">char</span> *pathtype, <span class="Type">const</span> <span class="Type">char</span> *item)

{   <span class="Type">int</span> ret;

    <span class="Type">char</span> cwd[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         next_path[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         path_list[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    _IMMORTAL <span class="Type">char</span> item_path[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Statement">if</span>(pathtype == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || item == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB ITEM </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do we have absolute path to current item? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(item[<span class="Constant">0</span>] == <span class="Constant">'/'</span> &amp;&amp; access(item,F_OK | X_OK) != (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB </span><span class="Special">%s</span><span class="Constant">: CWD RETURN PATH ABSOLUTE </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item,item);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(item);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Is the command in the current directory? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)getcwd(cwd,SSIZE);

    <span class="Statement">if</span>(strncmp(item,<span class="Constant">&quot;./&quot;</span>,<span class="Constant">2</span>) == <span class="Constant">0</span>)
       (<span class="Type">void</span>)snprintf(item_path,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,cwd,(<span class="Type">char</span> *)&amp;item[<span class="Constant">2</span>]);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(item_path,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,cwd,item);


<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB ITEM PATH </span><span class="Special">%s</span><span class="Constant"> (access </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item_path,access(item_path,F_OK | X_OK));
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(item_path,F_OK | X_OK) != (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB </span><span class="Special">%s</span><span class="Constant">: CWD RETURN PATH LOCAL </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item,item_path);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(item_path);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If pathtype is not a valid environmental variable </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> return immediately                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strccpy(path_list,(<span class="Type">char</span> *)getenv(pathtype)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }

    (<span class="Type">void</span>)strext(<span class="Constant">':'</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


    <span class="Statement">do</span> {    ret = strext(<span class="Constant">':'</span>,next_path,path_list);
            (<span class="Type">void</span>)snprintf(item_path,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,next_path,item);

<span class="PreProc">            #ifdef UTILIB_DEBUG</span>
            (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB PATH </span><span class="Special">%s</span><span class="Constant"> ACC: </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item_path,access(item_path,F_OK | X_OK));
            (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">            #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

            <span class="Statement">if</span>(access(item_path,F_OK | X_OK) != (-<span class="Constant">1</span>))
            {  (<span class="Type">void</span>)strext(<span class="Constant">':'</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);

<span class="PreProc">               #ifdef UTILIB_DEBUG</span>
               (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB </span><span class="Special">%s</span><span class="Constant">: RETURN PATH </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item,item_path);
               (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">               #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

               pups_set_errno(OK);
               <span class="Statement">return</span>(item_path);
           }
       } <span class="Statement">while</span>(ret != END_STRING);

<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB </span><span class="Special">%s</span><span class="Constant">: RETURN PATH NULL</span><span class="Special">\n</span><span class="Constant">&quot;</span>,item);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ENOENT</span>);
    <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Make a local link to an executable and then run it - this causes a process</span>
<span class="Comment">    to change its name in the process table ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_set_pen(<span class="Type">const</span> <span class="Type">char</span> *argv[], <span class="Type">const</span> <span class="Type">char</span> *ben_name, <span class="Type">const</span> <span class="Type">char</span> *pen_name)

{   <span class="Type">int</span>  pid;

    <span class="Type">char</span> exec_pathname   [SSIZE] = <span class="Constant">&quot;&quot;</span>,
         symlink_pathname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(argv     == (<span class="Type">const</span> <span class="Type">char</span> **)<span class="Constant">NULL</span>  ||
       ben_name == (<span class="Type">const</span> <span class="Type">char</span> *) <span class="Constant">NULL</span>  ||
       pen_name == (<span class="Type">const</span> <span class="Type">char</span> *) <span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if command already has an absolute path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strncmp(ben_name,<span class="Constant">&quot;..&quot;</span>,<span class="Constant">2</span>) != <span class="Constant">0</span> &amp;&amp; strncmp(ben_name,<span class="Constant">&quot;.&quot;</span>,<span class="Constant">1</span>) != <span class="Constant">0</span> &amp;&amp; ben_name[<span class="Constant">0</span>] != <span class="Constant">'/'</span>)
    {  <span class="Statement">if</span>(strccpy(exec_pathname,pups_search_path(<span class="Constant">&quot;PATH&quot;</span>,ben_name)) == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          pups_error(<span class="Constant">&quot;[set_pen] failed to resolve ben path&quot;</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Absolute path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(exec_pathname,ben_name,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure process calls itself by its pen </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> not its ben                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>


    (<span class="Type">void</span>)snprintf(symlink_pathname,SSIZE,<span class="Constant">&quot;/tmp/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,pen_name);
    (<span class="Type">void</span>)symlink(exec_pathname,symlink_pathname);

<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB PEN EXEC PATH </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,exec_pathname);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

    <span class="Type">int</span> i;
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">255</span>; ++i)
    {  <span class="Statement">if</span>(argv[i] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          <span class="Statement">break</span>;
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB argv[</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,argv[i]);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)execv(symlink_pathname,argv);
    pups_error(<span class="Constant">&quot;[pups_set_pen] exec failed&quot;</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span>
<span class="Comment">    Pread routine - blocks correctly on pipe ...</span>
<span class="Comment">          </span>
<span class="Comment">    Copyright (C) 1982 Michael Landy, Yoav Cohen, and George Sperling</span>
<span class="Comment">          </span>
<span class="Comment">    Disclaimer:  No guarantees of performance accompany this software,          </span>
<span class="Comment">    nor is any responsibility assumed on the part of the authors.  All the      </span>
<span class="Comment">    software has been tested extensively and every effort has been made to</span>
<span class="Comment">    insure its reliability.</span>

<span class="Comment">    * pipe_read.c - read subroutine which waits for its input count or EOF</span>
<span class="Comment">    *              </span>
<span class="Comment">    * For use with pipes, which return on read with that which is available      </span>
<span class="Comment">    * rather than that which is requested.</span>
<span class="Comment">    *                                                                            </span>
<span class="Comment">    * Michael Landy - 4/30/82</span>
<span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pups_pipe_read(<span class="Type">const</span> <span class="Type">int</span> fd, <span class="Type">void</span> *buf, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> count)

{   <span class="Type">int</span> cnt,
        r;

    <span class="Statement">if</span>(buf == (<span class="Type">void</span> *)<span class="Constant">NULL</span> || fd &lt; <span class="Constant">0</span> || count &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    cnt = count;
    <span class="Statement">while</span> (cnt &gt; <span class="Constant">0</span>)
    {

        <span class="Statement">if</span>((r = read(fd,buf,cnt)) == <span class="Constant">0</span>)
           <span class="Statement">break</span>;

        buf  = (<span class="Type">void</span> *)((<span class="Type">long</span>)buf + r);
        cnt -= r;
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(count - cnt);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">   Routine to block specified signal ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>


_PRIVATE _BOOLEAN in_pupshold = FALSE;

_PRIVATE sigset_t set,
                  old_set;

_PUBLIC <span class="Type">int</span> pupsighold(<span class="Type">const</span> <span class="Type">int</span> signum, <span class="Type">const</span> _BOOLEAN defer)

{   sigset_t  set;

    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS || (defer != FALSE &amp;&amp; defer != TRUE))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are handling a virtual timer event blocking signals </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is irrelevant as we are already in the signal handler     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure we only suspend the signal the first time the   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> routine is (recursively) called                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_vt_handler == TRUE || in_psrp_handler == TRUE || in_chan_handler == TRUE)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    <span class="Statement">if</span>(in_pupshold == FALSE)
    {  (<span class="Type">void</span>)sigfillset(&amp;set);
       (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,&amp;old_set);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsighold_cnt[signum] &lt; <span class="Constant">0</span>)
       pups_error(<span class="Constant">&quot;[pupsighold] pupsighold/pupsigrelse count mismatch&quot;</span>);

    <span class="Statement">if</span>(pupsighold_cnt[signum] &gt; <span class="Constant">0</span>)
    {  ++pupsighold_cnt[signum];

       <span class="Statement">if</span>(in_pupshold == FALSE)
         (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }
    <span class="Statement">else</span>
       pupsighold_cnt[signum] = <span class="Constant">1</span>;

    <span class="Statement">if</span>(defer == FALSE)
    {  (<span class="Type">void</span>)sigpending(&amp;set);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If this signal is pending we must guarantee its delivery before </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> sighold exits                                                   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(defer == FALSE &amp;&amp; sigismember(&amp;set,signum) &amp;&amp; sigtab[signum - <span class="Constant">1</span>].haddr != (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_IGN</span>)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Unmask only the target signal (signum) which may be pending    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> and awaits its delivery. We also need to unmask SIGABRT (which </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">  handles PSRP client-server interrupts, SIGARLM which is used  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> by the homeostasis sub-systems, SIGTERM (which terminates the  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> server in an orderly fashion, and SIGCONT (which is used by    </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> PSRP clients to test if the PSRP server is alive               </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)sigemptyset(&amp;set);
          (<span class="Type">void</span>)sigfillset (&amp;set);
          (<span class="Type">void</span>)sigdelset  (&amp;set,signum);
          (<span class="Type">void</span>)sigdelset  (&amp;set,<span class="Constant">SIGALRM</span>);
          (<span class="Type">void</span>)sigdelset  (&amp;set,<span class="Constant">SIGTERM</span>);
          (<span class="Type">void</span>)sigdelset  (&amp;set,<span class="Constant">SIGABRT</span>);
          (<span class="Type">void</span>)sigdelset  (&amp;set,<span class="Constant">SIGCONT</span>);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
	     <span class="Statement">if</span>(signum &lt; NSIG)
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): awaiting delivery of pending signal </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                   date,appl_name,appl_pid,appl_host,appl_owner,signum,signame[signum]);
	     <span class="Statement">else</span>
		fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): awaiting delivery of pending signal </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
				        date,appl_name,appl_pid,appl_host,appl_owner,signum);

             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          (<span class="Type">void</span>)sigsuspend(&amp;set);

          <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): delivered</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if target signal (signum) is pending    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> we must block it to prevent it being serviced before </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> sigsuspend is executed                               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_pupshold == FALSE)
    {  (<span class="Type">void</span>)sigaddset(&amp;old_set,signum);
       (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure that PUPS sigtab is updated </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigaddset(&amp;sigtab[signum].sa_mask,signum);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Block PUPS signals - this is usually called before entering a critical</span>
<span class="Comment">    section of code to postpone PSRP transactions until we are through the</span>
<span class="Comment">    critical section ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pupshold(<span class="Type">const</span> <span class="Type">int</span> sigs_to_hold)

{   sigset_t set;

    <span class="Statement">if</span>(sigs_to_hold != PSRP_SIGS &amp;&amp; sigs_to_hold != ALL_PUPS_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we handling a virtual timer or pupsighold() has been called </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> recursively and pupsighold_cnt &gt; 0  don't unblock signal       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_vt_handler == TRUE || in_psrp_handler == TRUE || in_chan_handler == TRUE)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)sigfillset(&amp;set);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_BLOCK,&amp;set,&amp;old_set);
    in_pupshold = TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupshold_cnt &lt; <span class="Constant">0</span>)
       pups_error(<span class="Constant">&quot;[pupshold] puphold/pupsrelse count mismatch&quot;</span>);

    <span class="Statement">if</span>(pupshold_cnt &gt; <span class="Constant">0</span>)
    {  ++pupshold_cnt;
       (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

       in_pupshold = FALSE;

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pupshold_cnt = <span class="Constant">1</span>;

    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

    <span class="Statement">if</span>(sigs_to_hold == ALL_PUPS_SIGS)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Note we must defer SIGALRM before any other signal or </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> it may be caught within a signal handler for another  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> signal which could be fatal.                          </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pupsighold(<span class="Constant">SIGALRM</span>,  TRUE);
       (<span class="Type">void</span>)pupsighold(<span class="Constant">SIGCHLD</span>,  TRUE);
    }

    <span class="Statement">if</span>(sigs_to_hold == ALL_PUPS_SIGS || ignore_pups_signals == TRUE)
    {  (<span class="Type">void</span>)pupsighold(SIGINIT,  TRUE);
       (<span class="Type">void</span>)pupsighold(SIGCHAN,  TRUE);
       (<span class="Type">void</span>)pupsighold(SIGPSRP,  TRUE);
       (<span class="Type">void</span>)pupsighold(SIGCLIENT,TRUE);
       (<span class="Type">void</span>)pupsighold(SIGALIVE, TRUE);
    }

    in_pupshold = FALSE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Release blocked PUPS signals ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pupsrelse(<span class="Type">const</span> <span class="Type">int</span> sigs_to_relse)

{   sigset_t set;

    <span class="Statement">if</span>(sigs_to_relse != PSRP_SIGS &amp;&amp; sigs_to_relse != ALL_PUPS_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we handling a virtual timer or pupsighold() has been called </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> recursively and pupsighold_cnt &gt; 0  don't unblock signal       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_vt_handler == TRUE || in_psrp_handler == TRUE || in_chan_handler == TRUE)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigfillset(&amp;set);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,&amp;old_set);

    <span class="Statement">if</span>(pupshold_cnt &lt; <span class="Constant">0</span>)
       pups_error(<span class="Constant">&quot;[pupsrelse] pupshold/pupsrelse count mismatch&quot;</span>);

    <span class="Statement">if</span>(pupshold_cnt &gt; <span class="Constant">1</span>)
    {  --pupshold_cnt;
       (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pupshold_cnt = <span class="Constant">0</span>;
    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

    <span class="Statement">if</span>(sigs_to_relse == ALL_PUPS_SIGS || ignore_pups_signals == FALSE)
    {  (<span class="Type">void</span>)pupsigrelse(SIGINIT);
       (<span class="Type">void</span>)pupsigrelse(SIGCHAN);
       (<span class="Type">void</span>)pupsigrelse(SIGPSRP);
       (<span class="Type">void</span>)pupsigrelse(SIGALIVE);
       (<span class="Type">void</span>)pupsigrelse(SIGCLIENT);
    }

    <span class="Statement">if</span>(sigs_to_relse == ALL_PUPS_SIGS)
    {  (<span class="Type">void</span>)pupsigrelse(<span class="Constant">SIGALRM</span>);
       (<span class="Type">void</span>)pupsigrelse(<span class="Constant">SIGCHLD</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">   Routine to release specified signal (previously blocked with sighold) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pupsigrelse(<span class="Type">const</span> <span class="Type">int</span> signum)

{   sigset_t set;


    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we handling a virtual timer or pupsighold() has been called </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> recursively and pupsighold_cnt &gt; 0  don't unblock signal       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_vt_handler == TRUE || in_psrp_handler == TRUE || in_chan_handler == TRUE)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigfillset(&amp;set);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,&amp;old_set);
    <span class="Statement">if</span>(pupsighold_cnt[signum] &lt; <span class="Constant">0</span>)
    {  <span class="Type">char</span> errstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

       (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[pupsigrelse] pupsighold/pupsigrelse count mismatch [</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">]: </span><span class="Special">%d</span><span class="Constant">&quot;</span>,signame[signum],signum,pupsighold_cnt[signum]);
       pups_error(errstr);
    }

    <span class="Statement">if</span>(pupsighold_cnt[signum] &gt; <span class="Constant">1</span>)
    {  --pupsighold_cnt[signum];
       (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }
    <span class="Statement">else</span>
       pupsighold_cnt[signum] = <span class="Constant">0</span>;
    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Unblock the signal </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;set);
    (<span class="Type">void</span>)sigaddset(&amp;set,signum);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_UNBLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure PUPS sigtab is updated </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigdelset(&amp;sigtab[signum].sa_mask,signum);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}





<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    PUPS signal handling facilties: reinstalls signal handler automatically on</span>
<span class="Comment">    call, blocks all signals during call, and restarts slow system calls if</span>
<span class="Comment">    handler called while they are running ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_sighandle(<span class="Type">const</span> <span class="Type">int</span> signum, <span class="Type">const</span> <span class="Type">char</span> *handler_name, <span class="Type">const</span> <span class="Type">void</span> *handler, <span class="Type">const</span> sigset_t *handler_mask)

{   <span class="Type">int</span>    ret;
    <span class="Type">struct</span> sigaction action;

    <span class="Statement">if</span>(signum       &lt;  <span class="Constant">1</span>                       ||
       signum       &gt;  MAX_SIGS                ||
       handler_name == (<span class="Type">const</span> <span class="Type">char</span> *)    <span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(handler_mask == (<span class="Type">const</span> sigset_t *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)sigemptyset(&amp;action.sa_mask);
    <span class="Statement">else</span>
       action.sa_mask = *handler_mask;

    action.sa_handler         = handler;
    action.sa_flags           = SA_RESTART;

    sigtab[signum].haddr    = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)handler;
    sigtab[signum].sa_mask  = action.sa_mask;
    sigtab[signum].sa_flags = action.sa_flags;

    <span class="Statement">if</span>(handler_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
      (<span class="Type">void</span>)strlcpy(sigtab[signum].hname,handler_name,SSIZE);

    ret = sigaction(signum,&amp;action,(<span class="Type">struct</span> sigaction *)<span class="Constant">NULL</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Save a PUPS signal table entry ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_sigtabsave(<span class="Type">const</span> <span class="Type">int</span> signum, sigtab_type *sigtab_entry)

{
    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS || sigtab_entry == (<span class="Type">const</span> sigtab_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    *sigtab_entry = sigtab[signum - <span class="Constant">1</span>];

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Restore a PUPS signal table entry (and re-install handler) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_sigtabrestore(<span class="Type">const</span> <span class="Type">int</span> signum, <span class="Type">const</span> sigtab_type *sigtab_entry)

{   <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS || sigtab_entry == (<span class="Type">const</span> sigtab_type *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sighandle(signum,sigtab_entry-&gt;hname,(<span class="Type">void</span> *)sigtab_entry-&gt;haddr,&amp;sigtab_entry-&gt;sa_mask);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Suspend process until specified signal recieved ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_signalpause(<span class="Type">const</span> <span class="Type">int</span> signum)

{   <span class="Type">int</span>      ret;
    sigset_t set;

    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

    (<span class="Type">void</span>)sigfillset(&amp;set);
    (<span class="Type">void</span>)sigdelset(&amp;set,signum);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure standard PUPS signals are not blocked </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigdelset(&amp;set,<span class="Constant">SIGTERM</span>);
    (<span class="Type">void</span>)sigdelset(&amp;set,SIGALIVE);
    (<span class="Type">void</span>)sigdelset(&amp;set,<span class="Constant">SIGALRM</span>);
    (<span class="Type">void</span>)sigdelset(&amp;set,<span class="Constant">SIGCONT</span>);

    <span class="Statement">if</span>((ret = sigsuspend(&amp;set)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(ret);

    (<span class="Type">void</span>)pups_malarm(vitimer_quantum);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if given signal is pending ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_signalpending(<span class="Type">const</span> <span class="Type">int</span> signum)

{   sigset_t set;

    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }
    <span class="Statement">else</span>
       pups_set_errno(OK);

    (<span class="Type">void</span>)sigpending(&amp;set);
    <span class="Statement">if</span>(sigismember(&amp;set,signum))
       <span class="Statement">return</span>(TRUE);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Initialise signal status ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> initsigstatus(<span class="Type">void</span>)

{   <span class="Type">int</span> i;


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;=MAX_SIGS; ++i)
    {  <span class="Statement">if</span>(i+<span class="Constant">1</span> == <span class="Constant">SIGTTIN</span>   ||
          i+<span class="Constant">1</span> == <span class="Constant">SIGTTOU</span>   ||
          i+<span class="Constant">1</span> == SIGIO     ||
          i+<span class="Constant">1</span> == SIGWINCH  ||
          i+<span class="Constant">1</span> == SIGURG    ||
          i+<span class="Constant">1</span> == <span class="Constant">SIGCONT</span>   ||
          i+<span class="Constant">1</span> == <span class="Constant">SIGCHLD</span>    )
       {  sigtab[i].haddr    = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_IGN</span>;
          (<span class="Type">void</span>)strlcpy(sigtab[i].hname,<span class="Constant">&quot;ignored&quot;</span>,SSIZE);
       }
       <span class="Statement">else</span>
       {  sigtab[i].haddr    = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_DFL</span>;
          (<span class="Type">void</span>)strlcpy(sigtab[i].hname,<span class="Constant">&quot;default&quot;</span>,SSIZE);
       }

       sigtab[i].sa_flags = <span class="Constant">0</span>;
       (<span class="Type">void</span>)sigemptyset(&amp;sigtab[i].sa_mask);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">     Status of signals ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_sigstatus(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        handlers_installed = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_sigstatus] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Signal handler status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =====================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;=MAX_SIGS; ++i)
    {  <span class="Statement">if</span>(sigtab[i].haddr == (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_IGN</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-16s</span><span class="Constant"> (</span><span class="Special">%02d</span><span class="Constant">): ignored</span><span class="Special">\n</span><span class="Constant">&quot;</span>,signame[i],i);
          (<span class="Type">void</span>)fflush(stream);

          ++handlers_installed;
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(sigtab[i].haddr != (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_DFL</span>)
          {  (<span class="Type">void</span>)fprintf(stream,
                     <span class="Constant">&quot;    </span><span class="Special">%-16s</span><span class="Constant"> (</span><span class="Special">%02d</span><span class="Constant">): re-entrant handler at </span><span class="Special">%016lx</span><span class="Constant"> virtual&quot;</span>,
                              signame[i],i,(<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)sigtab[i].haddr);

             <span class="Statement">if</span>(sigtab[i].hname != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot; (</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,sigtab[i].hname);
             <span class="Statement">else</span>
                (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">&quot;</span>);

             (<span class="Type">void</span>)fflush(stream);

             ++handlers_installed;
          }
       }
    }

    <span class="Statement">if</span>(handlers_installed == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Default signal handling (for all signals)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(handlers_installed == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> signals, non default handler installed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_SIGS);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> signals, </span><span class="Special">%04d</span><span class="Constant"> non default handlers installed</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,MAX_SIGS,handlers_installed);
    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Display state of signal mask (and signals pending) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_sigmaskstatus(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        b_cnt = <span class="Constant">0</span>,
        p_cnt = <span class="Constant">0</span>;

    <span class="Type">char</span> blockstatus[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         pendstatus[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    sigset_t set,
             old_set,
             pending_set;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_sigmaskstatus] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Signal mask status</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    ==================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    (<span class="Type">void</span>)sigemptyset(&amp;set);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,&amp;old_set);
    (<span class="Type">void</span>)sigpending(&amp;pending_set);

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;=MAX_SIGS; ++i)
    {  <span class="Statement">if</span>(sigismember(&amp;old_set,i))
       {  (<span class="Type">void</span>)strlcpy(blockstatus,<span class="Constant">&quot;blocked&quot;</span>,SSIZE);
          ++b_cnt;
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(blockstatus,<span class="Constant">&quot;active&quot;</span>,SSIZE);

       <span class="Statement">if</span>(sigismember(&amp;pending_set,i))
       {  (<span class="Type">void</span>)strlcpy(pendstatus,<span class="Constant">&quot;pending&quot;</span>,SSIZE);
          ++p_cnt;
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(pendstatus,<span class="Constant">&quot;&quot;</span>,SSIZE);

       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%-16s</span><span class="Constant"> (</span><span class="Special">%02d</span><span class="Constant">): </span><span class="Special">%-16s</span><span class="Constant">  </span><span class="Special">%-16s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,signame[i],i+<span class="Constant">1</span>,blockstatus,pendstatus);
       (<span class="Type">void</span>)fflush(stream);
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Blocked signals   : </span><span class="Special">%04d</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant"> active)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,b_cnt,MAX_SIGS - b_cnt);
    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Pending signals   : </span><span class="Special">%04d</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,p_cnt);
    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">     Convert signal name to signal number ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_signametosigno(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;
    <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(tmpstr,name,SSIZE);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(tmpstr); ++i)
       tmpstr[i] = toupper(tmpstr[i]);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;=MAX_SIGS; ++i)
    {  <span class="Statement">if</span>(strncmp(tmpstr,<span class="Constant">&quot;SIG&quot;</span>,<span class="Constant">3</span>) == <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(signame[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strin(signame[i],&amp;tmpstr[<span class="Constant">3</span>]) == TRUE)
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(OK);
             <span class="Statement">return</span>(i);
          }
       }
       <span class="Statement">else</span>
       {  <span class="Statement">if</span>(signame[i] != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strin(signame[i],tmpstr) == TRUE)
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(OK);
             <span class="Statement">return</span>(i);
          }
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">     Convert signal number to name ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *pups_signotosigname(<span class="Type">const</span> <span class="Type">int</span> signum, <span class="Type">char</span> *name)

{    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || signum &lt; <span class="Constant">1</span> || signum &gt;MAX_SIGS)
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
     }

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     (<span class="Type">void</span>)strlcpy(name,signame[signum],SSIZE);

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     pups_set_errno(OK);
     <span class="Statement">return</span>(name);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">     Show detailed state of specified signal ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_show_siglstatus(<span class="Type">const</span> <span class="Type">int</span> signum, <span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span>      i;
    _BOOLEAN maskbits_set = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_sigstatus] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(sigtab[signum].haddr == (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_DFL</span>)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    </span><span class="Special">%-16s</span><span class="Constant"> [</span><span class="Special">%04d</span><span class="Constant">]: default action</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,signame[signum],signum);
       (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(sigtab[signum-<span class="Constant">1</span>].haddr == (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)<span class="Constant">SIG_IGN</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n</span><span class="Constant">    </span><span class="Special">%-16s</span><span class="Constant"> [</span><span class="Special">%04d</span><span class="Constant">]: ignored</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,signame[signum],signum);
          (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%-16s</span><span class="Constant"> [</span><span class="Special">%04d</span><span class="Constant">] handler information</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,signame[signum],signum);
    (<span class="Type">void</span>)fflush(stream);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Handler </span><span class="Special">\&quot;</span><span class="Special">%-32s</span><span class="Special">\&quot;</span><span class="Constant"> installed at </span><span class="Special">%016lx</span><span class="Constant"> virtual</span><span class="Special">\n</span><span class="Constant">&quot;</span>,sigtab[signum].hname,
                                                            (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)sigtab[signum].haddr);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">if</span>(sigtab[signum].sa_flags &amp; SA_RESTART)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Handler will restart interrupted system calls on exit</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Handler will NOT restart interrupted system calls on exit</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">if</span>(sigtab[signum].sa_flags &amp; SA_RESETHAND)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Handler will be de-installed on exit</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Handler will stay installed on exit</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">for</span>(i=<span class="Constant">1</span>; i&lt;=MAX_SIGS; ++i)
    {  <span class="Statement">if</span>(sigismember(&amp;sigtab[signum].sa_mask,i+<span class="Constant">1</span>) == <span class="Constant">1</span>)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Signal </span><span class="Special">%-16s</span><span class="Constant"> [</span><span class="Special">%04d</span><span class="Constant">] is blocked while handler for </span><span class="Special">%-16s</span><span class="Constant"> [</span><span class="Special">%04d</span><span class="Constant">] is running</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                        signame[i+<span class="Constant">1</span>],i+<span class="Constant">1</span>,signame[signum],signum);
          (<span class="Type">void</span>)fflush(stream);

          maskbits_set = TRUE;
       }
    }

    <span class="Statement">if</span>(maskbits_set == TRUE)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);
    }
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Handler for </span><span class="Special">%-16s</span><span class="Constant"> [</span><span class="Special">%04d</span><span class="Constant">] does not block any other signals while running</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,
                                                                                       signame[signum],signum);
       (<span class="Type">void</span>)fflush(stream);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;sigtab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to execute non-local goto (as exit from a signal handler) ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_sigvector(<span class="Type">const</span> <span class="Type">int</span> signum, <span class="Type">const</span> sigjmp_buf *vector)

{   <span class="Statement">if</span>(signum &gt; <span class="Constant">0</span> &amp;&amp; signum &lt;= MAX_SIGS &amp;&amp; vector != (sigjmp_buf *)<span class="Constant">NULL</span> &amp;&amp; jump_vector == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Make sure that virtual timer gets rescheduled </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

       in_vt_handler = FALSE;

       (<span class="Type">void</span>)usleep(<span class="Constant">100</span>);
       siglongjmp(*vector,signum);
    }

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span>
<span class="Comment">    Check descriptor for data and/or exceptions ... </span>
<span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_monitor(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">int</span> secs, <span class="Type">const</span> <span class="Type">int</span> usecs)

{   fd_set read_set,
           write_set,
           excep_set;

    <span class="Type">struct</span> timeval timeout;

    <span class="Statement">if</span>(fdes &lt; <span class="Constant">0</span> || fdes &gt;= appl_max_files)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    FD_ZERO(&amp;read_set);
    FD_ZERO(&amp;write_set);
    FD_ZERO(&amp;excep_set);

    FD_SET(fdes,&amp;read_set);
    FD_SET(fdes,&amp;write_set);
    FD_SET(fdes,&amp;excep_set);

    timeout.tv_sec  = secs;
    timeout.tv_usec = usecs;

    <span class="Statement">if</span>(select(MAX_SIGS,&amp;read_set,&amp;write_set,&amp;excep_set,&amp;timeout) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>;

    pups_set_errno(OK);
    <span class="Statement">if</span>(FD_ISSET(fdes,&amp;read_set))
       <span class="Statement">return</span>(READ_DATA);

    <span class="Statement">if</span>(FD_ISSET(fdes,&amp;write_set))
       <span class="Statement">return</span>(WRITE_DATA);

    <span class="Statement">if</span>(FD_ISSET(fdes,&amp;write_set))
       <span class="Statement">return</span>(EXCEPTION_RAISED);

    <span class="Statement">return</span>(TIMED_OUT);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Return current date (thread safe) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> strdate(<span class="Type">char</span> *date)

{   <span class="Type">time_t</span> tval;

    <span class="Statement">if</span>(date == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>;
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;date_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PHTREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pupshold(ALL_PUPS_SIGS);

    (<span class="Type">void</span>)time(&amp;tval);
    (<span class="Type">void</span>)strlcpy(date,ctime(&amp;tval),SSIZE);
    date[strlen(date) - <span class="Constant">1</span>] = <span class="Special">'\0'</span>;

    (<span class="Type">void</span>)pupsrelse(ALL_PUPS_SIGS);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;date_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PHTREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Handler for vitual interval timer timeout ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Initialise PUPS virtual timer set </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">void</span> initvitimers(<span class="Type">int</span> appl_max_vtimers)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Allocate timer datastructure array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    vttab = (vttab_type *)pups_calloc(appl_max_vtimers,<span class="Statement">sizeof</span>(vttab_type));

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_vtimers; ++i)
    {  vttab[i].priority        = <span class="Constant">0</span>;
       vttab[i].mode            = VT_NONE;
       vttab[i].prescaler       = <span class="Constant">0</span>;
       vttab[i].interval_time   = <span class="Constant">0</span>;
       vttab[i].name            = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       vttab[i].handler_args    = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       vttab[i].handler         = <span class="Constant">NULL</span>;
    }

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS virtual timer system intialised (</span><span class="Special">%d</span><span class="Constant"> timers available)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                               date,appl_name,appl_pid,appl_host,appl_owner,appl_max_vtimers);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for PUPS virtual timer interrupt -- note if the handler for a given virtual timer </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> does not return control to the signal handler all subsequent timers will have to wait a   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> further clock cycle before they are serviced                                              </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_vt_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{   sigset_t   set;
    <span class="Type">int</span>        i;
    <span class="Type">time_t</span>     tdum;
    <span class="Type">char</span>       handler_args[SSIZE];
    <span class="Type">void</span>       (*handler)(<span class="Type">void</span> *, <span class="Type">char</span> *args) = <span class="Constant">NULL</span>;
    vttab_type tinfo;

<span class="Comment">// CHANGE</span>
<span class="Comment">//return 0;</span>

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_vt_handler] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(in_vt_handler == TRUE)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    in_vt_handler = TRUE;
    <span class="Statement">for</span>(i=start_index; i&lt;appl_max_vtimers; ++i)
    {  <span class="Statement">if</span>(vttab[i].priority &gt; <span class="Constant">0</span>)
       {  --vttab[i].prescaler;

          <span class="Statement">if</span>(vttab[i].prescaler == <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(vttab[i].mode == VT_ONESHOT)
             {  --active_v_timers;
                tinfo = vttab[i];

                vttab[i].priority      = <span class="Constant">0</span>;
                vttab[i].mode          = VT_NONE;
                vttab[i].interval_time = <span class="Constant">0</span>;

                <span class="Statement">if</span>(vttab[i].handler_args != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                   (<span class="Type">void</span>)strlcpy(handler_args,vttab[i].handler_args,SSIZE);

                vttab[i].handler_args    = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)vttab[i].handler_args);
                vttab[i].name            = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)vttab[i].name);
                handler                  = vttab[i].handler;
                vttab[i].handler         = <span class="Constant">NULL</span>;
             }
             <span class="Statement">else</span>
             {  <span class="Statement">if</span>(vttab[i].handler_args != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
                   (<span class="Type">void</span>)strlcpy(handler_args,vttab[i].handler_args,SSIZE);

                vttab[i].prescaler       = vttab[i].interval_time;
                tinfo                    = vttab[i];
                handler                  = vttab[i].handler;
             }


             <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Execute the handler - note we have to re-enable </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> SIGALRM when handler terminates                 </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(i &lt; appl_max_vtimers -  <span class="Constant">1</span>)
                start_index = i;

             (*handler)((<span class="Type">void</span> *)&amp;tinfo,handler_args);
          }
       }
    }

    start_index   = <span class="Constant">0</span>;

    <span class="Statement">if</span>(active_v_timers &gt; <span class="Constant">0</span>)
      (<span class="Type">void</span>)pups_malarm(vitimer_quantum);

    in_vt_handler = FALSE;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Sort function for virtual interval timer priority ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> sort_priority(vttab_type *el_1, vttab_type *el_2)

{   <span class="Statement">if</span>(el_1-&gt;priority &gt; el_2-&gt;priority)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    <span class="Statement">if</span>(el_2-&gt;priority &gt; el_1-&gt;priority)
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Restart virtual timer system (this routine is usually called as a precaution</span>
<span class="Comment">    after using dubious library functions e.g. CURSES which may silently reset</span>
<span class="Comment">    signal handlers in an undocumented fashion) ...</span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_vitrestart(<span class="Type">void</span>)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_vitrestart] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>((in_setvitimer == TRUE  &amp;&amp; active_v_timers == <span class="Constant">0</span>)    ||
       (in_setvitimer == FALSE &amp;&amp; active_v_timers &gt;  <span class="Constant">0</span>)     )
    {  sigset_t vt_set;


       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Initialise interval timer if this is the first </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> virtual timer activated                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> vt_set is the set of signals masked when the   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> vt_handler function is running                 </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)sigfillset(&amp;vt_set);
       (<span class="Type">void</span>)sigdelset(&amp;vt_set,<span class="Constant">SIGALRM</span>);
       (<span class="Type">void</span>)sigdelset(&amp;vt_set,<span class="Constant">SIGTERM</span>);
       (<span class="Type">void</span>)sigdelset(&amp;vt_set,<span class="Constant">SIGINT</span>);
       (<span class="Type">void</span>)sigdelset(&amp;vt_set,<span class="Constant">SIGCONT</span>);
       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGALRM</span>,<span class="Constant">&quot;vt_handler&quot;</span>,(<span class="Type">void</span> *)pups_vt_handler, &amp;vt_set);

       in_vt_handler = FALSE;
       (<span class="Type">void</span>)pups_malarm(vitimer_quantum);

       pups_set_errno(OK);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

    pups_set_errno(<span class="Constant">EINVAL</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Set up a virtual interval timer ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_setvitimer(<span class="Type">const</span> <span class="Type">char</span>   *tname,        <span class="Comment">/*</span><span class="Comment"> Timer payload name              </span><span class="Comment">*/</span>
                            <span class="Type">const</span> <span class="Type">int</span>    priority,      <span class="Comment">/*</span><span class="Comment"> Priority of handler             </span><span class="Comment">*/</span>
                            <span class="Type">const</span> <span class="Type">int</span>    mode,          <span class="Comment">/*</span><span class="Comment"> Mode of timer                   </span><span class="Comment">*/</span>
                            <span class="Type">const</span> <span class="Type">time_t</span> interval,      <span class="Comment">/*</span><span class="Comment"> Timeout interval (microseconds) </span><span class="Comment">*/</span>
                            <span class="Type">const</span> <span class="Type">char</span>   *handler_args, <span class="Comment">/*</span><span class="Comment"> Handler arguments               </span><span class="Comment">*/</span>
                            <span class="Type">const</span> <span class="Type">void</span>   *handler)      <span class="Comment">/*</span><span class="Comment"> Handler called on timeout       </span><span class="Comment">*/</span>

{   <span class="Type">int</span>      i,
             t_index;

    <span class="Type">time_t</span>   tdum;
    sigset_t set;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_setvitimer] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(tname        == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       priority     &lt;  <span class="Constant">0</span>                   ||
       interval     &lt;  <span class="Constant">0</span>                   ||
       handler      == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);

fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BAIL 1</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we have disabled VT services do not process this call </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(no_vt_services == TRUE)
    {  pups_set_errno(<span class="Constant">EACCES</span>);

fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BAIL 2</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(priority &lt; <span class="Constant">0</span>)
       pups_error(<span class="Constant">&quot;[setvitimer] invalid priority&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get free timer slot and check to make sure </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> this timer is unique                       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_vtimers; ++i)
    {   <span class="Statement">if</span>(vttab[i].name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(vttab[i].name,tname) == <span class="Constant">0</span>)
        {  pups_set_errno(<span class="Constant">EEXIST</span>);

fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BAIL 3  </span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,vttab[i].name,tname);
fflush(<span class="Constant">stderr</span>);

           <span class="Statement">return</span>(-<span class="Constant">1</span>);
        }

        <span class="Statement">if</span>((<span class="Type">void</span> *)vttab[i].handler == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
        {  t_index = i;
           <span class="Statement">goto</span> free_timer;
        }
    }

    pups_set_errno(<span class="Constant">ENOSPC</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);

<span class="Statement">free_timer</span>:

    <span class="Statement">if</span>(mode != VT_ONESHOT &amp;&amp; mode != VT_CONTINUOUS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);

fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BAIL 4</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(interval &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">ERANGE</span>);

fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BAIL 5</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Ignore timer signals while reseting timer </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)sigemptyset(&amp;set);
    (<span class="Type">void</span>)sigaddset(&amp;set,<span class="Constant">SIGALRM</span>);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_BLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up signal handler for virtual timer system </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    in_setvitimer = TRUE;
    (<span class="Type">void</span>)pups_vitrestart();
    in_setvitimer = FALSE;


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set up virtual timer </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(vttab[t_index].priority == <span class="Constant">0</span>)
       ++active_v_timers;

    vttab[t_index].priority       = priority;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> A negative interval means that we want the payload function </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> run immediately                                             </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(interval &gt; <span class="Constant">0</span> &amp;&amp; mode == VT_CONTINUOUS)
       vttab[t_index].prescaler   = interval;
    <span class="Statement">else</span> <span class="Statement">if</span>(mode != VT_CONTINUOUS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);

fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;BAIL 6</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
fflush(<span class="Constant">stderr</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    vttab[t_index].interval_time  = interval;
    vttab[t_index].mode           = mode;
    vttab[t_index].handler        = handler;

    <span class="Statement">if</span>(handler_args != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>(vttab[t_index].handler_args == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
          vttab[t_index].handler_args = (<span class="Type">char</span> *)pups_malloc(SSIZE);

       (<span class="Type">void</span>)strlcpy(vttab[t_index].handler_args,handler_args,SSIZE);
    }

    vttab[t_index].name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    (<span class="Type">void</span>)strlcpy(vttab[t_index].name,tname,SSIZE);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Order the timer structure by handler priority </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)qsort((<span class="Type">void</span> *)vttab,appl_max_vtimers,<span class="Statement">sizeof</span>(vttab_type),(<span class="Type">void</span> *)sort_priority);


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Re-enable interrupts from underlying hardware timer </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sigprocmask(SIG_UNBLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);
    (<span class="Type">void</span>)pups_malarm(vitimer_quantum);

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       <span class="Statement">if</span>(mode == VT_CONTINUOUS)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS virtual timer </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) continuous timer, priority </span><span class="Special">%d</span><span class="Constant"> (interval </span><span class="Special">%5.2F</span><span class="Constant"> secs)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                               date,
                                                                                                                          appl_name,
                                                                                                                           appl_pid,
                                                                                                                          appl_host,
                                                                                                                         appl_owner,
                                                                                                                            t_index,
                                                                                                                              tname,
                                                                                                                           priority,
                                                                                                            (FTYPE)interval / <span class="Constant">100.0</span>);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS virtual timer </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) one shot timer, priority </span><span class="Special">%d</span><span class="Constant"> (interval </span><span class="Special">%5.2F</span><span class="Constant"> secs)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                             date,
                                                                                                                        appl_name,
                                                                                                                         appl_pid,
                                                                                                                        appl_host,
                                                                                                                       appl_owner,
                                                                                                                          t_index,
                                                                                                                            tname,
                                                                                                                         priority,
                                                                                                           (FTYPE)interval /<span class="Constant">100.0</span>);

       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(t_index);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Clear virtual interval timer ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>


_PUBLIC <span class="Type">int</span> pups_clearvitimer(<span class="Type">const</span> <span class="Type">char</span> *tname)

{   <span class="Type">int</span>      i;
    sigset_t set;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[clearvitimer] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(tname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)sigemptyset(&amp;set);
    (<span class="Type">void</span>)sigaddset(&amp;set,<span class="Constant">SIGALRM</span>);
    (<span class="Type">void</span>)pups_sigprocmask(SIG_BLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_vtimers; ++i)
    {  <span class="Statement">if</span>(vttab[i].name != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(vttab[i].name,tname) == <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  <span class="Type">char</span> date[SSIZE] = <span class="Constant">&quot;&quot;</span>;

             (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PUPS virtual timer </span><span class="Special">%d</span><span class="Constant"> (</span><span class="Special">%s</span><span class="Constant">) cleared</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                              date,appl_name,appl_pid,appl_host,appl_owner,i,vttab[i].name);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }


          vttab[i].mode            = <span class="Constant">0</span>;
          vttab[i].priority        = <span class="Constant">0</span>;
          vttab[i].prescaler       = <span class="Constant">0</span>;
          vttab[i].interval_time   = <span class="Constant">0</span>;
          vttab[i].handler_args    = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)vttab[i].handler_args);
          vttab[i].name            = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)vttab[i].name);
          vttab[i].handler         = <span class="Constant">NULL</span>;

          --active_v_timers;

          <span class="Statement">if</span>(vt_no_reset == FALSE)
          {  <span class="Statement">if</span>(active_v_timers &gt; <span class="Constant">0</span>)
             {

               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> Note we have to re-enable the alarm after we have finished </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment"> clearing timers in case it expired in the critical section </span><span class="Comment">*/</span>
               <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

               (<span class="Type">void</span>)pups_sigprocmask(SIG_UNBLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);
               (<span class="Type">void</span>)pups_malarm(vitimer_quantum);
             }
             <span class="Statement">else</span>
             {  (<span class="Type">void</span>)pups_malarm(<span class="Constant">0</span>);
                (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGALRM</span>,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>, (sigset_t *)<span class="Constant">NULL</span>);
                (<span class="Type">void</span>)pups_sigprocmask(SIG_UNBLOCK,&amp;set,(sigset_t *)<span class="Constant">NULL</span>);
             }
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span>
<span class="Comment">    Show PUPS virtual timer status ...                      </span>
<span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_show_vitimers(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_vitimers] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(active_v_timers == <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    No virtual timers active (</span><span class="Special">%d</span><span class="Constant"> slots free)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_max_vtimers);
    <span class="Statement">else</span>
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Virtual timers active</span><span class="Special">\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    =====================</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>);
       (<span class="Type">void</span>)fflush(stream);

        (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Virtual timer quantum is </span><span class="Special">%7.4F</span><span class="Constant"> seconds</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,(FTYPE)vitimer_quantum*<span class="Constant">1.e-7</span>);
        (<span class="Type">void</span>)fflush(stream);

        <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_vtimers; ++i)
        {  <span class="Statement">if</span>(vttab[i].priority &gt; <span class="Constant">0</span>)
           {  <span class="Statement">if</span>(vttab[i].mode == VT_CONTINUOUS)
                 (<span class="Type">void</span>)fprintf(stream,
                               <span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-48s</span><span class="Special">\&quot;</span><span class="Constant"> priority </span><span class="Special">%02d</span><span class="Constant">, continuous mode, interval time </span><span class="Special">%7.4F</span><span class="Constant"> secs, prescaler </span><span class="Special">%04d</span><span class="Constant">, (handler at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                                                                                                 vttab[i].name,
                                                                                                                                             vttab[i].priority,
                                                                                                                         (FTYPE)vttab[i].interval_time / <span class="Constant">100.0</span>,
                                                                                                                                            vttab[i].prescaler,
                                                                                                                           (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)vttab[i].handler);
              <span class="Statement">else</span>
                (<span class="Type">void</span>)fprintf(stream,
                              <span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: </span><span class="Special">\&quot;</span><span class="Special">%-48s</span><span class="Special">\&quot;</span><span class="Constant"> priority </span><span class="Special">%02d</span><span class="Constant">, oneshot mode, interval time </span><span class="Special">%7.4F</span><span class="Constant"> secs, prescaler </span><span class="Special">%04d</span><span class="Constant">, (handler at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                                                                                             vttab[i].name,
                                                                                                                                         vttab[i].priority,
			                                                                                             (FTYPE)vttab[i].interval_time / <span class="Constant">100.0</span>,
                                                                                                                                        vttab[i].prescaler,
                                                                                                                       (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)vttab[i].handler);
              (<span class="Type">void</span>)fflush(stream);
           }
        }

        <span class="Statement">if</span>(active_v_timers &gt; <span class="Constant">1</span>)
           (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> virtual timers in use (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,active_v_timers,appl_max_vtimers - active_v_timers);
        <span class="Statement">else</span> <span class="Statement">if</span>(active_v_timers == <span class="Constant">1</span>)
           (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> virtual timers registered (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,appl_max_vtimers - <span class="Constant">1</span>);
        <span class="Statement">else</span>
           (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    No virtual timers in use ((</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_max_vtimers);
        (<span class="Type">void</span>)fflush(stream);
     }

     pups_set_errno(OK);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to get (or test) write lock on a FIFO ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_get_fd_lock(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">int</span> mode)

{   <span class="Type">int</span> f_index;

    <span class="Statement">if</span>(fdes &lt; <span class="Constant">0</span> || fdes &gt;= appl_max_files || mode != GETLOCK &amp;&amp; mode != TSTLOCK)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(in_psrp_new_segment == FALSE)
    {  <span class="Statement">if</span>((f_index = pups_get_ftab_index(fdes)) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">EBADF</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

    <span class="Statement">if</span>(mode == GETLOCK)
    {  (<span class="Type">void</span>)lockf(fdes,F_LOCK,<span class="Constant">0</span>);
       pups_set_errno(OK);
       <span class="Statement">return</span>(TRUE);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>(lockf(fdes,F_TLOCK,<span class="Constant">0</span>) &lt; <span class="Constant">0</span>)
       {  pups_set_errno(OK);
          <span class="Statement">return</span>(FALSE);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(in_psrp_new_segment == FALSE)
       ftab[f_index].locked == TRUE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to release a write lock on a FIFO ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_release_fd_lock(<span class="Type">const</span> <span class="Type">int</span> fd)

{   <span class="Type">int</span> f_index;

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fd)) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)lockf(fd,F_ULOCK,<span class="Constant">0</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    ftab[f_index].locked = FALSE;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to acquire lock on a named file ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_get_lock(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">int</span> mode)

{   <span class="Type">int</span>      fdes = (-<span class="Constant">1</span>);
    _BOOLEAN ret;

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || (mode !=  GETLOCK &amp;&amp; mode != TSTLOCK))
    { pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    fdes = pups_open(name,<span class="Constant">2</span>,LIVE);
    <span class="Statement">if</span>((ret = pups_get_fd_lock(fdes,mode)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    <span class="Statement">else</span>
       fdes = pups_close(fdes);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to release lock on a named file ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_release_lock(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span>      fdes = (-<span class="Constant">1</span>);
    _BOOLEAN ret;

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    { pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    fdes = pups_open(name,<span class="Constant">2</span>,LIVE);
    ret  = pups_release_fd_lock(fdes);
    fdes = pups_close(fdes);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Attach homeostat to a file table entry ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_attach_homeostat(<span class="Type">const</span> <span class="Type">int</span> fd, <span class="Type">const</span> <span class="Type">void</span> *homeostat)

{   <span class="Type">int</span> f_index;

    <span class="Statement">if</span>(homeostat == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_attach_homeostat] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fd)) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    ftab[f_index].homeostat = homeostat;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Detach homeostat function from file table entry  ...</span>
<span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_detach_homeostat(<span class="Type">const</span> <span class="Type">int</span> fd)

{   <span class="Type">int</span> f_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_detach_homeostat] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fd)) == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    ftab[f_index].homeostat = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to check a file system - similar to the &quot;fsw&quot; PUPS service filter in its</span>
<span class="Comment">    operation ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_check_fs_space(<span class="Type">const</span> <span class="Type">int</span> fd)

{   <span class="Type">int</span>                f_index;
    <span class="Type">struct</span>    statfs   fs_state;
    _IMMORTAL _BOOLEAN entered = FALSE;

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fd)) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find the state of the nominated filesystem </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fstatfs(fd,&amp;fs_state);

    <span class="Statement">if</span>(fs_state.f_bavail  &lt; ftab[f_index].fs_blocks)
    {  <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; entered == FALSE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): file system full (</span><span class="Special">%s</span><span class="Constant">) [free:</span><span class="Special">%ld</span><span class="Constant">, limit:</span><span class="Special">%ld</span><span class="Constant">] (FSHP version </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                              date,
                                                                                                         appl_name,
                                                                                                          appl_pid,
                                                                                                         appl_host,
                                                                                                        appl_owner,
                                                                                               ftab[f_index].fname,
                                                                                                 fs_state.f_bavail,
                                                                                           ftab[f_index].fs_blocks,
                                                                                                      FSHP_VERSION);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       entered = TRUE;
    }
    <span class="Statement">else</span>
    {  entered = FALSE;

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

      pups_set_errno(OK);
      <span class="Statement">return</span>(TRUE);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Set parameters for homeostatic file system space monitoring ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_set_fs_hsm_parameters(<span class="Type">const</span> <span class="Type">int</span> fd, <span class="Type">const</span> <span class="Type">int</span> fs_blocks, <span class="Type">const</span> <span class="Type">char</span> *fs_name)

{   <span class="Type">int</span> f_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_set_fs_hsm_parameters] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(fs_blocks &lt;= <span class="Constant">0</span> || fs_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(fd)) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    ftab[f_index].fs_blocks = fs_blocks;

    <span class="Statement">if</span>(fs_name != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       (<span class="Type">void</span>)strlcpy(ftab[f_index].fs_name,fs_name,SSIZE);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strlcpy(ftab[f_index].fs_name,<span class="Constant">&quot;&lt;unknown&gt;&quot;</span>,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span>
<span class="Comment">    Homeostatic write check - default action is to wait until file system has space</span>
<span class="Comment">    available. If mfunc is non-null this is executed (and implements a file</span>
<span class="Comment">    migration scheme) ...</span>
<span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                                    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
_PUBLIC _BOOLEAN fs_write_blocked = FALSE;          <span class="Comment">/*</span><span class="Comment"> If TRUE filesystem full      </span><span class="Comment">*/</span>
                                                    <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_write_homeostat(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">int</span> (*mfunc)(<span class="Type">int</span>))

{

    <span class="Type">int</span> iter = <span class="Constant">0</span>,
        f_index;

    <span class="Type">struct</span> statfs  fs_buf;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_write_homeostat] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>((<span class="Type">void</span> *)mfunc == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    f_index = pups_get_ftab_index(fdes);

    <span class="Statement">if</span>(fstatfs(fdes,&amp;fs_buf) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If a monitoring function is installed, execute it when the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> file system filled to user defined limit                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(fs_buf.f_bavail &lt; ftab[f_index].fs_blocks &amp;&amp; (<span class="Type">void</span> *)mfunc != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  <span class="Type">int</span> new_fdes;

       fs_write_blocked = TRUE;
       new_fdes         = (*mfunc)(fdes);
       fs_write_blocked = FALSE;

       pups_set_errno(OK);
       <span class="Statement">return</span>(new_fdes);
    }
    <span class="Statement">else</span>
    {  <span class="Statement">while</span>(fs_buf.f_bavail &lt; ftab[f_index].fs_blocks)
       {

            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Stop rest of process group (usually processes in same pipeline   </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> as caller)                                                       </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> Note that we have to ignore SIGTSTOP as we have to remain active </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment"> to monitor the state of the filesystem we are writing to         </span><span class="Comment">*/</span>
            <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span>(iter == <span class="Constant">0</span>)
            {  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;ignored&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
               (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGTSTP</span>);
            }

            (<span class="Type">void</span>)sched_yield();

            <span class="Statement">if</span>(iter == <span class="Constant">0</span> &amp;&amp; appl_verbose == TRUE)
            {  (<span class="Type">void</span>)strdate(date);
               (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">): file system full (</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">) [avail:</span><span class="Special">%ld</span><span class="Constant"> limit:</span><span class="Special">%ld</span><span class="Constant">] (FSHP version </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                                                   date,
                                                                                                              appl_name,
                                                                                                               appl_pid,
                                                                                                              appl_host,
                                                                                                    ftab[f_index].fname,
                                                                                                                   fdes,
                                                                                                        fs_buf.f_bavail,
                                                                                                ftab[f_index].fs_blocks,
                                                                                                           FSHP_VERSION);
               (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

               fs_write_blocked = TRUE;
            }

            ++iter;
            (<span class="Type">void</span>)fstatfs(fdes, &amp;fs_buf);
       }

       <span class="Statement">if</span>(fs_write_blocked == TRUE)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  (<span class="Type">void</span>)strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): filesystem has space (</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">): continuing (FSHP version </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                                              appl_name,
                                                                                                               appl_pid,
                                                                                                             appl_owner,
                                                                                                              appl_host,
                                                                                                    ftab[f_index].fname,
                                                                                                                   fdes,
                                                                                                           FSHP_VERSION);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Restore default signal processing for SIGSTOP </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> and restart pipeline                          </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

          fs_write_blocked = FALSE;
          (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>,(sigset_t *)<span class="Constant">NULL</span>);
          (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGCONT</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    PUPS compliant sleep call (does not interact wih SIGALRM) ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_sleep(<span class="Type">const</span> <span class="Type">int</span> secs)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(secs &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Use half seconds so we do not cause an overflow in nanosleep()  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">2</span>*secs; ++i)
       pups_usleep(<span class="Constant">500000</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Alarm function which works in microseconds - raises SIGALRM on timeout ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_malarm(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> usecs)

{   <span class="Type">struct</span>   itimerval itimer;
    sigset_t set;
    <span class="Type">int</span>      ret;

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;malarm_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    itimer.it_interval.tv_sec  = <span class="Constant">0</span>;
    itimer.it_interval.tv_usec = <span class="Constant">0</span>;
    itimer.it_value.tv_sec     = <span class="Constant">0</span>;
    itimer.it_value.tv_usec    = usecs;

    ret = setitimer(ITIMER_REAL,&amp;itimer,(<span class="Type">struct</span> itimerval *)<span class="Constant">NULL</span>);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;malarm_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Unhide the branch part of a file pathname (and its shadow) ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN pups_unhide_pathnames(vttab_type *t_info, <span class="Type">char</span> *fname, <span class="Type">char</span> *fshadow)

{   <span class="Type">char</span> new_fname[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Update file name </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(fname[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
       (<span class="Type">void</span>)snprintf (new_fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,(<span class="Type">char</span> *)&amp;fname[<span class="Constant">1</span>]);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)strep(fname,  new_fname, <span class="Constant">&quot;/.&quot;</span>, <span class="Constant">&quot;/&quot;</span>);

    <span class="Statement">if</span>(strcmp(fname,new_fname) != <span class="Constant">0</span>)
    {  <span class="Type">char</span> branch     [SSIZE] = <span class="Constant">&quot;&quot;</span>,
            new_branch [SSIZE] = <span class="Constant">&quot;&quot;</span>,
            leaf       [SSIZE] = <span class="Constant">&quot;&quot;</span>,
            new_fshadow[SSIZE] = <span class="Constant">&quot;&quot;</span>;


       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Update file homeostat </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strlcpy((vttab_type *)t_info-&gt;name,new_fname,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Update filename </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strncpy(fname,new_fname,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Update shadow file name </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strbranch(fshadow,branch);
       (<span class="Type">void</span>)strleaf  (fshadow,leaf);

       <span class="Statement">if</span>(branch[<span class="Constant">0</span>] == <span class="Constant">'.'</span>)
          (<span class="Type">void</span>)snprintf (new_fshadow,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,(<span class="Type">char</span> *)&amp;branch[<span class="Constant">1</span>],leaf);
       <span class="Statement">else</span>
       {  (<span class="Type">void</span>)strep    (branch, new_branch, <span class="Constant">&quot;/.&quot;</span>, <span class="Constant">&quot;/&quot;</span>);
          (<span class="Type">void</span>)snprintf (new_fshadow,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/</span><span class="Special">%s</span><span class="Constant">&quot;</span>,new_branch,leaf);
       }

       (<span class="Type">void</span>)rename (fshadow,new_fshadow);
       (<span class="Type">void</span>)strncpy(fshadow,new_fshadow,SSIZE);



       <span class="Statement">return</span>(TRUE);
    }

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Homeostat for stdio (FIFO) redirection ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN default_fd_homeostat_action = FALSE;

_PUBLIC <span class="Type">int</span> pups_default_fd_homeostat(<span class="Type">void</span> *t_info, <span class="Type">const</span> <span class="Type">char</span> *args)

{   <span class="Type">int</span>  f_index;

    <span class="Type">char</span> fname[SSIZE]            = <span class="Constant">&quot;&quot;</span>,
         object_type[SSIZE]      = <span class="Constant">&quot;&quot;</span>,
         current_hostname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">struct</span> stat buf;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_default_fd_homeostat] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(t_info == (<span class="Type">void</span> *)      <span class="Constant">NULL</span>   ||
       args   == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>    )
       pups_error(<span class="Constant">&quot;[pups_default_fd_homeostat] invalid arguments&quot;</span>);

    <span class="Statement">if</span>(sscanf(args,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;f_index) != <span class="Constant">1</span> || f_index &lt; <span class="Constant">0</span>)
       pups_error(<span class="Constant">&quot;[pups_default_fd_homeostat] argument decode error&quot;</span>);


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If this is one of the stdio descriptors -- check to see if our process group </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> is currently in the foreground.                                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check whether we are currently a foreground task </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_fgnd == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Is this application about to go into the background?    </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If so all unredirected stdio streams must be redirected </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> to the data sink                                        </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(appl_nodetach == FALSE &amp;&amp; tcgetpgrp(appl_tty) != getpgrp())
       {   <span class="Statement">if</span>(appl_verbose == TRUE)
           {  (<span class="Type">void</span>)strdate(date);
              (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): background (controlling tty [</span><span class="Special">%s</span><span class="Constant">] detached)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                          date,appl_name,appl_pid,appl_host,appl_owner,appl_ttyname);
              (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
           }

           <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
           {

              <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Backgrounded channels are never live </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
              <span class="Constant">stdin</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;r&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Make sure that we do not remove /dev/tty      </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> this is possible if application is runnig as  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> suid root and we do not protect /dev/tty with </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> a guard link                                  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                 (<span class="Type">void</span>)link(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;/dev/ttyprot&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remove the file </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)unlink(ftab[<span class="Constant">0</span>].fname);


              <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remove shadow file </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)unlink(ftab[<span class="Constant">0</span>].fshadow);

              <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                 (<span class="Type">void</span>)rename(<span class="Constant">&quot;/dev/ttyprot&quot;</span>,<span class="Constant">&quot;/dev/tty&quot;</span>);

              (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fname,  <span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
              (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
           }

           <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
           {  (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
              <span class="Constant">stdout</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;w&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Make sure that we do not remove /dev/tty      </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> this is possible if application is runnig as  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> suid root and we do not protect /dev/tty with </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> a guard link                                  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                 (<span class="Type">void</span>)link(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;/dev/ttyprot&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remove the file </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)unlink(ftab[<span class="Constant">1</span>].fname);


              <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remove shadow file </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)unlink(ftab[<span class="Constant">1</span>].fshadow);

              <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                 (<span class="Type">void</span>)rename(<span class="Constant">&quot;/dev/ttyprot&quot;</span>,<span class="Constant">&quot;/dev/tty&quot;</span>);

              (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fname,  <span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
              (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
           }

           <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
           {  (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
              <span class="Constant">stderr</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;w&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Make sure that we do not remove /dev/tty      </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> this is possible if application is runnig as  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> suid root and we do not protect /dev/tty with </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> a guard link                                  </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

              <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                 (<span class="Type">void</span>)link(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;/dev/ttyprot&quot;</span>);


              <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remove the file </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)unlink(ftab[<span class="Constant">2</span>].fname);


              <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Remove shadow file </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)unlink(ftab[<span class="Constant">2</span>].fshadow);

              <span class="Statement">if</span>(getuid() == <span class="Constant">0</span>)
                 (<span class="Type">void</span>)rename(<span class="Constant">&quot;/dev/ttyprot&quot;</span>,<span class="Constant">&quot;/dev/tty&quot;</span>);

              (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fname,  <span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
              (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
           }

           appl_fgnd = FALSE;
       }
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Are we now back in the foreground process group. If we are </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> re-attach stdio streams redirected to /dev/null to the     </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> controlling terminal                                       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(tcgetpgrp(appl_tty) == getpgrp())
       {


          <span class="Statement">if</span>(strcmp(ftab[<span class="Constant">0</span>].fname,<span class="Constant">&quot;/dev/null&quot;</span>) == <span class="Constant">0</span>)
          {  (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
             <span class="Constant">stdin</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;r&quot;</span>);

             (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">0</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdin.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid);
             (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>,SSIZE);


             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If we have been started in the background we will need to create </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> lockpost                                                         </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[<span class="Constant">0</span>].fname);
          }

          <span class="Statement">if</span>(strcmp(ftab[<span class="Constant">1</span>].fname,<span class="Constant">&quot;/dev/null&quot;</span>) == <span class="Constant">0</span>)
          {  (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
             <span class="Constant">stdout</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
             (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">1</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stdout.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid);
             (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>,SSIZE);


             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If we have been started in the background we will need to create </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> lockpost                                                         </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[<span class="Constant">1</span>].fname);
          }

          <span class="Statement">if</span>(strcmp(ftab[<span class="Constant">2</span>].fname,<span class="Constant">&quot;/dev/null&quot;</span>) == <span class="Constant">0</span>)
          {  (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
             <span class="Constant">stderr</span> = fopen(<span class="Constant">&quot;/dev/tty&quot;</span>,<span class="Constant">&quot;w&quot;</span>);

             (<span class="Type">void</span>)snprintf(ftab[<span class="Constant">2</span>].fname,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%s</span><span class="Constant">.stderr.pst.</span><span class="Special">%d</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">&quot;</span>, appl_fifo_dir,appl_name,appl_host,appl_pid,appl_uid);
             (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>,SSIZE);


             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> If we have been started in the background we will need to create </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> lockpost                                                         </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

             (<span class="Type">void</span>)symlink(<span class="Constant">&quot;/dev/tty&quot;</span>,ftab[<span class="Constant">2</span>].fname);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Try to get precise name of controlling tty </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
             (<span class="Type">void</span>)strlcpy(appl_ttyname,ttyname(<span class="Constant">0</span>),SSIZE);
          <span class="Statement">else</span> <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
             (<span class="Type">void</span>)strlcpy(appl_ttyname,ttyname(<span class="Constant">1</span>),SSIZE);
          <span class="Statement">else</span> <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
             (<span class="Type">void</span>)strlcpy(appl_ttyname,ttyname(<span class="Constant">2</span>),SSIZE);
          <span class="Statement">else</span>
             (<span class="Type">void</span>)strlcpy(appl_ttyname,<span class="Constant">&quot;/dev/tty&quot;</span>,SSIZE);

          <span class="Statement">if</span>(appl_verbose == TRUE &amp;&amp; isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
          {  (<span class="Type">void</span>)strdate(date);
             <span class="Statement">if</span>(started_detached == TRUE)
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): foreground (controlling tty [</span><span class="Special">%s</span><span class="Constant">] attached)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                            date,appl_name,appl_pid,appl_host,appl_owner,appl_ttyname);
             <span class="Statement">else</span>
                (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): foreground (controlling tty [</span><span class="Special">%s</span><span class="Constant">] re-attached)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                               date,appl_name,appl_pid,appl_host,appl_owner,appl_ttyname);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          <span class="Statement">if</span>(started_detached == TRUE)
             started_detached = FALSE;

          appl_fgnd = TRUE;
       }
    }

    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check for mode change on file system object -- if mode has been changed, change it </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> back.                                                                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ftab[f_index].fname != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; ftab[f_index].fdes != (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)fstat(ftab[f_index].fdes,&amp;buf);


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Find out what sort of file system object we have lost. </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(S_ISFIFO(buf.st_mode))
          (<span class="Type">void</span>)strlcpy(object_type,<span class="Constant">&quot;FIFO&quot;</span>,SSIZE);
       <span class="Statement">else</span> <span class="Statement">if</span>(isatty(ftab[f_index].fdes))
          (<span class="Type">void</span>)strlcpy(object_type,<span class="Constant">&quot;tty&quot;</span>,SSIZE);
       <span class="Statement">else</span> <span class="Statement">if</span>(ftab[f_index].pheap == TRUE)
          (<span class="Type">void</span>)strlcpy(object_type,<span class="Constant">&quot;persistent heap&quot;</span>,SSIZE);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)strlcpy(object_type,<span class="Constant">&quot;regular file&quot;</span>,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Make sure protections on object are correct - if they have been changed by an </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> entity other than the objects owner - restore them now!                       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ftab[f_index].named == TRUE &amp;&amp; ftab[f_index].st_mode &amp; buf.st_mode != ftab[f_index].st_mode)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
          {  strdate(date);
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> protection mode changed (from </span><span class="Special">%o</span><span class="Constant"> to </span><span class="Special">%o</span><span class="Constant">) -- restoring</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                                                  appl_name,
                                                                                                                   appl_pid,
                                                                                                                  appl_host,
                                                                                                                 appl_owner,
                                                                                                                object_type,
                                                                                                        ftab[f_index].fname,
                                                                                          ftab[f_index].st_mode,buf.st_mode);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
          }

          (<span class="Type">void</span>)chmod(ftab[f_index].fname,ftab[f_index].st_mode);
       }


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we are a regular file, check that we have enough space for continued writes on </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> our FS (given that we are open in write mode). If not we have two options, either </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> sit it out until space becomes available, or migrate to a file system which has   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> sufficient space.                                                                 </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ftab[f_index].mode != <span class="Constant">0</span> &amp;&amp; S_ISREG(buf.st_mode) &amp;&amp; pups_check_fs_space(ftab[f_index].fdes) == FALSE)
       {  <span class="Type">int</span> iter = <span class="Constant">0</span>;


          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Do we have a router installed? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>((<span class="Type">void</span> *)ftab[f_index].homeostat == (<span class="Type">void</span> *)<span class="Constant">NULL</span> &amp;&amp; S_ISREG(buf.st_mode))
          {   <span class="Type">char</span> tmpname[SSIZE] = <span class="Constant">&quot;&quot;</span>;

              <span class="Statement">if</span>(appl_verbose == TRUE)
              {  strdate(date);
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): filesystem full (</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">): waiting for space (FSHP version </span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                                                    appl_name,
                                                                                                                     appl_pid,
                                                                                                                   appl_owner,
                                                                                                                    appl_host,
                                                                                                          ftab[f_index].fname,
                                                                                                           ftab[f_index].fdes,
                                                                                                                 FSHP_VERSION);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
              }

              <span class="Statement">while</span>(pups_check_fs_space(ftab[f_index].fdes) == FALSE)
              {

                   <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Stop rest of process group (usually processes in same pipeline  </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> as caller)                                                      </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> Note that we have to ignore SIGSTOP as we have to remain active </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment"> to monitor the state of the filesystem we are writing to        </span><span class="Comment">*/</span>
                   <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

                   <span class="Statement">if</span>(iter == <span class="Constant">0</span>)
                   {  (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;ignored&quot;</span>,<span class="Constant">SIG_IGN</span>,(sigset_t *)<span class="Constant">NULL</span>);
                      (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGTSTP</span>);
                   }

                   (<span class="Type">void</span>)sched_yield();
              }

              <span class="Statement">if</span>(appl_verbose == TRUE)
              {  (<span class="Type">void</span>)strdate(date);
                 (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): filesystem now has space (</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%d</span><span class="Constant">): continuing (FSHP version </span><span class="Special">%.2f</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                                                        appl_name,
                                                                                                                         appl_pid,
                                                                                                                       appl_owner,
                                                                                                                        appl_host,
                                                                                                              ftab[f_index].fname,
                                                                                                               ftab[f_index].fdes,
                                                                                                                     FSHP_VERSION);
                 (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
              }


              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> Restore default signal processing for SIGSTOP </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment"> and restart pipeline                          </span><span class="Comment">*/</span>
              <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

              (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGTSTP</span>,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>,(sigset_t *)<span class="Constant">NULL</span>);
              (<span class="Type">void</span>)kill(<span class="Constant">0</span>,<span class="Constant">SIGCONT</span>);

              default_fd_homeostat_action = TRUE;
          }
          <span class="Statement">else</span>
          {

             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> We have a router -- migrate the file to the file system          </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> selected by the router. If we do this we must leave a &quot;marker&quot;   </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> for other users of the file so they know about the migration and </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> can take appropriate action as a consequence of it. It is the    </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> part of the routers function to ensure that this marker is left  </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> and that it is adequately protected                              </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

             (*ftab[f_index].homeostat)(ftab[f_index].fdes,FILE_RELOCATE);
             default_fd_homeostat_action = FALSE;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if hostname has changed -- if it has terminate the process as all </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> the channelnames will be messed up (note we could restart here).               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)gethostname(current_hostname,SSIZE);


<span class="PreProc">    #ifdef EXIT_IF_HOST_RENAMED </span>
    <span class="Statement">if</span>(strcmp(appl_host,current_hostname) != <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a host renamer installed update all the                </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> PSRP/PUPS files/FIFOS on this host to refect the changed hostname </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ftab[f_index].homeostat == (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
       {  <span class="Statement">if</span>(appl_verbose == TRUE)
             pups_error(<span class="Constant">&quot;[pups_default_fd_homeosat] host name has been changed -- exiting&quot;</span>);
       }
       <span class="Statement">else</span>
       {  (*ftab[f_index].homeostat)(ftab[f_index].fdes,HOST_RENAME);
          pups_default_fd_homeostat_action = FALSE;
       }
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> EXIT_IF_HOST_RENAMED </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check that we have not lost a file (as a named inode) -- if we have simply </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> re-create it.                                                              </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

                                                                     <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Statement">if</span>(ftab[f_index].named                            == TRUE    &amp;&amp;  <span class="Comment">/*</span><span class="Comment"> Named file (i.e homeostatically protected      </span><span class="Comment">*/</span>
       ftab[f_index].fdes                             != (-<span class="Constant">1</span>)    &amp;&amp;  <span class="Comment">/*</span><span class="Comment"> File is open                                   </span><span class="Comment">*/</span>
       access(ftab[f_index].fname,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>)     )  <span class="Comment">/*</span><span class="Comment"> File is assessible (via is 'given' name)       </span><span class="Comment">*/</span>
                                                                     <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    {  _BOOLEAN file_found = FALSE;


       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If we have a (partially) hidden path - unhide it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_unhide_pathnames((vttab_type *)t_info,ftab[f_index].fname,ftab[f_index].fshadow) == FALSE)
       {

          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have a homeostat to search for the lost object use it to try and relocate the </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> file we have just lost -- in the case of FIFO object the homeostat will simply      </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> need to create the object.                                                          </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>((<span class="Type">void</span> *)ftab[f_index].homeostat != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
          {  file_found                  =  (*ftab[f_index].homeostat)(ftab[f_index].fdes,LOST_FILE_LOCATE);
             default_fd_homeostat_action = FALSE;
          }


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we do not have a homeostat or it cannot find file default action is required. </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

          ++ftab[f_index].lost_cnt;
          <span class="Statement">if</span>(file_found == FALSE)
          {  <span class="Statement">if</span>(appl_verbose == TRUE)
             {  (<span class="Type">void</span>)strdate(date);
                <span class="Statement">if</span>(ftab[f_index].lost_cnt == <span class="Constant">1</span>)
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lost (once) -- recreating</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                             appl_name,
                                                                                              appl_pid,
                                                                                             appl_host,
                                                                                            appl_owner,
                                                                                           object_type,
                                                                                   ftab[f_index].fname);
                <span class="Statement">else</span>
                   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lost (</span><span class="Special">%d</span><span class="Constant"> times) -- recreating</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                                 appl_name,
                                                                                                  appl_pid,
                                                                                                 appl_host,
                                                                                                appl_owner,
                                                                                               object_type,
                                                                                       ftab[f_index].fname,
                                                                                    ftab[f_index].lost_cnt);

                (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
             }


             <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Recreate the resource. </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

             <span class="Statement">if</span>(strcmp(ftab[f_index].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) == <span class="Constant">0</span>)
                (<span class="Type">void</span>)symlink(ftab[f_index].fshadow,ftab[f_index].fname);
             <span class="Statement">else</span>
             {  <span class="Statement">if</span>(link(ftab[f_index].fshadow,ftab[f_index].fname) == (-<span class="Constant">1</span>))
                {  <span class="Statement">if</span>((<span class="Type">void</span> *)ftab[f_index].homeostat != (<span class="Type">void</span> *)<span class="Constant">NULL</span>)
                   {  <span class="Statement">if</span>((*ftab[f_index].homeostat)(ftab[f_index].fdes,LOST_FILE_LOCATE) == FALSE)
                      {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[pups_default_fd__homeostat] </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lost (and cannot be found) -- exiting&quot;</span>,ftab[f_index].hname,ftab[f_index].fname);
                         pups_error(errstr);
                      }
                   }
                   <span class="Statement">else</span>
                   {  (<span class="Type">void</span>)snprintf(errstr,SSIZE,<span class="Constant">&quot;[pups_default_fd__homeostat] </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> lost (and cannot be found) -- exiting&quot;</span>,ftab[f_index].hname,ftab[f_index].fname);
                      pups_error(errstr);
                   }
                }
             }

             default_fd_homeostat_action = TRUE;
          }
       }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Conversely - if we have lost the shadow (as a named inode) - recreate it. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ftab[f_index].named == TRUE &amp;&amp; ftab[f_index].fdes != (-<span class="Constant">1</span>) &amp;&amp; access(ftab[f_index].fshadow,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): </span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant"> (shadow </span><span class="Special">\&quot;</span><span class="Special">%s</span><span class="Special">\&quot;</span><span class="Constant">) lost -- recreating</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,
                                                                                             appl_name,
                                                                                              appl_pid,
                                                                                             appl_host,
                                                                                            appl_owner,
                                                                                           object_type,
                                                                                   ftab[f_index].fname,
                                                                                 ftab[f_index].fshadow);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Recreate the resource. </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(strcmp(ftab[f_index].fshadow,<span class="Constant">&quot;/dev/tty&quot;</span>) != <span class="Constant">0</span>)
          (<span class="Type">void</span>)link(ftab[f_index].fname,ftab[f_index].fshadow);

       default_fd_homeostat_action = TRUE;
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see the /dev/tty has not been deleted. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(<span class="Constant">&quot;/dev/tty&quot;</span>,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): /dev/tty lost - recreating (mktty)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                           date,appl_name,appl_pid,appl_host,appl_owner);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)pups_system(<span class="Constant">&quot;mktty&quot;</span>,shell,PUPS_ERROR_EXIT,(<span class="Type">int</span> *)<span class="Constant">NULL</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    pups_set_errno(OK);
    <span class="Statement">return</span>(ftab[f_index].fdes);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Return file descriptor which corresponds to filename ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fname2fdes(<span class="Type">const</span> <span class="Type">char</span> *fname)

{   <span class="Type">int</span>  i;

    <span class="Statement">if</span>(fname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(strcmp(ftab[i].fname,fname) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(ftab[i].fdes);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Return stream which corresponds to filename ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">FILE</span> *pups_fname2fstream(<span class="Type">const</span> <span class="Type">char</span> *fname)

{   <span class="Type">int</span>  i;

    <span class="Statement">if</span>(fname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(strcmp(ftab[i].fname,fname) == <span class="Constant">0</span> &amp;&amp; ftab[i].stream != (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(ftab[i].stream);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------</span>
<span class="Comment">    Return file table index for file &quot;fname&quot; ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fname2index(<span class="Type">const</span> <span class="Type">char</span> *fname)

{   <span class="Type">int</span>  i;

    <span class="Statement">if</span>(fname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(strcmp(ftab[i].fname,fname) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------</span>
<span class="Comment">    Return file table index for file associated with descriptor &quot;fdes&quot; ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fdes2index(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">int</span>  i;

    <span class="Statement">if</span>(fdes &lt; <span class="Constant">0</span> || fdes &gt;= appl_max_files)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
    {  <span class="Statement">if</span>(ftab[i].fdes == fdes)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(i);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended creat command (which simply creates file without opening it) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_creat(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">int</span> mode)

{  <span class="Type">int</span> ret;

   <span class="Statement">if</span>(mode &lt; <span class="Constant">0</span> || name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

   <span class="Statement">if</span>(access(name,F_OK) == <span class="Constant">0</span>)
   {  pups_set_errno(<span class="Constant">EACCES</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }
   <span class="Statement">else</span>
   {  <span class="Statement">if</span>((ret = creat(name,mode)) == (-<span class="Constant">1</span>))
      {

         <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment"> Failed to create file </span><span class="Comment">*/</span>
         <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

         <span class="Statement">return</span>(-<span class="Constant">1</span>);
      }
   }

   <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Make sure we have really </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> closed the file          </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

   <span class="Statement">while</span>(close(ret) &lt; <span class="Constant">0</span>)
       pups_usleep(<span class="Constant">100</span>);

   pups_set_errno(OK);
   <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended chmod which updates ftab contents ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fchmod(<span class="Type">const</span> <span class="Type">int</span> des, <span class="Type">const</span> <span class="Type">int</span> mode)

{   <span class="Type">int</span> ret,
        f_index;

    <span class="Statement">if</span>(mode &lt; <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>((f_index = pups_get_ftab_index(des)) == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    ftab[f_index].st_mode = mode; <span class="Comment">// (int) </span>
    ret                   = fchmod(des,mode);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended strlen command ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_strlen(<span class="Type">const</span> <span class="Type">char</span> *s)

{    <span class="Statement">if</span>(s != (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
        <span class="Statement">return</span>(strlen(s) + <span class="Constant">1</span>);
     <span class="Statement">else</span>
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Initialise tracked object system ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Memory allocation table </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

_PRIVATE matab_type matab;

_PRIVATE <span class="Type">void</span> tinit(<span class="Type">void</span>)

{

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    matab.allocated = <span class="Constant">0</span>;
    matab.object    = (matab_object_type **)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): Static heap object tracking enabled</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                         date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Memory block tracking extended malloc routine ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_tmalloc(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size, <span class="Type">const</span> <span class="Type">char</span> *object_name, <span class="Type">const</span> <span class="Type">char</span> *object_type)

{   <span class="Type">int</span>  i,
         j;

    <span class="Type">void</span> *ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(size        &lt;= <span class="Constant">0</span>                   ||
       object_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       object_type == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] == (matab_object_type *)<span class="Constant">NULL</span>)
       {  ptr                   = pups_malloc(size);
          matab.object[i]       = (matab_object_type *)pups_malloc(<span class="Statement">sizeof</span>(matab_object_type));
          matab.object[i]-&gt;ptr  = ptr;
          matab.object[i]-&gt;size = size;
          matab.object[i]-&gt;name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
          matab.object[i]-&gt;type = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;name,object_name,SSIZE);
          (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;type,object_type,SSIZE);

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(ptr);
       }
    }

    i               =  matab.allocated;
    matab.allocated += ALLOC_QUANTUM;
    matab.object    = (matab_object_type **)pups_realloc((<span class="Type">void</span> *)matab.object,matab.allocated*<span class="Statement">sizeof</span>(matab_object_type *));


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure the newly allocated pointers are NULL </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(j=i; j&lt;matab.allocated; ++j)
       matab.object[j] = (matab_object_type *)<span class="Constant">NULL</span>;

    ptr                   = pups_malloc(size);
    matab.object[i]       = (matab_object_type *)pups_malloc(<span class="Statement">sizeof</span>(matab_object_type));
    matab.object[i]-&gt;ptr  = ptr;
    matab.object[i]-&gt;size = size;
    matab.object[i]-&gt;name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    matab.object[i]-&gt;type = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;name,object_name,SSIZE);
    (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;type,object_type,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ptr);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Memory block tracking extended calloc routine ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_tcalloc(<span class="Type">const</span> <span class="Type">int</span> n_el, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size, <span class="Type">const</span> <span class="Type">char</span> *object_name, <span class="Type">const</span> <span class="Type">char</span> *object_type)

{   <span class="Type">int</span>  i,
         j;

    <span class="Type">void</span> *ptr = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(n_el        &lt;= <span class="Constant">0</span>                   ||
       size        &lt;= <span class="Constant">0</span>                   ||
       object_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       object_type == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] == (matab_object_type *)<span class="Constant">NULL</span>)
       {  ptr                   = pups_calloc(n_el,size);
          matab.object[i]       = (matab_object_type *)pups_malloc(<span class="Statement">sizeof</span>(matab_object_type));
          matab.object[i]-&gt;ptr  = ptr;
          matab.object[i]-&gt;size = size;
          matab.object[i]-&gt;n_el = n_el;
          matab.object[i]-&gt;name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
          matab.object[i]-&gt;type = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;name,object_name,SSIZE);
          (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;type,object_type,SSIZE);

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(ptr);
       }
    }

    i               = matab.allocated;
    matab.allocated += ALLOC_QUANTUM;
    matab.object    = (matab_object_type **)pups_realloc((<span class="Type">void</span> *)matab.object,matab.allocated*<span class="Statement">sizeof</span>(matab_object_type *));


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure the newly allocated pointers are NULL </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(j=i; j&lt;matab.allocated; ++j)
       matab.object[j] = (matab_object_type *)<span class="Constant">NULL</span>;

    ptr                   = pups_calloc(n_el,size);
    matab.object[i]       = (matab_object_type *)pups_malloc(<span class="Statement">sizeof</span>(matab_object_type));
    matab.object[i]-&gt;ptr  = ptr;
    matab.object[i]-&gt;size = size;
    matab.object[i]-&gt;name = (<span class="Type">char</span> *)pups_malloc(SSIZE);
    matab.object[i]-&gt;type = (<span class="Type">char</span> *)pups_malloc(SSIZE);

    (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;name,object_name,SSIZE);
    (<span class="Type">void</span>)strlcpy(matab.object[i]-&gt;type,object_type,SSIZE);

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ptr);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Memory block tracking extended realloc routine ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_trealloc(<span class="Type">void</span> *ptr, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size)

{   <span class="Type">int</span>  i;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If this is our first time we need to be processed by tmalloc </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ptr == (<span class="Type">void</span> *)<span class="Constant">NULL</span> || size &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find object to be reallocated in the block tracking table </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; matab.object[i]-&gt;ptr == ptr)
       {  ptr                   = pups_realloc(ptr,size);
          matab.object[i]-&gt;size = size;
          matab.object[i]-&gt;ptr  = ptr;

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(ptr);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ERANGE</span>);
    <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to allocate a tracked dynamic array - this is based on T.K.W Chau's</span>
<span class="Comment">    allocation scheme ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> **pups_taalloc(<span class="Type">const</span> pindex_t rows, <span class="Type">const</span> pindex_t cols, <span class="Type">const</span> psize_t size, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> *type_name)

{   <span class="Type">int</span>   i;

    <span class="Type">char</span> mem_name[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">void</span> *array_mem      = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
    <span class="Type">void</span> **array         = (<span class="Type">void</span> **)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(rows      &lt;= <span class="Constant">0</span>                   ||
       cols      &lt;= <span class="Constant">0</span>                   ||
       size      &lt;= <span class="Constant">0</span>                   ||
       name      == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       type_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> **)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> First allocate memory for the whole array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(mem_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">[mem]&quot;</span>,name);
    array_mem = (<span class="Type">void</span> *)pups_tmalloc(rows*cols*size,mem_name,<span class="Constant">&quot;void *&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Now row allocate the pointer array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

    array = (<span class="Type">void</span> **)pups_tmalloc(rows*<span class="Statement">sizeof</span>(<span class="Type">void</span> **),name,type_name);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Now allocate the columns addressed by the pointer array </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;rows; ++i)
    {  array[i]  = (<span class="Type">void</span> *)array_mem;
       array_mem = (<span class="Type">void</span> *)((<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)array_mem + (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)(cols*size));
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(array);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Routine to free memory occupied by a dynamically allocated tracked array ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> **pups_tafree(<span class="Type">const</span> <span class="Type">void</span> **array)

{    <span class="Statement">if</span>(array != (<span class="Type">void</span> **)<span class="Constant">NULL</span>)
     {

        <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Free contiguous slab of array memory </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)pups_tfree((<span class="Type">const</span> <span class="Type">void</span> *)array[<span class="Constant">0</span>]);


        <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Free 2D mapping array </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

        (<span class="Type">void</span>)pups_tfree((<span class="Type">const</span> <span class="Type">void</span> **)array);

        pups_set_errno(OK);
     }

     pups_set_errno(<span class="Constant">EINVAL</span>);
     <span class="Statement">return</span>((<span class="Type">void</span> **)<span class="Constant">NULL</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert a tracked heap object name to heap address ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_tnametoptr(<span class="Type">const</span> <span class="Type">char</span> *name)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; strcmp(matab.object[i]-&gt;name,name) == <span class="Constant">0</span>)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(matab.object[i]-&gt;ptr);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert next instance of partial name to pointer ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_tpartnametoptr(<span class="Type">const</span> <span class="Type">char</span> *pname)

{   <span class="Type">int</span>           i;
    _IMMORTAL <span class="Type">int</span> pos = <span class="Constant">0</span>;

    <span class="Statement">if</span>(pname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(pname,<span class="Constant">&quot;RESET&quot;</span>) == <span class="Constant">0</span> || pos &gt;= matab.allocated)
    {  pos = <span class="Constant">0</span>;

<span class="PreProc">         #ifdef PTHREAD_SUPPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">for</span>(i=pos; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; strin(matab.object[i]-&gt;name,pname) == TRUE)
       {  pos = i + <span class="Constant">1</span>;

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(matab.object[i]-&gt;ptr);
       }
    }

    pos = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert type to pointer ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_ttypetoptr(<span class="Type">const</span> <span class="Type">char</span> *type)

{   <span class="Type">int</span>           i;
    _IMMORTAL <span class="Type">int</span> pos = <span class="Constant">0</span>;

    <span class="Statement">if</span>(type == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(type,<span class="Constant">&quot;RESET&quot;</span>) == <span class="Constant">0</span>)
    {  pos = <span class="Constant">0</span>;

<span class="PreProc">       #ifdef PTHREAD_SUPPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">for</span>(i=pos; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; strcmp(matab.object[i]-&gt;type,type) == <span class="Constant">0</span>)
       {  pos = i + <span class="Constant">1</span>;

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(matab.object[i]-&gt;ptr);
       }
    }

    pos = <span class="Constant">0</span>;

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended dynamic memory freeing routine - which keeps track of blocks freed by the</span>
<span class="Comment">    malloc family of dynamic memory allocators ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> *pups_tfree(<span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Simply ignore a NULL object (but warn user about it) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ptr == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Find the object to be freed </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; matab.object[i]-&gt;ptr == ptr)
       {

          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Free the object returning memory to free pool</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

          (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)ptr);


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Clear information about object (in PUPS memory allocation table) </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

          matab.object[i]-&gt;ptr  = (<span class="Type">void</span> *)<span class="Constant">NULL</span>;
          matab.object[i]-&gt;size = <span class="Constant">0</span>;
          matab.object[i]-&gt;n_el = <span class="Constant">0</span>;
          matab.object[i]-&gt;name = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)matab.object[i]-&gt;name);
          matab.object[i]-&gt;type = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)matab.object[i]-&gt;type);


          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Free the slot in the table which contained the information about </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> freed object                                                     </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

          matab.object[i] = (matab_object_type *)pups_free((<span class="Type">void</span> *)matab.object[i]);

<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>((<span class="Type">void</span> *)<span class="Constant">NULL</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Display currently allocated dynamic memory object ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_tshowobject(<span class="Type">const</span> <span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">void</span> *ptr)

{   <span class="Type">int</span> i;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_tobject] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span> || ptr == (<span class="Type">const</span> <span class="Type">void</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(matab.allocated == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; matab.object[i]-&gt;ptr == ptr)
       {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    Object </span><span class="Special">%-32s</span><span class="Constant"> (type </span><span class="Special">%-32s</span><span class="Constant">) size </span><span class="Special">%016lx</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,matab.object[i]-&gt;name,
                                                                                                 matab.object[i]-&gt;type,
                                                                                                 matab.object[i]-&gt;size,
                                                                               (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)matab.object[i]-&gt;ptr);
          (<span class="Type">void</span>)fflush(stream);


<span class="PreProc">          #ifdef PTHREAD_SUPPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Display all currently allocated dynamic memory objects ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> compare_objects(matab_object_type **el_1, matab_object_type **el_2)


{   <span class="Statement">if</span>(*el_1 == (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; *el_2 == (matab_object_type *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>(<span class="Constant">0</span>);

    <span class="Statement">if</span>(*el_1 != (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; *el_2 == (matab_object_type *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    <span class="Statement">if</span>(*el_1 == (matab_object_type *)<span class="Constant">NULL</span> &amp;&amp; *el_2 != (matab_object_type *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    <span class="Statement">if</span>((*el_1)-&gt;size &lt; (*el_2)-&gt;size)
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    <span class="Statement">if</span>((*el_1)-&gt;size &gt; (*el_2)-&gt;size)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Display N biggest currently allocated dynamic memory objects ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_tshowobjects(<span class="Type">const</span> <span class="Type">FILE</span> *stream, <span class="Type">int</span> *display_objects)

{   <span class="Type">int</span> i,
        t_cnt = <span class="Constant">0</span>;

    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> heap_used        = <span class="Constant">0</span>;
    matab_object_type **ordered_object = (matab_object_type **)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_tshowobjects] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Statement">if</span>(matab.allocated == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(<span class="Constant">0</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> As we may inadvertantly re-order the object table while we are doing a critical </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> operation on it (e.g. using one of the tracked object allocator routines) make  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> a copy of the table and re-order that                                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    ordered_object = (matab_object_type **)pups_calloc(matab.allocated,<span class="Statement">sizeof</span>(matab_type *));
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;matab.allocated; ++i)
    {  <span class="Statement">if</span>(matab.object[i] != (matab_object_type *)<span class="Constant">NULL</span>)
       {  ordered_object[t_cnt] = matab.object[i];
          ++t_cnt;
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;matab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Order the objects so the largest ones are always towards the top of the list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)qsort((<span class="Type">void</span> *)ordered_object,t_cnt,<span class="Statement">sizeof</span>(matab_object_type *),(<span class="Type">void</span> *)compare_objects);

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Heap objects for </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,getpid(),appl_host);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">if</span>(*display_objects &gt; t_cnt &amp;&amp; display_objects != (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
       *display_objects = t_cnt;

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;display_objects; ++i)
    {  (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: Object </span><span class="Special">%-32s</span><span class="Constant"> (type </span><span class="Special">%-32s</span><span class="Constant">) size </span><span class="Special">%016lx</span><span class="Constant"> (at </span><span class="Special">%016lx</span><span class="Constant"> virtual)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,i,
                                                                              ordered_object[i]-&gt;name,
                                                                              ordered_object[i]-&gt;type,
                                                                              ordered_object[i]-&gt;size,
                                                            (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)ordered_object[i]-&gt;ptr);
       (<span class="Type">void</span>)fflush(stream);

       heap_used += ordered_object[i]-&gt;size;
    }


    <span class="Statement">if</span>(t_cnt &gt; <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> tracked objects [in </span><span class="Special">%016lx</span><span class="Constant"> bytes of heap] (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,t_cnt,heap_used,matab.allocated - t_cnt);
    <span class="Statement">else</span> <span class="Statement">if</span>(t_cnt == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    </span><span class="Special">%04d</span><span class="Constant"> tracked objects [in </span><span class="Special">%016lx</span><span class="Constant"> bytes of heap] (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,heap_used,matab.allocated - <span class="Constant">1</span>);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    no tracked objects (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,matab.allocated);
    (<span class="Type">void</span>)fflush(stream);

    (<span class="Type">void</span>)pups_free((<span class="Type">void</span> *)ordered_object);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended fgets function ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *pups_fgets(<span class="Type">char</span> *s, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size, <span class="Type">const</span> <span class="Type">FILE</span> *stream)


{   <span class="Type">int</span>  c_index;
    <span class="Type">char</span> *ret = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

    ret = fgets(s,size,stream);
    <span class="Statement">if</span>((c_index = ch_pos(s,<span class="Special">'\n'</span>)) != (-<span class="Constant">1</span>))
       s[c_index] = <span class="Special">'\0'</span>;

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Test to see if line is a comment line (first non-space char is '#') or</span>
<span class="Comment">    empty ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN strcomment(<span class="Type">const</span> <span class="Type">char</span> *s)

{   <span class="Type">size_t</span> i;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Empty line </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(s[<span class="Constant">0</span>] ==<span class="Special">'\0'</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(TRUE);
    }

    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Comment or white/tab space? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s); ++i)
    {  <span class="Statement">if</span>(s[i] != <span class="Constant">' '</span>)
       {  <span class="Statement">if</span>(s[i] == <span class="Constant">'#'</span>)
          {  pups_set_errno(OK);
             <span class="Statement">return</span>(TRUE);
          }
       }
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Clear a string - set all characters to NULL '\0' ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> strclr(<span class="Type">char</span> *s)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s); ++i)
       s[i] = <span class="Special">'\0'</span>;

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Set errno ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_set_errno(<span class="Type">int</span> pups_errno)

{

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    <span class="Comment">//if(appl_root_thread != 0 &amp;&amp; pupsthread_is_root_thread() == FALSE)</span>
    <span class="Comment">//   pupsthread_set_errno(errno);</span>
    <span class="Comment">//else</span>
       errno = pups_errno;
<span class="PreProc">    #else</span>
      errno = pups_errno;
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

}





<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get errno ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_errno(<span class="Type">void</span>)

{   <span class="Statement">return</span>(errno);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Handler for SIGTTIN/SIGTTOU (automatically re-directs stdio to datasink if application</span>
<span class="Comment">    moved into background interactively from a shell) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> fgio_handler(<span class="Type">int</span> signum)

{

    <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
       <span class="Constant">stdin</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fname,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">0</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
    }

    <span class="Statement">if</span>(isatty(<span class="Constant">1</span>) == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
       <span class="Constant">stdout</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fname,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">1</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
    }

    <span class="Statement">if</span>(isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>)
    {  (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);
       <span class="Constant">stderr</span> = fopen(<span class="Constant">&quot;/dev/null&quot;</span>,<span class="Constant">&quot;w&quot;</span>);
       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fname,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
       (<span class="Type">void</span>)strlcpy(ftab[<span class="Constant">2</span>].fshadow,<span class="Constant">&quot;/dev/null&quot;</span>,SSIZE);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Turn tty echoing off ...</span>

<span class="Comment">    It is desirable to use this bit on systems that have it.</span>
<span class="Comment">    The only bit of terminal state we want to twiddle is echoing, which is</span>
<span class="Comment">    done in software; there is no need to change the state of the terminal</span>
<span class="Comment">    hardware ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#ifndef TCSASOFT</span>
<span class="PreProc">#define TCSASOFT </span><span class="Constant">0</span>
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> TCSASOFT </span><span class="Comment">*/</span>


_PUBLIC <span class="Type">int</span> pups_tty_echoing_off(<span class="Type">FILE</span> *in, <span class="Type">struct</span> termios *s)

{   <span class="Type">int</span>    tty_changed;
    <span class="Type">struct</span> termios t;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Turn echoing off if it is on now. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(tcgetattr (fileno (in), &amp;t) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Save the old one. </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

       *s = t;


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Tricky, tricky. </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       t.c_lflag &amp;= ~(ECHO|ISIG);
       tty_changed = (tcsetattr (fileno (in), TCSAFLUSH|TCSASOFT, &amp;t) == <span class="Constant">0</span>);
    }
    <span class="Statement">else</span>
       tty_changed = <span class="Constant">0</span>;

    <span class="Statement">return</span>(tty_changed);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Turn tty echoing on ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_tty_echoing_on(<span class="Type">FILE</span> *in, <span class="Type">int</span> tty_changed, <span class="Type">struct</span> termios s)

{

    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restore the original setting. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(tty_changed)
       (<span class="Type">void</span>) tcsetattr (fileno (in), TCSAFLUSH|TCSASOFT, &amp;s);
}





<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Execute command on local host ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_lexec(<span class="Type">char</span>   *shell,    <span class="Comment">/*</span><span class="Comment"> Shell to execute comamnd                      </span><span class="Comment">*/</span>
                       <span class="Type">char</span> *command,    <span class="Comment">/*</span><span class="Comment"> Command to be executed                        </span><span class="Comment">*/</span>
                       <span class="Type">int</span>      wait)    <span class="Comment">/*</span><span class="Comment"> Wait action flag                              </span><span class="Comment">*/</span>

{   <span class="Type">int</span> i,
        pid,
        status;

    _BOOLEAN obituary = FALSE;

    <span class="Statement">if</span>(shell == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || command == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Fork thread of control to create new process. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(wait &amp; PUPS_OBITUARY)
       obituary = TRUE;

    <span class="Statement">if</span>((pid = pups_fork(TRUE, obituary)) == <span class="Constant">0</span>)
    {  <span class="Type">int</span> i;


       <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Set effective and real user i.d's </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)setreuid(getuid(),getuid());


       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear any pending alarm </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_malarm(<span class="Constant">0</span>);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Restore all signals to default states </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;MAX_SIGS; ++i)
          (<span class="Type">void</span>)pups_sighandle(i,<span class="Constant">&quot;default&quot;</span>,<span class="Constant">SIG_DFL</span>, (sigset_t *)<span class="Constant">NULL</span>);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extract argument list for execl call and overlay. </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(execlp(shell,shell,<span class="Constant">&quot;-c&quot;</span>,command,(<span class="Type">char</span> *)<span class="Constant">0</span>) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Parent side of fork - return childs pid if we are not going to wait for it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> otherwise return the child's exit status.                                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_set_child_name(pid,command);

       <span class="Statement">if</span>(wait == PUPS_WAIT_FOR_CHILD)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Wait for the child we have forked </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(waitpid(pid,&amp;status,<span class="Constant">0</span>) == (-<span class="Constant">1</span>))
          {  pups_set_errno(<span class="Constant">ECHILD</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(status);
       }

       pups_set_errno(OK);
       <span class="Statement">return</span>(pid);
    }

    pups_set_errno(<span class="Constant">ENOSYS</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}





<span class="PreProc">#ifdef PSRP_AUTHENTICATE</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Check supplied secure application password ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_check_appl_password(<span class="Type">char</span> *password)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_check_appl_password] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(password == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check arguments -- if any are NULL simply return </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(TRUE);
    }

    <span class="Statement">if</span>(strncmp(password,appl_password,strlen(appl_password)-<span class="Constant">1</span>) != <span class="Constant">0</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if remote user is permitted to run this service ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_checkuser(<span class="Type">char</span> *username, <span class="Type">char</span> *password)

{   <span class="Type">struct</span> passwd  *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> salt[<span class="Constant">2</span>]                 = <span class="Constant">&quot;&quot;</span>,
         crypted_password[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_checkuser] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(username == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || password == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Authenticate remote user </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((pwent = pups_getpwnam(username)) == (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ESRCH</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Crypt password using first two characters </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in password for &quot;salt&quot;                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Crypt password using first two characters </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in in encrypted password for &quot;salt&quot;       </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    salt[<span class="Constant">0</span>] = pwent-&gt;pw_passwd[<span class="Constant">0</span>];
    salt[<span class="Constant">1</span>] = pwent-&gt;pw_passwd[<span class="Constant">1</span>];
    (<span class="Type">void</span>)strlcpy((<span class="Type">char</span> *)&amp;crypted_password,(<span class="Type">char</span> *)crypt(password,salt),SSIZE);

    <span class="Statement">if</span>(strcmp(pwent-&gt;pw_passwd,crypted_password) != <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EPERM</span>);
       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if we have an authentication token set ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_check_pass_set(<span class="Type">void</span>)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_check_pass_set] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) == <span class="Constant">0</span>)
       <span class="Statement">return</span>(FALSE);

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get authentication token -- Firstly we search /tmp to see if we have a auth file for</span>
<span class="Comment">    our application owner, if that fails, we see if we can reach a controlling tty for</span>
<span class="Comment">    manual password by the user. If we cannot reach a controlling tty -- abort ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_getpass(<span class="Type">char</span> *password_banner)

{   <span class="Type">char</span> pwd_file_name[SSIZE]         = <span class="Constant">&quot;&quot;</span>,
         pups_password_banner[SSIZE]  = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_getpass] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(password_banner == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check to see if we actually need to obtain an authentication </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> token                                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(appl_password,<span class="Constant">&quot;notset&quot;</span>) != <span class="Constant">0</span>)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(TRUE);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search /tmp for an authorisation token for application owner </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(pwd_file_name,SSIZE,<span class="Constant">&quot;/tmp/auth.</span><span class="Special">%s</span><span class="Constant">.tmp&quot;</span>,appl_owner);
    <span class="Statement">if</span>(access(pwd_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
    {

       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Can we get to a controlling tty to talk to our user? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((isatty(<span class="Constant">0</span>) == <span class="Constant">1</span> || isatty(<span class="Constant">1</span>) == <span class="Constant">1</span> || isatty(<span class="Constant">2</span>) == <span class="Constant">1</span>) &amp;&amp; access(pwd_file_name,F_OK | R_OK | W_OK) == (-<span class="Constant">1</span>))
       {  <span class="Type">int</span> indes = (-<span class="Constant">1</span>);


          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Is stdin indirected? If so we need to inverse indirect it so we </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> can talk to our user                                            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(isatty(<span class="Constant">0</span>) == <span class="Constant">0</span>)
          {  <span class="Type">int</span> ttydes = (-<span class="Constant">1</span>);

<span class="PreProc">             #ifdef UTILIB_DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;pups_getpass [</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">] duplicating stdin (and saving intial descriptor)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,getpid(),appl_host);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

             indes  = dup(<span class="Constant">0</span>);
          }

          (<span class="Type">void</span>)snprintf(pups_password_banner,SSIZE,<span class="Constant">&quot;PUPS </span><span class="Special">%s</span><span class="Constant"> [</span><span class="Special">%s</span><span class="Constant">] login: &quot;</span>,password_banner,appl_host);
          (<span class="Type">void</span>)strlcpy(appl_password,(<span class="Type">char</span> *)getpass(pups_password_banner),SSIZE);


          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Check authentication token </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(pups_checkuser(appl_owner,appl_password) == FALSE)
          {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;pups_getpass [</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">]: permission denied</span><span class="Special">\n</span><span class="Constant">&quot;</span>,getpid(),appl_name);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

             pups_set_errno(<span class="Constant">EPERM</span>);
             <span class="Statement">return</span>(FALSE);
          }


          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have had to inverse indirect restore stdin </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> to its intial (e.g. indirected) state            </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(indes != (-<span class="Constant">1</span>))
          {  (<span class="Type">void</span>)dup2(indes,<span class="Constant">0</span>);
             (<span class="Type">void</span>)close(indes);

<span class="PreProc">             #ifdef DEBUG</span>
             (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;rfifod [</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">]: initial stdin descriptor restored (after password entry)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,getpid(),appl_host);
             (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> DEBUG </span><span class="Comment">*/</span>
          }

          pups_set_errno(OK);
          <span class="Statement">return</span>(TRUE);
       }
    }
    <span class="Statement">else</span>
    {  <span class="Type">FILE</span> *pwd_stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Extract token from authorisation token file </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       pwd_stream = pups_fopen(pwd_file_name,<span class="Constant">&quot;r&quot;</span>,DEAD);

       (<span class="Type">void</span>)fscanf(pwd_stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_password);
       (<span class="Type">void</span>)pups_fclose(pwd_stream);


       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Check authentication token </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(pups_checkuser(appl_owner,appl_password) == FALSE)
       {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">: permission denied</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_pid,appl_name);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);

          pups_set_errno(<span class="Constant">EPERM</span>);
          <span class="Statement">return</span>(FALSE);
       }

       pups_set_errno(OK);
       <span class="Statement">return</span>(TRUE);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We cannot get an authentication token </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    pups_set_errno(<span class="Constant">EPERM</span>);
    <span class="Statement">return</span>(FALSE);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> PSRP_AUTHENTICATE </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Handler for SIGSEGV, SIGBUS and SIGFPE ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> segbusfpe_handler(<span class="Type">int</span> signum)

{    <span class="Type">int</span> i;

     <span class="Statement">if</span>(signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
     {  pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }


     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Make sure that shadows are removed. The files </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> which they are shadowing are not removed as   </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> they may contain information which will aid   </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> debugging                                     </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_lock(&amp;ftab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_max_files; ++i)
     {  <span class="Statement">if</span>(ftab[i].fshadow != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(ftab[i].fshadow,<span class="Constant">&quot;none&quot;</span>) != <span class="Constant">0</span>)
           (<span class="Type">void</span>)unlink(ftab[i].fshadow);
     }

<span class="PreProc">     #ifdef PTHREAD_SUPPORT</span>
     (<span class="Type">void</span>)pthread_mutex_unlock(&amp;ftab_mutex);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

     (<span class="Type">void</span>)strdate(date);

     <span class="Statement">if</span>(appl_verbose == TRUE)
     {  <span class="Statement">switch</span>(signum)
        {    <span class="Statement">case</span> <span class="Constant">SIGSEGV</span>:  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIGSEGV</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
                            <span class="Statement">break</span>;

             <span class="Statement">case</span> <span class="Constant">SIGFPE</span>:   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIGFPE</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
                            <span class="Statement">break</span>;

             <span class="Statement">case</span> SIGBUS:   (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): SIGBUS</span><span class="Special">\n</span><span class="Constant">&quot;</span>,date,appl_name,appl_pid,appl_host,appl_owner);
                            <span class="Statement">break</span>;

             <span class="Statement">default</span>:       <span class="Statement">break</span>;
        }
    }

    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are error trapping wait to be attached to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> a debugger here                                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(appl_etrap == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> SIGTERM must be released so we can terminate the process </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)sigfillset(&amp;set);
       (<span class="Type">void</span>)sigdelset(&amp;set,<span class="Constant">SIGTERM</span>);
       (<span class="Type">void</span>)sigdelset(&amp;set,<span class="Constant">SIGINT</span>);

       (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;old_set,(sigset_t *)<span class="Constant">NULL</span>);

       <span class="Statement">while</span>(<span class="Constant">1</span>)
            (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);
    }

    pups_exit(<span class="Constant">255</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    PUPS kill function which notes state of signalled process - processes which are</span>
<span class="Comment">    terminated or stopped return appropriate error condition ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_statkill(<span class="Type">const</span> <span class="Type">int</span> pid, <span class="Type">const</span> <span class="Type">int</span> signum)

{   <span class="Type">int</span>  next_pid;

    <span class="Type">char</span> line[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         procstatus[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *procstream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(pid &lt;= <span class="Constant">0</span> || signum &lt; <span class="Constant">1</span> || signum &gt; MAX_SIGS)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(procstatus,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/status&quot;</span>,pid);
    <span class="Statement">if</span>(access(procstatus,F_OK) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(PUPS_TERMINATED);

    procstream = fopen(procstatus,<span class="Constant">&quot;r&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We have to search for the relevant line in the </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> status file as this file is kernel dependent   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {    (<span class="Type">void</span>)fgets(line,SSIZE,procstream);
       } <span class="Statement">while</span>(strin(line,<span class="Constant">&quot;State&quot;</span>) == FALSE);

    (<span class="Type">void</span>)fclose(procstream);

    <span class="Statement">if</span>(strin(line,<span class="Constant">&quot;T&quot;</span>) == TRUE)
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(PUPS_STOPPED);
    }

<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;UTILIB SENDING SIGNAL </span><span class="Special">%d</span><span class="Special">\n</span><span class="Constant">&quot;</span>,signum);
    (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

    <span class="Statement">if</span>(kill(pid,signum) == (-<span class="Constant">1</span>))
    {  pups_set_errno(OK);
       <span class="Statement">return</span>(PUPS_TERMINATED);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(PUPS_EXEC);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended lockf ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_lockf(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">int</span> cmd, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size)

{   <span class="Type">int</span>    ret = <span class="Constant">0</span>;
    <span class="Type">struct</span> flock lock;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Santity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(fdes &lt;  <span class="Constant">0</span>                 ||
       fdes &gt;= appl_max_files     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Check lock command </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
                                     <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Statement">if</span>(cmd != PUPS_UNLOCK        &amp;&amp;  <span class="Comment">/*</span><span class="Comment"> Unlock memory segment                     </span><span class="Comment">*/</span>
       cmd != PUPS_RDLOCK        &amp;&amp;  <span class="Comment">/*</span><span class="Comment"> Blocking read lock on memory segment      </span><span class="Comment">*/</span>
       cmd != PUPS_TRY_RDLOCK    &amp;&amp;  <span class="Comment">/*</span><span class="Comment"> Non blocking read lock on memebry segment </span><span class="Comment">*/</span>
       cmd != PUPS_WRLOCK        &amp;&amp;  <span class="Comment">/*</span><span class="Comment"> Blocking write lock on memory segment     </span><span class="Comment">*/</span>
       cmd != PUPS_TRY_WRLOCK     )  <span class="Comment">/*</span><span class="Comment"> Non blocking write lock on memory segment </span><span class="Comment">*/</span>
                                     <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    {

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    (<span class="Type">void</span>)pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> fcntl() lock type translation </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cmd == PUPS_RDLOCK || cmd == PUPS_TRY_RDLOCK)
       lock.l_type = F_RDLCK;
    <span class="Statement">else</span> <span class="Statement">if</span>(cmd == PUPS_WRLOCK || cmd == PUPS_TRY_WRLOCK)
       lock.l_type = F_WRLCK;
    <span class="Statement">else</span>
       lock.l_type = F_UNLCK;


    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Segment details </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

    lock.l_whence = <span class="Constant">SEEK_SET</span>;
    lock.l_start  = <span class="Constant">0L</span>;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If segment size is zero just lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> address specified                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(size == <span class="Constant">0L</span>)
       lock.l_len = <span class="Statement">sizeof</span>(<span class="Type">void</span> *);
    <span class="Statement">else</span>
       lock.l_len = size;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Acquire lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    ret = fcntl(fdes,F_SETLK,&amp;lock);

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get load average for localhost ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC FTYPE pups_get_load_average(<span class="Type">const</span> <span class="Type">int</span> which_load_average)

{   <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    FTYPE l_1,
          l_2,
          l_3;

    <span class="Statement">if</span>((stream = fopen(<span class="Constant">&quot;/proc/loadavg&quot;</span>,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1.0</span>);
    }

    (<span class="Type">void</span>)fscanf(stream,<span class="Constant">&quot;</span><span class="Special">%F%F%F</span><span class="Constant">&quot;</span>,&amp;l_1,&amp;l_2,&amp;l_3);
    (<span class="Type">void</span>)fclose(stream);

    <span class="Statement">switch</span>(which_load_average)
    {     <span class="Statement">case</span> LOAD_AVERAGE_1: pups_set_errno(OK);
                               <span class="Statement">return</span>(l_1);

          <span class="Statement">case</span> LOAD_AVERAGE_2: pups_set_errno(OK);
                               <span class="Statement">return</span>(l_2);

          <span class="Statement">case</span> LOAD_AVERAGE_3: pups_set_errno(OK);
                               <span class="Statement">return</span>(l_3);

          <span class="Statement">default</span>:   pups_set_errno(<span class="Constant">EINVAL</span>);
                     <span class="Statement">return</span>(-<span class="Constant">1.0</span>);
    }

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Test whether fdes is associated with a seekable device ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_seekable(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Statement">if</span>(pups_lseek(fdes,<span class="Constant">0</span>,<span class="Constant">SEEK_CUR</span>) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(FALSE);

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}



<span class="PreProc">#ifdef CRIU_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Checkpoint version tag </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define SSAVETAG    </span><span class="Constant">20</span>

<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------</span>
<span class="Comment">    Handler for SIGCHECK -- service an asynchronous checkpoint ...</span>
<span class="Comment">------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> ssave_handler(<span class="Type">int</span> signum)

{    <span class="Type">char</span> buildStr[SSIZE]  = <span class="Constant">&quot;&quot;</span>,
          buildpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
          ssave_buildpath  = <span class="Constant">&quot;&quot;</span>,
          criu_cmd[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

     <span class="Type">struct</span> timespec delay;

     <span class="Type">FILE</span> *stream        = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


<span class="PreProc">     #ifdef UTILIB_DEBUG</span>
     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;SIGCHECK: SAVING STATE AND EXITING (checkpoint </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_ssaves);
     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Create checkpointing directory if it doesn't exist </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)snprintf(appl_ssave_dir,SSIZE,<span class="Constant">&quot;/tmp/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.ssave&quot;</span>,appl_name,appl_pid);
     <span class="Statement">if</span>(access(appl_ssave_dir,F_OK) == (-<span class="Constant">1</span>))
     {  <span class="Statement">if</span>(mkdir(appl_ssave_dir,<span class="PreProc">0</span><span class="Constant">700</span>) == (-<span class="Constant">1</span>))


           <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> Error - cannot create state saving directory </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

           <span class="Statement">return</span>(-<span class="Constant">1</span>);
     }

     <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Run Criu command to save state      </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> it must run in background so it     </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> is not included in the process tree </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> of the caller                       </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>


     <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Kill server after saving state </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)snprintf(criu_cmd,SSIZE,<span class="Constant">&quot;criu --log-file /dev/null --shell-job --link-remap dump -D </span><span class="Special">%s</span><span class="Constant"> -t </span><span class="Special">%d</span><span class="Constant"> &amp;&quot;</span>,appl_ssave_dir,appl_pid);


     <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Build details for this application </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)snprintf(buildStr,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%d</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant">&quot;</span>,getenv(<span class="Constant">&quot;MACHTYPE&quot;</span>),SSAVETAG,<span class="Constant">__DATE__</span>);


     <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Put build date of this application </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> in checkpoint directory so restart </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> can see if it is stale             </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)snprintf(ssave_buildpath,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/build&quot;</span>,appl_ssave_dir);
     <span class="Statement">if</span>(access(ssave_buildpath,F_OK) == (-<span class="Constant">1</span>))
        (<span class="Type">void</span>)close(creat(ssave_buildpath,<span class="PreProc">0</span><span class="Constant">600</span>));

     stream = fopen(ssave_buildpath,<span class="Constant">&quot;w&quot;</span>);
     (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Special">\n</span><span class="Constant">&quot;</span>,buildStr);
     (<span class="Type">void</span>)fflush(stream);
     (<span class="Type">void</span>)fclose(stream);


     <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Take checkpoint </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)system(criu_cmd);


     <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> This is a dummy system call - on restore </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> EINTR will be generated and the process  </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> will restart from here                   </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

     delay.tv_sec  = <span class="Constant">60</span>;
     delay.tv_nsec = <span class="Constant">0</span>;

     (<span class="Type">void</span>)nanosleep(&amp;delay,(<span class="Type">struct</span> timespec *)<span class="Constant">NULL</span>);

<span class="PreProc">     #ifdef UTILIB_DEBUG</span>
     (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;RESTART (checkpoint: </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_ssaves);
     (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">     #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>

     ++appl_ssaves;


     <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Reschedule timers </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

     (<span class="Type">void</span>)pups_malarm(vitimer_quantum);
     <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span>
<span class="Comment">    Relay data between master and slave using FIFOS. </span>
<span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fifo_relay(<span class="Type">const</span> <span class="Type">int</span> slave_pid, <span class="Type">const</span> <span class="Type">int</span> in_fifo, <span class="Type">const</span> <span class="Type">int</span> out_fifo)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> in_bytes_read,
                      out_bytes_read;

    _BYTE buf[<span class="Constant">512</span>] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">do</span> {   <span class="Statement">if</span>(in_bytes_read = read(<span class="Constant">0</span>,buf,<span class="Constant">512</span>) &lt; <span class="Constant">0</span>)
              <span class="Statement">return</span>(-<span class="Constant">1</span>);

           <span class="Statement">if</span>(in_bytes_read &gt; <span class="Constant">0</span>)
           {  <span class="Statement">if</span>(write(out_fifo,buf,in_bytes_read) &lt; <span class="Constant">0</span>)
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
           }

           <span class="Statement">if</span>(out_bytes_read = read(in_fifo,buf,<span class="Constant">512</span>) &lt; <span class="Constant">0</span>)
              <span class="Statement">return</span>(-<span class="Constant">1</span>);

           <span class="Statement">if</span>(out_bytes_read &gt; <span class="Constant">0</span>)
           {  <span class="Statement">if</span>(write(<span class="Constant">1</span>,buf,out_bytes_read) &lt; <span class="Constant">0</span>)
                 <span class="Statement">return</span>(-<span class="Constant">1</span>);
           }
       } <span class="Statement">while</span>(pups_statkill(slave_pid,SIGALIVE) == PUPS_EXEC);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Make sure master is completely emptied </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {  <span class="Statement">if</span>(out_bytes_read = read(in_fifo,buf,<span class="Constant">512</span>) &lt; <span class="Constant">0</span>)
             <span class="Statement">return</span>(-<span class="Constant">1</span>);

          <span class="Statement">if</span>(out_bytes_read &gt; <span class="Constant">0</span>)
          {  <span class="Statement">if</span>(write(<span class="Constant">1</span>,buf,out_bytes_read) &lt; <span class="Constant">0</span>)
                <span class="Statement">return</span>(-<span class="Constant">1</span>);
             <span class="Statement">else</span>
                (<span class="Type">void</span>)tcdrain(<span class="Constant">1</span>);
          }
       } <span class="Statement">while</span>(out_bytes_read &gt; <span class="Constant">0</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Detect window resize data (embedded in a buffer of data). If resizing data is found</span>
<span class="Comment">    extract it and return it as a struct winsize ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN ws_extract(<span class="Type">int</span>                fdes,          <span class="Comment">/*</span><span class="Comment"> File descriptor for ibuf    </span><span class="Comment">*/</span>
                             _BYTE              *buf,          <span class="Comment">/*</span><span class="Comment"> Input buffer                </span><span class="Comment">*/</span>
                             <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>  bytes_read,    <span class="Comment">/*</span><span class="Comment"> Bytes in input buffer       </span><span class="Comment">*/</span>
                             _BYTE              *obuf_1,       <span class="Comment">/*</span><span class="Comment"> Pre resize buffer           </span><span class="Comment">*/</span>
                             <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>  *bytes_out_1,  <span class="Comment">/*</span><span class="Comment"> Number of pre resize bytes  </span><span class="Comment">*/</span>
                             _BYTE              *obuf_2,       <span class="Comment">/*</span><span class="Comment"> Post resize buffer          </span><span class="Comment">*/</span>
                             <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>  *bytes_out_2,  <span class="Comment">/*</span><span class="Comment"> Number of post resize bytes </span><span class="Comment">*/</span>
                             <span class="Type">struct</span> winsize     *ws)           <span class="Comment">/*</span><span class="Comment"> Winsize structure           </span><span class="Comment">*/</span>

{   <span class="Type">int</span> i,
        j,
        cnt = <span class="Constant">0</span>;

    _BYTE row_bytes[<span class="Constant">2</span>] = <span class="Constant">&quot;&quot;</span>,
          col_bytes[<span class="Constant">2</span>] = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN fill_obuf_2 = FALSE,
             buf_spill   = FALSE;


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Search for '255' which indicates that we need to resize </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> window associated with in_buf                           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;bytes_read; ++i)
    {  <span class="Statement">if</span>(buf[i] == WINRESIZE_PENDING)
       {  fill_obuf_2  = TRUE;
          *bytes_out_1 = cnt;
          cnt          = <span class="Constant">0</span>;


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Read next 4 bytes (which contain row and col </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> co-ordinates for the resize.                 </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> If we have less than four bytes read in the  </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> extra bytes.                                 </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

          ++i;
          <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;<span class="Constant">2</span>; ++j)
          {  <span class="Statement">if</span>(i+j &lt; bytes_read)
                row_bytes[j] = buf[i++];
             <span class="Statement">else</span>
             {  <span class="Comment">/*</span><span class="Comment"> Buffer spill - read missing bytes </span><span class="Comment">*/</span>
                buf_spill = TRUE;

                (<span class="Type">void</span>)fcntl(<span class="Constant">0</span>,F_SETFL, fcntl(<span class="Constant">0</span>,F_GETFL,<span class="Constant">0</span>) &amp; ~O_NONBLOCK);
                (<span class="Type">void</span>)read(fdes,&amp;row_bytes[j],<span class="Constant">1</span>);
                (<span class="Type">void</span>)fcntl(<span class="Constant">0</span>,F_SETFL, fcntl(<span class="Constant">0</span>,F_GETFL,<span class="Constant">0</span>) | O_NONBLOCK);
             }
          }

          <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;<span class="Constant">2</span>; ++j)
          {  <span class="Statement">if</span>(i+j &lt; bytes_read)
                col_bytes[j] = buf[i++];
             <span class="Statement">else</span>
             {  <span class="Comment">/*</span><span class="Comment"> Buffer spill - read missing bytes </span><span class="Comment">*/</span>
                buf_spill = TRUE;

                (<span class="Type">void</span>)fcntl(<span class="Constant">0</span>,F_SETFL,fcntl(<span class="Constant">0</span>,F_GETFL,<span class="Constant">0</span>) &amp; ~O_NONBLOCK);
                (<span class="Type">void</span>)read(fdes,&amp;col_bytes[j],<span class="Constant">1</span>);
                (<span class="Type">void</span>)fcntl(<span class="Constant">0</span>,F_SETFL, fcntl(<span class="Constant">0</span>,F_GETFL,<span class="Constant">0</span>) | O_NONBLOCK);
             }
          }

          ws-&gt;ws_row = row_bytes[<span class="Constant">0</span>] + <span class="Constant">256</span>*row_bytes[<span class="Constant">1</span>];
          ws-&gt;ws_col = col_bytes[<span class="Constant">0</span>] + <span class="Constant">256</span>*col_bytes[<span class="Constant">1</span>];
       }

       <span class="Statement">if</span>(fill_obuf_2 == TRUE)
       {  <span class="Statement">if</span>(buf_spill == FALSE)
             obuf_2[cnt++] = buf[i];
       }
       <span class="Statement">else</span>
          obuf_1[cnt++] = buf[i];
    }

    *bytes_out_2 = cnt;

    <span class="Statement">if</span>(fill_obuf_2 == TRUE || buf_spill == TRUE)
       <span class="Statement">return</span>(TRUE);
    <span class="Statement">else</span>
       <span class="Statement">return</span>(FALSE);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span>
<span class="Comment">    Wait for file to be unlinked before returning to caller ...</span>
<span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_unlink(<span class="Type">const</span> <span class="Type">char</span> *linkname)

{   <span class="Statement">if</span>(linkname == (<span class="Type">unsigned</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || unlink(linkname) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">while</span>(access(linkname,F_OK | R_OK | W_OK) == <span class="Constant">0</span>)
         (<span class="Type">void</span>)pups_usleep(<span class="Constant">100</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------</span>
<span class="Comment">    Clear a virtual timer datastructure ...</span>
<span class="Comment">--------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_clear_vitimer(<span class="Type">const</span> _BOOLEAN destroy, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">int</span> t_index)

{

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_clear_vitimer] attempt by non root thread to perform PUPS/P3 global utility operation&quot;</span>);


    <span class="Statement">if</span>(index &gt; appl_max_vtimers)
    {  pups_set_errno(<span class="Constant">ERANGE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    vttab[t_index].priority        = <span class="Constant">0</span>;
    vttab[t_index].mode            = VT_NONE;
    vttab[t_index].prescaler       = <span class="Constant">0</span>;
    vttab[t_index].interval_time   = <span class="Constant">0</span>;
    vttab[t_index].handler         = <span class="Constant">NULL</span>;

    <span class="Statement">if</span>(destroy == FALSE)
    {  vttab[t_index].name         = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
       vttab[t_index].handler_args = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;
    }
    <span class="Statement">else</span>
    {  vttab[t_index].name         = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)vttab[t_index].name);
       vttab[t_index].handler_args = (<span class="Type">char</span> *)pups_free((<span class="Type">void</span> *)vttab[t_index].handler_args);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Container for nanosleep function ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_usleep(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> useconds)

{   <span class="Type">int</span> i;

    <span class="Type">struct</span> timespec req,
                    rem;

    req.tv_sec  = <span class="Constant">0</span>;
    req.tv_nsec = useconds*<span class="Constant">1000</span>;

    rem.tv_sec  = <span class="Constant">0</span>;
    rem.tv_nsec = <span class="Constant">0</span>;

    (<span class="Type">void</span>)nanosleep(&amp;req,&amp;rem);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Is current file on a CDFS filesystem? ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_on_isofs(<span class="Type">const</span> <span class="Type">char</span> *f_name)

{   <span class="Type">struct</span> statfs buf;

    <span class="Statement">if</span>(f_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(statfs(f_name,&amp;buf) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(buf.f_type == ISOFS_SUPER_MAGIC)
       <span class="Statement">return</span>(TRUE);
    <span class="Statement">if</span>(buf.f_type == MS_RDONLY)
       <span class="Statement">return</span>(TRUE);

    pups_set_errno(<span class="Constant">ENOSYS</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Is current file descriptor connected to a CDFS filesystem?  ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_on_fisofs(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">struct</span> statfs buf;

    <span class="Statement">if</span>(fstatfs(fdes,&amp;buf) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(buf.f_type == ISOFS_SUPER_MAGIC)
       <span class="Statement">return</span>(TRUE);

    pups_set_errno(<span class="Constant">ENOSYS</span>);
    <span class="Statement">return</span>(FALSE);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Is current file on an NFS filesystem? ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_on_nfs(<span class="Type">const</span> <span class="Type">char</span> *f_name)

{   <span class="Type">struct</span> statfs buf;

    <span class="Statement">if</span>(f_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(FALSE);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the file system associated with this file an </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> NFS file system?                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(statfs(f_name,&amp;buf) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(buf.f_type == NFS_SUPER_MAGIC)
       <span class="Statement">return</span>(TRUE);

    pups_set_errno(<span class="Constant">ENOSYS</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Is current file on an NFS filesystem? ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_on_fnfs(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">struct</span> statfs buf;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If the file system associated with this file an </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> NFS file system?                                </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(fstatfs(fdes,&amp;buf) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(buf.f_type == NFS_SUPER_MAGIC)
       <span class="Statement">return</span>(TRUE);

    pups_set_errno(<span class="Constant">ENOSYS</span>);
    <span class="Statement">return</span>(FALSE);
}





<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Copy a file (by name) ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_cpfile(<span class="Type">const</span> <span class="Type">char</span> *from_path, <span class="Type">const</span> <span class="Type">char</span> *to_path, <span class="Type">const</span> <span class="Type">int</span> mode)

{   <span class="Type">int</span> ret,
        fdes_from = (-<span class="Constant">1</span>),
        fdes_to   = (-<span class="Constant">1</span>);

    <span class="Type">char</span> tmp_to_path[<span class="Constant">512</span>] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(from_path == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || to_path == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((fdes_from = open(from_path,<span class="Constant">0</span>)) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(tmp_to_path,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.nac&quot;</span>,to_path,getpid());
    <span class="Statement">if</span>(pups_creat(tmp_to_path,mode) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)close(fdes_from);
       pups_set_errno(<span class="Constant">EPERM</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((fdes_to = open(tmp_to_path,<span class="Constant">1</span>)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)close(fdes_from);
       pups_set_errno(<span class="Constant">EBADF</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>((ret = pups_fcpfile(fdes_from,fdes_to)) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)unlink(tmp_to_path);
       pups_set_errno(<span class="Constant">EBADF</span>);

       <span class="Statement">return</span>(ret);
    }

    (<span class="Type">void</span>)close(fdes_from);
    (<span class="Type">void</span>)close(fdes_to);

    <span class="Statement">if</span>(rename(tmp_to_path,to_path) == (-<span class="Constant">1</span>))
    {  (<span class="Type">void</span>)unlink(tmp_to_path);
       pups_set_errno(<span class="Constant">EPERM</span>);

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Copy a file (by [open] descriptor) ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fcpfile(<span class="Type">const</span> <span class="Type">int</span> fdes_from, <span class="Type">const</span> <span class="Type">int</span> fdes_to)

{   <span class="Type">int</span>   bytes_read;
    _BYTE buf[<span class="Constant">512</span>]    = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">do</span> {    bytes_read = read(fdes_from,buf,<span class="Constant">512</span>);
            <span class="Statement">if</span>(bytes_read &lt; <span class="Constant">0</span>)
               <span class="Statement">return</span>(-<span class="Constant">1</span>);

            <span class="Statement">if</span>(bytes_read &gt; <span class="Constant">0</span>)
            {  <span class="Statement">if</span>(write(fdes_to,buf,bytes_read) &lt; <span class="Constant">0</span>)
                  <span class="Statement">return</span>(-<span class="Constant">1</span>);
            }

       } <span class="Statement">while</span>(bytes_read &gt; <span class="Constant">0</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Test to see if a given command is running ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_cmd_running(<span class="Type">void</span>)

{   <span class="Type">DIR</span>           *dirp      = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;

    dirp = opendir(<span class="Constant">&quot;/proc&quot;</span>);
    pups_set_errno(OK);

    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {   <span class="Type">int</span>  pid;

        <span class="Type">char</span> procpidpath[SSIZE] = <span class="Constant">&quot;&quot;</span>,
             cmd_line[SSIZE]    = <span class="Constant">&quot;&quot;</span>;

        <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


        <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Is this a valid process directory? </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(sscanf(next_item-&gt;d_name,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,&amp;pid) == <span class="Constant">1</span>)
        {  <span class="Type">int</span> i;

           (<span class="Type">void</span>)snprintf(procpidpath,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">/cmdline&quot;</span>,pid);

           stream = fopen(procpidpath,<span class="Constant">&quot;r&quot;</span>);
           (<span class="Type">void</span>)fgets(cmd_line,SSIZE,stream);
           (<span class="Type">void</span>)fclose(stream);
        }
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Comamnd is not being run (by anybody) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)closedir(dirp);
    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Test to see if I own a given process ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_i_own(<span class="Type">const</span> <span class="Type">int</span> pid)

{   <span class="Type">struct</span> stat buf;
    <span class="Type">char</span>   procpidpath[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(pid &lt;= <span class="Constant">1</span>)
    {   pups_set_errno(<span class="Constant">EINVAL</span>);
        <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(procpidpath,SSIZE,<span class="Constant">&quot;/proc/</span><span class="Special">%d</span><span class="Constant">&quot;</span>,pid);
    <span class="Statement">if</span>(access(procpidpath,F_OK | R_OK) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EEXIST</span>);
       <span class="Statement">return</span>(FALSE);
    }

    (<span class="Type">void</span>)stat(procpidpath,&amp;buf);
    <span class="Statement">if</span>(buf.st_uid != appl_uid)
    {  pups_set_errno(<span class="Constant">EPERM</span>);
       <span class="Statement">return</span>(FALSE);
    }

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Monitor nominated parent and exit if it is terminated ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_default_parent_homeostat(<span class="Type">void</span> *t_info, <span class="Type">const</span> <span class="Type">char</span> *args)

{

    <span class="Statement">if</span>(t_info == (<span class="Type">void</span> *)      <span class="Constant">NULL</span>  ||
       args   == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_default_parent_homeostat] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(kill(appl_ppid,SIGALIVE) == (-<span class="Constant">1</span>))
    {  <span class="Statement">if</span>(appl_verbose == TRUE)
       {  (<span class="Type">void</span>)strdate(date);
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): effective parent process [</span><span class="Special">%d</span><span class="Constant">] terminated -- exiting</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                  date,appl_name,appl_pid,appl_host,appl_owner,appl_ppid);
          (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
       }

       (<span class="Type">void</span>)pups_exit(<span class="Constant">255</span>);
    }

    pups_set_errno(OK);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Enable process homeostat (set up a &quot;support&quot; child to grab the thread of execution if</span>
<span class="Comment">    the parent process is fatally damaged by a dangerous operation) ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_process_homeostat_enable(<span class="Type">const</span> _BOOLEAN wait_if_damaged)

{   <span class="Type">int</span>      child_pid;

    _BOOLEAN save_appl_verbose   = FALSE,
             pups_parent_damaged = FALSE;

    <span class="Statement">if</span>((child_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We are the parent -- simply return the PID of </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> support child.                                </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------------</span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(child_pid);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Child process -- simply monitor parent </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    appl_ppid = appl_pid;
    appl_pid  = child_pid;

    <span class="Statement">if</span>(appl_verbose == TRUE)
       save_appl_verbose = appl_verbose;

    <span class="Statement">while</span>(kill(appl_ppid,SIGALIVE) == <span class="Constant">0</span>)
         pups_usleep(<span class="Constant">1000</span>);


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we get here the parent has been terminated. Support </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> child now takes over the computation.                  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------</span><span class="Comment">*/</span>

    appl_verbose        = save_appl_verbose;
    pups_parent_damaged = TRUE;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);

       <span class="Statement">if</span>(wait_if_damaged == TRUE)
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PID </span><span class="Special">%d</span><span class="Constant"> fatally damaged, support child (PID </span><span class="Special">%d</span><span class="Constant">) taking over computation (wait mode)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                        date,appl_name,appl_pid,appl_host,appl_owner,appl_ppid,appl_pid);
       <span class="Statement">else</span>
          (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): PID </span><span class="Special">%d</span><span class="Constant"> fatally damaged, support child (PID </span><span class="Special">%d</span><span class="Constant">) taking over computation</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                            date,appl_name,appl_pid,appl_host,appl_owner,appl_ppid,appl_pid);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Restart virtual timers </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(vitimer_quantum &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)pups_malarm(vitimer_quantum);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Rename PSRP channel (so it relates to child) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)psrp_rename_channel(appl_name);

    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait if user has requested us to do so </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(wait_if_damaged == TRUE)
    {  <span class="Statement">while</span>(pups_parent_damaged == TRUE)
            pups_usleep(<span class="Constant">1000</span>);
    }

    pups_set_errno(<span class="Constant">EFAULT</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Disable process hoemostat (support child)  ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_process_hoemostat_disable(<span class="Type">const</span> <span class="Type">int</span> child_pid)

{

    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are not the child make sure that we do not commit suicide! </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(child_pid != appl_pid)
       (<span class="Type">void</span>)kill(child_pid,<span class="Constant">SIGTERM</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended PUPS getpwnam routine which searches static password table. If this</span>
<span class="Comment">    fails, the appropriate NIS map is then searched ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">struct</span> passwd *pups_getpwnam(<span class="Type">const</span> <span class="Type">char</span> *username)

{   _IMMORTAL <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;


    <span class="Statement">if</span>(username == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Authenticate remote user </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> By static table          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((pwent = getpwnam(username)) == (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>)
    {

<span class="PreProc">      #ifdef NIS_SUPPORT</span>
       _BYTE  pwent_buf[<span class="Constant">204</span>]     = <span class="Constant">&quot;&quot;</span>;
       <span class="Type">struct</span> passwd **pwent_ptr = (<span class="Type">struct</span> passwd **)<span class="Constant">NULL</span>;

       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> By NIS map </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((_nss_nis_getpwnam_r(username,&amp;pwent,pwent_buf,pwent_ptr)) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ESRCH</span>);
          <span class="Statement">return</span>((<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>);
       }
<span class="PreProc">       #else</span>
       pups_set_errno(<span class="Constant">ESRCH</span>);
       <span class="Statement">return</span>((<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> NIS_SUPPORT </span><span class="Comment">*/</span>
    }


<span class="PreProc">    #ifdef SHADOW_SUPPORT </span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we running a shadow password file? If so get the &quot;real&quot; password </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> from /etc/shadow                                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(pwent-&gt;pw_passwd,<span class="Constant">&quot;x&quot;</span>) == <span class="Constant">0</span> &amp;&amp; geteuid() == <span class="Constant">0</span>)
    {  <span class="Type">struct</span> spwd *shadow = (<span class="Type">struct</span> spwd *)<span class="Constant">NULL</span>;

       <span class="Statement">if</span>((shadow = getspnam(username)) == (<span class="Type">struct</span> spwd *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ESRCH</span>);
          <span class="Statement">return</span>(FALSE);
       }

       pwent-&gt;pw_passwd = shadow-&gt;sp_pwdp;
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SHADOW_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(pwent);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended PUPS getpwnam routine which searches static password table. If this</span>
<span class="Comment">    fails, the appropriate NIS map is then searched ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">struct</span> passwd *pups_getpwuid(<span class="Type">const</span> <span class="Type">int</span> uid)

{   _IMMORTAL <span class="Type">struct</span> passwd *pwent = (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Authenticate remote user </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> By static table          </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((pwent = getpwuid(uid)) == (<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>)
    {

<span class="PreProc">       #ifdef NIS_SUPPORT</span>
       _BYTE  pwent_buf[<span class="Constant">204</span>]     = <span class="Constant">&quot;&quot;</span>;
       <span class="Type">struct</span> passwd **pwent_ptr = (<span class="Type">struct</span> passwd **)<span class="Constant">NULL</span>;


       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> By NIS map </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((_nss_nis_getpwnam_r(uid,&amp;pwent,pwent_buf,pwent_ptr)) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ESRCH</span>);
          <span class="Statement">return</span>((<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>);
       }
<span class="PreProc">       #else</span>
       pups_set_errno(<span class="Constant">ESRCH</span>);
       <span class="Statement">return</span>((<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> NIS_SUPPORT </span><span class="Comment">*/</span>
    }


<span class="PreProc">    #ifdef SHADOW_SUPPORT</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Are we running a shadow password file? If so get the &quot;real&quot; password </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> from /etc/shadow                                                     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(pwent-&gt;pw_passwd,<span class="Constant">&quot;x&quot;</span>) == <span class="Constant">0</span> &amp;&amp; geteuid() == <span class="Constant">0</span>)
    {  <span class="Type">struct</span> spwd *shadow = (<span class="Type">struct</span> spwd *)<span class="Constant">NULL</span>;

       <span class="Statement">if</span>((shadow = getspnam(pwent-&gt;pw_name)) == (<span class="Type">struct</span> spwd *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ESRCH</span>);
          <span class="Statement">return</span>((<span class="Type">struct</span> passwd *)<span class="Constant">NULL</span>);
       }

       pwent-&gt;pw_passwd = shadow-&gt;sp_pwdp;
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> SHADOW_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(pwent);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Table initialisation function for icrc_16 ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">unsigned</span> <span class="Type">short</span> icrc1(<span class="Type">unsigned</span> <span class="Type">short</span> crc, _BYTE onech)

{   <span class="Type">int</span> i;
    <span class="Type">unsigned</span> <span class="Type">short</span> ans = (crc ^ onech &lt;&lt; <span class="Constant">8</span>);


    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generator for one bit shifts and XOR's with the generator polynomial </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">8</span>; ++i)
    {  <span class="Statement">if</span>(ans &amp; <span class="Constant">0x8000</span>)
          ans = (ans &lt;&lt;= <span class="Constant">1</span>) ^ <span class="Constant">4129</span>;
       <span class="Statement">else</span>
          ans &lt;&lt;= <span class="Constant">1</span>;
    }

    <span class="Statement">return</span>(ans);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Compute 16 bit cyclic redundancy checksum ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Macros required by CRC functionality </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

<span class="PreProc">#define LOBYTE(x) ((_BYTE)((x) &amp; </span><span class="Constant">0xFF</span><span class="PreProc">))</span>
<span class="PreProc">#define HIBYTE(x) ((_BYTE)((x) &gt;&gt; </span><span class="Constant">8</span><span class="PreProc">))</span>

                                                            <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>
_PRIVATE <span class="Type">unsigned</span> <span class="Type">short</span> icrc_16(<span class="Type">unsigned</span> <span class="Type">short</span>    crc,      <span class="Comment">/*</span><span class="Comment"> Used to initialise input register if jrev negative </span><span class="Comment">*/</span>
                                _BYTE             *bufptr,  <span class="Comment">/*</span><span class="Comment"> Pointer to buffer we are computing checksum for    </span><span class="Comment">*/</span>
                                <span class="Type">size_t</span>            len,      <span class="Comment">/*</span><span class="Comment"> Lenght of the buffer                               </span><span class="Comment">*/</span>
                                <span class="Type">short</span> <span class="Type">int</span>         jinit,    <span class="Comment">/*</span><span class="Comment"> Initialistion                                      </span><span class="Comment">*/</span>
                                <span class="Type">int</span>               jrev)     <span class="Comment">/*</span><span class="Comment"> Compute reversed checksum                          </span><span class="Comment">*/</span>
                                                            <span class="Comment">/*</span><span class="Comment">----------------------------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">unsigned</span> <span class="Type">short</span> irc1(<span class="Type">unsigned</span> <span class="Type">short</span> <span class="Type">int</span> crc, _BYTE onech);

    _IMMORTAL <span class="Type">unsigned</span> <span class="Type">short</span> icrctb[<span class="Constant">256</span>] = { [<span class="Constant">0</span> ... <span class="Constant">255</span>] = <span class="Constant">0</span> },
                             init        = <span class="Constant">0</span>;

    _IMMORTAL _BYTE rchr[<span class="Constant">256</span>] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">unsigned</span> <span class="Type">long</span>  <span class="Type">int</span> i;
    <span class="Type">unsigned</span> <span class="Type">short</span> <span class="Type">int</span> j,
                       cword = crc;


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Table of 4 bit reverses </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

    _IMMORTAL _BYTE it[<span class="Constant">16</span>] = { <span class="Constant">0</span>,<span class="Constant">8</span>,<span class="Constant">4</span>,<span class="Constant">12</span>,<span class="Constant">2</span>,<span class="Constant">10</span>,<span class="Constant">6</span>,<span class="Constant">14</span>,<span class="Constant">1</span>,<span class="Constant">9</span>,<span class="Constant">5</span>,<span class="Constant">13</span>,<span class="Constant">3</span>,<span class="Constant">11</span>,<span class="Constant">7</span>,<span class="Constant">15</span> };


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Do we need to intialise tables? </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(!init)
    {  init = <span class="Constant">1</span>;
       <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;=<span class="Constant">255</span>; ++j)
       {

           <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment"> The two tables are: CRC's of all characters and bit reverses of all characters </span><span class="Comment">*/</span>
           <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

           icrctb[j] = icrc1(j &lt;&lt; <span class="Constant">8</span>,(_BYTE)<span class="Constant">0</span>);
           rchr[j]  = (_BYTE)(it[j &amp; <span class="Constant">0xF</span>] &lt;&lt; <span class="Constant">4</span> | it[j &gt;&gt; <span class="Constant">4</span>]);
       }
    }

    <span class="Statement">if</span>(jinit &gt;= <span class="Constant">0</span>)
       cword = ((_BYTE)jinit) | (((_BYTE)jinit) &lt;&lt; <span class="Constant">8</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(jrev &lt; <span class="Constant">0</span>)
       cword = rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] &lt;&lt; <span class="Constant">8</span>;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Initialise the remainder register </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;len; ++i)
       cword = icrctb[(jrev &lt; <span class="Constant">0</span> ? rchr[bufptr[i]] : bufptr[i]) ^ HIBYTE(cword)] ^ LOBYTE(cword) &lt;&lt; <span class="Constant">8</span>;

    <span class="Statement">return</span>(jrev &gt;= <span class="Constant">0</span> ? cword : rchr[HIBYTE(cword)] | rchr[LOBYTE(cword)] &lt;&lt; <span class="Constant">8</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Compute pseudo 32 bit cyclic redundancy checksum ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_crc_p32(<span class="Type">const</span> <span class="Type">size_t</span> len, _BYTE *bufptr)

{   <span class="Type">int</span> crc_p32,
        low_16_bits,
        high_16_bits;

    <span class="Statement">if</span>(len &lt;= <span class="Constant">0</span> || bufptr == (_BYTE *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Geneate 16 bit CRC's </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------</span><span class="Comment">*/</span>

    low_16_bits  = (<span class="Type">int</span>)icrc_16(<span class="Constant">0</span>,bufptr,len,<span class="Constant">0</span>,<span class="Constant">1</span>);
    high_16_bits = (<span class="Type">int</span>)icrc_16(<span class="Constant">0</span>,bufptr,len,<span class="Constant">0</span>,(-<span class="Constant">1</span>)) &gt;&gt; <span class="Constant">16</span>;

    crc_p32 = low_16_bits | high_16_bits;

    pups_set_errno(OK);
    <span class="Statement">return</span>(crc_p32);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Generate table for 64 bit CRC </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN      crc64_table_generated        = FALSE;
_PRIVATE <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> poly                     = <span class="Constant">0xC96C5795D7870F42</span>;
_PRIVATE <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> crc64_lookup_table[<span class="Constant">256</span>]  = { [<span class="Constant">0</span> ... <span class="Constant">255</span>] = <span class="Constant">0L</span> };
_PRIVATE pthread_mutex_t crc64_init_mutex;

_PRIVATE <span class="Type">void</span> generate_crc64_lookup_table(<span class="Type">void</span>)
{   <span class="Type">int</span> i,
        j;


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    pthread_mutex_trylock(&amp;crc64_init_mutex);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If someone has generated the table while we were waiting to </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> out work is done                                            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(crc64_table_generated == TRUE)
    {  pthread_mutex_unlock(&amp;crc64_init_mutex);
       <span class="Statement">return</span>;
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate look up table for 64 bit CRC </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;<span class="Constant">256</span>; ++i)
    {
       <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> crc64 = i;
       <span class="Statement">for</span>(j=<span class="Constant">0</span>; j&lt;<span class="Constant">8</span>; ++j)
       {

          <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> is current coefficient set? </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(crc64 &amp; <span class="Constant">1</span>)
          {

             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> yes, then assume it gets zero'd (by implied x^64 coefficient of dividend)</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------</span><span class="Comment">*/</span>

             crc64 &gt;&gt;= <span class="Constant">1</span>;

             <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment"> Add rest of the divisor </span><span class="Comment">*/</span>
             <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

             crc64 ^= poly;
          }


          <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> No? Move to next coefficient </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">else</span>
             crc64 &gt;&gt;= <span class="Constant">1</span>;
      }

      crc64_lookup_table[i] = crc64;
   }

   crc64_table_generated = TRUE;

<span class="PreProc">   #ifdef PTHREAD_SUPPORT</span>
   pthread_mutex_unlock(&amp;crc64_init_mutex);
<span class="PreProc">   #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Generate 64 bit CRC </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pups_crc_64(<span class="Type">const</span> <span class="Type">size_t</span> len, _BYTE *bufptr)
{   <span class="Type">size_t</span>            i;
    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> crc64 = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate lookup table for 64 bit CRC if we need </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> to do so                                        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(crc64_table_generated == FALSE)
       generate_crc64_lookup_table();


    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;len; ++i)
    {   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> lookup;
        _BYTE             t_index;

        t_index = bufptr[i] ^ crc64;
        lookup  = crc64_lookup_table[t_index];
        crc64   &gt;&gt;= <span class="Constant">8</span>;
        crc64   ^=  lookup;
    }

    <span class="Statement">return</span>(crc64);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extract CRC (if any) from file name ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pups_get_signature(<span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">const</span> <span class="Type">char</span> signer)

{   <span class="Type">int</span> i,
        cnt = <span class="Constant">0</span>;

    <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> crc;

    <span class="Type">char</span>     crc_signature[SSIZE]  = <span class="Constant">&quot;&quot;</span>;
    _BOOLEAN begin_crc_signature = FALSE;

    <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(name); ++i)
    {  <span class="Statement">if</span>(name[i] == signer)
       {  <span class="Statement">if</span>(begin_crc_signature == FALSE)
             begin_crc_signature = TRUE;
          <span class="Statement">else</span>
          {  (<span class="Type">void</span>)sscanf(crc_signature,<span class="Constant">&quot;</span><span class="Special">%lx</span><span class="Constant">&quot;</span>,&amp;crc);

             pups_set_errno(OK);
             <span class="Statement">return</span>(crc);
          }
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(begin_crc_signature == TRUE)
       {  crc_signature[cnt] = name[i];
          ++cnt;
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    If a checksum is present -- sign filename with it ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_sign(<span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> crc, <span class="Type">const</span> <span class="Type">char</span> *name, <span class="Type">char</span> *signed_name, <span class="Type">const</span> <span class="Type">char</span> signer)

{  <span class="Type">int</span>  c_index;
   <span class="Type">char</span> tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

   <span class="Statement">if</span>(name == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || signed_name == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

   c_index = ch_pos(name,<span class="Constant">'/'</span>);
   <span class="Statement">if</span>(ch_index == (-<span class="Constant">1</span>))


      <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Leafname - simply prepend check string </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

      (<span class="Type">void</span>)snprintf(signed_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%c%lx%c%s</span><span class="Constant">&quot;</span>,signer,crc,signer,name);
   <span class="Statement">else</span>
   {

      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment"> Pathname -- extract leaf and prepend check string to it </span><span class="Comment">*/</span>
      <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

      <span class="Type">char</span> path[SSIZE] = <span class="Constant">&quot;&quot;</span>;

      (<span class="Type">void</span>)strlcpy(path,name,SSIZE);
      path[c_index] = <span class="Special">'\0'</span>;

      (<span class="Type">void</span>)strlcpy(tmpstr,&amp;name[c_index+<span class="Constant">1</span>],SSIZE);
      (<span class="Type">void</span>)snprintf(signed_name,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/#</span><span class="Special">%d</span><span class="Constant">#</span><span class="Special">%s</span><span class="Constant">&quot;</span>,path,crc,name);
   }

   pups_set_errno(OK);
   <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    PUPS lseek which is signal safe ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_lseek(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pos, <span class="Type">const</span> <span class="Type">int</span> whence)

{   <span class="Type">int</span> ret;

    sigset_t set,
             o_set;

    (<span class="Type">void</span>)sigfillset(&amp;set);
    (<span class="Type">void</span>)sigdelset (&amp;set,<span class="Constant">SIGSEGV</span>);
    (<span class="Type">void</span>)sigdelset (&amp;set,<span class="Constant">SIGTERM</span>);

    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;set,&amp;o_set);

    <span class="Statement">if</span>((ret = lseek(fdes,pos,whence)) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    (<span class="Type">void</span>)pups_sigprocmask(SIG_SETMASK,&amp;o_set,(sigset_t *)<span class="Constant">NULL</span>);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Replace item in command tail ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_replace_cmd_tail_item(<span class="Type">const</span> <span class="Type">char</span> *flag, <span class="Type">const</span> <span class="Type">char</span> *item)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(flag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || item == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_t_args; ++i)
    {  <span class="Statement">if</span>(strcmp(flag,args[i]) == <span class="Constant">0</span>)
       {  <span class="Statement">if</span>(i == appl_t_args - <span class="Constant">1</span>)
            args[t_args] = (<span class="Type">char</span> *)pups_malloc(SSIZE);

          (<span class="Type">void</span>)strlcpy(args[i+<span class="Constant">1</span>],item,SSIZE);
          ++appl_t_args;

          pups_set_errno(OK);
          <span class="Statement">return</span>(TRUE);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Clear command tail ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_clear_cmd_tail(<span class="Type">void</span>)
{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(appl_t_args &lt;= <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;appl_t_args; ++i)
    {  args[i] = (<span class="Type">char</span> *)pups_free(args[i]);
       argd[i] = FALSE;
    }

    sargc       = <span class="Constant">0</span>;
    appl_t_args = <span class="Constant">0</span>;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Insert item into command tail ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_insert_cmd_tail_item(<span class="Type">const</span> <span class="Type">char</span> *flag, <span class="Type">const</span> <span class="Type">char</span> *item)
{
    <span class="Statement">if</span>(appl_t_args &gt; <span class="Constant">253</span>)
    {  pups_set_errno(<span class="Constant">ENOSPC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(flag == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || item == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(args[appl_t_args] == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  args[appl_t_args] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
       (<span class="Type">void</span>)strlcpy(args[appl_t_args],flag,SSIZE);
       argd[appl_t_args] = FALSE;

       <span class="Statement">if</span>(item != (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {  args[appl_t_args + <span class="Constant">1</span>] = (<span class="Type">char</span> *)pups_malloc(SSIZE);
          (<span class="Type">void</span>)strlcpy(args[appl_t_args + <span class="Constant">1</span>],item,SSIZE);
          argd[appl_t_args + <span class="Constant">1</span>] = FALSE;
       }
    }

    appl_t_args += <span class="Constant">2</span>;
    sargc       += <span class="Constant">2</span>;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Backtrack to given point if a segmentation violation occurs -- this helps to </span>
<span class="Comment">    protects a dynamic application from badly written code! ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE sigjmp_buf segv_backtrack;


<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Handler for pointer access violations </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_segv_backtrack_handler(<span class="Type">const</span> <span class="Type">int</span> signum)

{   (<span class="Type">void</span>)usleep(<span class="Constant">100</span>);
    (<span class="Type">void</span>)siglongjmp(segv_backtrack,<span class="Constant">1</span>);
}


_PUBLIC _BOOLEAN pups_backtrack(<span class="Type">const</span> _BOOLEAN set)

{   <span class="Statement">if</span>(set == TRUE)
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Enable backtracking -- SIGSEGV will cause process to backtrack </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> to this point                                                  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGSEGV</span>,<span class="Constant">&quot;segv_backtrack_handler&quot;</span>,(<span class="Type">void</span> *)&amp;pups_segv_backtrack_handler,(sigset_t *)<span class="Constant">NULL</span>);

       <span class="Statement">if</span>(sigsetjmp(segv_backtrack,<span class="Constant">1</span>) == <span class="Constant">1</span>)
          <span class="Statement">return</span>(PUPS_BACKTRACK);
       <span class="Statement">else</span>
          <span class="Statement">return</span>(TRUE);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Default handler - backtracking disabled </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_sighandle(<span class="Constant">SIGSEGV</span>,<span class="Constant">&quot;segbusfpe_handler&quot;</span>,(<span class="Type">void</span> *)&amp;segbusfpe_handler,(sigset_t *)<span class="Constant">NULL</span>);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Has file be updated? ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_file_updated(<span class="Type">const</span> <span class="Type">char</span> *filename)

{   <span class="Type">struct</span>    stat   stat_buf;
    _IMMORTAL <span class="Type">time_t</span> last_update = (-<span class="Constant">1</span>);

    <span class="Statement">if</span>(filename == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(stat(filename,&amp;stat_buf) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(last_update == (-<span class="Constant">1</span>))
    {  last_update = stat_buf.st_ctime;
       <span class="Statement">return</span>(FALSE);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(stat_buf.st_ctime != last_update)
    {  last_update = stat_buf.st_ctime;
       <span class="Statement">return</span>(TRUE);
    }

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------------------------------------------------------</span>
<span class="Comment">    Set (round robin) scheduling priority ...</span>
<span class="Comment">---------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_set_rt_sched(<span class="Type">const</span> <span class="Type">int</span> priority)

{   <span class="Type">int</span>    ret;
    <span class="Type">struct</span> sched_param p;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_set_rt_sched] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(priority &lt; sched_get_priority_min(SCHED_RR) || priority &gt; sched_get_priority_max(SCHED_RR))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    p.sched_priority = priority;
    ret = sched_setscheduler(appl_pid,SCHED_RR,&amp;p);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Switch to standard (time sharing) scheduler ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_set_tslice_sched(<span class="Type">void</span>)

{   <span class="Type">int</span>    ret;
    <span class="Type">struct</span> sched_param p;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_set_tslice_sched] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    p.sched_priority = <span class="Constant">0</span>;
    ret = sched_setscheduler(appl_pid,SCHED_RR,&amp;p);

    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------</span>
<span class="Comment">    Check to see if a given host is reachable. Note that ip_adr can be either an</span>
<span class="Comment">    IPBV4 or IPV6 address or a host name  ...</span>
<span class="Comment">----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_host_reachable(<span class="Type">const</span> <span class="Type">char</span> *ip_addr)

{   <span class="Type">char</span> ping_command[SSIZE] = <span class="Constant">&quot;&quot;</span>,
	 ping_ret[SSIZE]     = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_host_reachable] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(ip_addr == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(ping_command,SSIZE,<span class="Constant">&quot;ping -q -w 1 -c 1 </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ip_addr);
    stream = popen(ping_command,<span class="Constant">&quot;r&quot;</span>);

    (<span class="Type">void</span>)fgets(ping_ret,<span class="Constant">255</span>,stream);
    (<span class="Type">void</span>)pclose(stream);

    <span class="Statement">if</span>(strcmp(ping_ret,<span class="Constant">&quot;rtt&quot;</span>) != <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(FALSE);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Set a discretionary lock (note this type of lock is safe over network</span>
<span class="Comment">    filesystem such as NFS and MFS) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span>    lock_fdes [PUPS_MAX_FLOCKS] = { [<span class="Constant">0</span> ... PUPS_MAX_FLOCKS-<span class="Constant">1</span>] = (-<span class="Constant">1</span>) };
_PRIVATE <span class="Type">int</span>    lock_type [PUPS_MAX_FLOCKS] = { [<span class="Constant">0</span> ... PUPS_MAX_FLOCKS-<span class="Constant">1</span>] = (-<span class="Constant">1</span>) };
_PRIVATE <span class="Type">off_t</span>  lock_start[PUPS_MAX_FLOCKS] = { [<span class="Constant">0</span> ... PUPS_MAX_FLOCKS-<span class="Constant">1</span>] = <span class="Constant">0</span>   };
_PRIVATE <span class="Type">off_t</span>  lock_size [PUPS_MAX_FLOCKS] = { [<span class="Constant">0</span> ... PUPS_MAX_FLOCKS-<span class="Constant">1</span>] = <span class="Constant">0</span>   };

_PUBLIC <span class="Type">int</span> pups_flock(<span class="Type">const</span> <span class="Type">int</span> fdes, <span class="Type">const</span> <span class="Type">int</span> cmd, <span class="Type">const</span> <span class="Type">off_t</span> l_start, <span class="Type">const</span> <span class="Type">off_t</span> l_len, <span class="Type">const</span> _BOOLEAN wait)

{   <span class="Type">int</span> i,
        ret,
        lock_index;

    <span class="Type">struct</span> flock lock;

    <span class="Statement">if</span>(l_start &lt; <span class="Constant">0</span> || l_len &lt;= <span class="Constant">0</span> || wait != TRUE &amp;&amp; wait != FALSE)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_FLOCKS; ++i)
    {  <span class="Statement">if</span>(lock_fdes[i] == fdes)
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          lock_index = i;
          <span class="Statement">goto</span> lock_found;
       }
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We must have a valid file descriptor for a unlock operation </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(cmd == F_UNLCK)
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="Statement">lock_found</span>:

    <span class="Statement">if</span>(cmd == F_WRLCK)
    {  lock.l_type = F_WRLCK;
       lock.l_start            = l_start;
       lock.l_len              = l_len;
       lock.l_whence           = <span class="Constant">SEEK_SET</span>;

       lock_type[lock_index]   = cmd;
       lock_start[lock_index]  = l_start;
       lock_size[lock_index]   = l_len;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(cmd == F_RDLCK)
    {  lock.l_type = F_RDLCK;
       lock.l_start            = l_start;
       lock.l_len              = l_len;
       lock.l_whence           = <span class="Constant">SEEK_SET</span>;

       lock_type[lock_index]   = cmd;
       lock_start[lock_index]  = l_start;
       lock_size[lock_index]   = l_len;
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(lock.l_type == F_UNLCK)
    {  lock.l_type = F_UNLCK;
       lock_type[lock_index]   = (-<span class="Constant">1</span>);
       lock_start[lock_index]  = <span class="Constant">0</span>;
       lock_size[lock_index]   = <span class="Constant">0</span>;
    }
    <span class="Statement">else</span>
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If wait is TRUE wait to acquire lock -- otherwise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> return if we cannot acquire lock.                 </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(wait == TRUE)
    {  <span class="Statement">if</span>((ret = fcntl(fdes,F_SETLKW,&amp;lock)) == (-<span class="Constant">1</span>))
       {

<span class="PreProc">         #ifdef PTHREAD_SUPPORT</span>
         (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">         #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EBADF</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }
    <span class="Statement">else</span>
    {  <span class="Statement">if</span>((ret = fcntl(fdes,F_SETLK, &amp;lock)) == (-<span class="Constant">1</span>))
       {

<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EBADF</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Set a discretionary lock for a named file. (note this type of lock is safe</span>
<span class="Comment">    over network filesystem such as NFS and MFS) ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">char</span> lock_name[PUPS_MAX_FLOCKS][SSIZE] = { [<span class="Constant">0</span> ... PUPS_MAX_FLOCKS-<span class="Constant">1</span>] = {<span class="Constant">&quot;&quot;</span>}};

_PUBLIC <span class="Type">int</span> pups_flockfile(<span class="Type">const</span> <span class="Type">char</span> *lock_file, <span class="Type">const</span> <span class="Type">int</span> cmd, <span class="Type">const</span> <span class="Type">off_t</span> l_start, <span class="Type">const</span> <span class="Type">off_t</span> l_len, <span class="Type">const</span> _BOOLEAN wait)

{   <span class="Type">int</span> i,
        ret,
        min_index  = <span class="Constant">0</span>,
        lock_index = <span class="Constant">0</span>;

    <span class="Statement">if</span>(lock_file == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || l_start &lt; <span class="Constant">0</span> || l_len &lt; <span class="Constant">1</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If lock file does not exist create it. </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(access(lock_file,F_OK) == (-<span class="Constant">1</span>))
    {

       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Lock file must exist if we are attempting an </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> unlock operation.                            </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(cmd == F_UNLCK)
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">EEXIST</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       <span class="Statement">if</span>(pups_creat(lock_file,<span class="PreProc">0</span><span class="Constant">600</span>) == (-<span class="Constant">1</span>))
          <span class="Statement">return</span>(-<span class="Constant">1</span>);


       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Find a free lock </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

       <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_FLOCKS; ++i)
       {  <span class="Statement">if</span>(lock_fdes[i] == (-<span class="Constant">1</span>))
          {  lock_index = i;
             <span class="Statement">goto</span> lock_index_found;
          }
       }


       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Too many locks held </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(min_index == (-<span class="Constant">1</span>))
       {
<span class="PreProc">          #ifdef PTHREAD_SUPPORT</span>
          (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">          #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

          pups_set_errno(<span class="Constant">ENFILE</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

<span class="Statement">lock_index_found</span>:


       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Open file (and apply lock) </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>((ret = pups_flock(lock_fdes[lock_index],cmd,l_start,l_len,wait)) == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)strlcpy(lock_name[lock_index],lock_file,SSIZE);
          lock_fdes[lock_index] = open(lock_file,<span class="Constant">2</span>);
       }

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(OK);
       <span class="Statement">return</span>(ret);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get lock index for current file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_FLOCKS; ++i)
    {  <span class="Statement">if</span>(strcmp(lock_name[i],lock_file) == <span class="Constant">0</span>)
       {

          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Attempt to unlock file which is already unlocked </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">if</span>(cmd == F_UNLCK &amp;&amp; lock_fdes[i] == (-<span class="Constant">1</span>))
          {

<span class="PreProc">             #ifdef PTHREAD_SUPPORT</span>
             (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">             #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

             pups_set_errno(<span class="Constant">EACCES</span>);
             <span class="Statement">return</span>(-<span class="Constant">1</span>);
          }

          lock_index = i;
          <span class="Statement">goto</span> lock_found;
       }


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Record lowest unused slot in the lock table </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(min_index == (-<span class="Constant">1</span>) &amp;&amp; lock_fdes[i] == (-<span class="Constant">1</span>))
          min_index = i;
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Too many locks held </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(min_index == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">ENFILE</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We don't hold a lock for this file  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Use the lowest numbered unused lock </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

    lock_index = min_index;

<span class="Statement">lock_found</span>:

    <span class="Statement">if</span>(cmd == F_UNLCK)
    {

       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Clear lock </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)close(lock_fdes[lock_index]);
       lock_fdes[lock_index]       = (-<span class="Constant">1</span>);
       (<span class="Type">void</span>)strlcpy(lock_name[lock_index],<span class="Constant">&quot;&quot;</span>,SSIZE);
    }
    <span class="Statement">else</span>
    {

       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> If file is currently closed, open it </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(lock_fdes[lock_index] == (-<span class="Constant">1</span>))
          lock_fdes[lock_index] = open(lock_file,<span class="Constant">2</span>);


       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Apply lock </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)strlcpy(lock_name[lock_index],lock_file,SSIZE);
       ret = pups_flock(lock_fdes[lock_index],cmd,l_start,l_len,wait);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------</span>
<span class="Comment">    Display list of flock locks currently held by caller process ...</span>
<span class="Comment">--------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_show_flock_locks(<span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span> i,
        flock_cnt = <span class="Constant">0</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_show_flock_locks] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">Flocks held by </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,appl_name,appl_pid,appl_host);
    (<span class="Type">void</span>)fflush(stream);

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;PUPS_MAX_FLOCKS; ++i)
    {  <span class="Statement">if</span>(lock_fdes[i] != (-<span class="Constant">1</span>))
       {  <span class="Statement">if</span>(lock_type[i] == F_RDLCK)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: (slot </span><span class="Special">%04d</span><span class="Constant">): </span><span class="Special">%-32s</span><span class="Constant"> [READLOCK  starting </span><span class="Special">%016lx</span><span class="Constant">, length </span><span class="Special">%016lx</span><span class="Constant">]&quot;</span>,flock_cnt,i,lock_name[i],lock_start[i],lock_size[i]);
          <span class="Statement">else</span> <span class="Statement">if</span>(lock_type[i] == F_WRLCK)
             (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    </span><span class="Special">%04d</span><span class="Constant">: (slot </span><span class="Special">%04d</span><span class="Constant">): </span><span class="Special">%-32s</span><span class="Constant"> [WRITELOCK starting </span><span class="Special">%016lx</span><span class="Constant">, length </span><span class="Special">%016lx</span><span class="Constant">]]&quot;</span>,flock_cnt,i,lock_name[i],lock_start[i],lock_size[i]);
          (<span class="Type">void</span>)fflush(stream);

          ++flock_cnt;
       }
    }

    <span class="Statement">if</span>(flock_cnt == <span class="Constant">1</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Total of </span><span class="Special">%04d</span><span class="Constant"> flock held (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,<span class="Constant">1</span>,PUPS_MAX_FLOCKS - <span class="Constant">1</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(flock_cnt &gt; <span class="Constant">0</span>)
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;</span><span class="Special">\n\n</span><span class="Constant">    Total of </span><span class="Special">%04d</span><span class="Constant"> flocks held (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,flock_cnt,PUPS_MAX_FLOCKS - flock_cnt);
    <span class="Statement">else</span>
       (<span class="Type">void</span>)fprintf(stream,<span class="Constant">&quot;    No flocks held (</span><span class="Special">%04d</span><span class="Constant"> slots free)</span><span class="Special">\n\n</span><span class="Constant">&quot;</span>,PUPS_MAX_FLOCKS);
    (<span class="Type">void</span>)fflush(stream);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;lock_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Substitute string s3 for substring s2 in s1, returning result in string s4 ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> strsub(<span class="Type">const</span> <span class="Type">char</span> *s1, <span class="Type">const</span> <span class="Type">char</span> *s2, <span class="Type">const</span> <span class="Type">char</span> *s3, <span class="Type">char</span> *s4)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(s1 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       s2 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       s3 == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       s4 == (<span class="Type">char</span>       *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s1); ++i)
    {  <span class="Statement">if</span>(strncmp((<span class="Type">char</span> *)&amp;s1[i],s2,strlen(s2)) == <span class="Constant">0</span>)
       {  <span class="Type">int</span> s1_index;

          (<span class="Type">void</span>)strlcpy(s4,s1,SSIZE);
          s4[i] = <span class="Special">'\0'</span>;
          (<span class="Type">void</span>)strlcat(s4,s3,SSIZE);

          s1_index = i + strlen(s2);
          (<span class="Type">void</span>)strlcat(s4,(<span class="Type">char</span> *)&amp;s1[s1_index],SSIZE);

          pups_set_errno(OK);
          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Return the type of a given file (this is effectively a wrapper function for the &quot;file&quot;</span>
<span class="Comment">    command) ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *pups_get_file_type(<span class="Type">const</span> <span class="Type">char</span> *file_name)

{   <span class="Type">char</span> strdum[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         line[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         file_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span>      *pstream         = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    _IMMORTAL <span class="Type">char</span> type[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       (<span class="Type">void</span>)snprintf(file_cmd,SSIZE,<span class="Constant">&quot;file </span><span class="Special">%s</span><span class="Constant">&quot;</span>,file_name);

    pstream = popen(file_cmd,<span class="Constant">&quot;r&quot;</span>);
    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
    (<span class="Type">void</span>)pclose(pstream);

    (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,strdum,type);

    pups_set_errno(OK);
    <span class="Statement">return</span>(type);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert a string to lower case ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> downcase(<span class="Type">char</span> *s)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s); ++i)
       s[i] = tolower(s[i]);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Convert a string to upper case ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> upcase(<span class="Type">char</span> *s)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(s == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(s); ++i)
       s[i] = toupper(s[i]);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Encrypt a string using a 256 rotor virtual enigma-like machine ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> ecryptstr(<span class="Type">const</span> <span class="Type">int</span> seed, <span class="Type">const</span> _BOOLEAN one_way, <span class="Type">const</span> <span class="Type">char</span> *plaintext, <span class="Type">char</span> *cipher)

{   <span class="Type">int</span> i;

    <span class="Statement">if</span>(plaintext == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || cipher == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Encrypt string </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)srand(seed);
    <span class="Statement">for</span>(i=<span class="Constant">0</span>; i&lt;strlen(plaintext); ++i)
    {   cipher[i] = (<span class="Type">unsigned</span> <span class="Type">char</span>)((<span class="Type">int</span>)plaintext[i] ^ rand());

        <span class="Statement">if</span>(one_way == TRUE)
        {  <span class="Statement">while</span>(cipher[i] &lt; <span class="Constant">60</span> || cipher[i] &gt; <span class="Constant">85</span>)
                 cipher[i] = (<span class="Type">unsigned</span> <span class="Type">char</span>)((<span class="Type">int</span>)cipher[i] ^ rand());
        }
    }

    cipher[i] = <span class="Special">'\0'</span>;

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get exporting NFS hostname (from filepath) ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_nfs_host(<span class="Type">const</span> <span class="Type">char</span> *pathname, <span class="Type">const</span> <span class="Type">char</span> *host)

{   <span class="Type">char</span> strdum[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         df_cmd[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         line[SSIZE]       = <span class="Constant">&quot;&quot;</span>,
         nfs_mount[SSIZE]  = <span class="Constant">&quot;&quot;</span>;

    _BOOLEAN looper      = TRUE;
    <span class="Type">FILE</span>     *pstream    = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_get_nfs_host] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);

    <span class="Statement">if</span>(pathname == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || host == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pstream = popen(df_cmd,<span class="Constant">&quot;r&quot;</span>);
    <span class="Statement">do</span> {    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);

            <span class="Statement">if</span>(feof(pstream) != <span class="Constant">0</span>)
               looper = FALSE;
            <span class="Statement">else</span> <span class="Statement">if</span>(sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,nfs_mount,strdum) == <span class="Constant">2</span>)
            {  (<span class="Type">void</span>)mchrep(<span class="Constant">' '</span>,<span class="Constant">&quot;:&quot;</span>,line);
               (<span class="Type">void</span>)sscanf(nfs_mount,<span class="Constant">&quot;</span><span class="Special">%s%s</span><span class="Constant">&quot;</span>,host,strdum);

               (<span class="Type">void</span>)pclose(pstream);
               pups_set_errno(OK);
               <span class="Statement">return</span>(<span class="Constant">0</span>);
            }
       } <span class="Statement">while</span>(looper == TRUE);

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------------------------------------------------------</span>
<span class="Comment">    Reflect endian ness of FTYPE ...</span>
<span class="Comment">----------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">float</span> fconv(<span class="Type">const</span> FTYPE fOld)
{
    <span class="Type">char</span> *pcOrig = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
         *pcNew  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

    <span class="Type">int</span> i,
        j;

    FTYPE fNew;

    pcOrig = (<span class="Type">char</span> *) &amp;fOld,
    pcNew  = (<span class="Type">char</span> *) &amp;fNew;

    j = <span class="Statement">sizeof</span>(FTYPE) - <span class="Constant">1</span>;
    <span class="Statement">for</span>(i = <span class="Constant">0</span>; i&lt;<span class="Statement">sizeof</span>(FTYPE); i++)
    {   pcNew[j] = pcOrig[i];
        j--;
    }

    <span class="Statement">return</span>(fNew);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Reflect endian ness of int ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> iconv(<span class="Type">const</span> <span class="Type">int</span> iOld)
{
    <span class="Type">char</span> *pcOrig = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
         *pcNew  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

    <span class="Type">int</span> i,
        j,
        iNew;

    pcOrig = (<span class="Type">char</span> *)&amp;iOld;
    pcNew  = (<span class="Type">char</span> *)&amp;iNew;

    j = <span class="Statement">sizeof</span>(<span class="Type">int</span>)-<span class="Constant">1</span>;
    <span class="Statement">for</span>(i = <span class="Constant">0</span>; i&lt;<span class="Statement">sizeof</span>(<span class="Type">int</span>); i++)
    {   pcNew[j] = pcOrig[i];
        j--;
    }

    <span class="Statement">return</span>(iNew);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------</span>
<span class="Comment">    Reflect endian ness of short ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">short</span> <span class="Type">int</span> sconv(<span class="Type">const</span> <span class="Type">short</span> <span class="Type">int</span> sOld)
{
    <span class="Type">char</span> *pcOrig = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
         * pcNew = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

    <span class="Type">short</span> <span class="Type">int</span> i,
              j,
              sNew;

    pcOrig = (<span class="Type">char</span> *)&amp;sOld;
    pcNew = (<span class="Type">char</span> *) &amp;sNew;

    j = <span class="Statement">sizeof</span>(<span class="Type">short</span> <span class="Type">int</span>)-<span class="Constant">1</span>;
    <span class="Statement">for</span>(i = <span class="Constant">0</span>; i&lt;<span class="Statement">sizeof</span>(<span class="Type">short</span> <span class="Type">int</span>); i++)
    {   pcNew[j] = pcOrig[i];
        j--;
    }

    <span class="Statement">return</span>(sNew);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------</span>
<span class="Comment">    Reflect endian ness of long ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">long</span> <span class="Type">int</span> lconv(<span class="Type">const</span> <span class="Type">long</span> <span class="Type">int</span> lOld)
{
    <span class="Type">char</span>  *pcOrig = (<span class="Type">char</span> *)<span class="Constant">NULL</span>,
          *pcNew  = (<span class="Type">char</span> *)<span class="Constant">NULL</span>;

    <span class="Type">long</span> <span class="Type">int</span> i,
             j,
             lNew;

    pcOrig = (<span class="Type">char</span> *)&amp;lOld;
    pcNew  = (<span class="Type">char</span> *)&amp;lNew;

    j = <span class="Statement">sizeof</span>(<span class="Type">long</span> <span class="Type">int</span>)-<span class="Constant">1</span>;
    <span class="Statement">for</span>(i = <span class="Constant">0</span>; i&lt;<span class="Statement">sizeof</span>(<span class="Type">long</span> <span class="Type">int</span>); i++)
    {   pcNew[j] = pcOrig[i];
        j--;
    }

    <span class="Statement">return</span>(lNew);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Encrypting formatted print ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> efprintf(<span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">char</span> *format, ...)

{   <span class="Type">int</span> ret;

    <span class="Type">char</span> plaintext[<span class="Constant">4096</span>] = <span class="Constant">&quot;&quot;</span>,
         cipher[<span class="Constant">4096</span>]    = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">va_list</span> ap;

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || format == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Generate plaintext from formatted I/P list </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------</span><span class="Comment">*/</span>

    va_start(ap,format);
    <span class="Statement">if</span>(vsnprintf(plaintext,SSIZE,format,ap) == (-<span class="Constant">1</span>))
    {  va_end(ap);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }
    <span class="Statement">else</span>
       va_end(ap);


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enigma encode plaintext </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef ECRYPT_SUPPORT</span>
    (<span class="Type">void</span>)ecrypt(appl_uid,FALSE,plaintext,cipher);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(cipher,plaintext,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> ECRYPT_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> write cipher </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    ret = fputs(cipher,stream);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Encrypting formatted fputs ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> efputs(<span class="Type">const</span> <span class="Type">char</span> *plaintext, <span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">int</span>  ret;
    <span class="Type">char</span> cipher[<span class="Constant">4096</span>]    = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(plaintext == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enigma encode plaintext </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef ECRYPT_SUPPORT</span>
    (<span class="Type">void</span>)ecrypt(appl_uid,FALSE,plaintext,cipher);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(cipher,plaintext,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> ECRYPT_SUPPORT </span><span class="Comment">*/</span>


   <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> write cipher </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

   ret = fputs(cipher,stream);

   pups_set_errno(OK);
   <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Encrypting formatted scan ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> efscanf(<span class="Type">FILE</span> *stream, <span class="Type">const</span> <span class="Type">char</span> *format, ...)

{   <span class="Type">int</span> ret;

    <span class="Type">char</span> plaintext[<span class="Constant">4096</span>] = <span class="Constant">&quot;&quot;</span>,
         cipher[<span class="Constant">4096</span>]    = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">va_list</span> ap;

    <span class="Statement">if</span>(stream == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || format == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get cipher </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fgets(cipher,<span class="Constant">4096</span>,stream);
    <span class="Statement">if</span>(strcmp(cipher,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EIO</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enigma encode plaintext </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef ECRYPT_SUPPORT</span>
    (<span class="Type">void</span>)ecrypt(appl_uid,FALSE,cipher,plaintext);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(plaintext,cipher,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> ECRYPT_SUPPORT </span><span class="Comment">*/</span>

    va_start(ap,format);
    ret = vsscanf(plaintext,format,ap);
    va_end(ap);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Encrypting formatted string scan ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> esscanf(<span class="Type">char</span> *cipher, <span class="Type">const</span> <span class="Type">char</span> *format, ...)

{   <span class="Type">int</span>     ret;
    <span class="Type">char</span>    plaintext[<span class="Constant">4096</span>] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">va_list</span> ap;

    <span class="Statement">if</span>(cipher == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || format == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get cipher </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(cipher,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EIO</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enigma encode plaintext </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef ECRYPT_SUPPORT</span>
    (<span class="Type">void</span>)ecrypt(appl_uid,FALSE,cipher,plaintext);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(plaintext,cipher,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> ECRYPT_SUPPORT </span><span class="Comment">*/</span>

    va_start(ap,format);
    ret = vsscanf(plaintext,format,ap);
    va_end(ap);

    pups_set_errno(OK);
    <span class="Statement">return</span>(ret);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------</span>
<span class="Comment">    Encrypting formatted scan ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">char</span> *efgets(<span class="Type">char</span> *plaintext, <span class="Type">const</span> <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size, <span class="Type">const</span> <span class="Type">FILE</span> *stream)

{   <span class="Type">char</span> cipher[<span class="Constant">4096</span>] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(plaintext  == (<span class="Type">char</span> *)<span class="Constant">NULL</span> || stream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get cipher </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fgets(cipher,<span class="Constant">4096</span>,stream);
    <span class="Statement">if</span>(strcmp(cipher,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
    {  pups_set_errno(<span class="Constant">EIO</span>);
       <span class="Statement">return</span>((<span class="Type">char</span> *)<span class="Constant">NULL</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Enigma encode plaintext </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

<span class="PreProc">    #ifdef ECRYPT_SUPPORT</span>
    (<span class="Type">void</span>)ecrypt(appl_uid,FALSE,cipher,plaintext);
<span class="PreProc">    #else</span>
    (<span class="Type">void</span>)strlcpy(plaintext,cipher,SSIZE);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> ECRYPT_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>((<span class="Type">char</span> *)&amp;plaintext[<span class="Constant">0</span>]);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Mark context of non-local goto valid ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_set_jump_vector(<span class="Type">void</span>)

{   jump_vector = TRUE;
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------</span>
<span class="Comment">    Mark context of non-local goto invalid ...</span>
<span class="Comment">-----------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_reset_jump_vector(<span class="Type">void</span>)

{   jump_vector = FALSE;
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Return TRUE if version information matches key ...</span>
<span class="Comment">-------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_linuxversion(<span class="Type">const</span> <span class="Type">char</span> *key)

{   <span class="Type">FILE</span> *stream         = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;
    <span class="Type">char</span> versionstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Statement">if</span>(key == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    stream = fopen(<span class="Constant">&quot;/proc/version&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
    (<span class="Type">void</span>)fgets(versionstr,SSIZE,stream);
    (<span class="Type">void</span>)fclose(stream);

    <span class="Statement">if</span>(strin(versionstr,key) == TRUE)
       <span class="Statement">return</span>(TRUE);

    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    How many CPU's does this machine have? ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_cpus(FTYPE *bogomips, <span class="Type">char</span> *processor)

{  <span class="Type">int</span>      cpus   = <span class="Constant">0</span>;
   _BOOLEAN looper = TRUE;

   <span class="Type">char</span>  line[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         strdum[SSIZE] = <span class="Constant">&quot;&quot;</span>;

   <span class="Type">FILE</span> *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

   <span class="Statement">if</span>(bogomips == (FTYPE *)<span class="Constant">NULL</span> || processor == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
   {  pups_set_errno(<span class="Constant">EINVAL</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

   stream = fopen(<span class="Constant">&quot;/proc/cpuinfo&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
   <span class="Statement">do</span> {    (<span class="Type">void</span>)fgets(line,SSIZE,stream);
           <span class="Statement">if</span>(feof(stream) &gt; <span class="Constant">0</span>)
              looper = FALSE;
           <span class="Statement">else</span> <span class="Statement">if</span>(strncmp(line,<span class="Constant">&quot;processor&quot;</span>,<span class="Constant">9</span>) == <span class="Constant">0</span>)
              ++cpus;
           <span class="Statement">else</span> <span class="Statement">if</span>(strncmp(line,<span class="Constant">&quot;bogomips&quot;</span>,<span class="Constant">8</span>) == <span class="Constant">0</span>)
              (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s%s%f</span><span class="Constant">&quot;</span>,strdum,strdum,bogomips);
           <span class="Statement">else</span> <span class="Statement">if</span>(strncmp(line,<span class="Constant">&quot;model name&quot;</span>,<span class="Constant">10</span>) == <span class="Constant">0</span>)
              (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s%s%s%s</span><span class="Constant">&quot;</span>,strdum,strdum,strdum,processor);
      } <span class="Statement">while</span>(looper == TRUE);

   (<span class="Type">void</span>)fclose(stream);

   pups_set_errno(OK);
   <span class="Statement">return</span>(cpus);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Get current process loading (and memory statistics) for host ...</span>
<span class="Comment">--------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_get_resource_loading(<span class="Type">const</span> _BOOLEAN weighted,     <span class="Comment">/*</span><span class="Comment"> If TRUE return BogoMIP weighted CPU loading </span><span class="Comment">*/</span>
                                      FTYPE          *cpu_loading, <span class="Comment">/*</span><span class="Comment"> CPU loading                                 </span><span class="Comment">*/</span>
                                      <span class="Type">int</span>            *free_mem)    <span class="Comment">/*</span><span class="Comment"> Free (virtual) memory                       </span><span class="Comment">*/</span>

{   <span class="Type">char</span> line[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         strdum[SSIZE] = <span class="Constant">&quot;&quot;</span>,
         tmpstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> i,
        idum,
        free,
        next_mem,
        cnt  = <span class="Constant">3</span>;

    FTYPE bogomips;

    _BOOLEAN looper  = TRUE;
    <span class="Type">FILE</span>     *stream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(cpu_loading == (FTYPE **)<span class="Constant">NULL</span> || free_mem == (<span class="Type">int</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    stream = fopen(<span class="Constant">&quot;/proc/stat&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
    (<span class="Type">void</span>)fscanf(stream,<span class="Constant">&quot;</span><span class="Special">%f</span><span class="Constant">&quot;</span>,cpu_loading);
    (<span class="Type">void</span>)fclose(stream);

    *cpu_loading /= (FTYPE)pups_cpus(&amp;bogomips,strdum);
    <span class="Statement">if</span>(weighted == TRUE)
    {  bogomips     /= BOGOMIP_SCALING;
       *cpu_loading /= bogomips;
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> LINUX returns the real amount of free (e.g. inactive) memory </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> as the cached field.                                         </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------------------</span><span class="Comment">*/</span>

    (*free_mem) = <span class="Constant">0</span>;
    stream = fopen(<span class="Constant">&quot;/proc/meminfo&quot;</span>,<span class="Constant">&quot;r&quot;</span>);
    <span class="Statement">do</span> {    (<span class="Type">void</span>)fscanf(stream,<span class="Constant">&quot;</span><span class="Special">%s%d</span><span class="Constant">&quot;</span>,tmpstr,&amp;next_mem);
            <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;MemFree:&quot;</span>) == <span class="Constant">0</span>)
               (*free_mem) += next_mem;
            <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(tmpstr,<span class="Constant">&quot;Cached:&quot;</span>) == <span class="Constant">0</span>)
            {  (*free_mem) += next_mem;
               looper = FALSE;
            }
       } <span class="Statement">while</span>(looper == TRUE);

    (<span class="Type">void</span>)fclose(stream);

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="PreProc">#ifdef SSH_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Peer mediated file transfer ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_scp(<span class="Type">const</span> <span class="Type">char</span> *ssh_port, <span class="Type">const</span> <span class="Type">char</span> *to_filepath, <span class="Type">const</span> <span class="Type">char</span> *from_filepath)

{   <span class="Type">char</span> line[SSIZE]     = <span class="Constant">&quot;&quot;</span>,
         ssh_opts[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> status,
        ret            = <span class="Constant">0</span>,
        scp_pid        = (-<span class="Constant">1</span>);


    <span class="Statement">if</span>(from_filepath == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       to_filepath   == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  (<span class="Type">void</span>)pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Fork of a process to run sftp and transfer the files </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((scp_pid = pups_fork(FALSE,FALSE)) == <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child side of fork </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We don't need stdio for child </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)fclose(<span class="Constant">stdin</span>);
       (<span class="Type">void</span>)fclose(<span class="Constant">stdout</span>);
       (<span class="Type">void</span>)fclose(<span class="Constant">stderr</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Transaction is public/private key only </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)snprintf(ssh_opts,SSIZE,<span class="Constant">&quot;-oPasswordAuthentication=no&quot;</span>);


       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Are we sending to a non-standard port? </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ssh_port != (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       {   <span class="Type">char</span> portOption[<span class="Constant">26</span>] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)snprintf(portOption,SSIZE,<span class="Constant">&quot; -P </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssh_port);
          (<span class="Type">void</span>)strlcat(ssh_opts,portOption,SSIZE);
       }
       <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(ssh_remote_port,<span class="Constant">&quot;&quot;</span>) != <span class="Constant">0</span>)
       {  <span class="Type">char</span> portOption[<span class="Constant">26</span>] = <span class="Constant">&quot;&quot;</span>;

          (<span class="Type">void</span>)snprintf(portOption,SSIZE,<span class="Constant">&quot; -P </span><span class="Special">%s</span><span class="Constant">&quot;</span>,ssh_remote_port);
          (<span class="Type">void</span>)strlcat(ssh_opts,portOption,SSIZE);
       }


       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Compress material being transferred </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(ssh_compression == TRUE)
          (<span class="Type">void</span>)strlcat(ssh_opts,<span class="Constant">&quot; +C&quot;</span>,SSIZE);


       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Run scp command </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)execlp(<span class="Constant">&quot;scp&quot;</span>,<span class="Constant">&quot;scp&quot;</span>,ssh_opts,from_filepath,to_filepath,(<span class="Type">char</span> *)<span class="Constant">NULL</span>);


       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> We should not get here -- if we do an error has occured </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------------------------</span><span class="Comment">*/</span>

       _exit(<span class="PreProc">0</span><span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Parent side of fork </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

    <span class="Statement">else</span> <span class="Statement">if</span>(scp_pid == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Wait for child to terminate </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and read reply (if any)     </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

    <span class="Statement">while</span>((ret = waitpid(scp_pid,&amp;status,WNOHANG)) != scp_pid)
    {    <span class="Statement">if</span>(ret == (-<span class="Constant">1</span>))
         {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
            <span class="Statement">return</span>(-<span class="Constant">1</span>);
         }

          pups_usleep(<span class="Constant">100</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get exit status of scp command </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(WEXITSTATUS(status) &gt; <span class="Constant">0</span>)
    {

       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> scp command failed to execute </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

       pups_set_errno(<span class="Constant">EACCES</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> We transferred the file  </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_set_errno(OK);
    <span class="Statement">return</span>(WEXITSTATUS(status));
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> SSH_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Is our process P3 aware ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PRIVATE _BOOLEAN pups_p3_aware(<span class="Type">const</span> <span class="Type">int</span> pid)

{   <span class="Type">DIR</span>           *dirp         = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;
    <span class="Type">struct</span> dirent *next_item    = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;
    <span class="Type">char</span>          pidstr[SSIZE] = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Assuming default P3 patchboard here! </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>

    dirp = opendir(<span class="Constant">&quot;/tmp&quot;</span>);
    (<span class="Type">void</span>)snprintf(pidstr,SSIZE,<span class="Constant">&quot;</span><span class="Special">%d</span><span class="Constant">&quot;</span>,pid);

    <span class="Statement">while</span>((next_item = readdir(dirp)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
    {   <span class="Statement">if</span>(strcmp(next_item-&gt;d_name,<span class="Constant">&quot;.&quot;</span>) != <span class="Constant">0</span> &amp;&amp; strcmp(next_item-&gt;d_name,<span class="Constant">&quot;..&quot;</span>) != <span class="Constant">0</span>)
        {  <span class="Statement">if</span>(strin(next_item-&gt;d_name,<span class="Constant">&quot;psrp&quot;</span>) == TRUE &amp;&amp; strin(next_item-&gt;d_name,pidstr) == TRUE)
           {  (<span class="Type">void</span>)closedir(dirp);
              <span class="Statement">return</span>(TRUE);
           }
        }
    }

    (<span class="Type">void</span>)closedir(dirp);
    <span class="Statement">return</span>(FALSE);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Extended popen() which works with file descriptors - popen() should be pfopen() actually!!</span>
<span class="Comment">-----------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
_PUBLIC <span class="Type">int</span> pups_popen(<span class="Type">const</span> <span class="Type">char</span> *shell,      <span class="Comment">/*</span><span class="Comment"> Shell to run command           </span><span class="Comment">*/</span>
                       <span class="Type">const</span> <span class="Type">char</span> *cmd,        <span class="Comment">/*</span><span class="Comment"> Command to run                 </span><span class="Comment">*/</span>
                       <span class="Type">const</span> <span class="Type">int</span>  rw_flags,    <span class="Comment">/*</span><span class="Comment"> r/w flags                      </span><span class="Comment">*/</span>
                       <span class="Type">int</span>        *child_pid)  <span class="Comment">/*</span><span class="Comment"> PID of child (payload) command </span><span class="Comment">*/</span>
                                               <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
{   <span class="Type">int</span> fildes[<span class="Constant">2</span>] = { [<span class="Constant">0</span> ... <span class="Constant">1</span>] = (-<span class="Constant">1</span>) };

    <span class="Statement">if</span>(shell     == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       cmd       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       child_pid == (<span class="Type">int</span>        *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create a pipe </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pipe(fildes);
    <span class="Statement">if</span>((*child_pid = fork()) == <span class="Constant">0</span>)
    {


       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child on end 2 of the pipe </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Child operation must mirror that requested for parent </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(rw_flags == <span class="Constant">0</span>)
       {  (<span class="Type">void</span>)dup2(fildes[<span class="Constant">1</span>],<span class="Constant">1</span>);
          (<span class="Type">void</span>)dup2(fildes[<span class="Constant">1</span>],<span class="Constant">2</span>);
       }
       <span class="Statement">else</span>
          (<span class="Type">void</span>)dup2(fildes[<span class="Constant">1</span>],<span class="Constant">0</span>);
       (<span class="Type">void</span>)close(fildes[<span class="Constant">1</span>]);

       (<span class="Type">void</span>)execlp(shell,shell,<span class="Constant">&quot;-c&quot;</span>,cmd,<span class="Constant">0</span>);

       (<span class="Type">void</span>)close(rw_flags);
       _exit(<span class="Constant">0</span>);
   }

   <span class="Statement">if</span>(kill(*child_pid,<span class="Constant">SIGCONT</span>) == (-<span class="Constant">1</span>))
   {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
      <span class="Statement">return</span>(-<span class="Constant">1</span>);
   }

   <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment"> Parent on end 1 of pipe </span><span class="Comment">*/</span>
   <span class="Comment">/*</span><span class="Comment">-------------------------</span><span class="Comment">*/</span>

   (<span class="Type">void</span>)close(fildes[<span class="Constant">1</span>]);

   pups_set_errno(OK);
   <span class="Statement">return</span>(fildes[<span class="Constant">0</span>]);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Open a buffered pipe stream ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>
                                                                               <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
_PUBLIC <span class="Type">FILE</span> *pups_fpopen(<span class="Type">const</span> <span class="Type">char</span> *shell,                                   <span class="Comment">/*</span><span class="Comment"> Shell to run command           </span><span class="Comment">*/</span>
                          <span class="Type">const</span> <span class="Type">char</span> *cmd,                                     <span class="Comment">/*</span><span class="Comment"> Command to run                 </span><span class="Comment">*/</span>
                          <span class="Type">const</span> <span class="Type">int</span>  rw_flags,                                 <span class="Comment">/*</span><span class="Comment"> r/w flags                      </span><span class="Comment">*/</span>
                          <span class="Type">int</span>        *child_pid)                               <span class="Comment">/*</span><span class="Comment"> PID of child (payload) command </span><span class="Comment">*/</span>
                                                                               <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

{   <span class="Type">int</span>  pdes     = (-<span class="Constant">1</span>);
    <span class="Type">FILE</span> *pstream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(shell     == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       cmd       == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       rw_flags  == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       child_pid == (<span class="Type">int</span>        *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }

    <span class="Statement">if</span>(strcmp(rw_flags,<span class="Constant">&quot;r&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>((pdes = pups_popen(shell,cmd, <span class="Constant">0</span>, child_pid)) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ECHILD</span>);
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
       }

       <span class="Statement">if</span>((pstream = fdopen(pdes,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }
    <span class="Statement">else</span> <span class="Statement">if</span>(strcmp(rw_flags,<span class="Constant">&quot;w&quot;</span>) == <span class="Constant">0</span>)
    {  <span class="Statement">if</span>((pdes = pups_popen(shell,cmd, <span class="Constant">1</span>, child_pid)) == (-<span class="Constant">1</span>))
       {  pups_set_errno(<span class="Constant">ECHILD</span>);
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
       }

       <span class="Statement">if</span>((pstream = fdopen(pdes,<span class="Constant">&quot;w&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
          <span class="Statement">return</span>((<span class="Type">FILE</span> *)<span class="Constant">NULL</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(pstream);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Close extended pipe stream...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

<span class="Type">int</span> pups_pclose(<span class="Type">const</span> <span class="Type">int</span> pdes, <span class="Type">const</span> <span class="Type">int</span> pid)

{   <span class="Type">int</span> status;

    <span class="Statement">if</span>(pdes &lt;= <span class="Constant">0</span> || pid &lt;= <span class="Constant">0</span>)
    {   pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Statement">if</span>(close(pdes) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EBADF</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(kill(pid,<span class="Constant">SIGTERM</span>) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">ECHILD</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)waitpid(pid,&amp;status,<span class="Constant">0</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">    Close extended buffered pipe stream ...</span>
<span class="Comment">-----------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_fpclose(<span class="Type">const</span> <span class="Type">FILE</span> *pstream, <span class="Type">const</span> <span class="Type">int</span> pid)

{   <span class="Type">int</span> pdes = (-<span class="Constant">1</span>);

    <span class="Statement">if</span>(pstream == (<span class="Type">const</span> <span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    pdes = fileno(pstream);
    <span class="Statement">if</span>(pups_pclose(pdes,pid) == (-<span class="Constant">1</span>))
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------------------------</span>
<span class="Comment">  Test to see if process in foreground ...</span>
<span class="Comment">------------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_foreground(<span class="Type">void</span>)

{   <span class="Statement">if</span>(tcgetpgrp(<span class="Constant">0</span>) != getpgrp())
       <span class="Statement">return</span>(FALSE);

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------------------------------------------------------------------------</span>
<span class="Comment"> Test to see if process in background ... </span>
<span class="Comment">------------------------------------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_is_background(<span class="Type">void</span>)

{   <span class="Statement">if</span>(tcgetpgrp(<span class="Constant">0</span>) == getpgrp())
       <span class="Statement">return</span>(FALSE);

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Is command installed on system ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_cmd_installed(<span class="Type">const</span> <span class="Type">char</span> *command)

{   <span class="Type">char</span> line[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
         pstream_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">FILE</span> *pstream = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span>(command == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)snprintf(pstream_cmd,SSIZE,<span class="Constant">&quot;which </span><span class="Special">%s</span><span class="Constant">&quot;</span>,command);
    <span class="Statement">if</span>((pstream = popen(pstream_cmd,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
    (<span class="Type">void</span>)pclose(pstream);

    pups_set_errno(OK);
    <span class="Statement">if</span>(strin(line,<span class="Constant">&quot;Command not found&quot;</span>) == TRUE)
       <span class="Statement">return</span>(FALSE);

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Get utilisation of CPU cores on current host ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC FTYPE pups_cpu_utilisation(<span class="Type">void</span>)

{    <span class="Type">char</span> line[SSIZE]        = <span class="Constant">&quot;&quot;</span>,
          pstream_cmd[SSIZE] = <span class="Constant">&quot;&quot;</span>;

     <span class="Type">FILE</span>  *pstream         = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

     FTYPE utilisation;

     <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Is the mpstat command installed? </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(pups_cmd_installed(<span class="Constant">&quot;mpstat&quot;</span>) == FALSE)
     {  pups_set_errno(<span class="Constant">ESRCH</span>);
        <span class="Statement">return</span>(-<span class="Constant">1.0</span>);
     }

     (<span class="Type">void</span>)snprintf(pstream_cmd,SSIZE,<span class="Constant">&quot;mpstat | tail -1 | awk '{print $11}'&quot;</span>);


     <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Find the CPU utilisation </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>((pstream = popen(pstream_cmd,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
     {   pups_set_errno(<span class="Constant">EINVAL</span>);
         <span class="Statement">return</span>(-<span class="Constant">1.0</span>);
     }

     (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
     (<span class="Type">void</span>)pclose(pstream);


     <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment"> Returns idle CPU percentage </span><span class="Comment">*/</span>
     <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

     <span class="Statement">if</span>(sscanf(line,<span class="Constant">&quot;</span><span class="Special">%F</span><span class="Constant">&quot;</span>,&amp;utilisation) != <span class="Constant">1</span>)
     {   pups_set_errno(<span class="Constant">EINVAL</span>);
         <span class="Statement">return</span>(-<span class="Constant">1.0</span>);
     }
     <span class="Statement">else</span>
     {
        <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Get occupied CPU percentage </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

        utilisation = <span class="Constant">100.0</span> - utilisation;
     }

     pups_set_errno(OK);
     <span class="Statement">return</span>(utilisation);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Get prefix from string ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_prefix(<span class="Type">const</span> <span class="Type">char</span> dm_ch, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">char</span> *strPrefix)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);
    <span class="Statement">for</span>(i=size; i&gt;<span class="Constant">0</span>; --i)
    {  <span class="Statement">if</span>(s[i] == dm_ch)
       {  (<span class="Type">void</span>)strlcpy(strPrefix,s,SSIZE);
          strPrefix[i] = <span class="Special">'\0'</span>;
          pups_set_errno(OK);

          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment"> Get suffix from string ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_suffix(<span class="Type">const</span> <span class="Type">char</span> dm_ch, <span class="Type">const</span> <span class="Type">char</span> *s, <span class="Type">char</span> *strSuffix)

{   <span class="Type">size_t</span> i,
           size;

    <span class="Statement">if</span>(s == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || strSuffix == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    size = strlen(s);
    <span class="Statement">for</span>(i=size; i&gt;<span class="Constant">0</span>; --i)
    {  <span class="Statement">if</span>(s[i] == dm_ch)
       {  (<span class="Type">void</span>)strlcpy(strSuffix,(<span class="Type">char</span> *)&amp;s[i+<span class="Constant">1</span>],SSIZE);
          pups_set_errno(OK);

          <span class="Statement">return</span>(<span class="Constant">0</span>);
       }
    }

    pups_set_errno(<span class="Constant">ESRCH</span>);
    <span class="Statement">return</span>(-<span class="Constant">1</span>);
}




<span class="Comment">/*</span><span class="Comment">-------------------------------------------------------------------------------------</span>
<span class="Comment">    Get file size ...</span>
<span class="Comment">-------------------------------------------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> pups_get_fsize(<span class="Type">const</span> <span class="Type">char</span> *file_name)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> size;
    <span class="Type">struct</span> stat       buf;

    <span class="Statement">if</span>(file_name == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span> || access(file_name,F_OK | R_OK) == (-<span class="Constant">1</span>))
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)stat(file_name,&amp;buf);
    size = (<span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span>)buf.st_size;

    pups_set_errno(OK);
    <span class="Statement">return</span>(size);
}




<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Missing tests on an open descriptor  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> isatty() is often a blunt instrument </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> if we need to know exactly what is   </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> attached to a descriptor             </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------------</span><span class="Comment">*/</span>


<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is the descriptor attached to a pipe (FIFO)? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> isapipe(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">struct</span> stat buf;

    <span class="Statement">if</span>(fstat(fdes,&amp;buf) &lt; <span class="Constant">0</span>)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(S_ISFIFO(buf.st_mode))
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is the descriptor attached to a file (REGF)? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> isafile(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">struct</span> stat buf;

    <span class="Statement">if</span>(fstat(fdes,&amp;buf) &lt; <span class="Constant">0</span>)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(S_ISREG(buf.st_mode))
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is the descriptor attached to a socket (SOCK)? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> isasock(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Type">struct</span> stat buf;

    <span class="Statement">if</span>(fstat(fdes,&amp;buf) &lt; <span class="Constant">0</span>)
       <span class="Statement">return</span>(-<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">if</span>(S_ISSOCK(buf.st_mode))
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Is the descriptor attached to a data source  </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> or sink?                                     </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> isaconduit(<span class="Type">const</span> <span class="Type">int</span> fdes)

{   <span class="Statement">if</span>(isafile(fdes) == <span class="Constant">1</span>)
       <span class="Statement">return</span>(<span class="Constant">1</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(isapipe(fdes) == <span class="Constant">1</span>)
       <span class="Statement">return</span>(<span class="Constant">1</span>);
    <span class="Statement">else</span> <span class="Statement">if</span>(isasock(fdes) == <span class="Constant">1</span>)
       <span class="Statement">return</span>(<span class="Constant">1</span>);

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get system information for current host </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_sysinfo(<span class="Type">char</span> *hostname,         <span class="Comment">// Name of host</span>
                         <span class="Type">char</span> *ostype,           <span class="Comment">// OS running on host</span>
                         <span class="Type">char</span> *osversion,        <span class="Comment">// Version of OS running on host</span>
                         <span class="Type">char</span> *machtype)         <span class="Comment">// Host (CPU) hardware</span>

{   <span class="Type">FILE</span> *pdes = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    <span class="Type">char</span> strdum[SSIZE]   = <span class="Constant">&quot;&quot;</span>,
         line[SSIZE]     = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Machine </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(machtype != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>((pdes = popen(<span class="Constant">&quot;uname --machine&quot;</span>,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)fgets(line,SSIZE,pdes);
       (<span class="Type">void</span>)pclose(pdes);
       (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,machtype);
    }


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Operating system </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(ostype != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>((pdes = popen(<span class="Constant">&quot;uname --operating-system&quot;</span>,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)fgets(line,SSIZE,pdes);
       (<span class="Type">void</span>)pclose(pdes);
       (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,ostype);
    }


    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Operating system version </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(osversion != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>((pdes = popen(<span class="Constant">&quot;uname --kernel-release&quot;</span>,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)fgets(line,SSIZE,pdes);
       (<span class="Type">void</span>)pclose(pdes);
       (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,osversion);
    }


    <span class="Comment">/*</span><span class="Comment">----------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Hostname </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(hostname != (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  <span class="Statement">if</span>((pdes = popen(<span class="Constant">&quot;uname --nodename&quot;</span>,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>)
       {  pups_set_errno(<span class="Constant">ENOEXEC</span>);
          <span class="Statement">return</span>(-<span class="Constant">1</span>);
       }

       (<span class="Type">void</span>)fgets(line,SSIZE,pdes);
       (<span class="Type">void</span>)pclose(pdes);
       (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,hostname);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Am I running in container or other sort </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> of virtual environment?                 </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_os_is_virtual(<span class="Type">char</span> *vmType)

{   <span class="Type">char</span> line[SSIZE] = <span class="Constant">&quot;&quot;</span>;
    <span class="Type">FILE</span> *pstream    = (<span class="Type">FILE</span> *)<span class="Constant">NULL</span>;

    pups_set_errno(OK);


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open pstream (with sanity check) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Must add the following line to /etc/sudoers: </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> ALL ALL=NOPASSWD: /sbin/virt-what            </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((pstream = popen(<span class="Constant">&quot;sudo virt-what | head -1&quot;</span>,<span class="Constant">&quot;r&quot;</span>)) == (<span class="Type">FILE</span> *)<span class="Constant">NULL</span> || vmType == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    (<span class="Type">void</span>)fgets(line,SSIZE,pstream);
    (<span class="Type">void</span>)sscanf(line,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">&quot;</span>,vmType);

    (<span class="Type">void</span>)fclose(pstream);


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> OS is running on &quot;bare metal&quot; </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(strcmp(vmType,<span class="Constant">&quot;&quot;</span>) == <span class="Constant">0</span>)
       <span class="Statement">return</span>(FALSE);


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> OS is running in some kind of </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> virtual environment           </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">return</span>(TRUE);
}




<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Detect whether hardware is big endian </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_bigendian(<span class="Type">void</span>)
{
    <span class="Type">unsigned</span> <span class="Type">int</span> x  = <span class="Constant">0x76543210</span>;
    <span class="Type">char</span>         *c = (<span class="Type">char</span>*) &amp;x;

  <span class="Statement">if</span>(*c == <span class="Constant">0x10</span>)
     <span class="Statement">return</span>(FALSE);

  <span class="Statement">return</span>(TRUE);
}




<span class="PreProc">#ifdef CRIU_SUPPORT</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Enable (Criu) state saving </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_ssave_enable(<span class="Type">void</span>)
{
    <span class="Type">int</span>  t_index;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_ssave_enable] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Create directory in /tmp for state saving </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(appl_ssave_dir,SSIZE,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant">/pups.</span><span class="Special">%s</span><span class="Constant">.</span><span class="Special">%d</span><span class="Constant">.ssave&quot;</span>,appl_criu_dir,appl_name,appl_pid);


    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If checkpoint directory exists then we have </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> resumed from a checkpoint                   </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------------------------</span><span class="Comment">*/</span>


    <span class="Statement">if</span>(access(appl_ssave_dir,F_OK) == (-<span class="Constant">1</span>))
    {
       <span class="Statement">if</span>(mkdir(appl_ssave_dir,<span class="PreProc">0</span><span class="Constant">700</span>) == (-<span class="Constant">1</span>))


          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment"> Error - cannot create state saving directory </span><span class="Comment">*/</span>
          <span class="Comment">/*</span><span class="Comment">----------------------------------------------</span><span class="Comment">*/</span>

          <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Note that we are saving state </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------</span><span class="Comment">*/</span>

    appl_ssave = TRUE;


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Set polling time for state saving (in seconds) </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    t_index = pups_setvitimer(<span class="Constant">&quot;ssave_homeostat&quot;</span>,
                              <span class="Constant">1</span>,VT_CONTINUOUS,<span class="Constant">10</span>,
                              (<span class="Type">void</span> *)<span class="Constant">NULL</span>,
                              (<span class="Type">void</span> *)ssave_homeostat);


    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): ssave homeostat activated (polling via vtimer </span><span class="Special">%d</span><span class="Constant"> (payload function: ssave_homeostat)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                                                                  date,appl_name,appl_pid,appl_host,appl_owner,t_index);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Disable (Criu) state saving </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-----------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_ssave_disable(<span class="Type">void</span>)

{   <span class="Type">char</span> rm_cmd[SSIZE]    = <span class="Constant">&quot;&quot;</span>;


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Only the root thread can process </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> PSRP requests                    </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(pupsthread_is_root_thread() == FALSE)
       pups_error(<span class="Constant">&quot;[pups_ssave_enable] attempt by non root thread to perform PUPS/P3 utility operation&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove homeostat </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)pups_clearvitimer(<span class="Constant">&quot;ssave_homeostat&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Remove directory in /tmp for state saving </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> and all its contents                      </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------------------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)snprintf(rm_cmd,SSIZE,<span class="Constant">&quot;rm -rf </span><span class="Special">%s</span><span class="Constant">&quot;</span>,appl_ssave_dir);
    (<span class="Type">void</span>)system(rm_cmd);

    appl_ssave  = FALSE;
    appl_ssaves = <span class="Constant">0</span>;

    <span class="Statement">if</span>(appl_verbose == TRUE)
    {  (<span class="Type">void</span>)strdate(date);
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;</span><span class="Special">%s</span><span class="Constant"> </span><span class="Special">%s</span><span class="Constant"> (</span><span class="Special">%d</span><span class="Constant">@</span><span class="Special">%s</span><span class="Constant">:</span><span class="Special">%s</span><span class="Constant">): ssave homeostat deactivated</span><span class="Special">\n</span><span class="Constant">&quot;</span>,
                                 date,appl_name,appl_pid,appl_host,appl_owner);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}



<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Perioidically save state (via Criu) </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>

_PRIVATE <span class="Type">int</span> ssave_homeostat(<span class="Type">void</span> *t_info, <span class="Type">char</span> *args)

{   _IMMORTAL _BOOLEAN entered = FALSE;

    _IMMORTAL <span class="Type">time_t</span> base_time,
                     elapsed_time;


    <span class="Type">struct</span> timespec delay;


    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> First time homeosat called - initialise </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(entered == FALSE)
    {  entered = TRUE;
       base_time = time((<span class="Type">time_t</span> *)<span class="Constant">NULL</span>);

       <span class="Statement">return</span>(<span class="Constant">1</span>);
    }

    elapsed_time = time((<span class="Type">time_t</span> *)<span class="Constant">NULL</span>) - base_time;


<span class="PreProc">    #ifdef UTILIB_DEBUG</span>
    <span class="Statement">if</span>(elapsed_time &gt;= <span class="Constant">5</span>)
    {  (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ELAPSED TIME: </span><span class="Special">%ld</span><span class="Special">\n</span><span class="Constant">&quot;</span>,elapsed_time);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
    }
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Save state if poll time exceeded </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">----------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(elapsed_time &gt;= appl_poll_time)
    {  <span class="Type">char</span> criu_cmd[SSIZE]  = <span class="Constant">&quot;&quot;</span>;


<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;ELAPSED TIME: </span><span class="Special">%ld</span><span class="Constant"> SAVING STATE (</span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,elapsed_time,appl_ssaves);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Run Criu command to save state      </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> it must run in background so it     </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> is not included in the process tree </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> of the caller                       </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------------------------</span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Kill server after saving state </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">if</span>(args != (<span class="Type">char</span> *)<span class="Constant">NULL</span> &amp;&amp; strcmp(args,<span class="Constant">&quot;kill&quot;</span>) == <span class="Constant">0</span>)
          (<span class="Type">void</span>)snprintf(criu_cmd,SSIZE,<span class="Constant">&quot;criu --log-file /dev/null --shell-job --link-remap dump -D </span><span class="Special">%s</span><span class="Constant"> -t </span><span class="Special">%d</span><span class="Constant"> &amp;&quot;</span>,appl_ssave_dir,appl_pid);


       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Server stays running after saving state </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

       <span class="Statement">else</span>
          (<span class="Type">void</span>)snprintf(criu_cmd,SSIZE,<span class="Constant">&quot;criu --log-file /dev/null --leave-running --shell-job --link-remap dump -D </span><span class="Special">%s</span><span class="Constant"> -t </span><span class="Special">%d</span><span class="Constant"> &amp;&quot;</span>,appl_ssave_dir,appl_pid);

       (<span class="Type">void</span>)system(criu_cmd);


       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> This is a dummy system call - on restore </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> EINTR will be generated and the process  </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> will restart from here                   </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">------------------------------------------</span><span class="Comment">*/</span>

       delay.tv_sec  = <span class="Constant">60</span>;
       delay.tv_nsec = <span class="Constant">0</span>;

       (<span class="Type">void</span>)nanosleep(&amp;delay,(<span class="Type">struct</span> timespec *)<span class="Constant">NULL</span>);

<span class="PreProc">       #ifdef UTILIB_DEBUG</span>
       (<span class="Type">void</span>)fprintf(<span class="Constant">stderr</span>,<span class="Constant">&quot;RESTART (checkpoint: </span><span class="Special">%d</span><span class="Constant">)</span><span class="Special">\n</span><span class="Constant">&quot;</span>,appl_ssaves);
       (<span class="Type">void</span>)fflush(<span class="Constant">stderr</span>);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> UTILIB_DEBUG </span><span class="Comment">*/</span>


       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Reset base time for new poll interval </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">---------------------------------------</span><span class="Comment">*/</span>

       base_time = time((<span class="Type">time_t</span> *)<span class="Constant">NULL</span>);
       ++appl_ssaves;


       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment"> Reschedule timers </span><span class="Comment">*/</span>
       <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

       (<span class="Type">void</span>)pups_malarm(vitimer_quantum);
    }

    <span class="Statement">return</span>(<span class="Constant">0</span>);
}
<span class="PreProc">#endif</span> <span class="Comment">/*</span><span class="Comment"> CRIU_SUPPORT </span><span class="Comment">*/</span>




<span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Copy a file </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">-------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">int</span> pups_copy_file(<span class="Type">const</span> <span class="Type">int</span> copy_op, <span class="Type">const</span> <span class="Type">char</span> *from, <span class="Type">const</span> <span class="Type">char</span> *to)

{   <span class="Type">unsigned</span> <span class="Type">long</span> <span class="Type">int</span> file_size,
                      bytes_read,
                      total_read = <span class="Constant">0L</span>;

    _BYTE buf[COPY_BUF_SIZE] = <span class="Constant">&quot;&quot;</span>;

    <span class="Type">int</span> to_des   = (-<span class="Constant">1</span>),
        from_des = (-<span class="Constant">1</span>);

    <span class="Type">struct</span> stat stat_buf;


    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Sanity check </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(from == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>  ||
       to   == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>   )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

    <span class="Statement">if</span>(copy_op != PUPS_FILE_MOVE    &amp;&amp;
       copy_op != PUPS_FILE_COPY     )
    {  pups_set_errno(<span class="Constant">EINVAL</span>);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_lock(&amp;copy_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>


    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open source file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((from_des = open(from,O_RDONLY)) == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;copy_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Open destination file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-----------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>((to_des = open(to,O_WRONLY | O_CREAT, <span class="PreProc">0</span><span class="Constant">600</span>)) == (-<span class="Constant">1</span>))
    {

<span class="PreProc">       #ifdef PTHREAD_SUPPORT</span>
       (<span class="Type">void</span>)pthread_mutex_unlock(&amp;copy_mutex);
<span class="PreProc">       #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

       (<span class="Type">void</span>)close(from_des);
       <span class="Statement">return</span>(-<span class="Constant">1</span>);
    }


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Get file size </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)fstat(from_des,&amp;stat_buf);
    file_size = stat_buf.st_size;


    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Copy the file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------</span><span class="Comment">*/</span>

    <span class="Statement">do</span> {    bytes_read = read(from_des,buf,COPY_BUF_SIZE);
            (<span class="Type">void</span>)write(to_des,buf,bytes_read);

            total_read += bytes_read;
       } <span class="Statement">while</span>(total_read &lt; file_size);

    (<span class="Type">void</span>)close(from);
    (<span class="Type">void</span>)close(to);


    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> If we are moving the file </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> delete source file        </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(copy_op == PUPS_FILE_MOVE)
       (<span class="Type">void</span>)unlink(from);

<span class="PreProc">    #ifdef PTHREAD_SUPPORT</span>
    (<span class="Type">void</span>)pthread_mutex_unlock(&amp;copy_mutex);
<span class="PreProc">    #endif</span> <span class="Comment">/*</span><span class="Comment"> PTHREAD_SUPPORT </span><span class="Comment">*/</span>

    pups_set_errno(OK);
    <span class="Statement">return</span>(<span class="Constant">0</span>);
}




<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Can we run command? </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------</span><span class="Comment">*/</span>

_PUBLIC _BOOLEAN pups_can_run_command(<span class="Type">const</span> <span class="Type">char</span> *cmd)
{

    <span class="Statement">if</span>(strchr(cmd, <span class="Constant">'/'</span>))
    {

        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> If cmd includes a slash, no path search is required </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> go straight to checking if it's executable          </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">return</span> access(cmd, X_OK)==<span class="Constant">0</span>;
    }

    <span class="Type">const</span> <span class="Type">char</span> *path = getenv(<span class="Constant">&quot;PATH&quot;</span>);


    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Error </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------</span><span class="Comment">*/</span>

    <span class="Statement">if</span>(path == (<span class="Type">const</span> <span class="Type">char</span> *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>(FALSE);


    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">  We are sure we won't need a buffer any longer </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Type">char</span> *buf = (<span class="Type">char</span> *)malloc(PATH_MAX);

    <span class="Statement">if</span>(buf == (<span class="Type">char</span> *)<span class="Constant">NULL</span>)
       <span class="Statement">return</span>(FALSE);

    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> loop as long as we have stuff to examine in path </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">--------------------------------------------------</span><span class="Comment">*/</span>

    <span class="Statement">for</span>(; *path; ++path)
    {

        <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> start from the beginning of the buffer </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------------------</span><span class="Comment">*/</span>

        <span class="Type">char</span> *p = buf;


        <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Copy current path element into buf </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">for</span>(; *path &amp;&amp; *path!=<span class="Constant">':'</span>; ++path,++p)
            *p = *path;


        <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> empty path entries are treated like &quot;.&quot; </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">-----------------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(p == buf)
           *p++=<span class="Constant">'.'</span>;


        <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> slash and command name </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(p[-<span class="Constant">1</span>] != <span class="Constant">'/'</span>)
           *p++=<span class="Constant">'/'</span>;

        (<span class="Type">void</span>)strlcpy(p, cmd,PATH_MAX);


        <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> check if we can execute it </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">----------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(access(buf, X_OK)==<span class="Constant">0</span>) {
           (<span class="Type">void</span>)free((<span class="Type">void</span> *)buf);
           <span class="Statement">return</span>(TRUE);
        }


        <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment"> Quit in last iteration </span><span class="Comment">*/</span>
        <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

        <span class="Statement">if</span>(!*path)
           <span class="Statement">break</span>;
    }


    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Command not found </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">-------------------</span><span class="Comment">*/</span>

    (<span class="Type">void</span>)free((<span class="Type">void</span> *)buf);
    <span class="Statement">return</span>(FALSE);
}



<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Enable (memory) residency </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">---------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">void</span> pups_enable_resident(<span class="Type">void</span>)

{   appl_enable_resident = TRUE;
}




<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment"> Get size of directory in bytes </span><span class="Comment">*/</span>
<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

_PUBLIC <span class="Type">off_t</span> pups_dsize(<span class="Type">const</span> <span class="Type">char</span> *directory_name)
{
    <span class="Type">off_t</span> directory_size = <span class="Constant">0</span>;
    <span class="Type">DIR</span>   *pDir          = (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>;

    <span class="Statement">if</span> ((pDir = opendir(directory_name)) != (<span class="Type">DIR</span> *)<span class="Constant">NULL</span>)
    {
        <span class="Type">struct</span> dirent *pDirent = (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>;

        <span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>
	<span class="Comment">/*</span><span class="Comment"> Get size of files in directory </span><span class="Comment">*/</span>
	<span class="Comment">/*</span><span class="Comment">--------------------------------</span><span class="Comment">*/</span>

        <span class="Statement">while</span> ((pDirent = readdir(pDir)) != (<span class="Type">struct</span> dirent *)<span class="Constant">NULL</span>)
        {
            <span class="Type">char</span>   buffer[PATH_MAX + <span class="Constant">1</span>] = <span class="Constant">&quot;&quot;</span>;
            <span class="Type">struct</span> stat file_stat;

            (<span class="Type">void</span>)strcat(strcat(strcpy(buffer, directory_name), <span class="Constant">&quot;/&quot;</span>), pDirent-&gt;d_name);

            <span class="Statement">if</span> (stat(buffer, &amp;file_stat) == <span class="Constant">0</span>)
                directory_size += file_stat.st_blocks * S_BLKSIZE;


	    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>
	    <span class="Comment">/*</span><span class="Comment"> Sub-directory ? </span><span class="Comment">*/</span>
	    <span class="Comment">/*</span><span class="Comment">-----------------</span><span class="Comment">*/</span>

            <span class="Statement">if</span> (pDirent-&gt;d_type == DT_DIR)
            {

	       <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>
	       <span class="Comment">/*</span><span class="Comment"> Yes </span><span class="Comment">*/</span>
	       <span class="Comment">/*</span><span class="Comment">-----</span><span class="Comment">*/</span>

	       <span class="Statement">if</span> (strcmp(pDirent-&gt;d_name, <span class="Constant">&quot;.&quot;</span>) != <span class="Constant">0</span> &amp;&amp; strcmp(pDirent-&gt;d_name, <span class="Constant">&quot;..&quot;</span>) != <span class="Constant">0</span>)
                    directory_size += pups_dsize(buffer);
            }
        }

        (<span class="Type">void</span>) closedir(pDir);
    }


    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> Size of directory tree </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment"> in bytes               </span><span class="Comment">*/</span>
    <span class="Comment">/*</span><span class="Comment">------------------------</span><span class="Comment">*/</span>

    <span class="Statement">return</span>(directory_size);
}
</pre>
</body>
</html>
<!-- vim: set foldmethod=manual : -->
